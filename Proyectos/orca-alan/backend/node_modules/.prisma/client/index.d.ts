
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Rol
 * 
 */
export type Rol = $Result.DefaultSelection<Prisma.$RolPayload>
/**
 * Model Permiso
 * 
 */
export type Permiso = $Result.DefaultSelection<Prisma.$PermisoPayload>
/**
 * Model Modulo
 * 
 */
export type Modulo = $Result.DefaultSelection<Prisma.$ModuloPayload>
/**
 * Model UsuarioRol
 * 
 */
export type UsuarioRol = $Result.DefaultSelection<Prisma.$UsuarioRolPayload>
/**
 * Model RolPermiso
 * 
 */
export type RolPermiso = $Result.DefaultSelection<Prisma.$RolPermisoPayload>
/**
 * Model UsuarioActivo
 * 
 */
export type UsuarioActivo = $Result.DefaultSelection<Prisma.$UsuarioActivoPayload>
/**
 * Model LogAuditoria
 * 
 */
export type LogAuditoria = $Result.DefaultSelection<Prisma.$LogAuditoriaPayload>
/**
 * Model ActivoAcceso
 * 
 */
export type ActivoAcceso = $Result.DefaultSelection<Prisma.$ActivoAccesoPayload>
/**
 * Model PlantillaActivo
 * 
 */
export type PlantillaActivo = $Result.DefaultSelection<Prisma.$PlantillaActivoPayload>
/**
 * Model Activo
 * 
 */
export type Activo = $Result.DefaultSelection<Prisma.$ActivoPayload>
/**
 * Model Riesgo
 * 
 */
export type Riesgo = $Result.DefaultSelection<Prisma.$RiesgoPayload>
/**
 * Model Incidente
 * 
 */
export type Incidente = $Result.DefaultSelection<Prisma.$IncidentePayload>
/**
 * Model Defecto
 * 
 */
export type Defecto = $Result.DefaultSelection<Prisma.$DefectoPayload>
/**
 * Model Organigrama
 * 
 */
export type Organigrama = $Result.DefaultSelection<Prisma.$OrganigramaPayload>
/**
 * Model NodoOrganigrama
 * 
 */
export type NodoOrganigrama = $Result.DefaultSelection<Prisma.$NodoOrganigramaPayload>
/**
 * Model MarcoNormativo
 * 
 */
export type MarcoNormativo = $Result.DefaultSelection<Prisma.$MarcoNormativoPayload>
/**
 * Model RequisitoNormativo
 * 
 */
export type RequisitoNormativo = $Result.DefaultSelection<Prisma.$RequisitoNormativoPayload>
/**
 * Model Cuestionario
 * 
 */
export type Cuestionario = $Result.DefaultSelection<Prisma.$CuestionarioPayload>
/**
 * Model Seccion
 * 
 */
export type Seccion = $Result.DefaultSelection<Prisma.$SeccionPayload>
/**
 * Model Pregunta
 * 
 */
export type Pregunta = $Result.DefaultSelection<Prisma.$PreguntaPayload>
/**
 * Model AsignacionCuestionario
 * 
 */
export type AsignacionCuestionario = $Result.DefaultSelection<Prisma.$AsignacionCuestionarioPayload>
/**
 * Model EvaluadoExterno
 * 
 */
export type EvaluadoExterno = $Result.DefaultSelection<Prisma.$EvaluadoExternoPayload>
/**
 * Model RespuestaCuestionario
 * 
 */
export type RespuestaCuestionario = $Result.DefaultSelection<Prisma.$RespuestaCuestionarioPayload>
/**
 * Model RespuestaPregunta
 * 
 */
export type RespuestaPregunta = $Result.DefaultSelection<Prisma.$RespuestaPreguntaPayload>
/**
 * Model Evidencia
 * 
 */
export type Evidencia = $Result.DefaultSelection<Prisma.$EvidenciaPayload>
/**
 * Model Hallazgo
 * 
 */
export type Hallazgo = $Result.DefaultSelection<Prisma.$HallazgoPayload>
/**
 * Model MensajeChat
 * 
 */
export type MensajeChat = $Result.DefaultSelection<Prisma.$MensajeChatPayload>
/**
 * Model AlertaCumplimiento
 * 
 */
export type AlertaCumplimiento = $Result.DefaultSelection<Prisma.$AlertaCumplimientoPayload>
/**
 * Model Proceso
 * 
 */
export type Proceso = $Result.DefaultSelection<Prisma.$ProcesoPayload>
/**
 * Model ProcessNode
 * 
 */
export type ProcessNode = $Result.DefaultSelection<Prisma.$ProcessNodePayload>
/**
 * Model ProcessEdge
 * 
 */
export type ProcessEdge = $Result.DefaultSelection<Prisma.$ProcessEdgePayload>
/**
 * Model ObjetivoProceso
 * 
 */
export type ObjetivoProceso = $Result.DefaultSelection<Prisma.$ObjetivoProcesoPayload>
/**
 * Model KpiProceso
 * 
 */
export type KpiProceso = $Result.DefaultSelection<Prisma.$KpiProcesoPayload>
/**
 * Model KpiHistorico
 * 
 */
export type KpiHistorico = $Result.DefaultSelection<Prisma.$KpiHistoricoPayload>
/**
 * Model DashboardConfig
 * 
 */
export type DashboardConfig = $Result.DefaultSelection<Prisma.$DashboardConfigPayload>
/**
 * Model DashboardWidget
 * 
 */
export type DashboardWidget = $Result.DefaultSelection<Prisma.$DashboardWidgetPayload>
/**
 * Model Catalogo
 * 
 */
export type Catalogo = $Result.DefaultSelection<Prisma.$CatalogoPayload>
/**
 * Model NotificationRule
 * 
 */
export type NotificationRule = $Result.DefaultSelection<Prisma.$NotificationRulePayload>
/**
 * Model AlertRule
 * 
 */
export type AlertRule = $Result.DefaultSelection<Prisma.$AlertRulePayload>
/**
 * Model ExpirationRule
 * 
 */
export type ExpirationRule = $Result.DefaultSelection<Prisma.$ExpirationRulePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model UserNotificationPreferences
 * 
 */
export type UserNotificationPreferences = $Result.DefaultSelection<Prisma.$UserNotificationPreferencesPayload>
/**
 * Model NotificationLog
 * 
 */
export type NotificationLog = $Result.DefaultSelection<Prisma.$NotificationLogPayload>
/**
 * Model NotificationProfile
 * 
 */
export type NotificationProfile = $Result.DefaultSelection<Prisma.$NotificationProfilePayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectObjective
 * 
 */
export type ProjectObjective = $Result.DefaultSelection<Prisma.$ProjectObjectivePayload>
/**
 * Model ProjectKPI
 * 
 */
export type ProjectKPI = $Result.DefaultSelection<Prisma.$ProjectKPIPayload>
/**
 * Model ProjectPhase
 * 
 */
export type ProjectPhase = $Result.DefaultSelection<Prisma.$ProjectPhasePayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskEvidence
 * 
 */
export type TaskEvidence = $Result.DefaultSelection<Prisma.$TaskEvidencePayload>
/**
 * Model TaskHistory
 * 
 */
export type TaskHistory = $Result.DefaultSelection<Prisma.$TaskHistoryPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.rol`: Exposes CRUD operations for the **Rol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rols
    * const rols = await prisma.rol.findMany()
    * ```
    */
  get rol(): Prisma.RolDelegate<ExtArgs>;

  /**
   * `prisma.permiso`: Exposes CRUD operations for the **Permiso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permisos
    * const permisos = await prisma.permiso.findMany()
    * ```
    */
  get permiso(): Prisma.PermisoDelegate<ExtArgs>;

  /**
   * `prisma.modulo`: Exposes CRUD operations for the **Modulo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modulos
    * const modulos = await prisma.modulo.findMany()
    * ```
    */
  get modulo(): Prisma.ModuloDelegate<ExtArgs>;

  /**
   * `prisma.usuarioRol`: Exposes CRUD operations for the **UsuarioRol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsuarioRols
    * const usuarioRols = await prisma.usuarioRol.findMany()
    * ```
    */
  get usuarioRol(): Prisma.UsuarioRolDelegate<ExtArgs>;

  /**
   * `prisma.rolPermiso`: Exposes CRUD operations for the **RolPermiso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolPermisos
    * const rolPermisos = await prisma.rolPermiso.findMany()
    * ```
    */
  get rolPermiso(): Prisma.RolPermisoDelegate<ExtArgs>;

  /**
   * `prisma.usuarioActivo`: Exposes CRUD operations for the **UsuarioActivo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsuarioActivos
    * const usuarioActivos = await prisma.usuarioActivo.findMany()
    * ```
    */
  get usuarioActivo(): Prisma.UsuarioActivoDelegate<ExtArgs>;

  /**
   * `prisma.logAuditoria`: Exposes CRUD operations for the **LogAuditoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogAuditorias
    * const logAuditorias = await prisma.logAuditoria.findMany()
    * ```
    */
  get logAuditoria(): Prisma.LogAuditoriaDelegate<ExtArgs>;

  /**
   * `prisma.activoAcceso`: Exposes CRUD operations for the **ActivoAcceso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivoAccesos
    * const activoAccesos = await prisma.activoAcceso.findMany()
    * ```
    */
  get activoAcceso(): Prisma.ActivoAccesoDelegate<ExtArgs>;

  /**
   * `prisma.plantillaActivo`: Exposes CRUD operations for the **PlantillaActivo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlantillaActivos
    * const plantillaActivos = await prisma.plantillaActivo.findMany()
    * ```
    */
  get plantillaActivo(): Prisma.PlantillaActivoDelegate<ExtArgs>;

  /**
   * `prisma.activo`: Exposes CRUD operations for the **Activo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activos
    * const activos = await prisma.activo.findMany()
    * ```
    */
  get activo(): Prisma.ActivoDelegate<ExtArgs>;

  /**
   * `prisma.riesgo`: Exposes CRUD operations for the **Riesgo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Riesgos
    * const riesgos = await prisma.riesgo.findMany()
    * ```
    */
  get riesgo(): Prisma.RiesgoDelegate<ExtArgs>;

  /**
   * `prisma.incidente`: Exposes CRUD operations for the **Incidente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incidentes
    * const incidentes = await prisma.incidente.findMany()
    * ```
    */
  get incidente(): Prisma.IncidenteDelegate<ExtArgs>;

  /**
   * `prisma.defecto`: Exposes CRUD operations for the **Defecto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Defectos
    * const defectos = await prisma.defecto.findMany()
    * ```
    */
  get defecto(): Prisma.DefectoDelegate<ExtArgs>;

  /**
   * `prisma.organigrama`: Exposes CRUD operations for the **Organigrama** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organigramas
    * const organigramas = await prisma.organigrama.findMany()
    * ```
    */
  get organigrama(): Prisma.OrganigramaDelegate<ExtArgs>;

  /**
   * `prisma.nodoOrganigrama`: Exposes CRUD operations for the **NodoOrganigrama** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NodoOrganigramas
    * const nodoOrganigramas = await prisma.nodoOrganigrama.findMany()
    * ```
    */
  get nodoOrganigrama(): Prisma.NodoOrganigramaDelegate<ExtArgs>;

  /**
   * `prisma.marcoNormativo`: Exposes CRUD operations for the **MarcoNormativo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarcoNormativos
    * const marcoNormativos = await prisma.marcoNormativo.findMany()
    * ```
    */
  get marcoNormativo(): Prisma.MarcoNormativoDelegate<ExtArgs>;

  /**
   * `prisma.requisitoNormativo`: Exposes CRUD operations for the **RequisitoNormativo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequisitoNormativos
    * const requisitoNormativos = await prisma.requisitoNormativo.findMany()
    * ```
    */
  get requisitoNormativo(): Prisma.RequisitoNormativoDelegate<ExtArgs>;

  /**
   * `prisma.cuestionario`: Exposes CRUD operations for the **Cuestionario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cuestionarios
    * const cuestionarios = await prisma.cuestionario.findMany()
    * ```
    */
  get cuestionario(): Prisma.CuestionarioDelegate<ExtArgs>;

  /**
   * `prisma.seccion`: Exposes CRUD operations for the **Seccion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seccions
    * const seccions = await prisma.seccion.findMany()
    * ```
    */
  get seccion(): Prisma.SeccionDelegate<ExtArgs>;

  /**
   * `prisma.pregunta`: Exposes CRUD operations for the **Pregunta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Preguntas
    * const preguntas = await prisma.pregunta.findMany()
    * ```
    */
  get pregunta(): Prisma.PreguntaDelegate<ExtArgs>;

  /**
   * `prisma.asignacionCuestionario`: Exposes CRUD operations for the **AsignacionCuestionario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AsignacionCuestionarios
    * const asignacionCuestionarios = await prisma.asignacionCuestionario.findMany()
    * ```
    */
  get asignacionCuestionario(): Prisma.AsignacionCuestionarioDelegate<ExtArgs>;

  /**
   * `prisma.evaluadoExterno`: Exposes CRUD operations for the **EvaluadoExterno** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvaluadoExternos
    * const evaluadoExternos = await prisma.evaluadoExterno.findMany()
    * ```
    */
  get evaluadoExterno(): Prisma.EvaluadoExternoDelegate<ExtArgs>;

  /**
   * `prisma.respuestaCuestionario`: Exposes CRUD operations for the **RespuestaCuestionario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RespuestaCuestionarios
    * const respuestaCuestionarios = await prisma.respuestaCuestionario.findMany()
    * ```
    */
  get respuestaCuestionario(): Prisma.RespuestaCuestionarioDelegate<ExtArgs>;

  /**
   * `prisma.respuestaPregunta`: Exposes CRUD operations for the **RespuestaPregunta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RespuestaPreguntas
    * const respuestaPreguntas = await prisma.respuestaPregunta.findMany()
    * ```
    */
  get respuestaPregunta(): Prisma.RespuestaPreguntaDelegate<ExtArgs>;

  /**
   * `prisma.evidencia`: Exposes CRUD operations for the **Evidencia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evidencias
    * const evidencias = await prisma.evidencia.findMany()
    * ```
    */
  get evidencia(): Prisma.EvidenciaDelegate<ExtArgs>;

  /**
   * `prisma.hallazgo`: Exposes CRUD operations for the **Hallazgo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hallazgos
    * const hallazgos = await prisma.hallazgo.findMany()
    * ```
    */
  get hallazgo(): Prisma.HallazgoDelegate<ExtArgs>;

  /**
   * `prisma.mensajeChat`: Exposes CRUD operations for the **MensajeChat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MensajeChats
    * const mensajeChats = await prisma.mensajeChat.findMany()
    * ```
    */
  get mensajeChat(): Prisma.MensajeChatDelegate<ExtArgs>;

  /**
   * `prisma.alertaCumplimiento`: Exposes CRUD operations for the **AlertaCumplimiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlertaCumplimientos
    * const alertaCumplimientos = await prisma.alertaCumplimiento.findMany()
    * ```
    */
  get alertaCumplimiento(): Prisma.AlertaCumplimientoDelegate<ExtArgs>;

  /**
   * `prisma.proceso`: Exposes CRUD operations for the **Proceso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Procesos
    * const procesos = await prisma.proceso.findMany()
    * ```
    */
  get proceso(): Prisma.ProcesoDelegate<ExtArgs>;

  /**
   * `prisma.processNode`: Exposes CRUD operations for the **ProcessNode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessNodes
    * const processNodes = await prisma.processNode.findMany()
    * ```
    */
  get processNode(): Prisma.ProcessNodeDelegate<ExtArgs>;

  /**
   * `prisma.processEdge`: Exposes CRUD operations for the **ProcessEdge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessEdges
    * const processEdges = await prisma.processEdge.findMany()
    * ```
    */
  get processEdge(): Prisma.ProcessEdgeDelegate<ExtArgs>;

  /**
   * `prisma.objetivoProceso`: Exposes CRUD operations for the **ObjetivoProceso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ObjetivoProcesos
    * const objetivoProcesos = await prisma.objetivoProceso.findMany()
    * ```
    */
  get objetivoProceso(): Prisma.ObjetivoProcesoDelegate<ExtArgs>;

  /**
   * `prisma.kpiProceso`: Exposes CRUD operations for the **KpiProceso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KpiProcesos
    * const kpiProcesos = await prisma.kpiProceso.findMany()
    * ```
    */
  get kpiProceso(): Prisma.KpiProcesoDelegate<ExtArgs>;

  /**
   * `prisma.kpiHistorico`: Exposes CRUD operations for the **KpiHistorico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KpiHistoricos
    * const kpiHistoricos = await prisma.kpiHistorico.findMany()
    * ```
    */
  get kpiHistorico(): Prisma.KpiHistoricoDelegate<ExtArgs>;

  /**
   * `prisma.dashboardConfig`: Exposes CRUD operations for the **DashboardConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardConfigs
    * const dashboardConfigs = await prisma.dashboardConfig.findMany()
    * ```
    */
  get dashboardConfig(): Prisma.DashboardConfigDelegate<ExtArgs>;

  /**
   * `prisma.dashboardWidget`: Exposes CRUD operations for the **DashboardWidget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardWidgets
    * const dashboardWidgets = await prisma.dashboardWidget.findMany()
    * ```
    */
  get dashboardWidget(): Prisma.DashboardWidgetDelegate<ExtArgs>;

  /**
   * `prisma.catalogo`: Exposes CRUD operations for the **Catalogo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Catalogos
    * const catalogos = await prisma.catalogo.findMany()
    * ```
    */
  get catalogo(): Prisma.CatalogoDelegate<ExtArgs>;

  /**
   * `prisma.notificationRule`: Exposes CRUD operations for the **NotificationRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationRules
    * const notificationRules = await prisma.notificationRule.findMany()
    * ```
    */
  get notificationRule(): Prisma.NotificationRuleDelegate<ExtArgs>;

  /**
   * `prisma.alertRule`: Exposes CRUD operations for the **AlertRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlertRules
    * const alertRules = await prisma.alertRule.findMany()
    * ```
    */
  get alertRule(): Prisma.AlertRuleDelegate<ExtArgs>;

  /**
   * `prisma.expirationRule`: Exposes CRUD operations for the **ExpirationRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpirationRules
    * const expirationRules = await prisma.expirationRule.findMany()
    * ```
    */
  get expirationRule(): Prisma.ExpirationRuleDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.userNotificationPreferences`: Exposes CRUD operations for the **UserNotificationPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserNotificationPreferences
    * const userNotificationPreferences = await prisma.userNotificationPreferences.findMany()
    * ```
    */
  get userNotificationPreferences(): Prisma.UserNotificationPreferencesDelegate<ExtArgs>;

  /**
   * `prisma.notificationLog`: Exposes CRUD operations for the **NotificationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationLogs
    * const notificationLogs = await prisma.notificationLog.findMany()
    * ```
    */
  get notificationLog(): Prisma.NotificationLogDelegate<ExtArgs>;

  /**
   * `prisma.notificationProfile`: Exposes CRUD operations for the **NotificationProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationProfiles
    * const notificationProfiles = await prisma.notificationProfile.findMany()
    * ```
    */
  get notificationProfile(): Prisma.NotificationProfileDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.projectObjective`: Exposes CRUD operations for the **ProjectObjective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectObjectives
    * const projectObjectives = await prisma.projectObjective.findMany()
    * ```
    */
  get projectObjective(): Prisma.ProjectObjectiveDelegate<ExtArgs>;

  /**
   * `prisma.projectKPI`: Exposes CRUD operations for the **ProjectKPI** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectKPIS
    * const projectKPIS = await prisma.projectKPI.findMany()
    * ```
    */
  get projectKPI(): Prisma.ProjectKPIDelegate<ExtArgs>;

  /**
   * `prisma.projectPhase`: Exposes CRUD operations for the **ProjectPhase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectPhases
    * const projectPhases = await prisma.projectPhase.findMany()
    * ```
    */
  get projectPhase(): Prisma.ProjectPhaseDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;

  /**
   * `prisma.taskEvidence`: Exposes CRUD operations for the **TaskEvidence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskEvidences
    * const taskEvidences = await prisma.taskEvidence.findMany()
    * ```
    */
  get taskEvidence(): Prisma.TaskEvidenceDelegate<ExtArgs>;

  /**
   * `prisma.taskHistory`: Exposes CRUD operations for the **TaskHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskHistories
    * const taskHistories = await prisma.taskHistory.findMany()
    * ```
    */
  get taskHistory(): Prisma.TaskHistoryDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Rol: 'Rol',
    Permiso: 'Permiso',
    Modulo: 'Modulo',
    UsuarioRol: 'UsuarioRol',
    RolPermiso: 'RolPermiso',
    UsuarioActivo: 'UsuarioActivo',
    LogAuditoria: 'LogAuditoria',
    ActivoAcceso: 'ActivoAcceso',
    PlantillaActivo: 'PlantillaActivo',
    Activo: 'Activo',
    Riesgo: 'Riesgo',
    Incidente: 'Incidente',
    Defecto: 'Defecto',
    Organigrama: 'Organigrama',
    NodoOrganigrama: 'NodoOrganigrama',
    MarcoNormativo: 'MarcoNormativo',
    RequisitoNormativo: 'RequisitoNormativo',
    Cuestionario: 'Cuestionario',
    Seccion: 'Seccion',
    Pregunta: 'Pregunta',
    AsignacionCuestionario: 'AsignacionCuestionario',
    EvaluadoExterno: 'EvaluadoExterno',
    RespuestaCuestionario: 'RespuestaCuestionario',
    RespuestaPregunta: 'RespuestaPregunta',
    Evidencia: 'Evidencia',
    Hallazgo: 'Hallazgo',
    MensajeChat: 'MensajeChat',
    AlertaCumplimiento: 'AlertaCumplimiento',
    Proceso: 'Proceso',
    ProcessNode: 'ProcessNode',
    ProcessEdge: 'ProcessEdge',
    ObjetivoProceso: 'ObjetivoProceso',
    KpiProceso: 'KpiProceso',
    KpiHistorico: 'KpiHistorico',
    DashboardConfig: 'DashboardConfig',
    DashboardWidget: 'DashboardWidget',
    Catalogo: 'Catalogo',
    NotificationRule: 'NotificationRule',
    AlertRule: 'AlertRule',
    ExpirationRule: 'ExpirationRule',
    Notification: 'Notification',
    UserNotificationPreferences: 'UserNotificationPreferences',
    NotificationLog: 'NotificationLog',
    NotificationProfile: 'NotificationProfile',
    Project: 'Project',
    ProjectObjective: 'ProjectObjective',
    ProjectKPI: 'ProjectKPI',
    ProjectPhase: 'ProjectPhase',
    Task: 'Task',
    TaskEvidence: 'TaskEvidence',
    TaskHistory: 'TaskHistory'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "usuario" | "rol" | "permiso" | "modulo" | "usuarioRol" | "rolPermiso" | "usuarioActivo" | "logAuditoria" | "activoAcceso" | "plantillaActivo" | "activo" | "riesgo" | "incidente" | "defecto" | "organigrama" | "nodoOrganigrama" | "marcoNormativo" | "requisitoNormativo" | "cuestionario" | "seccion" | "pregunta" | "asignacionCuestionario" | "evaluadoExterno" | "respuestaCuestionario" | "respuestaPregunta" | "evidencia" | "hallazgo" | "mensajeChat" | "alertaCumplimiento" | "proceso" | "processNode" | "processEdge" | "objetivoProceso" | "kpiProceso" | "kpiHistorico" | "dashboardConfig" | "dashboardWidget" | "catalogo" | "notificationRule" | "alertRule" | "expirationRule" | "notification" | "userNotificationPreferences" | "notificationLog" | "notificationProfile" | "project" | "projectObjective" | "projectKPI" | "projectPhase" | "task" | "taskEvidence" | "taskHistory"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Rol: {
        payload: Prisma.$RolPayload<ExtArgs>
        fields: Prisma.RolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          findFirst: {
            args: Prisma.RolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          findMany: {
            args: Prisma.RolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>[]
          }
          create: {
            args: Prisma.RolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          createMany: {
            args: Prisma.RolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>[]
          }
          delete: {
            args: Prisma.RolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          update: {
            args: Prisma.RolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          deleteMany: {
            args: Prisma.RolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          aggregate: {
            args: Prisma.RolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRol>
          }
          groupBy: {
            args: Prisma.RolGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolCountArgs<ExtArgs>
            result: $Utils.Optional<RolCountAggregateOutputType> | number
          }
        }
      }
      Permiso: {
        payload: Prisma.$PermisoPayload<ExtArgs>
        fields: Prisma.PermisoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermisoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermisoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          findFirst: {
            args: Prisma.PermisoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermisoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          findMany: {
            args: Prisma.PermisoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>[]
          }
          create: {
            args: Prisma.PermisoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          createMany: {
            args: Prisma.PermisoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermisoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>[]
          }
          delete: {
            args: Prisma.PermisoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          update: {
            args: Prisma.PermisoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          deleteMany: {
            args: Prisma.PermisoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermisoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermisoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          aggregate: {
            args: Prisma.PermisoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermiso>
          }
          groupBy: {
            args: Prisma.PermisoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermisoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermisoCountArgs<ExtArgs>
            result: $Utils.Optional<PermisoCountAggregateOutputType> | number
          }
        }
      }
      Modulo: {
        payload: Prisma.$ModuloPayload<ExtArgs>
        fields: Prisma.ModuloFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuloFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuloFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          findFirst: {
            args: Prisma.ModuloFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuloFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          findMany: {
            args: Prisma.ModuloFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>[]
          }
          create: {
            args: Prisma.ModuloCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          createMany: {
            args: Prisma.ModuloCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuloCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>[]
          }
          delete: {
            args: Prisma.ModuloDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          update: {
            args: Prisma.ModuloUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          deleteMany: {
            args: Prisma.ModuloDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuloUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModuloUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          aggregate: {
            args: Prisma.ModuloAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModulo>
          }
          groupBy: {
            args: Prisma.ModuloGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuloGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuloCountArgs<ExtArgs>
            result: $Utils.Optional<ModuloCountAggregateOutputType> | number
          }
        }
      }
      UsuarioRol: {
        payload: Prisma.$UsuarioRolPayload<ExtArgs>
        fields: Prisma.UsuarioRolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioRolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioRolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>
          }
          findFirst: {
            args: Prisma.UsuarioRolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioRolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>
          }
          findMany: {
            args: Prisma.UsuarioRolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>[]
          }
          create: {
            args: Prisma.UsuarioRolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>
          }
          createMany: {
            args: Prisma.UsuarioRolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioRolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>[]
          }
          delete: {
            args: Prisma.UsuarioRolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>
          }
          update: {
            args: Prisma.UsuarioRolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioRolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioRolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioRolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>
          }
          aggregate: {
            args: Prisma.UsuarioRolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuarioRol>
          }
          groupBy: {
            args: Prisma.UsuarioRolGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioRolGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioRolCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioRolCountAggregateOutputType> | number
          }
        }
      }
      RolPermiso: {
        payload: Prisma.$RolPermisoPayload<ExtArgs>
        fields: Prisma.RolPermisoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolPermisoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolPermisoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload>
          }
          findFirst: {
            args: Prisma.RolPermisoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolPermisoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload>
          }
          findMany: {
            args: Prisma.RolPermisoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload>[]
          }
          create: {
            args: Prisma.RolPermisoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload>
          }
          createMany: {
            args: Prisma.RolPermisoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolPermisoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload>[]
          }
          delete: {
            args: Prisma.RolPermisoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload>
          }
          update: {
            args: Prisma.RolPermisoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload>
          }
          deleteMany: {
            args: Prisma.RolPermisoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolPermisoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolPermisoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPermisoPayload>
          }
          aggregate: {
            args: Prisma.RolPermisoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolPermiso>
          }
          groupBy: {
            args: Prisma.RolPermisoGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolPermisoGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolPermisoCountArgs<ExtArgs>
            result: $Utils.Optional<RolPermisoCountAggregateOutputType> | number
          }
        }
      }
      UsuarioActivo: {
        payload: Prisma.$UsuarioActivoPayload<ExtArgs>
        fields: Prisma.UsuarioActivoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioActivoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioActivoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioActivoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioActivoPayload>
          }
          findFirst: {
            args: Prisma.UsuarioActivoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioActivoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioActivoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioActivoPayload>
          }
          findMany: {
            args: Prisma.UsuarioActivoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioActivoPayload>[]
          }
          create: {
            args: Prisma.UsuarioActivoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioActivoPayload>
          }
          createMany: {
            args: Prisma.UsuarioActivoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioActivoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioActivoPayload>[]
          }
          delete: {
            args: Prisma.UsuarioActivoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioActivoPayload>
          }
          update: {
            args: Prisma.UsuarioActivoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioActivoPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioActivoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioActivoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioActivoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioActivoPayload>
          }
          aggregate: {
            args: Prisma.UsuarioActivoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuarioActivo>
          }
          groupBy: {
            args: Prisma.UsuarioActivoGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioActivoGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioActivoCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioActivoCountAggregateOutputType> | number
          }
        }
      }
      LogAuditoria: {
        payload: Prisma.$LogAuditoriaPayload<ExtArgs>
        fields: Prisma.LogAuditoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogAuditoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogAuditoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload>
          }
          findFirst: {
            args: Prisma.LogAuditoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogAuditoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload>
          }
          findMany: {
            args: Prisma.LogAuditoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload>[]
          }
          create: {
            args: Prisma.LogAuditoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload>
          }
          createMany: {
            args: Prisma.LogAuditoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogAuditoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload>[]
          }
          delete: {
            args: Prisma.LogAuditoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload>
          }
          update: {
            args: Prisma.LogAuditoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload>
          }
          deleteMany: {
            args: Prisma.LogAuditoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogAuditoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogAuditoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload>
          }
          aggregate: {
            args: Prisma.LogAuditoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogAuditoria>
          }
          groupBy: {
            args: Prisma.LogAuditoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogAuditoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogAuditoriaCountArgs<ExtArgs>
            result: $Utils.Optional<LogAuditoriaCountAggregateOutputType> | number
          }
        }
      }
      ActivoAcceso: {
        payload: Prisma.$ActivoAccesoPayload<ExtArgs>
        fields: Prisma.ActivoAccesoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivoAccesoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoAccesoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivoAccesoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoAccesoPayload>
          }
          findFirst: {
            args: Prisma.ActivoAccesoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoAccesoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivoAccesoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoAccesoPayload>
          }
          findMany: {
            args: Prisma.ActivoAccesoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoAccesoPayload>[]
          }
          create: {
            args: Prisma.ActivoAccesoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoAccesoPayload>
          }
          createMany: {
            args: Prisma.ActivoAccesoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivoAccesoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoAccesoPayload>[]
          }
          delete: {
            args: Prisma.ActivoAccesoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoAccesoPayload>
          }
          update: {
            args: Prisma.ActivoAccesoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoAccesoPayload>
          }
          deleteMany: {
            args: Prisma.ActivoAccesoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivoAccesoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivoAccesoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoAccesoPayload>
          }
          aggregate: {
            args: Prisma.ActivoAccesoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivoAcceso>
          }
          groupBy: {
            args: Prisma.ActivoAccesoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivoAccesoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivoAccesoCountArgs<ExtArgs>
            result: $Utils.Optional<ActivoAccesoCountAggregateOutputType> | number
          }
        }
      }
      PlantillaActivo: {
        payload: Prisma.$PlantillaActivoPayload<ExtArgs>
        fields: Prisma.PlantillaActivoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlantillaActivoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaActivoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlantillaActivoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaActivoPayload>
          }
          findFirst: {
            args: Prisma.PlantillaActivoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaActivoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlantillaActivoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaActivoPayload>
          }
          findMany: {
            args: Prisma.PlantillaActivoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaActivoPayload>[]
          }
          create: {
            args: Prisma.PlantillaActivoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaActivoPayload>
          }
          createMany: {
            args: Prisma.PlantillaActivoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlantillaActivoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaActivoPayload>[]
          }
          delete: {
            args: Prisma.PlantillaActivoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaActivoPayload>
          }
          update: {
            args: Prisma.PlantillaActivoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaActivoPayload>
          }
          deleteMany: {
            args: Prisma.PlantillaActivoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlantillaActivoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlantillaActivoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaActivoPayload>
          }
          aggregate: {
            args: Prisma.PlantillaActivoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlantillaActivo>
          }
          groupBy: {
            args: Prisma.PlantillaActivoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlantillaActivoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlantillaActivoCountArgs<ExtArgs>
            result: $Utils.Optional<PlantillaActivoCountAggregateOutputType> | number
          }
        }
      }
      Activo: {
        payload: Prisma.$ActivoPayload<ExtArgs>
        fields: Prisma.ActivoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoPayload>
          }
          findFirst: {
            args: Prisma.ActivoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoPayload>
          }
          findMany: {
            args: Prisma.ActivoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoPayload>[]
          }
          create: {
            args: Prisma.ActivoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoPayload>
          }
          createMany: {
            args: Prisma.ActivoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoPayload>[]
          }
          delete: {
            args: Prisma.ActivoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoPayload>
          }
          update: {
            args: Prisma.ActivoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoPayload>
          }
          deleteMany: {
            args: Prisma.ActivoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivoPayload>
          }
          aggregate: {
            args: Prisma.ActivoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivo>
          }
          groupBy: {
            args: Prisma.ActivoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivoCountArgs<ExtArgs>
            result: $Utils.Optional<ActivoCountAggregateOutputType> | number
          }
        }
      }
      Riesgo: {
        payload: Prisma.$RiesgoPayload<ExtArgs>
        fields: Prisma.RiesgoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiesgoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiesgoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiesgoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiesgoPayload>
          }
          findFirst: {
            args: Prisma.RiesgoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiesgoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiesgoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiesgoPayload>
          }
          findMany: {
            args: Prisma.RiesgoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiesgoPayload>[]
          }
          create: {
            args: Prisma.RiesgoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiesgoPayload>
          }
          createMany: {
            args: Prisma.RiesgoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiesgoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiesgoPayload>[]
          }
          delete: {
            args: Prisma.RiesgoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiesgoPayload>
          }
          update: {
            args: Prisma.RiesgoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiesgoPayload>
          }
          deleteMany: {
            args: Prisma.RiesgoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiesgoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RiesgoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiesgoPayload>
          }
          aggregate: {
            args: Prisma.RiesgoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiesgo>
          }
          groupBy: {
            args: Prisma.RiesgoGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiesgoGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiesgoCountArgs<ExtArgs>
            result: $Utils.Optional<RiesgoCountAggregateOutputType> | number
          }
        }
      }
      Incidente: {
        payload: Prisma.$IncidentePayload<ExtArgs>
        fields: Prisma.IncidenteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidenteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidenteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentePayload>
          }
          findFirst: {
            args: Prisma.IncidenteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidenteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentePayload>
          }
          findMany: {
            args: Prisma.IncidenteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentePayload>[]
          }
          create: {
            args: Prisma.IncidenteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentePayload>
          }
          createMany: {
            args: Prisma.IncidenteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidenteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentePayload>[]
          }
          delete: {
            args: Prisma.IncidenteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentePayload>
          }
          update: {
            args: Prisma.IncidenteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentePayload>
          }
          deleteMany: {
            args: Prisma.IncidenteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidenteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncidenteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentePayload>
          }
          aggregate: {
            args: Prisma.IncidenteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncidente>
          }
          groupBy: {
            args: Prisma.IncidenteGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidenteGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidenteCountArgs<ExtArgs>
            result: $Utils.Optional<IncidenteCountAggregateOutputType> | number
          }
        }
      }
      Defecto: {
        payload: Prisma.$DefectoPayload<ExtArgs>
        fields: Prisma.DefectoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DefectoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DefectoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectoPayload>
          }
          findFirst: {
            args: Prisma.DefectoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DefectoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectoPayload>
          }
          findMany: {
            args: Prisma.DefectoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectoPayload>[]
          }
          create: {
            args: Prisma.DefectoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectoPayload>
          }
          createMany: {
            args: Prisma.DefectoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DefectoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectoPayload>[]
          }
          delete: {
            args: Prisma.DefectoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectoPayload>
          }
          update: {
            args: Prisma.DefectoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectoPayload>
          }
          deleteMany: {
            args: Prisma.DefectoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DefectoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DefectoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefectoPayload>
          }
          aggregate: {
            args: Prisma.DefectoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDefecto>
          }
          groupBy: {
            args: Prisma.DefectoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DefectoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DefectoCountArgs<ExtArgs>
            result: $Utils.Optional<DefectoCountAggregateOutputType> | number
          }
        }
      }
      Organigrama: {
        payload: Prisma.$OrganigramaPayload<ExtArgs>
        fields: Prisma.OrganigramaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganigramaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganigramaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganigramaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganigramaPayload>
          }
          findFirst: {
            args: Prisma.OrganigramaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganigramaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganigramaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganigramaPayload>
          }
          findMany: {
            args: Prisma.OrganigramaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganigramaPayload>[]
          }
          create: {
            args: Prisma.OrganigramaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganigramaPayload>
          }
          createMany: {
            args: Prisma.OrganigramaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganigramaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganigramaPayload>[]
          }
          delete: {
            args: Prisma.OrganigramaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganigramaPayload>
          }
          update: {
            args: Prisma.OrganigramaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganigramaPayload>
          }
          deleteMany: {
            args: Prisma.OrganigramaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganigramaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganigramaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganigramaPayload>
          }
          aggregate: {
            args: Prisma.OrganigramaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganigrama>
          }
          groupBy: {
            args: Prisma.OrganigramaGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganigramaGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganigramaCountArgs<ExtArgs>
            result: $Utils.Optional<OrganigramaCountAggregateOutputType> | number
          }
        }
      }
      NodoOrganigrama: {
        payload: Prisma.$NodoOrganigramaPayload<ExtArgs>
        fields: Prisma.NodoOrganigramaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NodoOrganigramaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodoOrganigramaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NodoOrganigramaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodoOrganigramaPayload>
          }
          findFirst: {
            args: Prisma.NodoOrganigramaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodoOrganigramaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NodoOrganigramaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodoOrganigramaPayload>
          }
          findMany: {
            args: Prisma.NodoOrganigramaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodoOrganigramaPayload>[]
          }
          create: {
            args: Prisma.NodoOrganigramaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodoOrganigramaPayload>
          }
          createMany: {
            args: Prisma.NodoOrganigramaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NodoOrganigramaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodoOrganigramaPayload>[]
          }
          delete: {
            args: Prisma.NodoOrganigramaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodoOrganigramaPayload>
          }
          update: {
            args: Prisma.NodoOrganigramaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodoOrganigramaPayload>
          }
          deleteMany: {
            args: Prisma.NodoOrganigramaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NodoOrganigramaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NodoOrganigramaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodoOrganigramaPayload>
          }
          aggregate: {
            args: Prisma.NodoOrganigramaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNodoOrganigrama>
          }
          groupBy: {
            args: Prisma.NodoOrganigramaGroupByArgs<ExtArgs>
            result: $Utils.Optional<NodoOrganigramaGroupByOutputType>[]
          }
          count: {
            args: Prisma.NodoOrganigramaCountArgs<ExtArgs>
            result: $Utils.Optional<NodoOrganigramaCountAggregateOutputType> | number
          }
        }
      }
      MarcoNormativo: {
        payload: Prisma.$MarcoNormativoPayload<ExtArgs>
        fields: Prisma.MarcoNormativoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarcoNormativoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarcoNormativoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarcoNormativoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarcoNormativoPayload>
          }
          findFirst: {
            args: Prisma.MarcoNormativoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarcoNormativoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarcoNormativoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarcoNormativoPayload>
          }
          findMany: {
            args: Prisma.MarcoNormativoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarcoNormativoPayload>[]
          }
          create: {
            args: Prisma.MarcoNormativoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarcoNormativoPayload>
          }
          createMany: {
            args: Prisma.MarcoNormativoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarcoNormativoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarcoNormativoPayload>[]
          }
          delete: {
            args: Prisma.MarcoNormativoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarcoNormativoPayload>
          }
          update: {
            args: Prisma.MarcoNormativoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarcoNormativoPayload>
          }
          deleteMany: {
            args: Prisma.MarcoNormativoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarcoNormativoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarcoNormativoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarcoNormativoPayload>
          }
          aggregate: {
            args: Prisma.MarcoNormativoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarcoNormativo>
          }
          groupBy: {
            args: Prisma.MarcoNormativoGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarcoNormativoGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarcoNormativoCountArgs<ExtArgs>
            result: $Utils.Optional<MarcoNormativoCountAggregateOutputType> | number
          }
        }
      }
      RequisitoNormativo: {
        payload: Prisma.$RequisitoNormativoPayload<ExtArgs>
        fields: Prisma.RequisitoNormativoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequisitoNormativoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitoNormativoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequisitoNormativoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitoNormativoPayload>
          }
          findFirst: {
            args: Prisma.RequisitoNormativoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitoNormativoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequisitoNormativoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitoNormativoPayload>
          }
          findMany: {
            args: Prisma.RequisitoNormativoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitoNormativoPayload>[]
          }
          create: {
            args: Prisma.RequisitoNormativoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitoNormativoPayload>
          }
          createMany: {
            args: Prisma.RequisitoNormativoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequisitoNormativoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitoNormativoPayload>[]
          }
          delete: {
            args: Prisma.RequisitoNormativoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitoNormativoPayload>
          }
          update: {
            args: Prisma.RequisitoNormativoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitoNormativoPayload>
          }
          deleteMany: {
            args: Prisma.RequisitoNormativoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequisitoNormativoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RequisitoNormativoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitoNormativoPayload>
          }
          aggregate: {
            args: Prisma.RequisitoNormativoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequisitoNormativo>
          }
          groupBy: {
            args: Prisma.RequisitoNormativoGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequisitoNormativoGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequisitoNormativoCountArgs<ExtArgs>
            result: $Utils.Optional<RequisitoNormativoCountAggregateOutputType> | number
          }
        }
      }
      Cuestionario: {
        payload: Prisma.$CuestionarioPayload<ExtArgs>
        fields: Prisma.CuestionarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CuestionarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuestionarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CuestionarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuestionarioPayload>
          }
          findFirst: {
            args: Prisma.CuestionarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuestionarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CuestionarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuestionarioPayload>
          }
          findMany: {
            args: Prisma.CuestionarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuestionarioPayload>[]
          }
          create: {
            args: Prisma.CuestionarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuestionarioPayload>
          }
          createMany: {
            args: Prisma.CuestionarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CuestionarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuestionarioPayload>[]
          }
          delete: {
            args: Prisma.CuestionarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuestionarioPayload>
          }
          update: {
            args: Prisma.CuestionarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuestionarioPayload>
          }
          deleteMany: {
            args: Prisma.CuestionarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CuestionarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CuestionarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuestionarioPayload>
          }
          aggregate: {
            args: Prisma.CuestionarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCuestionario>
          }
          groupBy: {
            args: Prisma.CuestionarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<CuestionarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.CuestionarioCountArgs<ExtArgs>
            result: $Utils.Optional<CuestionarioCountAggregateOutputType> | number
          }
        }
      }
      Seccion: {
        payload: Prisma.$SeccionPayload<ExtArgs>
        fields: Prisma.SeccionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeccionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeccionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeccionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeccionPayload>
          }
          findFirst: {
            args: Prisma.SeccionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeccionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeccionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeccionPayload>
          }
          findMany: {
            args: Prisma.SeccionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeccionPayload>[]
          }
          create: {
            args: Prisma.SeccionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeccionPayload>
          }
          createMany: {
            args: Prisma.SeccionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeccionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeccionPayload>[]
          }
          delete: {
            args: Prisma.SeccionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeccionPayload>
          }
          update: {
            args: Prisma.SeccionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeccionPayload>
          }
          deleteMany: {
            args: Prisma.SeccionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeccionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeccionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeccionPayload>
          }
          aggregate: {
            args: Prisma.SeccionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeccion>
          }
          groupBy: {
            args: Prisma.SeccionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeccionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeccionCountArgs<ExtArgs>
            result: $Utils.Optional<SeccionCountAggregateOutputType> | number
          }
        }
      }
      Pregunta: {
        payload: Prisma.$PreguntaPayload<ExtArgs>
        fields: Prisma.PreguntaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PreguntaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreguntaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PreguntaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreguntaPayload>
          }
          findFirst: {
            args: Prisma.PreguntaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreguntaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PreguntaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreguntaPayload>
          }
          findMany: {
            args: Prisma.PreguntaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreguntaPayload>[]
          }
          create: {
            args: Prisma.PreguntaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreguntaPayload>
          }
          createMany: {
            args: Prisma.PreguntaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PreguntaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreguntaPayload>[]
          }
          delete: {
            args: Prisma.PreguntaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreguntaPayload>
          }
          update: {
            args: Prisma.PreguntaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreguntaPayload>
          }
          deleteMany: {
            args: Prisma.PreguntaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PreguntaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PreguntaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreguntaPayload>
          }
          aggregate: {
            args: Prisma.PreguntaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePregunta>
          }
          groupBy: {
            args: Prisma.PreguntaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreguntaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PreguntaCountArgs<ExtArgs>
            result: $Utils.Optional<PreguntaCountAggregateOutputType> | number
          }
        }
      }
      AsignacionCuestionario: {
        payload: Prisma.$AsignacionCuestionarioPayload<ExtArgs>
        fields: Prisma.AsignacionCuestionarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AsignacionCuestionarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsignacionCuestionarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AsignacionCuestionarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsignacionCuestionarioPayload>
          }
          findFirst: {
            args: Prisma.AsignacionCuestionarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsignacionCuestionarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AsignacionCuestionarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsignacionCuestionarioPayload>
          }
          findMany: {
            args: Prisma.AsignacionCuestionarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsignacionCuestionarioPayload>[]
          }
          create: {
            args: Prisma.AsignacionCuestionarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsignacionCuestionarioPayload>
          }
          createMany: {
            args: Prisma.AsignacionCuestionarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AsignacionCuestionarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsignacionCuestionarioPayload>[]
          }
          delete: {
            args: Prisma.AsignacionCuestionarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsignacionCuestionarioPayload>
          }
          update: {
            args: Prisma.AsignacionCuestionarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsignacionCuestionarioPayload>
          }
          deleteMany: {
            args: Prisma.AsignacionCuestionarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AsignacionCuestionarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AsignacionCuestionarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsignacionCuestionarioPayload>
          }
          aggregate: {
            args: Prisma.AsignacionCuestionarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsignacionCuestionario>
          }
          groupBy: {
            args: Prisma.AsignacionCuestionarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<AsignacionCuestionarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.AsignacionCuestionarioCountArgs<ExtArgs>
            result: $Utils.Optional<AsignacionCuestionarioCountAggregateOutputType> | number
          }
        }
      }
      EvaluadoExterno: {
        payload: Prisma.$EvaluadoExternoPayload<ExtArgs>
        fields: Prisma.EvaluadoExternoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluadoExternoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluadoExternoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluadoExternoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluadoExternoPayload>
          }
          findFirst: {
            args: Prisma.EvaluadoExternoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluadoExternoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluadoExternoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluadoExternoPayload>
          }
          findMany: {
            args: Prisma.EvaluadoExternoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluadoExternoPayload>[]
          }
          create: {
            args: Prisma.EvaluadoExternoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluadoExternoPayload>
          }
          createMany: {
            args: Prisma.EvaluadoExternoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluadoExternoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluadoExternoPayload>[]
          }
          delete: {
            args: Prisma.EvaluadoExternoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluadoExternoPayload>
          }
          update: {
            args: Prisma.EvaluadoExternoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluadoExternoPayload>
          }
          deleteMany: {
            args: Prisma.EvaluadoExternoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluadoExternoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvaluadoExternoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluadoExternoPayload>
          }
          aggregate: {
            args: Prisma.EvaluadoExternoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluadoExterno>
          }
          groupBy: {
            args: Prisma.EvaluadoExternoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluadoExternoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluadoExternoCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluadoExternoCountAggregateOutputType> | number
          }
        }
      }
      RespuestaCuestionario: {
        payload: Prisma.$RespuestaCuestionarioPayload<ExtArgs>
        fields: Prisma.RespuestaCuestionarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RespuestaCuestionarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaCuestionarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RespuestaCuestionarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaCuestionarioPayload>
          }
          findFirst: {
            args: Prisma.RespuestaCuestionarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaCuestionarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RespuestaCuestionarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaCuestionarioPayload>
          }
          findMany: {
            args: Prisma.RespuestaCuestionarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaCuestionarioPayload>[]
          }
          create: {
            args: Prisma.RespuestaCuestionarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaCuestionarioPayload>
          }
          createMany: {
            args: Prisma.RespuestaCuestionarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RespuestaCuestionarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaCuestionarioPayload>[]
          }
          delete: {
            args: Prisma.RespuestaCuestionarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaCuestionarioPayload>
          }
          update: {
            args: Prisma.RespuestaCuestionarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaCuestionarioPayload>
          }
          deleteMany: {
            args: Prisma.RespuestaCuestionarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RespuestaCuestionarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RespuestaCuestionarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaCuestionarioPayload>
          }
          aggregate: {
            args: Prisma.RespuestaCuestionarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRespuestaCuestionario>
          }
          groupBy: {
            args: Prisma.RespuestaCuestionarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<RespuestaCuestionarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.RespuestaCuestionarioCountArgs<ExtArgs>
            result: $Utils.Optional<RespuestaCuestionarioCountAggregateOutputType> | number
          }
        }
      }
      RespuestaPregunta: {
        payload: Prisma.$RespuestaPreguntaPayload<ExtArgs>
        fields: Prisma.RespuestaPreguntaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RespuestaPreguntaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaPreguntaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RespuestaPreguntaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaPreguntaPayload>
          }
          findFirst: {
            args: Prisma.RespuestaPreguntaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaPreguntaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RespuestaPreguntaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaPreguntaPayload>
          }
          findMany: {
            args: Prisma.RespuestaPreguntaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaPreguntaPayload>[]
          }
          create: {
            args: Prisma.RespuestaPreguntaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaPreguntaPayload>
          }
          createMany: {
            args: Prisma.RespuestaPreguntaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RespuestaPreguntaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaPreguntaPayload>[]
          }
          delete: {
            args: Prisma.RespuestaPreguntaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaPreguntaPayload>
          }
          update: {
            args: Prisma.RespuestaPreguntaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaPreguntaPayload>
          }
          deleteMany: {
            args: Prisma.RespuestaPreguntaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RespuestaPreguntaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RespuestaPreguntaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RespuestaPreguntaPayload>
          }
          aggregate: {
            args: Prisma.RespuestaPreguntaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRespuestaPregunta>
          }
          groupBy: {
            args: Prisma.RespuestaPreguntaGroupByArgs<ExtArgs>
            result: $Utils.Optional<RespuestaPreguntaGroupByOutputType>[]
          }
          count: {
            args: Prisma.RespuestaPreguntaCountArgs<ExtArgs>
            result: $Utils.Optional<RespuestaPreguntaCountAggregateOutputType> | number
          }
        }
      }
      Evidencia: {
        payload: Prisma.$EvidenciaPayload<ExtArgs>
        fields: Prisma.EvidenciaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvidenciaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvidenciaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          findFirst: {
            args: Prisma.EvidenciaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvidenciaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          findMany: {
            args: Prisma.EvidenciaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>[]
          }
          create: {
            args: Prisma.EvidenciaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          createMany: {
            args: Prisma.EvidenciaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvidenciaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>[]
          }
          delete: {
            args: Prisma.EvidenciaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          update: {
            args: Prisma.EvidenciaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          deleteMany: {
            args: Prisma.EvidenciaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvidenciaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvidenciaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          aggregate: {
            args: Prisma.EvidenciaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvidencia>
          }
          groupBy: {
            args: Prisma.EvidenciaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvidenciaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvidenciaCountArgs<ExtArgs>
            result: $Utils.Optional<EvidenciaCountAggregateOutputType> | number
          }
        }
      }
      Hallazgo: {
        payload: Prisma.$HallazgoPayload<ExtArgs>
        fields: Prisma.HallazgoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HallazgoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallazgoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HallazgoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallazgoPayload>
          }
          findFirst: {
            args: Prisma.HallazgoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallazgoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HallazgoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallazgoPayload>
          }
          findMany: {
            args: Prisma.HallazgoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallazgoPayload>[]
          }
          create: {
            args: Prisma.HallazgoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallazgoPayload>
          }
          createMany: {
            args: Prisma.HallazgoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HallazgoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallazgoPayload>[]
          }
          delete: {
            args: Prisma.HallazgoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallazgoPayload>
          }
          update: {
            args: Prisma.HallazgoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallazgoPayload>
          }
          deleteMany: {
            args: Prisma.HallazgoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HallazgoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HallazgoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallazgoPayload>
          }
          aggregate: {
            args: Prisma.HallazgoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHallazgo>
          }
          groupBy: {
            args: Prisma.HallazgoGroupByArgs<ExtArgs>
            result: $Utils.Optional<HallazgoGroupByOutputType>[]
          }
          count: {
            args: Prisma.HallazgoCountArgs<ExtArgs>
            result: $Utils.Optional<HallazgoCountAggregateOutputType> | number
          }
        }
      }
      MensajeChat: {
        payload: Prisma.$MensajeChatPayload<ExtArgs>
        fields: Prisma.MensajeChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MensajeChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajeChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MensajeChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajeChatPayload>
          }
          findFirst: {
            args: Prisma.MensajeChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajeChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MensajeChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajeChatPayload>
          }
          findMany: {
            args: Prisma.MensajeChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajeChatPayload>[]
          }
          create: {
            args: Prisma.MensajeChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajeChatPayload>
          }
          createMany: {
            args: Prisma.MensajeChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MensajeChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajeChatPayload>[]
          }
          delete: {
            args: Prisma.MensajeChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajeChatPayload>
          }
          update: {
            args: Prisma.MensajeChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajeChatPayload>
          }
          deleteMany: {
            args: Prisma.MensajeChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MensajeChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MensajeChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajeChatPayload>
          }
          aggregate: {
            args: Prisma.MensajeChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMensajeChat>
          }
          groupBy: {
            args: Prisma.MensajeChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<MensajeChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.MensajeChatCountArgs<ExtArgs>
            result: $Utils.Optional<MensajeChatCountAggregateOutputType> | number
          }
        }
      }
      AlertaCumplimiento: {
        payload: Prisma.$AlertaCumplimientoPayload<ExtArgs>
        fields: Prisma.AlertaCumplimientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertaCumplimientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaCumplimientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertaCumplimientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaCumplimientoPayload>
          }
          findFirst: {
            args: Prisma.AlertaCumplimientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaCumplimientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertaCumplimientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaCumplimientoPayload>
          }
          findMany: {
            args: Prisma.AlertaCumplimientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaCumplimientoPayload>[]
          }
          create: {
            args: Prisma.AlertaCumplimientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaCumplimientoPayload>
          }
          createMany: {
            args: Prisma.AlertaCumplimientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertaCumplimientoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaCumplimientoPayload>[]
          }
          delete: {
            args: Prisma.AlertaCumplimientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaCumplimientoPayload>
          }
          update: {
            args: Prisma.AlertaCumplimientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaCumplimientoPayload>
          }
          deleteMany: {
            args: Prisma.AlertaCumplimientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertaCumplimientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertaCumplimientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaCumplimientoPayload>
          }
          aggregate: {
            args: Prisma.AlertaCumplimientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlertaCumplimiento>
          }
          groupBy: {
            args: Prisma.AlertaCumplimientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertaCumplimientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertaCumplimientoCountArgs<ExtArgs>
            result: $Utils.Optional<AlertaCumplimientoCountAggregateOutputType> | number
          }
        }
      }
      Proceso: {
        payload: Prisma.$ProcesoPayload<ExtArgs>
        fields: Prisma.ProcesoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcesoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcesoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          findFirst: {
            args: Prisma.ProcesoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcesoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          findMany: {
            args: Prisma.ProcesoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>[]
          }
          create: {
            args: Prisma.ProcesoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          createMany: {
            args: Prisma.ProcesoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcesoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>[]
          }
          delete: {
            args: Prisma.ProcesoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          update: {
            args: Prisma.ProcesoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          deleteMany: {
            args: Prisma.ProcesoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcesoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcesoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          aggregate: {
            args: Prisma.ProcesoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProceso>
          }
          groupBy: {
            args: Prisma.ProcesoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcesoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcesoCountArgs<ExtArgs>
            result: $Utils.Optional<ProcesoCountAggregateOutputType> | number
          }
        }
      }
      ProcessNode: {
        payload: Prisma.$ProcessNodePayload<ExtArgs>
        fields: Prisma.ProcessNodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessNodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessNodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessNodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessNodePayload>
          }
          findFirst: {
            args: Prisma.ProcessNodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessNodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessNodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessNodePayload>
          }
          findMany: {
            args: Prisma.ProcessNodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessNodePayload>[]
          }
          create: {
            args: Prisma.ProcessNodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessNodePayload>
          }
          createMany: {
            args: Prisma.ProcessNodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessNodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessNodePayload>[]
          }
          delete: {
            args: Prisma.ProcessNodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessNodePayload>
          }
          update: {
            args: Prisma.ProcessNodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessNodePayload>
          }
          deleteMany: {
            args: Prisma.ProcessNodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessNodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessNodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessNodePayload>
          }
          aggregate: {
            args: Prisma.ProcessNodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessNode>
          }
          groupBy: {
            args: Prisma.ProcessNodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessNodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessNodeCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessNodeCountAggregateOutputType> | number
          }
        }
      }
      ProcessEdge: {
        payload: Prisma.$ProcessEdgePayload<ExtArgs>
        fields: Prisma.ProcessEdgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessEdgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessEdgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessEdgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessEdgePayload>
          }
          findFirst: {
            args: Prisma.ProcessEdgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessEdgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessEdgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessEdgePayload>
          }
          findMany: {
            args: Prisma.ProcessEdgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessEdgePayload>[]
          }
          create: {
            args: Prisma.ProcessEdgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessEdgePayload>
          }
          createMany: {
            args: Prisma.ProcessEdgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessEdgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessEdgePayload>[]
          }
          delete: {
            args: Prisma.ProcessEdgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessEdgePayload>
          }
          update: {
            args: Prisma.ProcessEdgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessEdgePayload>
          }
          deleteMany: {
            args: Prisma.ProcessEdgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessEdgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessEdgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessEdgePayload>
          }
          aggregate: {
            args: Prisma.ProcessEdgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessEdge>
          }
          groupBy: {
            args: Prisma.ProcessEdgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessEdgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessEdgeCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessEdgeCountAggregateOutputType> | number
          }
        }
      }
      ObjetivoProceso: {
        payload: Prisma.$ObjetivoProcesoPayload<ExtArgs>
        fields: Prisma.ObjetivoProcesoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObjetivoProcesoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjetivoProcesoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObjetivoProcesoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjetivoProcesoPayload>
          }
          findFirst: {
            args: Prisma.ObjetivoProcesoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjetivoProcesoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObjetivoProcesoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjetivoProcesoPayload>
          }
          findMany: {
            args: Prisma.ObjetivoProcesoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjetivoProcesoPayload>[]
          }
          create: {
            args: Prisma.ObjetivoProcesoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjetivoProcesoPayload>
          }
          createMany: {
            args: Prisma.ObjetivoProcesoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ObjetivoProcesoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjetivoProcesoPayload>[]
          }
          delete: {
            args: Prisma.ObjetivoProcesoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjetivoProcesoPayload>
          }
          update: {
            args: Prisma.ObjetivoProcesoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjetivoProcesoPayload>
          }
          deleteMany: {
            args: Prisma.ObjetivoProcesoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ObjetivoProcesoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ObjetivoProcesoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjetivoProcesoPayload>
          }
          aggregate: {
            args: Prisma.ObjetivoProcesoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObjetivoProceso>
          }
          groupBy: {
            args: Prisma.ObjetivoProcesoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObjetivoProcesoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObjetivoProcesoCountArgs<ExtArgs>
            result: $Utils.Optional<ObjetivoProcesoCountAggregateOutputType> | number
          }
        }
      }
      KpiProceso: {
        payload: Prisma.$KpiProcesoPayload<ExtArgs>
        fields: Prisma.KpiProcesoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KpiProcesoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiProcesoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KpiProcesoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiProcesoPayload>
          }
          findFirst: {
            args: Prisma.KpiProcesoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiProcesoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KpiProcesoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiProcesoPayload>
          }
          findMany: {
            args: Prisma.KpiProcesoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiProcesoPayload>[]
          }
          create: {
            args: Prisma.KpiProcesoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiProcesoPayload>
          }
          createMany: {
            args: Prisma.KpiProcesoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KpiProcesoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiProcesoPayload>[]
          }
          delete: {
            args: Prisma.KpiProcesoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiProcesoPayload>
          }
          update: {
            args: Prisma.KpiProcesoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiProcesoPayload>
          }
          deleteMany: {
            args: Prisma.KpiProcesoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KpiProcesoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KpiProcesoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiProcesoPayload>
          }
          aggregate: {
            args: Prisma.KpiProcesoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKpiProceso>
          }
          groupBy: {
            args: Prisma.KpiProcesoGroupByArgs<ExtArgs>
            result: $Utils.Optional<KpiProcesoGroupByOutputType>[]
          }
          count: {
            args: Prisma.KpiProcesoCountArgs<ExtArgs>
            result: $Utils.Optional<KpiProcesoCountAggregateOutputType> | number
          }
        }
      }
      KpiHistorico: {
        payload: Prisma.$KpiHistoricoPayload<ExtArgs>
        fields: Prisma.KpiHistoricoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KpiHistoricoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiHistoricoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KpiHistoricoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiHistoricoPayload>
          }
          findFirst: {
            args: Prisma.KpiHistoricoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiHistoricoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KpiHistoricoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiHistoricoPayload>
          }
          findMany: {
            args: Prisma.KpiHistoricoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiHistoricoPayload>[]
          }
          create: {
            args: Prisma.KpiHistoricoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiHistoricoPayload>
          }
          createMany: {
            args: Prisma.KpiHistoricoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KpiHistoricoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiHistoricoPayload>[]
          }
          delete: {
            args: Prisma.KpiHistoricoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiHistoricoPayload>
          }
          update: {
            args: Prisma.KpiHistoricoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiHistoricoPayload>
          }
          deleteMany: {
            args: Prisma.KpiHistoricoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KpiHistoricoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KpiHistoricoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiHistoricoPayload>
          }
          aggregate: {
            args: Prisma.KpiHistoricoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKpiHistorico>
          }
          groupBy: {
            args: Prisma.KpiHistoricoGroupByArgs<ExtArgs>
            result: $Utils.Optional<KpiHistoricoGroupByOutputType>[]
          }
          count: {
            args: Prisma.KpiHistoricoCountArgs<ExtArgs>
            result: $Utils.Optional<KpiHistoricoCountAggregateOutputType> | number
          }
        }
      }
      DashboardConfig: {
        payload: Prisma.$DashboardConfigPayload<ExtArgs>
        fields: Prisma.DashboardConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DashboardConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DashboardConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>
          }
          findFirst: {
            args: Prisma.DashboardConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DashboardConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>
          }
          findMany: {
            args: Prisma.DashboardConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>[]
          }
          create: {
            args: Prisma.DashboardConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>
          }
          createMany: {
            args: Prisma.DashboardConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DashboardConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>[]
          }
          delete: {
            args: Prisma.DashboardConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>
          }
          update: {
            args: Prisma.DashboardConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>
          }
          deleteMany: {
            args: Prisma.DashboardConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DashboardConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DashboardConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardConfigPayload>
          }
          aggregate: {
            args: Prisma.DashboardConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDashboardConfig>
          }
          groupBy: {
            args: Prisma.DashboardConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<DashboardConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.DashboardConfigCountArgs<ExtArgs>
            result: $Utils.Optional<DashboardConfigCountAggregateOutputType> | number
          }
        }
      }
      DashboardWidget: {
        payload: Prisma.$DashboardWidgetPayload<ExtArgs>
        fields: Prisma.DashboardWidgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DashboardWidgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardWidgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DashboardWidgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardWidgetPayload>
          }
          findFirst: {
            args: Prisma.DashboardWidgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardWidgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DashboardWidgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardWidgetPayload>
          }
          findMany: {
            args: Prisma.DashboardWidgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardWidgetPayload>[]
          }
          create: {
            args: Prisma.DashboardWidgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardWidgetPayload>
          }
          createMany: {
            args: Prisma.DashboardWidgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DashboardWidgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardWidgetPayload>[]
          }
          delete: {
            args: Prisma.DashboardWidgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardWidgetPayload>
          }
          update: {
            args: Prisma.DashboardWidgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardWidgetPayload>
          }
          deleteMany: {
            args: Prisma.DashboardWidgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DashboardWidgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DashboardWidgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardWidgetPayload>
          }
          aggregate: {
            args: Prisma.DashboardWidgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDashboardWidget>
          }
          groupBy: {
            args: Prisma.DashboardWidgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<DashboardWidgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.DashboardWidgetCountArgs<ExtArgs>
            result: $Utils.Optional<DashboardWidgetCountAggregateOutputType> | number
          }
        }
      }
      Catalogo: {
        payload: Prisma.$CatalogoPayload<ExtArgs>
        fields: Prisma.CatalogoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPayload>
          }
          findFirst: {
            args: Prisma.CatalogoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPayload>
          }
          findMany: {
            args: Prisma.CatalogoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPayload>[]
          }
          create: {
            args: Prisma.CatalogoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPayload>
          }
          createMany: {
            args: Prisma.CatalogoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPayload>[]
          }
          delete: {
            args: Prisma.CatalogoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPayload>
          }
          update: {
            args: Prisma.CatalogoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPayload>
          }
          deleteMany: {
            args: Prisma.CatalogoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CatalogoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPayload>
          }
          aggregate: {
            args: Prisma.CatalogoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatalogo>
          }
          groupBy: {
            args: Prisma.CatalogoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatalogoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogoCountArgs<ExtArgs>
            result: $Utils.Optional<CatalogoCountAggregateOutputType> | number
          }
        }
      }
      NotificationRule: {
        payload: Prisma.$NotificationRulePayload<ExtArgs>
        fields: Prisma.NotificationRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          findFirst: {
            args: Prisma.NotificationRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          findMany: {
            args: Prisma.NotificationRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>[]
          }
          create: {
            args: Prisma.NotificationRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          createMany: {
            args: Prisma.NotificationRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>[]
          }
          delete: {
            args: Prisma.NotificationRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          update: {
            args: Prisma.NotificationRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          deleteMany: {
            args: Prisma.NotificationRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          aggregate: {
            args: Prisma.NotificationRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationRule>
          }
          groupBy: {
            args: Prisma.NotificationRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationRuleCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationRuleCountAggregateOutputType> | number
          }
        }
      }
      AlertRule: {
        payload: Prisma.$AlertRulePayload<ExtArgs>
        fields: Prisma.AlertRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          findFirst: {
            args: Prisma.AlertRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          findMany: {
            args: Prisma.AlertRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>[]
          }
          create: {
            args: Prisma.AlertRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          createMany: {
            args: Prisma.AlertRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>[]
          }
          delete: {
            args: Prisma.AlertRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          update: {
            args: Prisma.AlertRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          deleteMany: {
            args: Prisma.AlertRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          aggregate: {
            args: Prisma.AlertRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlertRule>
          }
          groupBy: {
            args: Prisma.AlertRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertRuleCountArgs<ExtArgs>
            result: $Utils.Optional<AlertRuleCountAggregateOutputType> | number
          }
        }
      }
      ExpirationRule: {
        payload: Prisma.$ExpirationRulePayload<ExtArgs>
        fields: Prisma.ExpirationRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpirationRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpirationRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpirationRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpirationRulePayload>
          }
          findFirst: {
            args: Prisma.ExpirationRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpirationRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpirationRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpirationRulePayload>
          }
          findMany: {
            args: Prisma.ExpirationRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpirationRulePayload>[]
          }
          create: {
            args: Prisma.ExpirationRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpirationRulePayload>
          }
          createMany: {
            args: Prisma.ExpirationRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpirationRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpirationRulePayload>[]
          }
          delete: {
            args: Prisma.ExpirationRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpirationRulePayload>
          }
          update: {
            args: Prisma.ExpirationRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpirationRulePayload>
          }
          deleteMany: {
            args: Prisma.ExpirationRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpirationRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpirationRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpirationRulePayload>
          }
          aggregate: {
            args: Prisma.ExpirationRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpirationRule>
          }
          groupBy: {
            args: Prisma.ExpirationRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpirationRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpirationRuleCountArgs<ExtArgs>
            result: $Utils.Optional<ExpirationRuleCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      UserNotificationPreferences: {
        payload: Prisma.$UserNotificationPreferencesPayload<ExtArgs>
        fields: Prisma.UserNotificationPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserNotificationPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserNotificationPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload>
          }
          findFirst: {
            args: Prisma.UserNotificationPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserNotificationPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload>
          }
          findMany: {
            args: Prisma.UserNotificationPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload>[]
          }
          create: {
            args: Prisma.UserNotificationPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload>
          }
          createMany: {
            args: Prisma.UserNotificationPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserNotificationPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload>[]
          }
          delete: {
            args: Prisma.UserNotificationPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload>
          }
          update: {
            args: Prisma.UserNotificationPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.UserNotificationPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserNotificationPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserNotificationPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload>
          }
          aggregate: {
            args: Prisma.UserNotificationPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserNotificationPreferences>
          }
          groupBy: {
            args: Prisma.UserNotificationPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserNotificationPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserNotificationPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<UserNotificationPreferencesCountAggregateOutputType> | number
          }
        }
      }
      NotificationLog: {
        payload: Prisma.$NotificationLogPayload<ExtArgs>
        fields: Prisma.NotificationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findFirst: {
            args: Prisma.NotificationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findMany: {
            args: Prisma.NotificationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          create: {
            args: Prisma.NotificationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          createMany: {
            args: Prisma.NotificationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          delete: {
            args: Prisma.NotificationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          update: {
            args: Prisma.NotificationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          deleteMany: {
            args: Prisma.NotificationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          aggregate: {
            args: Prisma.NotificationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationLog>
          }
          groupBy: {
            args: Prisma.NotificationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationLogCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogCountAggregateOutputType> | number
          }
        }
      }
      NotificationProfile: {
        payload: Prisma.$NotificationProfilePayload<ExtArgs>
        fields: Prisma.NotificationProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProfilePayload>
          }
          findFirst: {
            args: Prisma.NotificationProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProfilePayload>
          }
          findMany: {
            args: Prisma.NotificationProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProfilePayload>[]
          }
          create: {
            args: Prisma.NotificationProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProfilePayload>
          }
          createMany: {
            args: Prisma.NotificationProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProfilePayload>[]
          }
          delete: {
            args: Prisma.NotificationProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProfilePayload>
          }
          update: {
            args: Prisma.NotificationProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProfilePayload>
          }
          deleteMany: {
            args: Prisma.NotificationProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProfilePayload>
          }
          aggregate: {
            args: Prisma.NotificationProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationProfile>
          }
          groupBy: {
            args: Prisma.NotificationProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationProfileCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationProfileCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectObjective: {
        payload: Prisma.$ProjectObjectivePayload<ExtArgs>
        fields: Prisma.ProjectObjectiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectObjectiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectObjectivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectObjectiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectObjectivePayload>
          }
          findFirst: {
            args: Prisma.ProjectObjectiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectObjectivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectObjectiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectObjectivePayload>
          }
          findMany: {
            args: Prisma.ProjectObjectiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectObjectivePayload>[]
          }
          create: {
            args: Prisma.ProjectObjectiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectObjectivePayload>
          }
          createMany: {
            args: Prisma.ProjectObjectiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectObjectiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectObjectivePayload>[]
          }
          delete: {
            args: Prisma.ProjectObjectiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectObjectivePayload>
          }
          update: {
            args: Prisma.ProjectObjectiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectObjectivePayload>
          }
          deleteMany: {
            args: Prisma.ProjectObjectiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectObjectiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectObjectiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectObjectivePayload>
          }
          aggregate: {
            args: Prisma.ProjectObjectiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectObjective>
          }
          groupBy: {
            args: Prisma.ProjectObjectiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectObjectiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectObjectiveCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectObjectiveCountAggregateOutputType> | number
          }
        }
      }
      ProjectKPI: {
        payload: Prisma.$ProjectKPIPayload<ExtArgs>
        fields: Prisma.ProjectKPIFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectKPIFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectKPIPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectKPIFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectKPIPayload>
          }
          findFirst: {
            args: Prisma.ProjectKPIFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectKPIPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectKPIFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectKPIPayload>
          }
          findMany: {
            args: Prisma.ProjectKPIFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectKPIPayload>[]
          }
          create: {
            args: Prisma.ProjectKPICreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectKPIPayload>
          }
          createMany: {
            args: Prisma.ProjectKPICreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectKPICreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectKPIPayload>[]
          }
          delete: {
            args: Prisma.ProjectKPIDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectKPIPayload>
          }
          update: {
            args: Prisma.ProjectKPIUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectKPIPayload>
          }
          deleteMany: {
            args: Prisma.ProjectKPIDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectKPIUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectKPIUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectKPIPayload>
          }
          aggregate: {
            args: Prisma.ProjectKPIAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectKPI>
          }
          groupBy: {
            args: Prisma.ProjectKPIGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectKPIGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectKPICountArgs<ExtArgs>
            result: $Utils.Optional<ProjectKPICountAggregateOutputType> | number
          }
        }
      }
      ProjectPhase: {
        payload: Prisma.$ProjectPhasePayload<ExtArgs>
        fields: Prisma.ProjectPhaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectPhaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectPhaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload>
          }
          findFirst: {
            args: Prisma.ProjectPhaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectPhaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload>
          }
          findMany: {
            args: Prisma.ProjectPhaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload>[]
          }
          create: {
            args: Prisma.ProjectPhaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload>
          }
          createMany: {
            args: Prisma.ProjectPhaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectPhaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload>[]
          }
          delete: {
            args: Prisma.ProjectPhaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload>
          }
          update: {
            args: Prisma.ProjectPhaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload>
          }
          deleteMany: {
            args: Prisma.ProjectPhaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectPhaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectPhaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload>
          }
          aggregate: {
            args: Prisma.ProjectPhaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectPhase>
          }
          groupBy: {
            args: Prisma.ProjectPhaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectPhaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectPhaseCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectPhaseCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskEvidence: {
        payload: Prisma.$TaskEvidencePayload<ExtArgs>
        fields: Prisma.TaskEvidenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskEvidenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEvidencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskEvidenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEvidencePayload>
          }
          findFirst: {
            args: Prisma.TaskEvidenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEvidencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskEvidenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEvidencePayload>
          }
          findMany: {
            args: Prisma.TaskEvidenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEvidencePayload>[]
          }
          create: {
            args: Prisma.TaskEvidenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEvidencePayload>
          }
          createMany: {
            args: Prisma.TaskEvidenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskEvidenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEvidencePayload>[]
          }
          delete: {
            args: Prisma.TaskEvidenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEvidencePayload>
          }
          update: {
            args: Prisma.TaskEvidenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEvidencePayload>
          }
          deleteMany: {
            args: Prisma.TaskEvidenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskEvidenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskEvidenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEvidencePayload>
          }
          aggregate: {
            args: Prisma.TaskEvidenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskEvidence>
          }
          groupBy: {
            args: Prisma.TaskEvidenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskEvidenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskEvidenceCountArgs<ExtArgs>
            result: $Utils.Optional<TaskEvidenceCountAggregateOutputType> | number
          }
        }
      }
      TaskHistory: {
        payload: Prisma.$TaskHistoryPayload<ExtArgs>
        fields: Prisma.TaskHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskHistoryPayload>
          }
          findFirst: {
            args: Prisma.TaskHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskHistoryPayload>
          }
          findMany: {
            args: Prisma.TaskHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskHistoryPayload>[]
          }
          create: {
            args: Prisma.TaskHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskHistoryPayload>
          }
          createMany: {
            args: Prisma.TaskHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskHistoryPayload>[]
          }
          delete: {
            args: Prisma.TaskHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskHistoryPayload>
          }
          update: {
            args: Prisma.TaskHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskHistoryPayload>
          }
          deleteMany: {
            args: Prisma.TaskHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskHistoryPayload>
          }
          aggregate: {
            args: Prisma.TaskHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskHistory>
          }
          groupBy: {
            args: Prisma.TaskHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<TaskHistoryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    roles: number
    activosAcceso: number
    logsAuditoria: number
    respuestasCuestionario: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | UsuarioCountOutputTypeCountRolesArgs
    activosAcceso?: boolean | UsuarioCountOutputTypeCountActivosAccesoArgs
    logsAuditoria?: boolean | UsuarioCountOutputTypeCountLogsAuditoriaArgs
    respuestasCuestionario?: boolean | UsuarioCountOutputTypeCountRespuestasCuestionarioArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioRolWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountActivosAccesoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioActivoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountLogsAuditoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogAuditoriaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountRespuestasCuestionarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RespuestaCuestionarioWhereInput
  }


  /**
   * Count Type RolCountOutputType
   */

  export type RolCountOutputType = {
    usuarios: number
    permisos: number
  }

  export type RolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | RolCountOutputTypeCountUsuariosArgs
    permisos?: boolean | RolCountOutputTypeCountPermisosArgs
  }

  // Custom InputTypes
  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolCountOutputType
     */
    select?: RolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioRolWhereInput
  }

  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeCountPermisosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolPermisoWhereInput
  }


  /**
   * Count Type PermisoCountOutputType
   */

  export type PermisoCountOutputType = {
    hijos: number
    roles: number
  }

  export type PermisoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hijos?: boolean | PermisoCountOutputTypeCountHijosArgs
    roles?: boolean | PermisoCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermisoCountOutputType without action
   */
  export type PermisoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermisoCountOutputType
     */
    select?: PermisoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermisoCountOutputType without action
   */
  export type PermisoCountOutputTypeCountHijosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermisoWhereInput
  }

  /**
   * PermisoCountOutputType without action
   */
  export type PermisoCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolPermisoWhereInput
  }


  /**
   * Count Type ActivoAccesoCountOutputType
   */

  export type ActivoAccesoCountOutputType = {
    hijos: number
    usuarios: number
  }

  export type ActivoAccesoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hijos?: boolean | ActivoAccesoCountOutputTypeCountHijosArgs
    usuarios?: boolean | ActivoAccesoCountOutputTypeCountUsuariosArgs
  }

  // Custom InputTypes
  /**
   * ActivoAccesoCountOutputType without action
   */
  export type ActivoAccesoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivoAccesoCountOutputType
     */
    select?: ActivoAccesoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivoAccesoCountOutputType without action
   */
  export type ActivoAccesoCountOutputTypeCountHijosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivoAccesoWhereInput
  }

  /**
   * ActivoAccesoCountOutputType without action
   */
  export type ActivoAccesoCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioActivoWhereInput
  }


  /**
   * Count Type PlantillaActivoCountOutputType
   */

  export type PlantillaActivoCountOutputType = {
    activos: number
  }

  export type PlantillaActivoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activos?: boolean | PlantillaActivoCountOutputTypeCountActivosArgs
  }

  // Custom InputTypes
  /**
   * PlantillaActivoCountOutputType without action
   */
  export type PlantillaActivoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaActivoCountOutputType
     */
    select?: PlantillaActivoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlantillaActivoCountOutputType without action
   */
  export type PlantillaActivoCountOutputTypeCountActivosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivoWhereInput
  }


  /**
   * Count Type ActivoCountOutputType
   */

  export type ActivoCountOutputType = {
    riesgos: number
    incidentes: number
    defectos: number
  }

  export type ActivoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    riesgos?: boolean | ActivoCountOutputTypeCountRiesgosArgs
    incidentes?: boolean | ActivoCountOutputTypeCountIncidentesArgs
    defectos?: boolean | ActivoCountOutputTypeCountDefectosArgs
  }

  // Custom InputTypes
  /**
   * ActivoCountOutputType without action
   */
  export type ActivoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivoCountOutputType
     */
    select?: ActivoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivoCountOutputType without action
   */
  export type ActivoCountOutputTypeCountRiesgosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiesgoWhereInput
  }

  /**
   * ActivoCountOutputType without action
   */
  export type ActivoCountOutputTypeCountIncidentesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidenteWhereInput
  }

  /**
   * ActivoCountOutputType without action
   */
  export type ActivoCountOutputTypeCountDefectosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefectoWhereInput
  }


  /**
   * Count Type OrganigramaCountOutputType
   */

  export type OrganigramaCountOutputType = {
    nodos: number
  }

  export type OrganigramaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodos?: boolean | OrganigramaCountOutputTypeCountNodosArgs
  }

  // Custom InputTypes
  /**
   * OrganigramaCountOutputType without action
   */
  export type OrganigramaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganigramaCountOutputType
     */
    select?: OrganigramaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganigramaCountOutputType without action
   */
  export type OrganigramaCountOutputTypeCountNodosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodoOrganigramaWhereInput
  }


  /**
   * Count Type NodoOrganigramaCountOutputType
   */

  export type NodoOrganigramaCountOutputType = {
    subordinados: number
  }

  export type NodoOrganigramaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subordinados?: boolean | NodoOrganigramaCountOutputTypeCountSubordinadosArgs
  }

  // Custom InputTypes
  /**
   * NodoOrganigramaCountOutputType without action
   */
  export type NodoOrganigramaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodoOrganigramaCountOutputType
     */
    select?: NodoOrganigramaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NodoOrganigramaCountOutputType without action
   */
  export type NodoOrganigramaCountOutputTypeCountSubordinadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodoOrganigramaWhereInput
  }


  /**
   * Count Type MarcoNormativoCountOutputType
   */

  export type MarcoNormativoCountOutputType = {
    requisitos: number
    cuestionarios: number
  }

  export type MarcoNormativoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requisitos?: boolean | MarcoNormativoCountOutputTypeCountRequisitosArgs
    cuestionarios?: boolean | MarcoNormativoCountOutputTypeCountCuestionariosArgs
  }

  // Custom InputTypes
  /**
   * MarcoNormativoCountOutputType without action
   */
  export type MarcoNormativoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarcoNormativoCountOutputType
     */
    select?: MarcoNormativoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MarcoNormativoCountOutputType without action
   */
  export type MarcoNormativoCountOutputTypeCountRequisitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequisitoNormativoWhereInput
  }

  /**
   * MarcoNormativoCountOutputType without action
   */
  export type MarcoNormativoCountOutputTypeCountCuestionariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CuestionarioWhereInput
  }


  /**
   * Count Type CuestionarioCountOutputType
   */

  export type CuestionarioCountOutputType = {
    secciones: number
    asignaciones: number
  }

  export type CuestionarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    secciones?: boolean | CuestionarioCountOutputTypeCountSeccionesArgs
    asignaciones?: boolean | CuestionarioCountOutputTypeCountAsignacionesArgs
  }

  // Custom InputTypes
  /**
   * CuestionarioCountOutputType without action
   */
  export type CuestionarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CuestionarioCountOutputType
     */
    select?: CuestionarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CuestionarioCountOutputType without action
   */
  export type CuestionarioCountOutputTypeCountSeccionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeccionWhereInput
  }

  /**
   * CuestionarioCountOutputType without action
   */
  export type CuestionarioCountOutputTypeCountAsignacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AsignacionCuestionarioWhereInput
  }


  /**
   * Count Type SeccionCountOutputType
   */

  export type SeccionCountOutputType = {
    preguntas: number
  }

  export type SeccionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preguntas?: boolean | SeccionCountOutputTypeCountPreguntasArgs
  }

  // Custom InputTypes
  /**
   * SeccionCountOutputType without action
   */
  export type SeccionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeccionCountOutputType
     */
    select?: SeccionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeccionCountOutputType without action
   */
  export type SeccionCountOutputTypeCountPreguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreguntaWhereInput
  }


  /**
   * Count Type PreguntaCountOutputType
   */

  export type PreguntaCountOutputType = {
    respuestas: number
    hallazgos: number
  }

  export type PreguntaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    respuestas?: boolean | PreguntaCountOutputTypeCountRespuestasArgs
    hallazgos?: boolean | PreguntaCountOutputTypeCountHallazgosArgs
  }

  // Custom InputTypes
  /**
   * PreguntaCountOutputType without action
   */
  export type PreguntaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreguntaCountOutputType
     */
    select?: PreguntaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PreguntaCountOutputType without action
   */
  export type PreguntaCountOutputTypeCountRespuestasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RespuestaPreguntaWhereInput
  }

  /**
   * PreguntaCountOutputType without action
   */
  export type PreguntaCountOutputTypeCountHallazgosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HallazgoWhereInput
  }


  /**
   * Count Type AsignacionCuestionarioCountOutputType
   */

  export type AsignacionCuestionarioCountOutputType = {
    evaluadosExternos: number
    respuestas: number
    mensajesChat: number
  }

  export type AsignacionCuestionarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluadosExternos?: boolean | AsignacionCuestionarioCountOutputTypeCountEvaluadosExternosArgs
    respuestas?: boolean | AsignacionCuestionarioCountOutputTypeCountRespuestasArgs
    mensajesChat?: boolean | AsignacionCuestionarioCountOutputTypeCountMensajesChatArgs
  }

  // Custom InputTypes
  /**
   * AsignacionCuestionarioCountOutputType without action
   */
  export type AsignacionCuestionarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsignacionCuestionarioCountOutputType
     */
    select?: AsignacionCuestionarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AsignacionCuestionarioCountOutputType without action
   */
  export type AsignacionCuestionarioCountOutputTypeCountEvaluadosExternosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluadoExternoWhereInput
  }

  /**
   * AsignacionCuestionarioCountOutputType without action
   */
  export type AsignacionCuestionarioCountOutputTypeCountRespuestasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RespuestaCuestionarioWhereInput
  }

  /**
   * AsignacionCuestionarioCountOutputType without action
   */
  export type AsignacionCuestionarioCountOutputTypeCountMensajesChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MensajeChatWhereInput
  }


  /**
   * Count Type RespuestaCuestionarioCountOutputType
   */

  export type RespuestaCuestionarioCountOutputType = {
    respuestas: number
  }

  export type RespuestaCuestionarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    respuestas?: boolean | RespuestaCuestionarioCountOutputTypeCountRespuestasArgs
  }

  // Custom InputTypes
  /**
   * RespuestaCuestionarioCountOutputType without action
   */
  export type RespuestaCuestionarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaCuestionarioCountOutputType
     */
    select?: RespuestaCuestionarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RespuestaCuestionarioCountOutputType without action
   */
  export type RespuestaCuestionarioCountOutputTypeCountRespuestasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RespuestaPreguntaWhereInput
  }


  /**
   * Count Type RespuestaPreguntaCountOutputType
   */

  export type RespuestaPreguntaCountOutputType = {
    evidencias: number
  }

  export type RespuestaPreguntaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidencias?: boolean | RespuestaPreguntaCountOutputTypeCountEvidenciasArgs
  }

  // Custom InputTypes
  /**
   * RespuestaPreguntaCountOutputType without action
   */
  export type RespuestaPreguntaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaPreguntaCountOutputType
     */
    select?: RespuestaPreguntaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RespuestaPreguntaCountOutputType without action
   */
  export type RespuestaPreguntaCountOutputTypeCountEvidenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenciaWhereInput
  }


  /**
   * Count Type ProcesoCountOutputType
   */

  export type ProcesoCountOutputType = {
    nodos: number
    edges: number
    objetivos: number
    kpis: number
  }

  export type ProcesoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodos?: boolean | ProcesoCountOutputTypeCountNodosArgs
    edges?: boolean | ProcesoCountOutputTypeCountEdgesArgs
    objetivos?: boolean | ProcesoCountOutputTypeCountObjetivosArgs
    kpis?: boolean | ProcesoCountOutputTypeCountKpisArgs
  }

  // Custom InputTypes
  /**
   * ProcesoCountOutputType without action
   */
  export type ProcesoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcesoCountOutputType
     */
    select?: ProcesoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcesoCountOutputType without action
   */
  export type ProcesoCountOutputTypeCountNodosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessNodeWhereInput
  }

  /**
   * ProcesoCountOutputType without action
   */
  export type ProcesoCountOutputTypeCountEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessEdgeWhereInput
  }

  /**
   * ProcesoCountOutputType without action
   */
  export type ProcesoCountOutputTypeCountObjetivosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjetivoProcesoWhereInput
  }

  /**
   * ProcesoCountOutputType without action
   */
  export type ProcesoCountOutputTypeCountKpisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiProcesoWhereInput
  }


  /**
   * Count Type ProcessNodeCountOutputType
   */

  export type ProcessNodeCountOutputType = {
    edgesFrom: number
    edgesTo: number
    kpiHistorico: number
  }

  export type ProcessNodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edgesFrom?: boolean | ProcessNodeCountOutputTypeCountEdgesFromArgs
    edgesTo?: boolean | ProcessNodeCountOutputTypeCountEdgesToArgs
    kpiHistorico?: boolean | ProcessNodeCountOutputTypeCountKpiHistoricoArgs
  }

  // Custom InputTypes
  /**
   * ProcessNodeCountOutputType without action
   */
  export type ProcessNodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessNodeCountOutputType
     */
    select?: ProcessNodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcessNodeCountOutputType without action
   */
  export type ProcessNodeCountOutputTypeCountEdgesFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessEdgeWhereInput
  }

  /**
   * ProcessNodeCountOutputType without action
   */
  export type ProcessNodeCountOutputTypeCountEdgesToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessEdgeWhereInput
  }

  /**
   * ProcessNodeCountOutputType without action
   */
  export type ProcessNodeCountOutputTypeCountKpiHistoricoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiHistoricoWhereInput
  }


  /**
   * Count Type ObjetivoProcesoCountOutputType
   */

  export type ObjetivoProcesoCountOutputType = {
    kpis: number
  }

  export type ObjetivoProcesoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kpis?: boolean | ObjetivoProcesoCountOutputTypeCountKpisArgs
  }

  // Custom InputTypes
  /**
   * ObjetivoProcesoCountOutputType without action
   */
  export type ObjetivoProcesoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjetivoProcesoCountOutputType
     */
    select?: ObjetivoProcesoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ObjetivoProcesoCountOutputType without action
   */
  export type ObjetivoProcesoCountOutputTypeCountKpisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiProcesoWhereInput
  }


  /**
   * Count Type KpiProcesoCountOutputType
   */

  export type KpiProcesoCountOutputType = {
    historico: number
  }

  export type KpiProcesoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    historico?: boolean | KpiProcesoCountOutputTypeCountHistoricoArgs
  }

  // Custom InputTypes
  /**
   * KpiProcesoCountOutputType without action
   */
  export type KpiProcesoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiProcesoCountOutputType
     */
    select?: KpiProcesoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KpiProcesoCountOutputType without action
   */
  export type KpiProcesoCountOutputTypeCountHistoricoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiHistoricoWhereInput
  }


  /**
   * Count Type DashboardConfigCountOutputType
   */

  export type DashboardConfigCountOutputType = {
    widgets: number
  }

  export type DashboardConfigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    widgets?: boolean | DashboardConfigCountOutputTypeCountWidgetsArgs
  }

  // Custom InputTypes
  /**
   * DashboardConfigCountOutputType without action
   */
  export type DashboardConfigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfigCountOutputType
     */
    select?: DashboardConfigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DashboardConfigCountOutputType without action
   */
  export type DashboardConfigCountOutputTypeCountWidgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardWidgetWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    objectives: number
    kpis: number
    phases: number
    tasks: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    objectives?: boolean | ProjectCountOutputTypeCountObjectivesArgs
    kpis?: boolean | ProjectCountOutputTypeCountKpisArgs
    phases?: boolean | ProjectCountOutputTypeCountPhasesArgs
    tasks?: boolean | ProjectCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountObjectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectObjectiveWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountKpisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectKPIWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPhasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectPhaseWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type ProjectPhaseCountOutputType
   */

  export type ProjectPhaseCountOutputType = {
    dependents: number
    tasks: number
  }

  export type ProjectPhaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dependents?: boolean | ProjectPhaseCountOutputTypeCountDependentsArgs
    tasks?: boolean | ProjectPhaseCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * ProjectPhaseCountOutputType without action
   */
  export type ProjectPhaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhaseCountOutputType
     */
    select?: ProjectPhaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectPhaseCountOutputType without action
   */
  export type ProjectPhaseCountOutputTypeCountDependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectPhaseWhereInput
  }

  /**
   * ProjectPhaseCountOutputType without action
   */
  export type ProjectPhaseCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    evidences: number
    history: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidences?: boolean | TaskCountOutputTypeCountEvidencesArgs
    history?: boolean | TaskCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountEvidencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskEvidenceWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskHistoryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    sesionesActivas: number | null
    maxSesionesPermitidas: number | null
    intentosFallidos: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    sesionesActivas: number | null
    maxSesionesPermitidas: number | null
    intentosFallidos: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    apellido: string | null
    email: string | null
    password: string | null
    telefono: string | null
    avatar: string | null
    estado: string | null
    departamento: string | null
    cargo: string | null
    region: string | null
    autenticacionDosFactor: boolean | null
    cambioPasswordRequerido: boolean | null
    sesionesActivas: number | null
    maxSesionesPermitidas: number | null
    ultimoCambioPassword: Date | null
    intentosFallidos: number | null
    fechaCreacion: Date | null
    fechaExpiracion: Date | null
    ultimoAcceso: Date | null
    updatedAt: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    apellido: string | null
    email: string | null
    password: string | null
    telefono: string | null
    avatar: string | null
    estado: string | null
    departamento: string | null
    cargo: string | null
    region: string | null
    autenticacionDosFactor: boolean | null
    cambioPasswordRequerido: boolean | null
    sesionesActivas: number | null
    maxSesionesPermitidas: number | null
    ultimoCambioPassword: Date | null
    intentosFallidos: number | null
    fechaCreacion: Date | null
    fechaExpiracion: Date | null
    ultimoAcceso: Date | null
    updatedAt: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombre: number
    apellido: number
    email: number
    password: number
    telefono: number
    avatar: number
    estado: number
    departamento: number
    cargo: number
    region: number
    autenticacionDosFactor: number
    cambioPasswordRequerido: number
    sesionesActivas: number
    maxSesionesPermitidas: number
    ultimoCambioPassword: number
    intentosFallidos: number
    fechaCreacion: number
    fechaExpiracion: number
    ultimoAcceso: number
    updatedAt: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    sesionesActivas?: true
    maxSesionesPermitidas?: true
    intentosFallidos?: true
  }

  export type UsuarioSumAggregateInputType = {
    sesionesActivas?: true
    maxSesionesPermitidas?: true
    intentosFallidos?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    email?: true
    password?: true
    telefono?: true
    avatar?: true
    estado?: true
    departamento?: true
    cargo?: true
    region?: true
    autenticacionDosFactor?: true
    cambioPasswordRequerido?: true
    sesionesActivas?: true
    maxSesionesPermitidas?: true
    ultimoCambioPassword?: true
    intentosFallidos?: true
    fechaCreacion?: true
    fechaExpiracion?: true
    ultimoAcceso?: true
    updatedAt?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    email?: true
    password?: true
    telefono?: true
    avatar?: true
    estado?: true
    departamento?: true
    cargo?: true
    region?: true
    autenticacionDosFactor?: true
    cambioPasswordRequerido?: true
    sesionesActivas?: true
    maxSesionesPermitidas?: true
    ultimoCambioPassword?: true
    intentosFallidos?: true
    fechaCreacion?: true
    fechaExpiracion?: true
    ultimoAcceso?: true
    updatedAt?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    email?: true
    password?: true
    telefono?: true
    avatar?: true
    estado?: true
    departamento?: true
    cargo?: true
    region?: true
    autenticacionDosFactor?: true
    cambioPasswordRequerido?: true
    sesionesActivas?: true
    maxSesionesPermitidas?: true
    ultimoCambioPassword?: true
    intentosFallidos?: true
    fechaCreacion?: true
    fechaExpiracion?: true
    ultimoAcceso?: true
    updatedAt?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: string
    nombre: string
    apellido: string
    email: string
    password: string | null
    telefono: string | null
    avatar: string | null
    estado: string
    departamento: string | null
    cargo: string | null
    region: string
    autenticacionDosFactor: boolean
    cambioPasswordRequerido: boolean
    sesionesActivas: number
    maxSesionesPermitidas: number
    ultimoCambioPassword: Date | null
    intentosFallidos: number
    fechaCreacion: Date
    fechaExpiracion: Date | null
    ultimoAcceso: Date | null
    updatedAt: Date
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    password?: boolean
    telefono?: boolean
    avatar?: boolean
    estado?: boolean
    departamento?: boolean
    cargo?: boolean
    region?: boolean
    autenticacionDosFactor?: boolean
    cambioPasswordRequerido?: boolean
    sesionesActivas?: boolean
    maxSesionesPermitidas?: boolean
    ultimoCambioPassword?: boolean
    intentosFallidos?: boolean
    fechaCreacion?: boolean
    fechaExpiracion?: boolean
    ultimoAcceso?: boolean
    updatedAt?: boolean
    roles?: boolean | Usuario$rolesArgs<ExtArgs>
    activosAcceso?: boolean | Usuario$activosAccesoArgs<ExtArgs>
    logsAuditoria?: boolean | Usuario$logsAuditoriaArgs<ExtArgs>
    respuestasCuestionario?: boolean | Usuario$respuestasCuestionarioArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    password?: boolean
    telefono?: boolean
    avatar?: boolean
    estado?: boolean
    departamento?: boolean
    cargo?: boolean
    region?: boolean
    autenticacionDosFactor?: boolean
    cambioPasswordRequerido?: boolean
    sesionesActivas?: boolean
    maxSesionesPermitidas?: boolean
    ultimoCambioPassword?: boolean
    intentosFallidos?: boolean
    fechaCreacion?: boolean
    fechaExpiracion?: boolean
    ultimoAcceso?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    password?: boolean
    telefono?: boolean
    avatar?: boolean
    estado?: boolean
    departamento?: boolean
    cargo?: boolean
    region?: boolean
    autenticacionDosFactor?: boolean
    cambioPasswordRequerido?: boolean
    sesionesActivas?: boolean
    maxSesionesPermitidas?: boolean
    ultimoCambioPassword?: boolean
    intentosFallidos?: boolean
    fechaCreacion?: boolean
    fechaExpiracion?: boolean
    ultimoAcceso?: boolean
    updatedAt?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Usuario$rolesArgs<ExtArgs>
    activosAcceso?: boolean | Usuario$activosAccesoArgs<ExtArgs>
    logsAuditoria?: boolean | Usuario$logsAuditoriaArgs<ExtArgs>
    respuestasCuestionario?: boolean | Usuario$respuestasCuestionarioArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      roles: Prisma.$UsuarioRolPayload<ExtArgs>[]
      activosAcceso: Prisma.$UsuarioActivoPayload<ExtArgs>[]
      logsAuditoria: Prisma.$LogAuditoriaPayload<ExtArgs>[]
      respuestasCuestionario: Prisma.$RespuestaCuestionarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      apellido: string
      email: string
      password: string | null
      telefono: string | null
      avatar: string | null
      estado: string
      departamento: string | null
      cargo: string | null
      region: string
      autenticacionDosFactor: boolean
      cambioPasswordRequerido: boolean
      sesionesActivas: number
      maxSesionesPermitidas: number
      ultimoCambioPassword: Date | null
      intentosFallidos: number
      fechaCreacion: Date
      fechaExpiracion: Date | null
      ultimoAcceso: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Usuario$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "findMany"> | Null>
    activosAcceso<T extends Usuario$activosAccesoArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$activosAccesoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioActivoPayload<ExtArgs>, T, "findMany"> | Null>
    logsAuditoria<T extends Usuario$logsAuditoriaArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$logsAuditoriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "findMany"> | Null>
    respuestasCuestionario<T extends Usuario$respuestasCuestionarioArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$respuestasCuestionarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RespuestaCuestionarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'String'>
    readonly nombre: FieldRef<"Usuario", 'String'>
    readonly apellido: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly password: FieldRef<"Usuario", 'String'>
    readonly telefono: FieldRef<"Usuario", 'String'>
    readonly avatar: FieldRef<"Usuario", 'String'>
    readonly estado: FieldRef<"Usuario", 'String'>
    readonly departamento: FieldRef<"Usuario", 'String'>
    readonly cargo: FieldRef<"Usuario", 'String'>
    readonly region: FieldRef<"Usuario", 'String'>
    readonly autenticacionDosFactor: FieldRef<"Usuario", 'Boolean'>
    readonly cambioPasswordRequerido: FieldRef<"Usuario", 'Boolean'>
    readonly sesionesActivas: FieldRef<"Usuario", 'Int'>
    readonly maxSesionesPermitidas: FieldRef<"Usuario", 'Int'>
    readonly ultimoCambioPassword: FieldRef<"Usuario", 'DateTime'>
    readonly intentosFallidos: FieldRef<"Usuario", 'Int'>
    readonly fechaCreacion: FieldRef<"Usuario", 'DateTime'>
    readonly fechaExpiracion: FieldRef<"Usuario", 'DateTime'>
    readonly ultimoAcceso: FieldRef<"Usuario", 'DateTime'>
    readonly updatedAt: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario.roles
   */
  export type Usuario$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    where?: UsuarioRolWhereInput
    orderBy?: UsuarioRolOrderByWithRelationInput | UsuarioRolOrderByWithRelationInput[]
    cursor?: UsuarioRolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioRolScalarFieldEnum | UsuarioRolScalarFieldEnum[]
  }

  /**
   * Usuario.activosAcceso
   */
  export type Usuario$activosAccesoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioActivo
     */
    select?: UsuarioActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioActivoInclude<ExtArgs> | null
    where?: UsuarioActivoWhereInput
    orderBy?: UsuarioActivoOrderByWithRelationInput | UsuarioActivoOrderByWithRelationInput[]
    cursor?: UsuarioActivoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioActivoScalarFieldEnum | UsuarioActivoScalarFieldEnum[]
  }

  /**
   * Usuario.logsAuditoria
   */
  export type Usuario$logsAuditoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogAuditoriaInclude<ExtArgs> | null
    where?: LogAuditoriaWhereInput
    orderBy?: LogAuditoriaOrderByWithRelationInput | LogAuditoriaOrderByWithRelationInput[]
    cursor?: LogAuditoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogAuditoriaScalarFieldEnum | LogAuditoriaScalarFieldEnum[]
  }

  /**
   * Usuario.respuestasCuestionario
   */
  export type Usuario$respuestasCuestionarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaCuestionario
     */
    select?: RespuestaCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaCuestionarioInclude<ExtArgs> | null
    where?: RespuestaCuestionarioWhereInput
    orderBy?: RespuestaCuestionarioOrderByWithRelationInput | RespuestaCuestionarioOrderByWithRelationInput[]
    cursor?: RespuestaCuestionarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RespuestaCuestionarioScalarFieldEnum | RespuestaCuestionarioScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Rol
   */

  export type AggregateRol = {
    _count: RolCountAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  export type RolMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    nivelAcceso: string | null
    region: string | null
    tipoArbol: string | null
    color: string | null
    icono: string | null
    activo: boolean | null
    esRolSistema: boolean | null
    fechaCreacion: Date | null
    fechaModificacion: Date | null
  }

  export type RolMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    nivelAcceso: string | null
    region: string | null
    tipoArbol: string | null
    color: string | null
    icono: string | null
    activo: boolean | null
    esRolSistema: boolean | null
    fechaCreacion: Date | null
    fechaModificacion: Date | null
  }

  export type RolCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    nivelAcceso: number
    region: number
    tipoArbol: number
    color: number
    icono: number
    activo: number
    esRolSistema: number
    fechaCreacion: number
    fechaModificacion: number
    _all: number
  }


  export type RolMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    nivelAcceso?: true
    region?: true
    tipoArbol?: true
    color?: true
    icono?: true
    activo?: true
    esRolSistema?: true
    fechaCreacion?: true
    fechaModificacion?: true
  }

  export type RolMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    nivelAcceso?: true
    region?: true
    tipoArbol?: true
    color?: true
    icono?: true
    activo?: true
    esRolSistema?: true
    fechaCreacion?: true
    fechaModificacion?: true
  }

  export type RolCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    nivelAcceso?: true
    region?: true
    tipoArbol?: true
    color?: true
    icono?: true
    activo?: true
    esRolSistema?: true
    fechaCreacion?: true
    fechaModificacion?: true
    _all?: true
  }

  export type RolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rol to aggregate.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rols
    **/
    _count?: true | RolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolMaxAggregateInputType
  }

  export type GetRolAggregateType<T extends RolAggregateArgs> = {
        [P in keyof T & keyof AggregateRol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRol[P]>
      : GetScalarType<T[P], AggregateRol[P]>
  }




  export type RolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolWhereInput
    orderBy?: RolOrderByWithAggregationInput | RolOrderByWithAggregationInput[]
    by: RolScalarFieldEnum[] | RolScalarFieldEnum
    having?: RolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolCountAggregateInputType | true
    _min?: RolMinAggregateInputType
    _max?: RolMaxAggregateInputType
  }

  export type RolGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string
    nivelAcceso: string
    region: string
    tipoArbol: string
    color: string | null
    icono: string | null
    activo: boolean
    esRolSistema: boolean
    fechaCreacion: Date
    fechaModificacion: Date
    _count: RolCountAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  type GetRolGroupByPayload<T extends RolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolGroupByOutputType[P]>
            : GetScalarType<T[P], RolGroupByOutputType[P]>
        }
      >
    >


  export type RolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    nivelAcceso?: boolean
    region?: boolean
    tipoArbol?: boolean
    color?: boolean
    icono?: boolean
    activo?: boolean
    esRolSistema?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
    usuarios?: boolean | Rol$usuariosArgs<ExtArgs>
    permisos?: boolean | Rol$permisosArgs<ExtArgs>
    _count?: boolean | RolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rol"]>

  export type RolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    nivelAcceso?: boolean
    region?: boolean
    tipoArbol?: boolean
    color?: boolean
    icono?: boolean
    activo?: boolean
    esRolSistema?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
  }, ExtArgs["result"]["rol"]>

  export type RolSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    nivelAcceso?: boolean
    region?: boolean
    tipoArbol?: boolean
    color?: boolean
    icono?: boolean
    activo?: boolean
    esRolSistema?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
  }

  export type RolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | Rol$usuariosArgs<ExtArgs>
    permisos?: boolean | Rol$permisosArgs<ExtArgs>
    _count?: boolean | RolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rol"
    objects: {
      usuarios: Prisma.$UsuarioRolPayload<ExtArgs>[]
      permisos: Prisma.$RolPermisoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      descripcion: string
      nivelAcceso: string
      region: string
      tipoArbol: string
      color: string | null
      icono: string | null
      activo: boolean
      esRolSistema: boolean
      fechaCreacion: Date
      fechaModificacion: Date
    }, ExtArgs["result"]["rol"]>
    composites: {}
  }

  type RolGetPayload<S extends boolean | null | undefined | RolDefaultArgs> = $Result.GetResult<Prisma.$RolPayload, S>

  type RolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolCountAggregateInputType | true
    }

  export interface RolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rol'], meta: { name: 'Rol' } }
    /**
     * Find zero or one Rol that matches the filter.
     * @param {RolFindUniqueArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolFindUniqueArgs>(args: SelectSubset<T, RolFindUniqueArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rol that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolFindUniqueOrThrowArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolFindUniqueOrThrowArgs>(args: SelectSubset<T, RolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindFirstArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolFindFirstArgs>(args?: SelectSubset<T, RolFindFirstArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindFirstOrThrowArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolFindFirstOrThrowArgs>(args?: SelectSubset<T, RolFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rols
     * const rols = await prisma.rol.findMany()
     * 
     * // Get first 10 Rols
     * const rols = await prisma.rol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolWithIdOnly = await prisma.rol.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolFindManyArgs>(args?: SelectSubset<T, RolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rol.
     * @param {RolCreateArgs} args - Arguments to create a Rol.
     * @example
     * // Create one Rol
     * const Rol = await prisma.rol.create({
     *   data: {
     *     // ... data to create a Rol
     *   }
     * })
     * 
     */
    create<T extends RolCreateArgs>(args: SelectSubset<T, RolCreateArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rols.
     * @param {RolCreateManyArgs} args - Arguments to create many Rols.
     * @example
     * // Create many Rols
     * const rol = await prisma.rol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolCreateManyArgs>(args?: SelectSubset<T, RolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rols and returns the data saved in the database.
     * @param {RolCreateManyAndReturnArgs} args - Arguments to create many Rols.
     * @example
     * // Create many Rols
     * const rol = await prisma.rol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rols and only return the `id`
     * const rolWithIdOnly = await prisma.rol.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolCreateManyAndReturnArgs>(args?: SelectSubset<T, RolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Rol.
     * @param {RolDeleteArgs} args - Arguments to delete one Rol.
     * @example
     * // Delete one Rol
     * const Rol = await prisma.rol.delete({
     *   where: {
     *     // ... filter to delete one Rol
     *   }
     * })
     * 
     */
    delete<T extends RolDeleteArgs>(args: SelectSubset<T, RolDeleteArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rol.
     * @param {RolUpdateArgs} args - Arguments to update one Rol.
     * @example
     * // Update one Rol
     * const rol = await prisma.rol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolUpdateArgs>(args: SelectSubset<T, RolUpdateArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rols.
     * @param {RolDeleteManyArgs} args - Arguments to filter Rols to delete.
     * @example
     * // Delete a few Rols
     * const { count } = await prisma.rol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolDeleteManyArgs>(args?: SelectSubset<T, RolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rols
     * const rol = await prisma.rol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolUpdateManyArgs>(args: SelectSubset<T, RolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rol.
     * @param {RolUpsertArgs} args - Arguments to update or create a Rol.
     * @example
     * // Update or create a Rol
     * const rol = await prisma.rol.upsert({
     *   create: {
     *     // ... data to create a Rol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rol we want to update
     *   }
     * })
     */
    upsert<T extends RolUpsertArgs>(args: SelectSubset<T, RolUpsertArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolCountArgs} args - Arguments to filter Rols to count.
     * @example
     * // Count the number of Rols
     * const count = await prisma.rol.count({
     *   where: {
     *     // ... the filter for the Rols we want to count
     *   }
     * })
    **/
    count<T extends RolCountArgs>(
      args?: Subset<T, RolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolAggregateArgs>(args: Subset<T, RolAggregateArgs>): Prisma.PrismaPromise<GetRolAggregateType<T>>

    /**
     * Group by Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolGroupByArgs['orderBy'] }
        : { orderBy?: RolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rol model
   */
  readonly fields: RolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuarios<T extends Rol$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, Rol$usuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "findMany"> | Null>
    permisos<T extends Rol$permisosArgs<ExtArgs> = {}>(args?: Subset<T, Rol$permisosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rol model
   */ 
  interface RolFieldRefs {
    readonly id: FieldRef<"Rol", 'String'>
    readonly nombre: FieldRef<"Rol", 'String'>
    readonly descripcion: FieldRef<"Rol", 'String'>
    readonly nivelAcceso: FieldRef<"Rol", 'String'>
    readonly region: FieldRef<"Rol", 'String'>
    readonly tipoArbol: FieldRef<"Rol", 'String'>
    readonly color: FieldRef<"Rol", 'String'>
    readonly icono: FieldRef<"Rol", 'String'>
    readonly activo: FieldRef<"Rol", 'Boolean'>
    readonly esRolSistema: FieldRef<"Rol", 'Boolean'>
    readonly fechaCreacion: FieldRef<"Rol", 'DateTime'>
    readonly fechaModificacion: FieldRef<"Rol", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Rol findUnique
   */
  export type RolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol findUniqueOrThrow
   */
  export type RolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol findFirst
   */
  export type RolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rols.
     */
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol findFirstOrThrow
   */
  export type RolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rols.
     */
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol findMany
   */
  export type RolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rols to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol create
   */
  export type RolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The data needed to create a Rol.
     */
    data: XOR<RolCreateInput, RolUncheckedCreateInput>
  }

  /**
   * Rol createMany
   */
  export type RolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rols.
     */
    data: RolCreateManyInput | RolCreateManyInput[]
  }

  /**
   * Rol createManyAndReturn
   */
  export type RolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rols.
     */
    data: RolCreateManyInput | RolCreateManyInput[]
  }

  /**
   * Rol update
   */
  export type RolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The data needed to update a Rol.
     */
    data: XOR<RolUpdateInput, RolUncheckedUpdateInput>
    /**
     * Choose, which Rol to update.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol updateMany
   */
  export type RolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rols.
     */
    data: XOR<RolUpdateManyMutationInput, RolUncheckedUpdateManyInput>
    /**
     * Filter which Rols to update
     */
    where?: RolWhereInput
  }

  /**
   * Rol upsert
   */
  export type RolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The filter to search for the Rol to update in case it exists.
     */
    where: RolWhereUniqueInput
    /**
     * In case the Rol found by the `where` argument doesn't exist, create a new Rol with this data.
     */
    create: XOR<RolCreateInput, RolUncheckedCreateInput>
    /**
     * In case the Rol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolUpdateInput, RolUncheckedUpdateInput>
  }

  /**
   * Rol delete
   */
  export type RolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter which Rol to delete.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol deleteMany
   */
  export type RolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rols to delete
     */
    where?: RolWhereInput
  }

  /**
   * Rol.usuarios
   */
  export type Rol$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    where?: UsuarioRolWhereInput
    orderBy?: UsuarioRolOrderByWithRelationInput | UsuarioRolOrderByWithRelationInput[]
    cursor?: UsuarioRolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioRolScalarFieldEnum | UsuarioRolScalarFieldEnum[]
  }

  /**
   * Rol.permisos
   */
  export type Rol$permisosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    where?: RolPermisoWhereInput
    orderBy?: RolPermisoOrderByWithRelationInput | RolPermisoOrderByWithRelationInput[]
    cursor?: RolPermisoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolPermisoScalarFieldEnum | RolPermisoScalarFieldEnum[]
  }

  /**
   * Rol without action
   */
  export type RolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
  }


  /**
   * Model Permiso
   */

  export type AggregatePermiso = {
    _count: PermisoCountAggregateOutputType | null
    _min: PermisoMinAggregateOutputType | null
    _max: PermisoMaxAggregateOutputType | null
  }

  export type PermisoMinAggregateOutputType = {
    id: string | null
    codigo: string | null
    nombre: string | null
    descripcion: string | null
    modulo: string | null
    categoria: string | null
    activo: boolean | null
    padreId: string | null
  }

  export type PermisoMaxAggregateOutputType = {
    id: string | null
    codigo: string | null
    nombre: string | null
    descripcion: string | null
    modulo: string | null
    categoria: string | null
    activo: boolean | null
    padreId: string | null
  }

  export type PermisoCountAggregateOutputType = {
    id: number
    codigo: number
    nombre: number
    descripcion: number
    modulo: number
    categoria: number
    activo: number
    padreId: number
    _all: number
  }


  export type PermisoMinAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    descripcion?: true
    modulo?: true
    categoria?: true
    activo?: true
    padreId?: true
  }

  export type PermisoMaxAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    descripcion?: true
    modulo?: true
    categoria?: true
    activo?: true
    padreId?: true
  }

  export type PermisoCountAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    descripcion?: true
    modulo?: true
    categoria?: true
    activo?: true
    padreId?: true
    _all?: true
  }

  export type PermisoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permiso to aggregate.
     */
    where?: PermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisos to fetch.
     */
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permisos
    **/
    _count?: true | PermisoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermisoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermisoMaxAggregateInputType
  }

  export type GetPermisoAggregateType<T extends PermisoAggregateArgs> = {
        [P in keyof T & keyof AggregatePermiso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermiso[P]>
      : GetScalarType<T[P], AggregatePermiso[P]>
  }




  export type PermisoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermisoWhereInput
    orderBy?: PermisoOrderByWithAggregationInput | PermisoOrderByWithAggregationInput[]
    by: PermisoScalarFieldEnum[] | PermisoScalarFieldEnum
    having?: PermisoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermisoCountAggregateInputType | true
    _min?: PermisoMinAggregateInputType
    _max?: PermisoMaxAggregateInputType
  }

  export type PermisoGroupByOutputType = {
    id: string
    codigo: string
    nombre: string
    descripcion: string
    modulo: string
    categoria: string
    activo: boolean
    padreId: string | null
    _count: PermisoCountAggregateOutputType | null
    _min: PermisoMinAggregateOutputType | null
    _max: PermisoMaxAggregateOutputType | null
  }

  type GetPermisoGroupByPayload<T extends PermisoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermisoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermisoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermisoGroupByOutputType[P]>
            : GetScalarType<T[P], PermisoGroupByOutputType[P]>
        }
      >
    >


  export type PermisoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    modulo?: boolean
    categoria?: boolean
    activo?: boolean
    padreId?: boolean
    padre?: boolean | Permiso$padreArgs<ExtArgs>
    hijos?: boolean | Permiso$hijosArgs<ExtArgs>
    roles?: boolean | Permiso$rolesArgs<ExtArgs>
    _count?: boolean | PermisoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permiso"]>

  export type PermisoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    modulo?: boolean
    categoria?: boolean
    activo?: boolean
    padreId?: boolean
    padre?: boolean | Permiso$padreArgs<ExtArgs>
  }, ExtArgs["result"]["permiso"]>

  export type PermisoSelectScalar = {
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    modulo?: boolean
    categoria?: boolean
    activo?: boolean
    padreId?: boolean
  }

  export type PermisoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    padre?: boolean | Permiso$padreArgs<ExtArgs>
    hijos?: boolean | Permiso$hijosArgs<ExtArgs>
    roles?: boolean | Permiso$rolesArgs<ExtArgs>
    _count?: boolean | PermisoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermisoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    padre?: boolean | Permiso$padreArgs<ExtArgs>
  }

  export type $PermisoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permiso"
    objects: {
      padre: Prisma.$PermisoPayload<ExtArgs> | null
      hijos: Prisma.$PermisoPayload<ExtArgs>[]
      roles: Prisma.$RolPermisoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      codigo: string
      nombre: string
      descripcion: string
      modulo: string
      categoria: string
      activo: boolean
      padreId: string | null
    }, ExtArgs["result"]["permiso"]>
    composites: {}
  }

  type PermisoGetPayload<S extends boolean | null | undefined | PermisoDefaultArgs> = $Result.GetResult<Prisma.$PermisoPayload, S>

  type PermisoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermisoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermisoCountAggregateInputType | true
    }

  export interface PermisoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permiso'], meta: { name: 'Permiso' } }
    /**
     * Find zero or one Permiso that matches the filter.
     * @param {PermisoFindUniqueArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermisoFindUniqueArgs>(args: SelectSubset<T, PermisoFindUniqueArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permiso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermisoFindUniqueOrThrowArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermisoFindUniqueOrThrowArgs>(args: SelectSubset<T, PermisoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permiso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoFindFirstArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermisoFindFirstArgs>(args?: SelectSubset<T, PermisoFindFirstArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permiso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoFindFirstOrThrowArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermisoFindFirstOrThrowArgs>(args?: SelectSubset<T, PermisoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permisos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permisos
     * const permisos = await prisma.permiso.findMany()
     * 
     * // Get first 10 Permisos
     * const permisos = await prisma.permiso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permisoWithIdOnly = await prisma.permiso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermisoFindManyArgs>(args?: SelectSubset<T, PermisoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permiso.
     * @param {PermisoCreateArgs} args - Arguments to create a Permiso.
     * @example
     * // Create one Permiso
     * const Permiso = await prisma.permiso.create({
     *   data: {
     *     // ... data to create a Permiso
     *   }
     * })
     * 
     */
    create<T extends PermisoCreateArgs>(args: SelectSubset<T, PermisoCreateArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permisos.
     * @param {PermisoCreateManyArgs} args - Arguments to create many Permisos.
     * @example
     * // Create many Permisos
     * const permiso = await prisma.permiso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermisoCreateManyArgs>(args?: SelectSubset<T, PermisoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permisos and returns the data saved in the database.
     * @param {PermisoCreateManyAndReturnArgs} args - Arguments to create many Permisos.
     * @example
     * // Create many Permisos
     * const permiso = await prisma.permiso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permisos and only return the `id`
     * const permisoWithIdOnly = await prisma.permiso.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermisoCreateManyAndReturnArgs>(args?: SelectSubset<T, PermisoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Permiso.
     * @param {PermisoDeleteArgs} args - Arguments to delete one Permiso.
     * @example
     * // Delete one Permiso
     * const Permiso = await prisma.permiso.delete({
     *   where: {
     *     // ... filter to delete one Permiso
     *   }
     * })
     * 
     */
    delete<T extends PermisoDeleteArgs>(args: SelectSubset<T, PermisoDeleteArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permiso.
     * @param {PermisoUpdateArgs} args - Arguments to update one Permiso.
     * @example
     * // Update one Permiso
     * const permiso = await prisma.permiso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermisoUpdateArgs>(args: SelectSubset<T, PermisoUpdateArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permisos.
     * @param {PermisoDeleteManyArgs} args - Arguments to filter Permisos to delete.
     * @example
     * // Delete a few Permisos
     * const { count } = await prisma.permiso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermisoDeleteManyArgs>(args?: SelectSubset<T, PermisoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permisos
     * const permiso = await prisma.permiso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermisoUpdateManyArgs>(args: SelectSubset<T, PermisoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permiso.
     * @param {PermisoUpsertArgs} args - Arguments to update or create a Permiso.
     * @example
     * // Update or create a Permiso
     * const permiso = await prisma.permiso.upsert({
     *   create: {
     *     // ... data to create a Permiso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permiso we want to update
     *   }
     * })
     */
    upsert<T extends PermisoUpsertArgs>(args: SelectSubset<T, PermisoUpsertArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoCountArgs} args - Arguments to filter Permisos to count.
     * @example
     * // Count the number of Permisos
     * const count = await prisma.permiso.count({
     *   where: {
     *     // ... the filter for the Permisos we want to count
     *   }
     * })
    **/
    count<T extends PermisoCountArgs>(
      args?: Subset<T, PermisoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermisoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermisoAggregateArgs>(args: Subset<T, PermisoAggregateArgs>): Prisma.PrismaPromise<GetPermisoAggregateType<T>>

    /**
     * Group by Permiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermisoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermisoGroupByArgs['orderBy'] }
        : { orderBy?: PermisoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermisoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermisoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permiso model
   */
  readonly fields: PermisoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permiso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermisoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    padre<T extends Permiso$padreArgs<ExtArgs> = {}>(args?: Subset<T, Permiso$padreArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    hijos<T extends Permiso$hijosArgs<ExtArgs> = {}>(args?: Subset<T, Permiso$hijosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findMany"> | Null>
    roles<T extends Permiso$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permiso$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permiso model
   */ 
  interface PermisoFieldRefs {
    readonly id: FieldRef<"Permiso", 'String'>
    readonly codigo: FieldRef<"Permiso", 'String'>
    readonly nombre: FieldRef<"Permiso", 'String'>
    readonly descripcion: FieldRef<"Permiso", 'String'>
    readonly modulo: FieldRef<"Permiso", 'String'>
    readonly categoria: FieldRef<"Permiso", 'String'>
    readonly activo: FieldRef<"Permiso", 'Boolean'>
    readonly padreId: FieldRef<"Permiso", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Permiso findUnique
   */
  export type PermisoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter, which Permiso to fetch.
     */
    where: PermisoWhereUniqueInput
  }

  /**
   * Permiso findUniqueOrThrow
   */
  export type PermisoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter, which Permiso to fetch.
     */
    where: PermisoWhereUniqueInput
  }

  /**
   * Permiso findFirst
   */
  export type PermisoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter, which Permiso to fetch.
     */
    where?: PermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisos to fetch.
     */
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permisos.
     */
    cursor?: PermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permisos.
     */
    distinct?: PermisoScalarFieldEnum | PermisoScalarFieldEnum[]
  }

  /**
   * Permiso findFirstOrThrow
   */
  export type PermisoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter, which Permiso to fetch.
     */
    where?: PermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisos to fetch.
     */
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permisos.
     */
    cursor?: PermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permisos.
     */
    distinct?: PermisoScalarFieldEnum | PermisoScalarFieldEnum[]
  }

  /**
   * Permiso findMany
   */
  export type PermisoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter, which Permisos to fetch.
     */
    where?: PermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisos to fetch.
     */
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permisos.
     */
    cursor?: PermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisos.
     */
    skip?: number
    distinct?: PermisoScalarFieldEnum | PermisoScalarFieldEnum[]
  }

  /**
   * Permiso create
   */
  export type PermisoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * The data needed to create a Permiso.
     */
    data: XOR<PermisoCreateInput, PermisoUncheckedCreateInput>
  }

  /**
   * Permiso createMany
   */
  export type PermisoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permisos.
     */
    data: PermisoCreateManyInput | PermisoCreateManyInput[]
  }

  /**
   * Permiso createManyAndReturn
   */
  export type PermisoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Permisos.
     */
    data: PermisoCreateManyInput | PermisoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Permiso update
   */
  export type PermisoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * The data needed to update a Permiso.
     */
    data: XOR<PermisoUpdateInput, PermisoUncheckedUpdateInput>
    /**
     * Choose, which Permiso to update.
     */
    where: PermisoWhereUniqueInput
  }

  /**
   * Permiso updateMany
   */
  export type PermisoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permisos.
     */
    data: XOR<PermisoUpdateManyMutationInput, PermisoUncheckedUpdateManyInput>
    /**
     * Filter which Permisos to update
     */
    where?: PermisoWhereInput
  }

  /**
   * Permiso upsert
   */
  export type PermisoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * The filter to search for the Permiso to update in case it exists.
     */
    where: PermisoWhereUniqueInput
    /**
     * In case the Permiso found by the `where` argument doesn't exist, create a new Permiso with this data.
     */
    create: XOR<PermisoCreateInput, PermisoUncheckedCreateInput>
    /**
     * In case the Permiso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermisoUpdateInput, PermisoUncheckedUpdateInput>
  }

  /**
   * Permiso delete
   */
  export type PermisoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter which Permiso to delete.
     */
    where: PermisoWhereUniqueInput
  }

  /**
   * Permiso deleteMany
   */
  export type PermisoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permisos to delete
     */
    where?: PermisoWhereInput
  }

  /**
   * Permiso.padre
   */
  export type Permiso$padreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    where?: PermisoWhereInput
  }

  /**
   * Permiso.hijos
   */
  export type Permiso$hijosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    where?: PermisoWhereInput
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    cursor?: PermisoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermisoScalarFieldEnum | PermisoScalarFieldEnum[]
  }

  /**
   * Permiso.roles
   */
  export type Permiso$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    where?: RolPermisoWhereInput
    orderBy?: RolPermisoOrderByWithRelationInput | RolPermisoOrderByWithRelationInput[]
    cursor?: RolPermisoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolPermisoScalarFieldEnum | RolPermisoScalarFieldEnum[]
  }

  /**
   * Permiso without action
   */
  export type PermisoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
  }


  /**
   * Model Modulo
   */

  export type AggregateModulo = {
    _count: ModuloCountAggregateOutputType | null
    _avg: ModuloAvgAggregateOutputType | null
    _sum: ModuloSumAggregateOutputType | null
    _min: ModuloMinAggregateOutputType | null
    _max: ModuloMaxAggregateOutputType | null
  }

  export type ModuloAvgAggregateOutputType = {
    orden: number | null
  }

  export type ModuloSumAggregateOutputType = {
    orden: number | null
  }

  export type ModuloMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    icono: string | null
    orden: number | null
    activo: boolean | null
    permisoCreacion: boolean | null
    permisoEdicion: boolean | null
    permisoVisualizacion: boolean | null
    permisoEliminacion: boolean | null
  }

  export type ModuloMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    icono: string | null
    orden: number | null
    activo: boolean | null
    permisoCreacion: boolean | null
    permisoEdicion: boolean | null
    permisoVisualizacion: boolean | null
    permisoEliminacion: boolean | null
  }

  export type ModuloCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    icono: number
    orden: number
    activo: number
    permisoCreacion: number
    permisoEdicion: number
    permisoVisualizacion: number
    permisoEliminacion: number
    _all: number
  }


  export type ModuloAvgAggregateInputType = {
    orden?: true
  }

  export type ModuloSumAggregateInputType = {
    orden?: true
  }

  export type ModuloMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    icono?: true
    orden?: true
    activo?: true
    permisoCreacion?: true
    permisoEdicion?: true
    permisoVisualizacion?: true
    permisoEliminacion?: true
  }

  export type ModuloMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    icono?: true
    orden?: true
    activo?: true
    permisoCreacion?: true
    permisoEdicion?: true
    permisoVisualizacion?: true
    permisoEliminacion?: true
  }

  export type ModuloCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    icono?: true
    orden?: true
    activo?: true
    permisoCreacion?: true
    permisoEdicion?: true
    permisoVisualizacion?: true
    permisoEliminacion?: true
    _all?: true
  }

  export type ModuloAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modulo to aggregate.
     */
    where?: ModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modulos
    **/
    _count?: true | ModuloCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuloAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuloSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuloMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuloMaxAggregateInputType
  }

  export type GetModuloAggregateType<T extends ModuloAggregateArgs> = {
        [P in keyof T & keyof AggregateModulo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModulo[P]>
      : GetScalarType<T[P], AggregateModulo[P]>
  }




  export type ModuloGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuloWhereInput
    orderBy?: ModuloOrderByWithAggregationInput | ModuloOrderByWithAggregationInput[]
    by: ModuloScalarFieldEnum[] | ModuloScalarFieldEnum
    having?: ModuloScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuloCountAggregateInputType | true
    _avg?: ModuloAvgAggregateInputType
    _sum?: ModuloSumAggregateInputType
    _min?: ModuloMinAggregateInputType
    _max?: ModuloMaxAggregateInputType
  }

  export type ModuloGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string | null
    icono: string | null
    orden: number
    activo: boolean
    permisoCreacion: boolean
    permisoEdicion: boolean
    permisoVisualizacion: boolean
    permisoEliminacion: boolean
    _count: ModuloCountAggregateOutputType | null
    _avg: ModuloAvgAggregateOutputType | null
    _sum: ModuloSumAggregateOutputType | null
    _min: ModuloMinAggregateOutputType | null
    _max: ModuloMaxAggregateOutputType | null
  }

  type GetModuloGroupByPayload<T extends ModuloGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuloGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuloGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuloGroupByOutputType[P]>
            : GetScalarType<T[P], ModuloGroupByOutputType[P]>
        }
      >
    >


  export type ModuloSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    icono?: boolean
    orden?: boolean
    activo?: boolean
    permisoCreacion?: boolean
    permisoEdicion?: boolean
    permisoVisualizacion?: boolean
    permisoEliminacion?: boolean
  }, ExtArgs["result"]["modulo"]>

  export type ModuloSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    icono?: boolean
    orden?: boolean
    activo?: boolean
    permisoCreacion?: boolean
    permisoEdicion?: boolean
    permisoVisualizacion?: boolean
    permisoEliminacion?: boolean
  }, ExtArgs["result"]["modulo"]>

  export type ModuloSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    icono?: boolean
    orden?: boolean
    activo?: boolean
    permisoCreacion?: boolean
    permisoEdicion?: boolean
    permisoVisualizacion?: boolean
    permisoEliminacion?: boolean
  }


  export type $ModuloPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Modulo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      descripcion: string | null
      icono: string | null
      orden: number
      activo: boolean
      permisoCreacion: boolean
      permisoEdicion: boolean
      permisoVisualizacion: boolean
      permisoEliminacion: boolean
    }, ExtArgs["result"]["modulo"]>
    composites: {}
  }

  type ModuloGetPayload<S extends boolean | null | undefined | ModuloDefaultArgs> = $Result.GetResult<Prisma.$ModuloPayload, S>

  type ModuloCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModuloFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModuloCountAggregateInputType | true
    }

  export interface ModuloDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Modulo'], meta: { name: 'Modulo' } }
    /**
     * Find zero or one Modulo that matches the filter.
     * @param {ModuloFindUniqueArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuloFindUniqueArgs>(args: SelectSubset<T, ModuloFindUniqueArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Modulo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModuloFindUniqueOrThrowArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuloFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuloFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Modulo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloFindFirstArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuloFindFirstArgs>(args?: SelectSubset<T, ModuloFindFirstArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Modulo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloFindFirstOrThrowArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuloFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuloFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Modulos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modulos
     * const modulos = await prisma.modulo.findMany()
     * 
     * // Get first 10 Modulos
     * const modulos = await prisma.modulo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduloWithIdOnly = await prisma.modulo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuloFindManyArgs>(args?: SelectSubset<T, ModuloFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Modulo.
     * @param {ModuloCreateArgs} args - Arguments to create a Modulo.
     * @example
     * // Create one Modulo
     * const Modulo = await prisma.modulo.create({
     *   data: {
     *     // ... data to create a Modulo
     *   }
     * })
     * 
     */
    create<T extends ModuloCreateArgs>(args: SelectSubset<T, ModuloCreateArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Modulos.
     * @param {ModuloCreateManyArgs} args - Arguments to create many Modulos.
     * @example
     * // Create many Modulos
     * const modulo = await prisma.modulo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuloCreateManyArgs>(args?: SelectSubset<T, ModuloCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modulos and returns the data saved in the database.
     * @param {ModuloCreateManyAndReturnArgs} args - Arguments to create many Modulos.
     * @example
     * // Create many Modulos
     * const modulo = await prisma.modulo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modulos and only return the `id`
     * const moduloWithIdOnly = await prisma.modulo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuloCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuloCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Modulo.
     * @param {ModuloDeleteArgs} args - Arguments to delete one Modulo.
     * @example
     * // Delete one Modulo
     * const Modulo = await prisma.modulo.delete({
     *   where: {
     *     // ... filter to delete one Modulo
     *   }
     * })
     * 
     */
    delete<T extends ModuloDeleteArgs>(args: SelectSubset<T, ModuloDeleteArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Modulo.
     * @param {ModuloUpdateArgs} args - Arguments to update one Modulo.
     * @example
     * // Update one Modulo
     * const modulo = await prisma.modulo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuloUpdateArgs>(args: SelectSubset<T, ModuloUpdateArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Modulos.
     * @param {ModuloDeleteManyArgs} args - Arguments to filter Modulos to delete.
     * @example
     * // Delete a few Modulos
     * const { count } = await prisma.modulo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuloDeleteManyArgs>(args?: SelectSubset<T, ModuloDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modulos
     * const modulo = await prisma.modulo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuloUpdateManyArgs>(args: SelectSubset<T, ModuloUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Modulo.
     * @param {ModuloUpsertArgs} args - Arguments to update or create a Modulo.
     * @example
     * // Update or create a Modulo
     * const modulo = await prisma.modulo.upsert({
     *   create: {
     *     // ... data to create a Modulo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Modulo we want to update
     *   }
     * })
     */
    upsert<T extends ModuloUpsertArgs>(args: SelectSubset<T, ModuloUpsertArgs<ExtArgs>>): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloCountArgs} args - Arguments to filter Modulos to count.
     * @example
     * // Count the number of Modulos
     * const count = await prisma.modulo.count({
     *   where: {
     *     // ... the filter for the Modulos we want to count
     *   }
     * })
    **/
    count<T extends ModuloCountArgs>(
      args?: Subset<T, ModuloCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuloCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Modulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuloAggregateArgs>(args: Subset<T, ModuloAggregateArgs>): Prisma.PrismaPromise<GetModuloAggregateType<T>>

    /**
     * Group by Modulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuloGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuloGroupByArgs['orderBy'] }
        : { orderBy?: ModuloGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuloGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuloGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Modulo model
   */
  readonly fields: ModuloFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Modulo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuloClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Modulo model
   */ 
  interface ModuloFieldRefs {
    readonly id: FieldRef<"Modulo", 'String'>
    readonly nombre: FieldRef<"Modulo", 'String'>
    readonly descripcion: FieldRef<"Modulo", 'String'>
    readonly icono: FieldRef<"Modulo", 'String'>
    readonly orden: FieldRef<"Modulo", 'Int'>
    readonly activo: FieldRef<"Modulo", 'Boolean'>
    readonly permisoCreacion: FieldRef<"Modulo", 'Boolean'>
    readonly permisoEdicion: FieldRef<"Modulo", 'Boolean'>
    readonly permisoVisualizacion: FieldRef<"Modulo", 'Boolean'>
    readonly permisoEliminacion: FieldRef<"Modulo", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Modulo findUnique
   */
  export type ModuloFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Filter, which Modulo to fetch.
     */
    where: ModuloWhereUniqueInput
  }

  /**
   * Modulo findUniqueOrThrow
   */
  export type ModuloFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Filter, which Modulo to fetch.
     */
    where: ModuloWhereUniqueInput
  }

  /**
   * Modulo findFirst
   */
  export type ModuloFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Filter, which Modulo to fetch.
     */
    where?: ModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modulos.
     */
    cursor?: ModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modulos.
     */
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[]
  }

  /**
   * Modulo findFirstOrThrow
   */
  export type ModuloFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Filter, which Modulo to fetch.
     */
    where?: ModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modulos.
     */
    cursor?: ModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modulos.
     */
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[]
  }

  /**
   * Modulo findMany
   */
  export type ModuloFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Filter, which Modulos to fetch.
     */
    where?: ModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modulos.
     */
    cursor?: ModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modulos.
     */
    skip?: number
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[]
  }

  /**
   * Modulo create
   */
  export type ModuloCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * The data needed to create a Modulo.
     */
    data: XOR<ModuloCreateInput, ModuloUncheckedCreateInput>
  }

  /**
   * Modulo createMany
   */
  export type ModuloCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modulos.
     */
    data: ModuloCreateManyInput | ModuloCreateManyInput[]
  }

  /**
   * Modulo createManyAndReturn
   */
  export type ModuloCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Modulos.
     */
    data: ModuloCreateManyInput | ModuloCreateManyInput[]
  }

  /**
   * Modulo update
   */
  export type ModuloUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * The data needed to update a Modulo.
     */
    data: XOR<ModuloUpdateInput, ModuloUncheckedUpdateInput>
    /**
     * Choose, which Modulo to update.
     */
    where: ModuloWhereUniqueInput
  }

  /**
   * Modulo updateMany
   */
  export type ModuloUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modulos.
     */
    data: XOR<ModuloUpdateManyMutationInput, ModuloUncheckedUpdateManyInput>
    /**
     * Filter which Modulos to update
     */
    where?: ModuloWhereInput
  }

  /**
   * Modulo upsert
   */
  export type ModuloUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * The filter to search for the Modulo to update in case it exists.
     */
    where: ModuloWhereUniqueInput
    /**
     * In case the Modulo found by the `where` argument doesn't exist, create a new Modulo with this data.
     */
    create: XOR<ModuloCreateInput, ModuloUncheckedCreateInput>
    /**
     * In case the Modulo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuloUpdateInput, ModuloUncheckedUpdateInput>
  }

  /**
   * Modulo delete
   */
  export type ModuloDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Filter which Modulo to delete.
     */
    where: ModuloWhereUniqueInput
  }

  /**
   * Modulo deleteMany
   */
  export type ModuloDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modulos to delete
     */
    where?: ModuloWhereInput
  }

  /**
   * Modulo without action
   */
  export type ModuloDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
  }


  /**
   * Model UsuarioRol
   */

  export type AggregateUsuarioRol = {
    _count: UsuarioRolCountAggregateOutputType | null
    _min: UsuarioRolMinAggregateOutputType | null
    _max: UsuarioRolMaxAggregateOutputType | null
  }

  export type UsuarioRolMinAggregateOutputType = {
    usuarioId: string | null
    rolId: string | null
    fechaAsignacion: Date | null
  }

  export type UsuarioRolMaxAggregateOutputType = {
    usuarioId: string | null
    rolId: string | null
    fechaAsignacion: Date | null
  }

  export type UsuarioRolCountAggregateOutputType = {
    usuarioId: number
    rolId: number
    fechaAsignacion: number
    _all: number
  }


  export type UsuarioRolMinAggregateInputType = {
    usuarioId?: true
    rolId?: true
    fechaAsignacion?: true
  }

  export type UsuarioRolMaxAggregateInputType = {
    usuarioId?: true
    rolId?: true
    fechaAsignacion?: true
  }

  export type UsuarioRolCountAggregateInputType = {
    usuarioId?: true
    rolId?: true
    fechaAsignacion?: true
    _all?: true
  }

  export type UsuarioRolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsuarioRol to aggregate.
     */
    where?: UsuarioRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioRols to fetch.
     */
    orderBy?: UsuarioRolOrderByWithRelationInput | UsuarioRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioRols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsuarioRols
    **/
    _count?: true | UsuarioRolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioRolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioRolMaxAggregateInputType
  }

  export type GetUsuarioRolAggregateType<T extends UsuarioRolAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarioRol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarioRol[P]>
      : GetScalarType<T[P], AggregateUsuarioRol[P]>
  }




  export type UsuarioRolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioRolWhereInput
    orderBy?: UsuarioRolOrderByWithAggregationInput | UsuarioRolOrderByWithAggregationInput[]
    by: UsuarioRolScalarFieldEnum[] | UsuarioRolScalarFieldEnum
    having?: UsuarioRolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioRolCountAggregateInputType | true
    _min?: UsuarioRolMinAggregateInputType
    _max?: UsuarioRolMaxAggregateInputType
  }

  export type UsuarioRolGroupByOutputType = {
    usuarioId: string
    rolId: string
    fechaAsignacion: Date
    _count: UsuarioRolCountAggregateOutputType | null
    _min: UsuarioRolMinAggregateOutputType | null
    _max: UsuarioRolMaxAggregateOutputType | null
  }

  type GetUsuarioRolGroupByPayload<T extends UsuarioRolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioRolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioRolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioRolGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioRolGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioRolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    usuarioId?: boolean
    rolId?: boolean
    fechaAsignacion?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarioRol"]>

  export type UsuarioRolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    usuarioId?: boolean
    rolId?: boolean
    fechaAsignacion?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarioRol"]>

  export type UsuarioRolSelectScalar = {
    usuarioId?: boolean
    rolId?: boolean
    fechaAsignacion?: boolean
  }

  export type UsuarioRolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }
  export type UsuarioRolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }

  export type $UsuarioRolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsuarioRol"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      rol: Prisma.$RolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      usuarioId: string
      rolId: string
      fechaAsignacion: Date
    }, ExtArgs["result"]["usuarioRol"]>
    composites: {}
  }

  type UsuarioRolGetPayload<S extends boolean | null | undefined | UsuarioRolDefaultArgs> = $Result.GetResult<Prisma.$UsuarioRolPayload, S>

  type UsuarioRolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioRolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioRolCountAggregateInputType | true
    }

  export interface UsuarioRolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsuarioRol'], meta: { name: 'UsuarioRol' } }
    /**
     * Find zero or one UsuarioRol that matches the filter.
     * @param {UsuarioRolFindUniqueArgs} args - Arguments to find a UsuarioRol
     * @example
     * // Get one UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioRolFindUniqueArgs>(args: SelectSubset<T, UsuarioRolFindUniqueArgs<ExtArgs>>): Prisma__UsuarioRolClient<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsuarioRol that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioRolFindUniqueOrThrowArgs} args - Arguments to find a UsuarioRol
     * @example
     * // Get one UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioRolFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioRolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioRolClient<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsuarioRol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolFindFirstArgs} args - Arguments to find a UsuarioRol
     * @example
     * // Get one UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioRolFindFirstArgs>(args?: SelectSubset<T, UsuarioRolFindFirstArgs<ExtArgs>>): Prisma__UsuarioRolClient<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsuarioRol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolFindFirstOrThrowArgs} args - Arguments to find a UsuarioRol
     * @example
     * // Get one UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioRolFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioRolFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioRolClient<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsuarioRols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsuarioRols
     * const usuarioRols = await prisma.usuarioRol.findMany()
     * 
     * // Get first 10 UsuarioRols
     * const usuarioRols = await prisma.usuarioRol.findMany({ take: 10 })
     * 
     * // Only select the `usuarioId`
     * const usuarioRolWithUsuarioIdOnly = await prisma.usuarioRol.findMany({ select: { usuarioId: true } })
     * 
     */
    findMany<T extends UsuarioRolFindManyArgs>(args?: SelectSubset<T, UsuarioRolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsuarioRol.
     * @param {UsuarioRolCreateArgs} args - Arguments to create a UsuarioRol.
     * @example
     * // Create one UsuarioRol
     * const UsuarioRol = await prisma.usuarioRol.create({
     *   data: {
     *     // ... data to create a UsuarioRol
     *   }
     * })
     * 
     */
    create<T extends UsuarioRolCreateArgs>(args: SelectSubset<T, UsuarioRolCreateArgs<ExtArgs>>): Prisma__UsuarioRolClient<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsuarioRols.
     * @param {UsuarioRolCreateManyArgs} args - Arguments to create many UsuarioRols.
     * @example
     * // Create many UsuarioRols
     * const usuarioRol = await prisma.usuarioRol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioRolCreateManyArgs>(args?: SelectSubset<T, UsuarioRolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsuarioRols and returns the data saved in the database.
     * @param {UsuarioRolCreateManyAndReturnArgs} args - Arguments to create many UsuarioRols.
     * @example
     * // Create many UsuarioRols
     * const usuarioRol = await prisma.usuarioRol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsuarioRols and only return the `usuarioId`
     * const usuarioRolWithUsuarioIdOnly = await prisma.usuarioRol.createManyAndReturn({ 
     *   select: { usuarioId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioRolCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioRolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsuarioRol.
     * @param {UsuarioRolDeleteArgs} args - Arguments to delete one UsuarioRol.
     * @example
     * // Delete one UsuarioRol
     * const UsuarioRol = await prisma.usuarioRol.delete({
     *   where: {
     *     // ... filter to delete one UsuarioRol
     *   }
     * })
     * 
     */
    delete<T extends UsuarioRolDeleteArgs>(args: SelectSubset<T, UsuarioRolDeleteArgs<ExtArgs>>): Prisma__UsuarioRolClient<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsuarioRol.
     * @param {UsuarioRolUpdateArgs} args - Arguments to update one UsuarioRol.
     * @example
     * // Update one UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioRolUpdateArgs>(args: SelectSubset<T, UsuarioRolUpdateArgs<ExtArgs>>): Prisma__UsuarioRolClient<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsuarioRols.
     * @param {UsuarioRolDeleteManyArgs} args - Arguments to filter UsuarioRols to delete.
     * @example
     * // Delete a few UsuarioRols
     * const { count } = await prisma.usuarioRol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioRolDeleteManyArgs>(args?: SelectSubset<T, UsuarioRolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuarioRols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsuarioRols
     * const usuarioRol = await prisma.usuarioRol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioRolUpdateManyArgs>(args: SelectSubset<T, UsuarioRolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsuarioRol.
     * @param {UsuarioRolUpsertArgs} args - Arguments to update or create a UsuarioRol.
     * @example
     * // Update or create a UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.upsert({
     *   create: {
     *     // ... data to create a UsuarioRol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsuarioRol we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioRolUpsertArgs>(args: SelectSubset<T, UsuarioRolUpsertArgs<ExtArgs>>): Prisma__UsuarioRolClient<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsuarioRols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolCountArgs} args - Arguments to filter UsuarioRols to count.
     * @example
     * // Count the number of UsuarioRols
     * const count = await prisma.usuarioRol.count({
     *   where: {
     *     // ... the filter for the UsuarioRols we want to count
     *   }
     * })
    **/
    count<T extends UsuarioRolCountArgs>(
      args?: Subset<T, UsuarioRolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioRolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsuarioRol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioRolAggregateArgs>(args: Subset<T, UsuarioRolAggregateArgs>): Prisma.PrismaPromise<GetUsuarioRolAggregateType<T>>

    /**
     * Group by UsuarioRol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioRolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioRolGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioRolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioRolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioRolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsuarioRol model
   */
  readonly fields: UsuarioRolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsuarioRol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioRolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rol<T extends RolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolDefaultArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsuarioRol model
   */ 
  interface UsuarioRolFieldRefs {
    readonly usuarioId: FieldRef<"UsuarioRol", 'String'>
    readonly rolId: FieldRef<"UsuarioRol", 'String'>
    readonly fechaAsignacion: FieldRef<"UsuarioRol", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsuarioRol findUnique
   */
  export type UsuarioRolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioRol to fetch.
     */
    where: UsuarioRolWhereUniqueInput
  }

  /**
   * UsuarioRol findUniqueOrThrow
   */
  export type UsuarioRolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioRol to fetch.
     */
    where: UsuarioRolWhereUniqueInput
  }

  /**
   * UsuarioRol findFirst
   */
  export type UsuarioRolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioRol to fetch.
     */
    where?: UsuarioRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioRols to fetch.
     */
    orderBy?: UsuarioRolOrderByWithRelationInput | UsuarioRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuarioRols.
     */
    cursor?: UsuarioRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioRols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuarioRols.
     */
    distinct?: UsuarioRolScalarFieldEnum | UsuarioRolScalarFieldEnum[]
  }

  /**
   * UsuarioRol findFirstOrThrow
   */
  export type UsuarioRolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioRol to fetch.
     */
    where?: UsuarioRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioRols to fetch.
     */
    orderBy?: UsuarioRolOrderByWithRelationInput | UsuarioRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuarioRols.
     */
    cursor?: UsuarioRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioRols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuarioRols.
     */
    distinct?: UsuarioRolScalarFieldEnum | UsuarioRolScalarFieldEnum[]
  }

  /**
   * UsuarioRol findMany
   */
  export type UsuarioRolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioRols to fetch.
     */
    where?: UsuarioRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioRols to fetch.
     */
    orderBy?: UsuarioRolOrderByWithRelationInput | UsuarioRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsuarioRols.
     */
    cursor?: UsuarioRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioRols.
     */
    skip?: number
    distinct?: UsuarioRolScalarFieldEnum | UsuarioRolScalarFieldEnum[]
  }

  /**
   * UsuarioRol create
   */
  export type UsuarioRolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * The data needed to create a UsuarioRol.
     */
    data: XOR<UsuarioRolCreateInput, UsuarioRolUncheckedCreateInput>
  }

  /**
   * UsuarioRol createMany
   */
  export type UsuarioRolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsuarioRols.
     */
    data: UsuarioRolCreateManyInput | UsuarioRolCreateManyInput[]
  }

  /**
   * UsuarioRol createManyAndReturn
   */
  export type UsuarioRolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsuarioRols.
     */
    data: UsuarioRolCreateManyInput | UsuarioRolCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsuarioRol update
   */
  export type UsuarioRolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * The data needed to update a UsuarioRol.
     */
    data: XOR<UsuarioRolUpdateInput, UsuarioRolUncheckedUpdateInput>
    /**
     * Choose, which UsuarioRol to update.
     */
    where: UsuarioRolWhereUniqueInput
  }

  /**
   * UsuarioRol updateMany
   */
  export type UsuarioRolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsuarioRols.
     */
    data: XOR<UsuarioRolUpdateManyMutationInput, UsuarioRolUncheckedUpdateManyInput>
    /**
     * Filter which UsuarioRols to update
     */
    where?: UsuarioRolWhereInput
  }

  /**
   * UsuarioRol upsert
   */
  export type UsuarioRolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * The filter to search for the UsuarioRol to update in case it exists.
     */
    where: UsuarioRolWhereUniqueInput
    /**
     * In case the UsuarioRol found by the `where` argument doesn't exist, create a new UsuarioRol with this data.
     */
    create: XOR<UsuarioRolCreateInput, UsuarioRolUncheckedCreateInput>
    /**
     * In case the UsuarioRol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioRolUpdateInput, UsuarioRolUncheckedUpdateInput>
  }

  /**
   * UsuarioRol delete
   */
  export type UsuarioRolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * Filter which UsuarioRol to delete.
     */
    where: UsuarioRolWhereUniqueInput
  }

  /**
   * UsuarioRol deleteMany
   */
  export type UsuarioRolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsuarioRols to delete
     */
    where?: UsuarioRolWhereInput
  }

  /**
   * UsuarioRol without action
   */
  export type UsuarioRolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
  }


  /**
   * Model RolPermiso
   */

  export type AggregateRolPermiso = {
    _count: RolPermisoCountAggregateOutputType | null
    _min: RolPermisoMinAggregateOutputType | null
    _max: RolPermisoMaxAggregateOutputType | null
  }

  export type RolPermisoMinAggregateOutputType = {
    rolId: string | null
    permisoId: string | null
  }

  export type RolPermisoMaxAggregateOutputType = {
    rolId: string | null
    permisoId: string | null
  }

  export type RolPermisoCountAggregateOutputType = {
    rolId: number
    permisoId: number
    _all: number
  }


  export type RolPermisoMinAggregateInputType = {
    rolId?: true
    permisoId?: true
  }

  export type RolPermisoMaxAggregateInputType = {
    rolId?: true
    permisoId?: true
  }

  export type RolPermisoCountAggregateInputType = {
    rolId?: true
    permisoId?: true
    _all?: true
  }

  export type RolPermisoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolPermiso to aggregate.
     */
    where?: RolPermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolPermisos to fetch.
     */
    orderBy?: RolPermisoOrderByWithRelationInput | RolPermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolPermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolPermisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolPermisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolPermisos
    **/
    _count?: true | RolPermisoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolPermisoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolPermisoMaxAggregateInputType
  }

  export type GetRolPermisoAggregateType<T extends RolPermisoAggregateArgs> = {
        [P in keyof T & keyof AggregateRolPermiso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolPermiso[P]>
      : GetScalarType<T[P], AggregateRolPermiso[P]>
  }




  export type RolPermisoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolPermisoWhereInput
    orderBy?: RolPermisoOrderByWithAggregationInput | RolPermisoOrderByWithAggregationInput[]
    by: RolPermisoScalarFieldEnum[] | RolPermisoScalarFieldEnum
    having?: RolPermisoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolPermisoCountAggregateInputType | true
    _min?: RolPermisoMinAggregateInputType
    _max?: RolPermisoMaxAggregateInputType
  }

  export type RolPermisoGroupByOutputType = {
    rolId: string
    permisoId: string
    _count: RolPermisoCountAggregateOutputType | null
    _min: RolPermisoMinAggregateOutputType | null
    _max: RolPermisoMaxAggregateOutputType | null
  }

  type GetRolPermisoGroupByPayload<T extends RolPermisoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolPermisoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolPermisoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolPermisoGroupByOutputType[P]>
            : GetScalarType<T[P], RolPermisoGroupByOutputType[P]>
        }
      >
    >


  export type RolPermisoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rolId?: boolean
    permisoId?: boolean
    rol?: boolean | RolDefaultArgs<ExtArgs>
    permiso?: boolean | PermisoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolPermiso"]>

  export type RolPermisoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rolId?: boolean
    permisoId?: boolean
    rol?: boolean | RolDefaultArgs<ExtArgs>
    permiso?: boolean | PermisoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolPermiso"]>

  export type RolPermisoSelectScalar = {
    rolId?: boolean
    permisoId?: boolean
  }

  export type RolPermisoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rol?: boolean | RolDefaultArgs<ExtArgs>
    permiso?: boolean | PermisoDefaultArgs<ExtArgs>
  }
  export type RolPermisoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rol?: boolean | RolDefaultArgs<ExtArgs>
    permiso?: boolean | PermisoDefaultArgs<ExtArgs>
  }

  export type $RolPermisoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolPermiso"
    objects: {
      rol: Prisma.$RolPayload<ExtArgs>
      permiso: Prisma.$PermisoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      rolId: string
      permisoId: string
    }, ExtArgs["result"]["rolPermiso"]>
    composites: {}
  }

  type RolPermisoGetPayload<S extends boolean | null | undefined | RolPermisoDefaultArgs> = $Result.GetResult<Prisma.$RolPermisoPayload, S>

  type RolPermisoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolPermisoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolPermisoCountAggregateInputType | true
    }

  export interface RolPermisoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolPermiso'], meta: { name: 'RolPermiso' } }
    /**
     * Find zero or one RolPermiso that matches the filter.
     * @param {RolPermisoFindUniqueArgs} args - Arguments to find a RolPermiso
     * @example
     * // Get one RolPermiso
     * const rolPermiso = await prisma.rolPermiso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolPermisoFindUniqueArgs>(args: SelectSubset<T, RolPermisoFindUniqueArgs<ExtArgs>>): Prisma__RolPermisoClient<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolPermiso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolPermisoFindUniqueOrThrowArgs} args - Arguments to find a RolPermiso
     * @example
     * // Get one RolPermiso
     * const rolPermiso = await prisma.rolPermiso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolPermisoFindUniqueOrThrowArgs>(args: SelectSubset<T, RolPermisoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolPermisoClient<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolPermiso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolPermisoFindFirstArgs} args - Arguments to find a RolPermiso
     * @example
     * // Get one RolPermiso
     * const rolPermiso = await prisma.rolPermiso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolPermisoFindFirstArgs>(args?: SelectSubset<T, RolPermisoFindFirstArgs<ExtArgs>>): Prisma__RolPermisoClient<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolPermiso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolPermisoFindFirstOrThrowArgs} args - Arguments to find a RolPermiso
     * @example
     * // Get one RolPermiso
     * const rolPermiso = await prisma.rolPermiso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolPermisoFindFirstOrThrowArgs>(args?: SelectSubset<T, RolPermisoFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolPermisoClient<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolPermisos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolPermisoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolPermisos
     * const rolPermisos = await prisma.rolPermiso.findMany()
     * 
     * // Get first 10 RolPermisos
     * const rolPermisos = await prisma.rolPermiso.findMany({ take: 10 })
     * 
     * // Only select the `rolId`
     * const rolPermisoWithRolIdOnly = await prisma.rolPermiso.findMany({ select: { rolId: true } })
     * 
     */
    findMany<T extends RolPermisoFindManyArgs>(args?: SelectSubset<T, RolPermisoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolPermiso.
     * @param {RolPermisoCreateArgs} args - Arguments to create a RolPermiso.
     * @example
     * // Create one RolPermiso
     * const RolPermiso = await prisma.rolPermiso.create({
     *   data: {
     *     // ... data to create a RolPermiso
     *   }
     * })
     * 
     */
    create<T extends RolPermisoCreateArgs>(args: SelectSubset<T, RolPermisoCreateArgs<ExtArgs>>): Prisma__RolPermisoClient<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolPermisos.
     * @param {RolPermisoCreateManyArgs} args - Arguments to create many RolPermisos.
     * @example
     * // Create many RolPermisos
     * const rolPermiso = await prisma.rolPermiso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolPermisoCreateManyArgs>(args?: SelectSubset<T, RolPermisoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolPermisos and returns the data saved in the database.
     * @param {RolPermisoCreateManyAndReturnArgs} args - Arguments to create many RolPermisos.
     * @example
     * // Create many RolPermisos
     * const rolPermiso = await prisma.rolPermiso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolPermisos and only return the `rolId`
     * const rolPermisoWithRolIdOnly = await prisma.rolPermiso.createManyAndReturn({ 
     *   select: { rolId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolPermisoCreateManyAndReturnArgs>(args?: SelectSubset<T, RolPermisoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RolPermiso.
     * @param {RolPermisoDeleteArgs} args - Arguments to delete one RolPermiso.
     * @example
     * // Delete one RolPermiso
     * const RolPermiso = await prisma.rolPermiso.delete({
     *   where: {
     *     // ... filter to delete one RolPermiso
     *   }
     * })
     * 
     */
    delete<T extends RolPermisoDeleteArgs>(args: SelectSubset<T, RolPermisoDeleteArgs<ExtArgs>>): Prisma__RolPermisoClient<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolPermiso.
     * @param {RolPermisoUpdateArgs} args - Arguments to update one RolPermiso.
     * @example
     * // Update one RolPermiso
     * const rolPermiso = await prisma.rolPermiso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolPermisoUpdateArgs>(args: SelectSubset<T, RolPermisoUpdateArgs<ExtArgs>>): Prisma__RolPermisoClient<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolPermisos.
     * @param {RolPermisoDeleteManyArgs} args - Arguments to filter RolPermisos to delete.
     * @example
     * // Delete a few RolPermisos
     * const { count } = await prisma.rolPermiso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolPermisoDeleteManyArgs>(args?: SelectSubset<T, RolPermisoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolPermisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolPermisoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolPermisos
     * const rolPermiso = await prisma.rolPermiso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolPermisoUpdateManyArgs>(args: SelectSubset<T, RolPermisoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolPermiso.
     * @param {RolPermisoUpsertArgs} args - Arguments to update or create a RolPermiso.
     * @example
     * // Update or create a RolPermiso
     * const rolPermiso = await prisma.rolPermiso.upsert({
     *   create: {
     *     // ... data to create a RolPermiso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolPermiso we want to update
     *   }
     * })
     */
    upsert<T extends RolPermisoUpsertArgs>(args: SelectSubset<T, RolPermisoUpsertArgs<ExtArgs>>): Prisma__RolPermisoClient<$Result.GetResult<Prisma.$RolPermisoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolPermisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolPermisoCountArgs} args - Arguments to filter RolPermisos to count.
     * @example
     * // Count the number of RolPermisos
     * const count = await prisma.rolPermiso.count({
     *   where: {
     *     // ... the filter for the RolPermisos we want to count
     *   }
     * })
    **/
    count<T extends RolPermisoCountArgs>(
      args?: Subset<T, RolPermisoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolPermisoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolPermiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolPermisoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolPermisoAggregateArgs>(args: Subset<T, RolPermisoAggregateArgs>): Prisma.PrismaPromise<GetRolPermisoAggregateType<T>>

    /**
     * Group by RolPermiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolPermisoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolPermisoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolPermisoGroupByArgs['orderBy'] }
        : { orderBy?: RolPermisoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolPermisoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolPermisoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolPermiso model
   */
  readonly fields: RolPermisoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolPermiso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolPermisoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rol<T extends RolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolDefaultArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    permiso<T extends PermisoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermisoDefaultArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolPermiso model
   */ 
  interface RolPermisoFieldRefs {
    readonly rolId: FieldRef<"RolPermiso", 'String'>
    readonly permisoId: FieldRef<"RolPermiso", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RolPermiso findUnique
   */
  export type RolPermisoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * Filter, which RolPermiso to fetch.
     */
    where: RolPermisoWhereUniqueInput
  }

  /**
   * RolPermiso findUniqueOrThrow
   */
  export type RolPermisoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * Filter, which RolPermiso to fetch.
     */
    where: RolPermisoWhereUniqueInput
  }

  /**
   * RolPermiso findFirst
   */
  export type RolPermisoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * Filter, which RolPermiso to fetch.
     */
    where?: RolPermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolPermisos to fetch.
     */
    orderBy?: RolPermisoOrderByWithRelationInput | RolPermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolPermisos.
     */
    cursor?: RolPermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolPermisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolPermisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolPermisos.
     */
    distinct?: RolPermisoScalarFieldEnum | RolPermisoScalarFieldEnum[]
  }

  /**
   * RolPermiso findFirstOrThrow
   */
  export type RolPermisoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * Filter, which RolPermiso to fetch.
     */
    where?: RolPermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolPermisos to fetch.
     */
    orderBy?: RolPermisoOrderByWithRelationInput | RolPermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolPermisos.
     */
    cursor?: RolPermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolPermisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolPermisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolPermisos.
     */
    distinct?: RolPermisoScalarFieldEnum | RolPermisoScalarFieldEnum[]
  }

  /**
   * RolPermiso findMany
   */
  export type RolPermisoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * Filter, which RolPermisos to fetch.
     */
    where?: RolPermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolPermisos to fetch.
     */
    orderBy?: RolPermisoOrderByWithRelationInput | RolPermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolPermisos.
     */
    cursor?: RolPermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolPermisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolPermisos.
     */
    skip?: number
    distinct?: RolPermisoScalarFieldEnum | RolPermisoScalarFieldEnum[]
  }

  /**
   * RolPermiso create
   */
  export type RolPermisoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * The data needed to create a RolPermiso.
     */
    data: XOR<RolPermisoCreateInput, RolPermisoUncheckedCreateInput>
  }

  /**
   * RolPermiso createMany
   */
  export type RolPermisoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolPermisos.
     */
    data: RolPermisoCreateManyInput | RolPermisoCreateManyInput[]
  }

  /**
   * RolPermiso createManyAndReturn
   */
  export type RolPermisoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RolPermisos.
     */
    data: RolPermisoCreateManyInput | RolPermisoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolPermiso update
   */
  export type RolPermisoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * The data needed to update a RolPermiso.
     */
    data: XOR<RolPermisoUpdateInput, RolPermisoUncheckedUpdateInput>
    /**
     * Choose, which RolPermiso to update.
     */
    where: RolPermisoWhereUniqueInput
  }

  /**
   * RolPermiso updateMany
   */
  export type RolPermisoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolPermisos.
     */
    data: XOR<RolPermisoUpdateManyMutationInput, RolPermisoUncheckedUpdateManyInput>
    /**
     * Filter which RolPermisos to update
     */
    where?: RolPermisoWhereInput
  }

  /**
   * RolPermiso upsert
   */
  export type RolPermisoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * The filter to search for the RolPermiso to update in case it exists.
     */
    where: RolPermisoWhereUniqueInput
    /**
     * In case the RolPermiso found by the `where` argument doesn't exist, create a new RolPermiso with this data.
     */
    create: XOR<RolPermisoCreateInput, RolPermisoUncheckedCreateInput>
    /**
     * In case the RolPermiso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolPermisoUpdateInput, RolPermisoUncheckedUpdateInput>
  }

  /**
   * RolPermiso delete
   */
  export type RolPermisoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
    /**
     * Filter which RolPermiso to delete.
     */
    where: RolPermisoWhereUniqueInput
  }

  /**
   * RolPermiso deleteMany
   */
  export type RolPermisoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolPermisos to delete
     */
    where?: RolPermisoWhereInput
  }

  /**
   * RolPermiso without action
   */
  export type RolPermisoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolPermiso
     */
    select?: RolPermisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolPermisoInclude<ExtArgs> | null
  }


  /**
   * Model UsuarioActivo
   */

  export type AggregateUsuarioActivo = {
    _count: UsuarioActivoCountAggregateOutputType | null
    _min: UsuarioActivoMinAggregateOutputType | null
    _max: UsuarioActivoMaxAggregateOutputType | null
  }

  export type UsuarioActivoMinAggregateOutputType = {
    usuarioId: string | null
    activoId: string | null
    nivelAcceso: string | null
  }

  export type UsuarioActivoMaxAggregateOutputType = {
    usuarioId: string | null
    activoId: string | null
    nivelAcceso: string | null
  }

  export type UsuarioActivoCountAggregateOutputType = {
    usuarioId: number
    activoId: number
    nivelAcceso: number
    _all: number
  }


  export type UsuarioActivoMinAggregateInputType = {
    usuarioId?: true
    activoId?: true
    nivelAcceso?: true
  }

  export type UsuarioActivoMaxAggregateInputType = {
    usuarioId?: true
    activoId?: true
    nivelAcceso?: true
  }

  export type UsuarioActivoCountAggregateInputType = {
    usuarioId?: true
    activoId?: true
    nivelAcceso?: true
    _all?: true
  }

  export type UsuarioActivoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsuarioActivo to aggregate.
     */
    where?: UsuarioActivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioActivos to fetch.
     */
    orderBy?: UsuarioActivoOrderByWithRelationInput | UsuarioActivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioActivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioActivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioActivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsuarioActivos
    **/
    _count?: true | UsuarioActivoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioActivoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioActivoMaxAggregateInputType
  }

  export type GetUsuarioActivoAggregateType<T extends UsuarioActivoAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarioActivo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarioActivo[P]>
      : GetScalarType<T[P], AggregateUsuarioActivo[P]>
  }




  export type UsuarioActivoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioActivoWhereInput
    orderBy?: UsuarioActivoOrderByWithAggregationInput | UsuarioActivoOrderByWithAggregationInput[]
    by: UsuarioActivoScalarFieldEnum[] | UsuarioActivoScalarFieldEnum
    having?: UsuarioActivoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioActivoCountAggregateInputType | true
    _min?: UsuarioActivoMinAggregateInputType
    _max?: UsuarioActivoMaxAggregateInputType
  }

  export type UsuarioActivoGroupByOutputType = {
    usuarioId: string
    activoId: string
    nivelAcceso: string
    _count: UsuarioActivoCountAggregateOutputType | null
    _min: UsuarioActivoMinAggregateOutputType | null
    _max: UsuarioActivoMaxAggregateOutputType | null
  }

  type GetUsuarioActivoGroupByPayload<T extends UsuarioActivoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioActivoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioActivoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioActivoGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioActivoGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioActivoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    usuarioId?: boolean
    activoId?: boolean
    nivelAcceso?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    activo?: boolean | ActivoAccesoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarioActivo"]>

  export type UsuarioActivoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    usuarioId?: boolean
    activoId?: boolean
    nivelAcceso?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    activo?: boolean | ActivoAccesoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarioActivo"]>

  export type UsuarioActivoSelectScalar = {
    usuarioId?: boolean
    activoId?: boolean
    nivelAcceso?: boolean
  }

  export type UsuarioActivoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    activo?: boolean | ActivoAccesoDefaultArgs<ExtArgs>
  }
  export type UsuarioActivoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    activo?: boolean | ActivoAccesoDefaultArgs<ExtArgs>
  }

  export type $UsuarioActivoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsuarioActivo"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      activo: Prisma.$ActivoAccesoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      usuarioId: string
      activoId: string
      nivelAcceso: string
    }, ExtArgs["result"]["usuarioActivo"]>
    composites: {}
  }

  type UsuarioActivoGetPayload<S extends boolean | null | undefined | UsuarioActivoDefaultArgs> = $Result.GetResult<Prisma.$UsuarioActivoPayload, S>

  type UsuarioActivoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioActivoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioActivoCountAggregateInputType | true
    }

  export interface UsuarioActivoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsuarioActivo'], meta: { name: 'UsuarioActivo' } }
    /**
     * Find zero or one UsuarioActivo that matches the filter.
     * @param {UsuarioActivoFindUniqueArgs} args - Arguments to find a UsuarioActivo
     * @example
     * // Get one UsuarioActivo
     * const usuarioActivo = await prisma.usuarioActivo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioActivoFindUniqueArgs>(args: SelectSubset<T, UsuarioActivoFindUniqueArgs<ExtArgs>>): Prisma__UsuarioActivoClient<$Result.GetResult<Prisma.$UsuarioActivoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsuarioActivo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioActivoFindUniqueOrThrowArgs} args - Arguments to find a UsuarioActivo
     * @example
     * // Get one UsuarioActivo
     * const usuarioActivo = await prisma.usuarioActivo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioActivoFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioActivoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioActivoClient<$Result.GetResult<Prisma.$UsuarioActivoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsuarioActivo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioActivoFindFirstArgs} args - Arguments to find a UsuarioActivo
     * @example
     * // Get one UsuarioActivo
     * const usuarioActivo = await prisma.usuarioActivo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioActivoFindFirstArgs>(args?: SelectSubset<T, UsuarioActivoFindFirstArgs<ExtArgs>>): Prisma__UsuarioActivoClient<$Result.GetResult<Prisma.$UsuarioActivoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsuarioActivo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioActivoFindFirstOrThrowArgs} args - Arguments to find a UsuarioActivo
     * @example
     * // Get one UsuarioActivo
     * const usuarioActivo = await prisma.usuarioActivo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioActivoFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioActivoFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioActivoClient<$Result.GetResult<Prisma.$UsuarioActivoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsuarioActivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioActivoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsuarioActivos
     * const usuarioActivos = await prisma.usuarioActivo.findMany()
     * 
     * // Get first 10 UsuarioActivos
     * const usuarioActivos = await prisma.usuarioActivo.findMany({ take: 10 })
     * 
     * // Only select the `usuarioId`
     * const usuarioActivoWithUsuarioIdOnly = await prisma.usuarioActivo.findMany({ select: { usuarioId: true } })
     * 
     */
    findMany<T extends UsuarioActivoFindManyArgs>(args?: SelectSubset<T, UsuarioActivoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioActivoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsuarioActivo.
     * @param {UsuarioActivoCreateArgs} args - Arguments to create a UsuarioActivo.
     * @example
     * // Create one UsuarioActivo
     * const UsuarioActivo = await prisma.usuarioActivo.create({
     *   data: {
     *     // ... data to create a UsuarioActivo
     *   }
     * })
     * 
     */
    create<T extends UsuarioActivoCreateArgs>(args: SelectSubset<T, UsuarioActivoCreateArgs<ExtArgs>>): Prisma__UsuarioActivoClient<$Result.GetResult<Prisma.$UsuarioActivoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsuarioActivos.
     * @param {UsuarioActivoCreateManyArgs} args - Arguments to create many UsuarioActivos.
     * @example
     * // Create many UsuarioActivos
     * const usuarioActivo = await prisma.usuarioActivo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioActivoCreateManyArgs>(args?: SelectSubset<T, UsuarioActivoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsuarioActivos and returns the data saved in the database.
     * @param {UsuarioActivoCreateManyAndReturnArgs} args - Arguments to create many UsuarioActivos.
     * @example
     * // Create many UsuarioActivos
     * const usuarioActivo = await prisma.usuarioActivo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsuarioActivos and only return the `usuarioId`
     * const usuarioActivoWithUsuarioIdOnly = await prisma.usuarioActivo.createManyAndReturn({ 
     *   select: { usuarioId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioActivoCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioActivoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioActivoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsuarioActivo.
     * @param {UsuarioActivoDeleteArgs} args - Arguments to delete one UsuarioActivo.
     * @example
     * // Delete one UsuarioActivo
     * const UsuarioActivo = await prisma.usuarioActivo.delete({
     *   where: {
     *     // ... filter to delete one UsuarioActivo
     *   }
     * })
     * 
     */
    delete<T extends UsuarioActivoDeleteArgs>(args: SelectSubset<T, UsuarioActivoDeleteArgs<ExtArgs>>): Prisma__UsuarioActivoClient<$Result.GetResult<Prisma.$UsuarioActivoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsuarioActivo.
     * @param {UsuarioActivoUpdateArgs} args - Arguments to update one UsuarioActivo.
     * @example
     * // Update one UsuarioActivo
     * const usuarioActivo = await prisma.usuarioActivo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioActivoUpdateArgs>(args: SelectSubset<T, UsuarioActivoUpdateArgs<ExtArgs>>): Prisma__UsuarioActivoClient<$Result.GetResult<Prisma.$UsuarioActivoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsuarioActivos.
     * @param {UsuarioActivoDeleteManyArgs} args - Arguments to filter UsuarioActivos to delete.
     * @example
     * // Delete a few UsuarioActivos
     * const { count } = await prisma.usuarioActivo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioActivoDeleteManyArgs>(args?: SelectSubset<T, UsuarioActivoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuarioActivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioActivoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsuarioActivos
     * const usuarioActivo = await prisma.usuarioActivo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioActivoUpdateManyArgs>(args: SelectSubset<T, UsuarioActivoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsuarioActivo.
     * @param {UsuarioActivoUpsertArgs} args - Arguments to update or create a UsuarioActivo.
     * @example
     * // Update or create a UsuarioActivo
     * const usuarioActivo = await prisma.usuarioActivo.upsert({
     *   create: {
     *     // ... data to create a UsuarioActivo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsuarioActivo we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioActivoUpsertArgs>(args: SelectSubset<T, UsuarioActivoUpsertArgs<ExtArgs>>): Prisma__UsuarioActivoClient<$Result.GetResult<Prisma.$UsuarioActivoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsuarioActivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioActivoCountArgs} args - Arguments to filter UsuarioActivos to count.
     * @example
     * // Count the number of UsuarioActivos
     * const count = await prisma.usuarioActivo.count({
     *   where: {
     *     // ... the filter for the UsuarioActivos we want to count
     *   }
     * })
    **/
    count<T extends UsuarioActivoCountArgs>(
      args?: Subset<T, UsuarioActivoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioActivoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsuarioActivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioActivoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioActivoAggregateArgs>(args: Subset<T, UsuarioActivoAggregateArgs>): Prisma.PrismaPromise<GetUsuarioActivoAggregateType<T>>

    /**
     * Group by UsuarioActivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioActivoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioActivoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioActivoGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioActivoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioActivoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioActivoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsuarioActivo model
   */
  readonly fields: UsuarioActivoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsuarioActivo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioActivoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    activo<T extends ActivoAccesoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivoAccesoDefaultArgs<ExtArgs>>): Prisma__ActivoAccesoClient<$Result.GetResult<Prisma.$ActivoAccesoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsuarioActivo model
   */ 
  interface UsuarioActivoFieldRefs {
    readonly usuarioId: FieldRef<"UsuarioActivo", 'String'>
    readonly activoId: FieldRef<"UsuarioActivo", 'String'>
    readonly nivelAcceso: FieldRef<"UsuarioActivo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UsuarioActivo findUnique
   */
  export type UsuarioActivoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioActivo
     */
    select?: UsuarioActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioActivoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioActivo to fetch.
     */
    where: UsuarioActivoWhereUniqueInput
  }

  /**
   * UsuarioActivo findUniqueOrThrow
   */
  export type UsuarioActivoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioActivo
     */
    select?: UsuarioActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioActivoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioActivo to fetch.
     */
    where: UsuarioActivoWhereUniqueInput
  }

  /**
   * UsuarioActivo findFirst
   */
  export type UsuarioActivoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioActivo
     */
    select?: UsuarioActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioActivoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioActivo to fetch.
     */
    where?: UsuarioActivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioActivos to fetch.
     */
    orderBy?: UsuarioActivoOrderByWithRelationInput | UsuarioActivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuarioActivos.
     */
    cursor?: UsuarioActivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioActivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioActivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuarioActivos.
     */
    distinct?: UsuarioActivoScalarFieldEnum | UsuarioActivoScalarFieldEnum[]
  }

  /**
   * UsuarioActivo findFirstOrThrow
   */
  export type UsuarioActivoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioActivo
     */
    select?: UsuarioActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioActivoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioActivo to fetch.
     */
    where?: UsuarioActivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioActivos to fetch.
     */
    orderBy?: UsuarioActivoOrderByWithRelationInput | UsuarioActivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuarioActivos.
     */
    cursor?: UsuarioActivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioActivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioActivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuarioActivos.
     */
    distinct?: UsuarioActivoScalarFieldEnum | UsuarioActivoScalarFieldEnum[]
  }

  /**
   * UsuarioActivo findMany
   */
  export type UsuarioActivoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioActivo
     */
    select?: UsuarioActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioActivoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioActivos to fetch.
     */
    where?: UsuarioActivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioActivos to fetch.
     */
    orderBy?: UsuarioActivoOrderByWithRelationInput | UsuarioActivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsuarioActivos.
     */
    cursor?: UsuarioActivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioActivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioActivos.
     */
    skip?: number
    distinct?: UsuarioActivoScalarFieldEnum | UsuarioActivoScalarFieldEnum[]
  }

  /**
   * UsuarioActivo create
   */
  export type UsuarioActivoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioActivo
     */
    select?: UsuarioActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioActivoInclude<ExtArgs> | null
    /**
     * The data needed to create a UsuarioActivo.
     */
    data: XOR<UsuarioActivoCreateInput, UsuarioActivoUncheckedCreateInput>
  }

  /**
   * UsuarioActivo createMany
   */
  export type UsuarioActivoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsuarioActivos.
     */
    data: UsuarioActivoCreateManyInput | UsuarioActivoCreateManyInput[]
  }

  /**
   * UsuarioActivo createManyAndReturn
   */
  export type UsuarioActivoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioActivo
     */
    select?: UsuarioActivoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsuarioActivos.
     */
    data: UsuarioActivoCreateManyInput | UsuarioActivoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioActivoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsuarioActivo update
   */
  export type UsuarioActivoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioActivo
     */
    select?: UsuarioActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioActivoInclude<ExtArgs> | null
    /**
     * The data needed to update a UsuarioActivo.
     */
    data: XOR<UsuarioActivoUpdateInput, UsuarioActivoUncheckedUpdateInput>
    /**
     * Choose, which UsuarioActivo to update.
     */
    where: UsuarioActivoWhereUniqueInput
  }

  /**
   * UsuarioActivo updateMany
   */
  export type UsuarioActivoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsuarioActivos.
     */
    data: XOR<UsuarioActivoUpdateManyMutationInput, UsuarioActivoUncheckedUpdateManyInput>
    /**
     * Filter which UsuarioActivos to update
     */
    where?: UsuarioActivoWhereInput
  }

  /**
   * UsuarioActivo upsert
   */
  export type UsuarioActivoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioActivo
     */
    select?: UsuarioActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioActivoInclude<ExtArgs> | null
    /**
     * The filter to search for the UsuarioActivo to update in case it exists.
     */
    where: UsuarioActivoWhereUniqueInput
    /**
     * In case the UsuarioActivo found by the `where` argument doesn't exist, create a new UsuarioActivo with this data.
     */
    create: XOR<UsuarioActivoCreateInput, UsuarioActivoUncheckedCreateInput>
    /**
     * In case the UsuarioActivo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioActivoUpdateInput, UsuarioActivoUncheckedUpdateInput>
  }

  /**
   * UsuarioActivo delete
   */
  export type UsuarioActivoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioActivo
     */
    select?: UsuarioActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioActivoInclude<ExtArgs> | null
    /**
     * Filter which UsuarioActivo to delete.
     */
    where: UsuarioActivoWhereUniqueInput
  }

  /**
   * UsuarioActivo deleteMany
   */
  export type UsuarioActivoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsuarioActivos to delete
     */
    where?: UsuarioActivoWhereInput
  }

  /**
   * UsuarioActivo without action
   */
  export type UsuarioActivoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioActivo
     */
    select?: UsuarioActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioActivoInclude<ExtArgs> | null
  }


  /**
   * Model LogAuditoria
   */

  export type AggregateLogAuditoria = {
    _count: LogAuditoriaCountAggregateOutputType | null
    _min: LogAuditoriaMinAggregateOutputType | null
    _max: LogAuditoriaMaxAggregateOutputType | null
  }

  export type LogAuditoriaMinAggregateOutputType = {
    id: string | null
    accion: string | null
    entidad: string | null
    entidadId: string | null
    entidadNombre: string | null
    detalles: string | null
    ip: string | null
    userAgent: string | null
    fecha: Date | null
    usuarioId: string | null
  }

  export type LogAuditoriaMaxAggregateOutputType = {
    id: string | null
    accion: string | null
    entidad: string | null
    entidadId: string | null
    entidadNombre: string | null
    detalles: string | null
    ip: string | null
    userAgent: string | null
    fecha: Date | null
    usuarioId: string | null
  }

  export type LogAuditoriaCountAggregateOutputType = {
    id: number
    accion: number
    entidad: number
    entidadId: number
    entidadNombre: number
    detalles: number
    ip: number
    userAgent: number
    fecha: number
    usuarioId: number
    _all: number
  }


  export type LogAuditoriaMinAggregateInputType = {
    id?: true
    accion?: true
    entidad?: true
    entidadId?: true
    entidadNombre?: true
    detalles?: true
    ip?: true
    userAgent?: true
    fecha?: true
    usuarioId?: true
  }

  export type LogAuditoriaMaxAggregateInputType = {
    id?: true
    accion?: true
    entidad?: true
    entidadId?: true
    entidadNombre?: true
    detalles?: true
    ip?: true
    userAgent?: true
    fecha?: true
    usuarioId?: true
  }

  export type LogAuditoriaCountAggregateInputType = {
    id?: true
    accion?: true
    entidad?: true
    entidadId?: true
    entidadNombre?: true
    detalles?: true
    ip?: true
    userAgent?: true
    fecha?: true
    usuarioId?: true
    _all?: true
  }

  export type LogAuditoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogAuditoria to aggregate.
     */
    where?: LogAuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogAuditorias to fetch.
     */
    orderBy?: LogAuditoriaOrderByWithRelationInput | LogAuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogAuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogAuditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogAuditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogAuditorias
    **/
    _count?: true | LogAuditoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogAuditoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogAuditoriaMaxAggregateInputType
  }

  export type GetLogAuditoriaAggregateType<T extends LogAuditoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateLogAuditoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogAuditoria[P]>
      : GetScalarType<T[P], AggregateLogAuditoria[P]>
  }




  export type LogAuditoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogAuditoriaWhereInput
    orderBy?: LogAuditoriaOrderByWithAggregationInput | LogAuditoriaOrderByWithAggregationInput[]
    by: LogAuditoriaScalarFieldEnum[] | LogAuditoriaScalarFieldEnum
    having?: LogAuditoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogAuditoriaCountAggregateInputType | true
    _min?: LogAuditoriaMinAggregateInputType
    _max?: LogAuditoriaMaxAggregateInputType
  }

  export type LogAuditoriaGroupByOutputType = {
    id: string
    accion: string
    entidad: string
    entidadId: string
    entidadNombre: string
    detalles: string | null
    ip: string | null
    userAgent: string | null
    fecha: Date
    usuarioId: string
    _count: LogAuditoriaCountAggregateOutputType | null
    _min: LogAuditoriaMinAggregateOutputType | null
    _max: LogAuditoriaMaxAggregateOutputType | null
  }

  type GetLogAuditoriaGroupByPayload<T extends LogAuditoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogAuditoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogAuditoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogAuditoriaGroupByOutputType[P]>
            : GetScalarType<T[P], LogAuditoriaGroupByOutputType[P]>
        }
      >
    >


  export type LogAuditoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    entidadNombre?: boolean
    detalles?: boolean
    ip?: boolean
    userAgent?: boolean
    fecha?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logAuditoria"]>

  export type LogAuditoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    entidadNombre?: boolean
    detalles?: boolean
    ip?: boolean
    userAgent?: boolean
    fecha?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logAuditoria"]>

  export type LogAuditoriaSelectScalar = {
    id?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    entidadNombre?: boolean
    detalles?: boolean
    ip?: boolean
    userAgent?: boolean
    fecha?: boolean
    usuarioId?: boolean
  }

  export type LogAuditoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type LogAuditoriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $LogAuditoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogAuditoria"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accion: string
      entidad: string
      entidadId: string
      entidadNombre: string
      detalles: string | null
      ip: string | null
      userAgent: string | null
      fecha: Date
      usuarioId: string
    }, ExtArgs["result"]["logAuditoria"]>
    composites: {}
  }

  type LogAuditoriaGetPayload<S extends boolean | null | undefined | LogAuditoriaDefaultArgs> = $Result.GetResult<Prisma.$LogAuditoriaPayload, S>

  type LogAuditoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogAuditoriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogAuditoriaCountAggregateInputType | true
    }

  export interface LogAuditoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogAuditoria'], meta: { name: 'LogAuditoria' } }
    /**
     * Find zero or one LogAuditoria that matches the filter.
     * @param {LogAuditoriaFindUniqueArgs} args - Arguments to find a LogAuditoria
     * @example
     * // Get one LogAuditoria
     * const logAuditoria = await prisma.logAuditoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogAuditoriaFindUniqueArgs>(args: SelectSubset<T, LogAuditoriaFindUniqueArgs<ExtArgs>>): Prisma__LogAuditoriaClient<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LogAuditoria that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogAuditoriaFindUniqueOrThrowArgs} args - Arguments to find a LogAuditoria
     * @example
     * // Get one LogAuditoria
     * const logAuditoria = await prisma.logAuditoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogAuditoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, LogAuditoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogAuditoriaClient<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LogAuditoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAuditoriaFindFirstArgs} args - Arguments to find a LogAuditoria
     * @example
     * // Get one LogAuditoria
     * const logAuditoria = await prisma.logAuditoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogAuditoriaFindFirstArgs>(args?: SelectSubset<T, LogAuditoriaFindFirstArgs<ExtArgs>>): Prisma__LogAuditoriaClient<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LogAuditoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAuditoriaFindFirstOrThrowArgs} args - Arguments to find a LogAuditoria
     * @example
     * // Get one LogAuditoria
     * const logAuditoria = await prisma.logAuditoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogAuditoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, LogAuditoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogAuditoriaClient<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LogAuditorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAuditoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogAuditorias
     * const logAuditorias = await prisma.logAuditoria.findMany()
     * 
     * // Get first 10 LogAuditorias
     * const logAuditorias = await prisma.logAuditoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logAuditoriaWithIdOnly = await prisma.logAuditoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogAuditoriaFindManyArgs>(args?: SelectSubset<T, LogAuditoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LogAuditoria.
     * @param {LogAuditoriaCreateArgs} args - Arguments to create a LogAuditoria.
     * @example
     * // Create one LogAuditoria
     * const LogAuditoria = await prisma.logAuditoria.create({
     *   data: {
     *     // ... data to create a LogAuditoria
     *   }
     * })
     * 
     */
    create<T extends LogAuditoriaCreateArgs>(args: SelectSubset<T, LogAuditoriaCreateArgs<ExtArgs>>): Prisma__LogAuditoriaClient<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LogAuditorias.
     * @param {LogAuditoriaCreateManyArgs} args - Arguments to create many LogAuditorias.
     * @example
     * // Create many LogAuditorias
     * const logAuditoria = await prisma.logAuditoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogAuditoriaCreateManyArgs>(args?: SelectSubset<T, LogAuditoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LogAuditorias and returns the data saved in the database.
     * @param {LogAuditoriaCreateManyAndReturnArgs} args - Arguments to create many LogAuditorias.
     * @example
     * // Create many LogAuditorias
     * const logAuditoria = await prisma.logAuditoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LogAuditorias and only return the `id`
     * const logAuditoriaWithIdOnly = await prisma.logAuditoria.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogAuditoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, LogAuditoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LogAuditoria.
     * @param {LogAuditoriaDeleteArgs} args - Arguments to delete one LogAuditoria.
     * @example
     * // Delete one LogAuditoria
     * const LogAuditoria = await prisma.logAuditoria.delete({
     *   where: {
     *     // ... filter to delete one LogAuditoria
     *   }
     * })
     * 
     */
    delete<T extends LogAuditoriaDeleteArgs>(args: SelectSubset<T, LogAuditoriaDeleteArgs<ExtArgs>>): Prisma__LogAuditoriaClient<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LogAuditoria.
     * @param {LogAuditoriaUpdateArgs} args - Arguments to update one LogAuditoria.
     * @example
     * // Update one LogAuditoria
     * const logAuditoria = await prisma.logAuditoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogAuditoriaUpdateArgs>(args: SelectSubset<T, LogAuditoriaUpdateArgs<ExtArgs>>): Prisma__LogAuditoriaClient<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LogAuditorias.
     * @param {LogAuditoriaDeleteManyArgs} args - Arguments to filter LogAuditorias to delete.
     * @example
     * // Delete a few LogAuditorias
     * const { count } = await prisma.logAuditoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogAuditoriaDeleteManyArgs>(args?: SelectSubset<T, LogAuditoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogAuditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAuditoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogAuditorias
     * const logAuditoria = await prisma.logAuditoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogAuditoriaUpdateManyArgs>(args: SelectSubset<T, LogAuditoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogAuditoria.
     * @param {LogAuditoriaUpsertArgs} args - Arguments to update or create a LogAuditoria.
     * @example
     * // Update or create a LogAuditoria
     * const logAuditoria = await prisma.logAuditoria.upsert({
     *   create: {
     *     // ... data to create a LogAuditoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogAuditoria we want to update
     *   }
     * })
     */
    upsert<T extends LogAuditoriaUpsertArgs>(args: SelectSubset<T, LogAuditoriaUpsertArgs<ExtArgs>>): Prisma__LogAuditoriaClient<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LogAuditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAuditoriaCountArgs} args - Arguments to filter LogAuditorias to count.
     * @example
     * // Count the number of LogAuditorias
     * const count = await prisma.logAuditoria.count({
     *   where: {
     *     // ... the filter for the LogAuditorias we want to count
     *   }
     * })
    **/
    count<T extends LogAuditoriaCountArgs>(
      args?: Subset<T, LogAuditoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogAuditoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogAuditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAuditoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAuditoriaAggregateArgs>(args: Subset<T, LogAuditoriaAggregateArgs>): Prisma.PrismaPromise<GetLogAuditoriaAggregateType<T>>

    /**
     * Group by LogAuditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAuditoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogAuditoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogAuditoriaGroupByArgs['orderBy'] }
        : { orderBy?: LogAuditoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogAuditoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogAuditoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogAuditoria model
   */
  readonly fields: LogAuditoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogAuditoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogAuditoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LogAuditoria model
   */ 
  interface LogAuditoriaFieldRefs {
    readonly id: FieldRef<"LogAuditoria", 'String'>
    readonly accion: FieldRef<"LogAuditoria", 'String'>
    readonly entidad: FieldRef<"LogAuditoria", 'String'>
    readonly entidadId: FieldRef<"LogAuditoria", 'String'>
    readonly entidadNombre: FieldRef<"LogAuditoria", 'String'>
    readonly detalles: FieldRef<"LogAuditoria", 'String'>
    readonly ip: FieldRef<"LogAuditoria", 'String'>
    readonly userAgent: FieldRef<"LogAuditoria", 'String'>
    readonly fecha: FieldRef<"LogAuditoria", 'DateTime'>
    readonly usuarioId: FieldRef<"LogAuditoria", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LogAuditoria findUnique
   */
  export type LogAuditoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogAuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which LogAuditoria to fetch.
     */
    where: LogAuditoriaWhereUniqueInput
  }

  /**
   * LogAuditoria findUniqueOrThrow
   */
  export type LogAuditoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogAuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which LogAuditoria to fetch.
     */
    where: LogAuditoriaWhereUniqueInput
  }

  /**
   * LogAuditoria findFirst
   */
  export type LogAuditoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogAuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which LogAuditoria to fetch.
     */
    where?: LogAuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogAuditorias to fetch.
     */
    orderBy?: LogAuditoriaOrderByWithRelationInput | LogAuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogAuditorias.
     */
    cursor?: LogAuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogAuditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogAuditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogAuditorias.
     */
    distinct?: LogAuditoriaScalarFieldEnum | LogAuditoriaScalarFieldEnum[]
  }

  /**
   * LogAuditoria findFirstOrThrow
   */
  export type LogAuditoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogAuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which LogAuditoria to fetch.
     */
    where?: LogAuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogAuditorias to fetch.
     */
    orderBy?: LogAuditoriaOrderByWithRelationInput | LogAuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogAuditorias.
     */
    cursor?: LogAuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogAuditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogAuditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogAuditorias.
     */
    distinct?: LogAuditoriaScalarFieldEnum | LogAuditoriaScalarFieldEnum[]
  }

  /**
   * LogAuditoria findMany
   */
  export type LogAuditoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogAuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which LogAuditorias to fetch.
     */
    where?: LogAuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogAuditorias to fetch.
     */
    orderBy?: LogAuditoriaOrderByWithRelationInput | LogAuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogAuditorias.
     */
    cursor?: LogAuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogAuditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogAuditorias.
     */
    skip?: number
    distinct?: LogAuditoriaScalarFieldEnum | LogAuditoriaScalarFieldEnum[]
  }

  /**
   * LogAuditoria create
   */
  export type LogAuditoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogAuditoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a LogAuditoria.
     */
    data: XOR<LogAuditoriaCreateInput, LogAuditoriaUncheckedCreateInput>
  }

  /**
   * LogAuditoria createMany
   */
  export type LogAuditoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogAuditorias.
     */
    data: LogAuditoriaCreateManyInput | LogAuditoriaCreateManyInput[]
  }

  /**
   * LogAuditoria createManyAndReturn
   */
  export type LogAuditoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LogAuditorias.
     */
    data: LogAuditoriaCreateManyInput | LogAuditoriaCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogAuditoriaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LogAuditoria update
   */
  export type LogAuditoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogAuditoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a LogAuditoria.
     */
    data: XOR<LogAuditoriaUpdateInput, LogAuditoriaUncheckedUpdateInput>
    /**
     * Choose, which LogAuditoria to update.
     */
    where: LogAuditoriaWhereUniqueInput
  }

  /**
   * LogAuditoria updateMany
   */
  export type LogAuditoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogAuditorias.
     */
    data: XOR<LogAuditoriaUpdateManyMutationInput, LogAuditoriaUncheckedUpdateManyInput>
    /**
     * Filter which LogAuditorias to update
     */
    where?: LogAuditoriaWhereInput
  }

  /**
   * LogAuditoria upsert
   */
  export type LogAuditoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogAuditoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the LogAuditoria to update in case it exists.
     */
    where: LogAuditoriaWhereUniqueInput
    /**
     * In case the LogAuditoria found by the `where` argument doesn't exist, create a new LogAuditoria with this data.
     */
    create: XOR<LogAuditoriaCreateInput, LogAuditoriaUncheckedCreateInput>
    /**
     * In case the LogAuditoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogAuditoriaUpdateInput, LogAuditoriaUncheckedUpdateInput>
  }

  /**
   * LogAuditoria delete
   */
  export type LogAuditoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogAuditoriaInclude<ExtArgs> | null
    /**
     * Filter which LogAuditoria to delete.
     */
    where: LogAuditoriaWhereUniqueInput
  }

  /**
   * LogAuditoria deleteMany
   */
  export type LogAuditoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogAuditorias to delete
     */
    where?: LogAuditoriaWhereInput
  }

  /**
   * LogAuditoria without action
   */
  export type LogAuditoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogAuditoriaInclude<ExtArgs> | null
  }


  /**
   * Model ActivoAcceso
   */

  export type AggregateActivoAcceso = {
    _count: ActivoAccesoCountAggregateOutputType | null
    _min: ActivoAccesoMinAggregateOutputType | null
    _max: ActivoAccesoMaxAggregateOutputType | null
  }

  export type ActivoAccesoMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    tipo: string | null
    icono: string | null
    nivelAcceso: string | null
    expanded: boolean | null
    padreId: string | null
  }

  export type ActivoAccesoMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    tipo: string | null
    icono: string | null
    nivelAcceso: string | null
    expanded: boolean | null
    padreId: string | null
  }

  export type ActivoAccesoCountAggregateOutputType = {
    id: number
    nombre: number
    tipo: number
    icono: number
    nivelAcceso: number
    expanded: number
    padreId: number
    _all: number
  }


  export type ActivoAccesoMinAggregateInputType = {
    id?: true
    nombre?: true
    tipo?: true
    icono?: true
    nivelAcceso?: true
    expanded?: true
    padreId?: true
  }

  export type ActivoAccesoMaxAggregateInputType = {
    id?: true
    nombre?: true
    tipo?: true
    icono?: true
    nivelAcceso?: true
    expanded?: true
    padreId?: true
  }

  export type ActivoAccesoCountAggregateInputType = {
    id?: true
    nombre?: true
    tipo?: true
    icono?: true
    nivelAcceso?: true
    expanded?: true
    padreId?: true
    _all?: true
  }

  export type ActivoAccesoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivoAcceso to aggregate.
     */
    where?: ActivoAccesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivoAccesos to fetch.
     */
    orderBy?: ActivoAccesoOrderByWithRelationInput | ActivoAccesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivoAccesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivoAccesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivoAccesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivoAccesos
    **/
    _count?: true | ActivoAccesoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivoAccesoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivoAccesoMaxAggregateInputType
  }

  export type GetActivoAccesoAggregateType<T extends ActivoAccesoAggregateArgs> = {
        [P in keyof T & keyof AggregateActivoAcceso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivoAcceso[P]>
      : GetScalarType<T[P], AggregateActivoAcceso[P]>
  }




  export type ActivoAccesoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivoAccesoWhereInput
    orderBy?: ActivoAccesoOrderByWithAggregationInput | ActivoAccesoOrderByWithAggregationInput[]
    by: ActivoAccesoScalarFieldEnum[] | ActivoAccesoScalarFieldEnum
    having?: ActivoAccesoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivoAccesoCountAggregateInputType | true
    _min?: ActivoAccesoMinAggregateInputType
    _max?: ActivoAccesoMaxAggregateInputType
  }

  export type ActivoAccesoGroupByOutputType = {
    id: string
    nombre: string
    tipo: string
    icono: string | null
    nivelAcceso: string | null
    expanded: boolean
    padreId: string | null
    _count: ActivoAccesoCountAggregateOutputType | null
    _min: ActivoAccesoMinAggregateOutputType | null
    _max: ActivoAccesoMaxAggregateOutputType | null
  }

  type GetActivoAccesoGroupByPayload<T extends ActivoAccesoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivoAccesoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivoAccesoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivoAccesoGroupByOutputType[P]>
            : GetScalarType<T[P], ActivoAccesoGroupByOutputType[P]>
        }
      >
    >


  export type ActivoAccesoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    tipo?: boolean
    icono?: boolean
    nivelAcceso?: boolean
    expanded?: boolean
    padreId?: boolean
    padre?: boolean | ActivoAcceso$padreArgs<ExtArgs>
    hijos?: boolean | ActivoAcceso$hijosArgs<ExtArgs>
    usuarios?: boolean | ActivoAcceso$usuariosArgs<ExtArgs>
    _count?: boolean | ActivoAccesoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activoAcceso"]>

  export type ActivoAccesoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    tipo?: boolean
    icono?: boolean
    nivelAcceso?: boolean
    expanded?: boolean
    padreId?: boolean
    padre?: boolean | ActivoAcceso$padreArgs<ExtArgs>
  }, ExtArgs["result"]["activoAcceso"]>

  export type ActivoAccesoSelectScalar = {
    id?: boolean
    nombre?: boolean
    tipo?: boolean
    icono?: boolean
    nivelAcceso?: boolean
    expanded?: boolean
    padreId?: boolean
  }

  export type ActivoAccesoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    padre?: boolean | ActivoAcceso$padreArgs<ExtArgs>
    hijos?: boolean | ActivoAcceso$hijosArgs<ExtArgs>
    usuarios?: boolean | ActivoAcceso$usuariosArgs<ExtArgs>
    _count?: boolean | ActivoAccesoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivoAccesoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    padre?: boolean | ActivoAcceso$padreArgs<ExtArgs>
  }

  export type $ActivoAccesoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivoAcceso"
    objects: {
      padre: Prisma.$ActivoAccesoPayload<ExtArgs> | null
      hijos: Prisma.$ActivoAccesoPayload<ExtArgs>[]
      usuarios: Prisma.$UsuarioActivoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      tipo: string
      icono: string | null
      nivelAcceso: string | null
      expanded: boolean
      padreId: string | null
    }, ExtArgs["result"]["activoAcceso"]>
    composites: {}
  }

  type ActivoAccesoGetPayload<S extends boolean | null | undefined | ActivoAccesoDefaultArgs> = $Result.GetResult<Prisma.$ActivoAccesoPayload, S>

  type ActivoAccesoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivoAccesoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivoAccesoCountAggregateInputType | true
    }

  export interface ActivoAccesoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivoAcceso'], meta: { name: 'ActivoAcceso' } }
    /**
     * Find zero or one ActivoAcceso that matches the filter.
     * @param {ActivoAccesoFindUniqueArgs} args - Arguments to find a ActivoAcceso
     * @example
     * // Get one ActivoAcceso
     * const activoAcceso = await prisma.activoAcceso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivoAccesoFindUniqueArgs>(args: SelectSubset<T, ActivoAccesoFindUniqueArgs<ExtArgs>>): Prisma__ActivoAccesoClient<$Result.GetResult<Prisma.$ActivoAccesoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActivoAcceso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivoAccesoFindUniqueOrThrowArgs} args - Arguments to find a ActivoAcceso
     * @example
     * // Get one ActivoAcceso
     * const activoAcceso = await prisma.activoAcceso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivoAccesoFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivoAccesoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivoAccesoClient<$Result.GetResult<Prisma.$ActivoAccesoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActivoAcceso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivoAccesoFindFirstArgs} args - Arguments to find a ActivoAcceso
     * @example
     * // Get one ActivoAcceso
     * const activoAcceso = await prisma.activoAcceso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivoAccesoFindFirstArgs>(args?: SelectSubset<T, ActivoAccesoFindFirstArgs<ExtArgs>>): Prisma__ActivoAccesoClient<$Result.GetResult<Prisma.$ActivoAccesoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActivoAcceso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivoAccesoFindFirstOrThrowArgs} args - Arguments to find a ActivoAcceso
     * @example
     * // Get one ActivoAcceso
     * const activoAcceso = await prisma.activoAcceso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivoAccesoFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivoAccesoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivoAccesoClient<$Result.GetResult<Prisma.$ActivoAccesoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActivoAccesos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivoAccesoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivoAccesos
     * const activoAccesos = await prisma.activoAcceso.findMany()
     * 
     * // Get first 10 ActivoAccesos
     * const activoAccesos = await prisma.activoAcceso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activoAccesoWithIdOnly = await prisma.activoAcceso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivoAccesoFindManyArgs>(args?: SelectSubset<T, ActivoAccesoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivoAccesoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActivoAcceso.
     * @param {ActivoAccesoCreateArgs} args - Arguments to create a ActivoAcceso.
     * @example
     * // Create one ActivoAcceso
     * const ActivoAcceso = await prisma.activoAcceso.create({
     *   data: {
     *     // ... data to create a ActivoAcceso
     *   }
     * })
     * 
     */
    create<T extends ActivoAccesoCreateArgs>(args: SelectSubset<T, ActivoAccesoCreateArgs<ExtArgs>>): Prisma__ActivoAccesoClient<$Result.GetResult<Prisma.$ActivoAccesoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActivoAccesos.
     * @param {ActivoAccesoCreateManyArgs} args - Arguments to create many ActivoAccesos.
     * @example
     * // Create many ActivoAccesos
     * const activoAcceso = await prisma.activoAcceso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivoAccesoCreateManyArgs>(args?: SelectSubset<T, ActivoAccesoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivoAccesos and returns the data saved in the database.
     * @param {ActivoAccesoCreateManyAndReturnArgs} args - Arguments to create many ActivoAccesos.
     * @example
     * // Create many ActivoAccesos
     * const activoAcceso = await prisma.activoAcceso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivoAccesos and only return the `id`
     * const activoAccesoWithIdOnly = await prisma.activoAcceso.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivoAccesoCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivoAccesoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivoAccesoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActivoAcceso.
     * @param {ActivoAccesoDeleteArgs} args - Arguments to delete one ActivoAcceso.
     * @example
     * // Delete one ActivoAcceso
     * const ActivoAcceso = await prisma.activoAcceso.delete({
     *   where: {
     *     // ... filter to delete one ActivoAcceso
     *   }
     * })
     * 
     */
    delete<T extends ActivoAccesoDeleteArgs>(args: SelectSubset<T, ActivoAccesoDeleteArgs<ExtArgs>>): Prisma__ActivoAccesoClient<$Result.GetResult<Prisma.$ActivoAccesoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActivoAcceso.
     * @param {ActivoAccesoUpdateArgs} args - Arguments to update one ActivoAcceso.
     * @example
     * // Update one ActivoAcceso
     * const activoAcceso = await prisma.activoAcceso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivoAccesoUpdateArgs>(args: SelectSubset<T, ActivoAccesoUpdateArgs<ExtArgs>>): Prisma__ActivoAccesoClient<$Result.GetResult<Prisma.$ActivoAccesoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActivoAccesos.
     * @param {ActivoAccesoDeleteManyArgs} args - Arguments to filter ActivoAccesos to delete.
     * @example
     * // Delete a few ActivoAccesos
     * const { count } = await prisma.activoAcceso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivoAccesoDeleteManyArgs>(args?: SelectSubset<T, ActivoAccesoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivoAccesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivoAccesoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivoAccesos
     * const activoAcceso = await prisma.activoAcceso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivoAccesoUpdateManyArgs>(args: SelectSubset<T, ActivoAccesoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivoAcceso.
     * @param {ActivoAccesoUpsertArgs} args - Arguments to update or create a ActivoAcceso.
     * @example
     * // Update or create a ActivoAcceso
     * const activoAcceso = await prisma.activoAcceso.upsert({
     *   create: {
     *     // ... data to create a ActivoAcceso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivoAcceso we want to update
     *   }
     * })
     */
    upsert<T extends ActivoAccesoUpsertArgs>(args: SelectSubset<T, ActivoAccesoUpsertArgs<ExtArgs>>): Prisma__ActivoAccesoClient<$Result.GetResult<Prisma.$ActivoAccesoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActivoAccesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivoAccesoCountArgs} args - Arguments to filter ActivoAccesos to count.
     * @example
     * // Count the number of ActivoAccesos
     * const count = await prisma.activoAcceso.count({
     *   where: {
     *     // ... the filter for the ActivoAccesos we want to count
     *   }
     * })
    **/
    count<T extends ActivoAccesoCountArgs>(
      args?: Subset<T, ActivoAccesoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivoAccesoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivoAcceso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivoAccesoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivoAccesoAggregateArgs>(args: Subset<T, ActivoAccesoAggregateArgs>): Prisma.PrismaPromise<GetActivoAccesoAggregateType<T>>

    /**
     * Group by ActivoAcceso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivoAccesoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivoAccesoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivoAccesoGroupByArgs['orderBy'] }
        : { orderBy?: ActivoAccesoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivoAccesoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivoAccesoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivoAcceso model
   */
  readonly fields: ActivoAccesoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivoAcceso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivoAccesoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    padre<T extends ActivoAcceso$padreArgs<ExtArgs> = {}>(args?: Subset<T, ActivoAcceso$padreArgs<ExtArgs>>): Prisma__ActivoAccesoClient<$Result.GetResult<Prisma.$ActivoAccesoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    hijos<T extends ActivoAcceso$hijosArgs<ExtArgs> = {}>(args?: Subset<T, ActivoAcceso$hijosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivoAccesoPayload<ExtArgs>, T, "findMany"> | Null>
    usuarios<T extends ActivoAcceso$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, ActivoAcceso$usuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioActivoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivoAcceso model
   */ 
  interface ActivoAccesoFieldRefs {
    readonly id: FieldRef<"ActivoAcceso", 'String'>
    readonly nombre: FieldRef<"ActivoAcceso", 'String'>
    readonly tipo: FieldRef<"ActivoAcceso", 'String'>
    readonly icono: FieldRef<"ActivoAcceso", 'String'>
    readonly nivelAcceso: FieldRef<"ActivoAcceso", 'String'>
    readonly expanded: FieldRef<"ActivoAcceso", 'Boolean'>
    readonly padreId: FieldRef<"ActivoAcceso", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ActivoAcceso findUnique
   */
  export type ActivoAccesoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivoAcceso
     */
    select?: ActivoAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoAccesoInclude<ExtArgs> | null
    /**
     * Filter, which ActivoAcceso to fetch.
     */
    where: ActivoAccesoWhereUniqueInput
  }

  /**
   * ActivoAcceso findUniqueOrThrow
   */
  export type ActivoAccesoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivoAcceso
     */
    select?: ActivoAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoAccesoInclude<ExtArgs> | null
    /**
     * Filter, which ActivoAcceso to fetch.
     */
    where: ActivoAccesoWhereUniqueInput
  }

  /**
   * ActivoAcceso findFirst
   */
  export type ActivoAccesoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivoAcceso
     */
    select?: ActivoAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoAccesoInclude<ExtArgs> | null
    /**
     * Filter, which ActivoAcceso to fetch.
     */
    where?: ActivoAccesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivoAccesos to fetch.
     */
    orderBy?: ActivoAccesoOrderByWithRelationInput | ActivoAccesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivoAccesos.
     */
    cursor?: ActivoAccesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivoAccesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivoAccesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivoAccesos.
     */
    distinct?: ActivoAccesoScalarFieldEnum | ActivoAccesoScalarFieldEnum[]
  }

  /**
   * ActivoAcceso findFirstOrThrow
   */
  export type ActivoAccesoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivoAcceso
     */
    select?: ActivoAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoAccesoInclude<ExtArgs> | null
    /**
     * Filter, which ActivoAcceso to fetch.
     */
    where?: ActivoAccesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivoAccesos to fetch.
     */
    orderBy?: ActivoAccesoOrderByWithRelationInput | ActivoAccesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivoAccesos.
     */
    cursor?: ActivoAccesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivoAccesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivoAccesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivoAccesos.
     */
    distinct?: ActivoAccesoScalarFieldEnum | ActivoAccesoScalarFieldEnum[]
  }

  /**
   * ActivoAcceso findMany
   */
  export type ActivoAccesoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivoAcceso
     */
    select?: ActivoAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoAccesoInclude<ExtArgs> | null
    /**
     * Filter, which ActivoAccesos to fetch.
     */
    where?: ActivoAccesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivoAccesos to fetch.
     */
    orderBy?: ActivoAccesoOrderByWithRelationInput | ActivoAccesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivoAccesos.
     */
    cursor?: ActivoAccesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivoAccesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivoAccesos.
     */
    skip?: number
    distinct?: ActivoAccesoScalarFieldEnum | ActivoAccesoScalarFieldEnum[]
  }

  /**
   * ActivoAcceso create
   */
  export type ActivoAccesoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivoAcceso
     */
    select?: ActivoAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoAccesoInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivoAcceso.
     */
    data: XOR<ActivoAccesoCreateInput, ActivoAccesoUncheckedCreateInput>
  }

  /**
   * ActivoAcceso createMany
   */
  export type ActivoAccesoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivoAccesos.
     */
    data: ActivoAccesoCreateManyInput | ActivoAccesoCreateManyInput[]
  }

  /**
   * ActivoAcceso createManyAndReturn
   */
  export type ActivoAccesoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivoAcceso
     */
    select?: ActivoAccesoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActivoAccesos.
     */
    data: ActivoAccesoCreateManyInput | ActivoAccesoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoAccesoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivoAcceso update
   */
  export type ActivoAccesoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivoAcceso
     */
    select?: ActivoAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoAccesoInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivoAcceso.
     */
    data: XOR<ActivoAccesoUpdateInput, ActivoAccesoUncheckedUpdateInput>
    /**
     * Choose, which ActivoAcceso to update.
     */
    where: ActivoAccesoWhereUniqueInput
  }

  /**
   * ActivoAcceso updateMany
   */
  export type ActivoAccesoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivoAccesos.
     */
    data: XOR<ActivoAccesoUpdateManyMutationInput, ActivoAccesoUncheckedUpdateManyInput>
    /**
     * Filter which ActivoAccesos to update
     */
    where?: ActivoAccesoWhereInput
  }

  /**
   * ActivoAcceso upsert
   */
  export type ActivoAccesoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivoAcceso
     */
    select?: ActivoAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoAccesoInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivoAcceso to update in case it exists.
     */
    where: ActivoAccesoWhereUniqueInput
    /**
     * In case the ActivoAcceso found by the `where` argument doesn't exist, create a new ActivoAcceso with this data.
     */
    create: XOR<ActivoAccesoCreateInput, ActivoAccesoUncheckedCreateInput>
    /**
     * In case the ActivoAcceso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivoAccesoUpdateInput, ActivoAccesoUncheckedUpdateInput>
  }

  /**
   * ActivoAcceso delete
   */
  export type ActivoAccesoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivoAcceso
     */
    select?: ActivoAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoAccesoInclude<ExtArgs> | null
    /**
     * Filter which ActivoAcceso to delete.
     */
    where: ActivoAccesoWhereUniqueInput
  }

  /**
   * ActivoAcceso deleteMany
   */
  export type ActivoAccesoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivoAccesos to delete
     */
    where?: ActivoAccesoWhereInput
  }

  /**
   * ActivoAcceso.padre
   */
  export type ActivoAcceso$padreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivoAcceso
     */
    select?: ActivoAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoAccesoInclude<ExtArgs> | null
    where?: ActivoAccesoWhereInput
  }

  /**
   * ActivoAcceso.hijos
   */
  export type ActivoAcceso$hijosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivoAcceso
     */
    select?: ActivoAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoAccesoInclude<ExtArgs> | null
    where?: ActivoAccesoWhereInput
    orderBy?: ActivoAccesoOrderByWithRelationInput | ActivoAccesoOrderByWithRelationInput[]
    cursor?: ActivoAccesoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivoAccesoScalarFieldEnum | ActivoAccesoScalarFieldEnum[]
  }

  /**
   * ActivoAcceso.usuarios
   */
  export type ActivoAcceso$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioActivo
     */
    select?: UsuarioActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioActivoInclude<ExtArgs> | null
    where?: UsuarioActivoWhereInput
    orderBy?: UsuarioActivoOrderByWithRelationInput | UsuarioActivoOrderByWithRelationInput[]
    cursor?: UsuarioActivoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioActivoScalarFieldEnum | UsuarioActivoScalarFieldEnum[]
  }

  /**
   * ActivoAcceso without action
   */
  export type ActivoAccesoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivoAcceso
     */
    select?: ActivoAccesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoAccesoInclude<ExtArgs> | null
  }


  /**
   * Model PlantillaActivo
   */

  export type AggregatePlantillaActivo = {
    _count: PlantillaActivoCountAggregateOutputType | null
    _min: PlantillaActivoMinAggregateOutputType | null
    _max: PlantillaActivoMaxAggregateOutputType | null
  }

  export type PlantillaActivoMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    tipoActivo: string | null
    descripcion: string | null
    icono: string | null
    color: string | null
    propiedades: string | null
    activo: boolean | null
    fechaCreacion: Date | null
  }

  export type PlantillaActivoMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    tipoActivo: string | null
    descripcion: string | null
    icono: string | null
    color: string | null
    propiedades: string | null
    activo: boolean | null
    fechaCreacion: Date | null
  }

  export type PlantillaActivoCountAggregateOutputType = {
    id: number
    nombre: number
    tipoActivo: number
    descripcion: number
    icono: number
    color: number
    propiedades: number
    activo: number
    fechaCreacion: number
    _all: number
  }


  export type PlantillaActivoMinAggregateInputType = {
    id?: true
    nombre?: true
    tipoActivo?: true
    descripcion?: true
    icono?: true
    color?: true
    propiedades?: true
    activo?: true
    fechaCreacion?: true
  }

  export type PlantillaActivoMaxAggregateInputType = {
    id?: true
    nombre?: true
    tipoActivo?: true
    descripcion?: true
    icono?: true
    color?: true
    propiedades?: true
    activo?: true
    fechaCreacion?: true
  }

  export type PlantillaActivoCountAggregateInputType = {
    id?: true
    nombre?: true
    tipoActivo?: true
    descripcion?: true
    icono?: true
    color?: true
    propiedades?: true
    activo?: true
    fechaCreacion?: true
    _all?: true
  }

  export type PlantillaActivoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantillaActivo to aggregate.
     */
    where?: PlantillaActivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantillaActivos to fetch.
     */
    orderBy?: PlantillaActivoOrderByWithRelationInput | PlantillaActivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlantillaActivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantillaActivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantillaActivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlantillaActivos
    **/
    _count?: true | PlantillaActivoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlantillaActivoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlantillaActivoMaxAggregateInputType
  }

  export type GetPlantillaActivoAggregateType<T extends PlantillaActivoAggregateArgs> = {
        [P in keyof T & keyof AggregatePlantillaActivo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlantillaActivo[P]>
      : GetScalarType<T[P], AggregatePlantillaActivo[P]>
  }




  export type PlantillaActivoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantillaActivoWhereInput
    orderBy?: PlantillaActivoOrderByWithAggregationInput | PlantillaActivoOrderByWithAggregationInput[]
    by: PlantillaActivoScalarFieldEnum[] | PlantillaActivoScalarFieldEnum
    having?: PlantillaActivoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlantillaActivoCountAggregateInputType | true
    _min?: PlantillaActivoMinAggregateInputType
    _max?: PlantillaActivoMaxAggregateInputType
  }

  export type PlantillaActivoGroupByOutputType = {
    id: string
    nombre: string
    tipoActivo: string
    descripcion: string
    icono: string | null
    color: string | null
    propiedades: string
    activo: boolean
    fechaCreacion: Date
    _count: PlantillaActivoCountAggregateOutputType | null
    _min: PlantillaActivoMinAggregateOutputType | null
    _max: PlantillaActivoMaxAggregateOutputType | null
  }

  type GetPlantillaActivoGroupByPayload<T extends PlantillaActivoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlantillaActivoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlantillaActivoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlantillaActivoGroupByOutputType[P]>
            : GetScalarType<T[P], PlantillaActivoGroupByOutputType[P]>
        }
      >
    >


  export type PlantillaActivoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    tipoActivo?: boolean
    descripcion?: boolean
    icono?: boolean
    color?: boolean
    propiedades?: boolean
    activo?: boolean
    fechaCreacion?: boolean
    activos?: boolean | PlantillaActivo$activosArgs<ExtArgs>
    _count?: boolean | PlantillaActivoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantillaActivo"]>

  export type PlantillaActivoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    tipoActivo?: boolean
    descripcion?: boolean
    icono?: boolean
    color?: boolean
    propiedades?: boolean
    activo?: boolean
    fechaCreacion?: boolean
  }, ExtArgs["result"]["plantillaActivo"]>

  export type PlantillaActivoSelectScalar = {
    id?: boolean
    nombre?: boolean
    tipoActivo?: boolean
    descripcion?: boolean
    icono?: boolean
    color?: boolean
    propiedades?: boolean
    activo?: boolean
    fechaCreacion?: boolean
  }

  export type PlantillaActivoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activos?: boolean | PlantillaActivo$activosArgs<ExtArgs>
    _count?: boolean | PlantillaActivoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlantillaActivoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlantillaActivoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlantillaActivo"
    objects: {
      activos: Prisma.$ActivoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      tipoActivo: string
      descripcion: string
      icono: string | null
      color: string | null
      propiedades: string
      activo: boolean
      fechaCreacion: Date
    }, ExtArgs["result"]["plantillaActivo"]>
    composites: {}
  }

  type PlantillaActivoGetPayload<S extends boolean | null | undefined | PlantillaActivoDefaultArgs> = $Result.GetResult<Prisma.$PlantillaActivoPayload, S>

  type PlantillaActivoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlantillaActivoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlantillaActivoCountAggregateInputType | true
    }

  export interface PlantillaActivoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlantillaActivo'], meta: { name: 'PlantillaActivo' } }
    /**
     * Find zero or one PlantillaActivo that matches the filter.
     * @param {PlantillaActivoFindUniqueArgs} args - Arguments to find a PlantillaActivo
     * @example
     * // Get one PlantillaActivo
     * const plantillaActivo = await prisma.plantillaActivo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlantillaActivoFindUniqueArgs>(args: SelectSubset<T, PlantillaActivoFindUniqueArgs<ExtArgs>>): Prisma__PlantillaActivoClient<$Result.GetResult<Prisma.$PlantillaActivoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlantillaActivo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlantillaActivoFindUniqueOrThrowArgs} args - Arguments to find a PlantillaActivo
     * @example
     * // Get one PlantillaActivo
     * const plantillaActivo = await prisma.plantillaActivo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlantillaActivoFindUniqueOrThrowArgs>(args: SelectSubset<T, PlantillaActivoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlantillaActivoClient<$Result.GetResult<Prisma.$PlantillaActivoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlantillaActivo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantillaActivoFindFirstArgs} args - Arguments to find a PlantillaActivo
     * @example
     * // Get one PlantillaActivo
     * const plantillaActivo = await prisma.plantillaActivo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlantillaActivoFindFirstArgs>(args?: SelectSubset<T, PlantillaActivoFindFirstArgs<ExtArgs>>): Prisma__PlantillaActivoClient<$Result.GetResult<Prisma.$PlantillaActivoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlantillaActivo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantillaActivoFindFirstOrThrowArgs} args - Arguments to find a PlantillaActivo
     * @example
     * // Get one PlantillaActivo
     * const plantillaActivo = await prisma.plantillaActivo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlantillaActivoFindFirstOrThrowArgs>(args?: SelectSubset<T, PlantillaActivoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlantillaActivoClient<$Result.GetResult<Prisma.$PlantillaActivoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlantillaActivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantillaActivoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlantillaActivos
     * const plantillaActivos = await prisma.plantillaActivo.findMany()
     * 
     * // Get first 10 PlantillaActivos
     * const plantillaActivos = await prisma.plantillaActivo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plantillaActivoWithIdOnly = await prisma.plantillaActivo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlantillaActivoFindManyArgs>(args?: SelectSubset<T, PlantillaActivoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantillaActivoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlantillaActivo.
     * @param {PlantillaActivoCreateArgs} args - Arguments to create a PlantillaActivo.
     * @example
     * // Create one PlantillaActivo
     * const PlantillaActivo = await prisma.plantillaActivo.create({
     *   data: {
     *     // ... data to create a PlantillaActivo
     *   }
     * })
     * 
     */
    create<T extends PlantillaActivoCreateArgs>(args: SelectSubset<T, PlantillaActivoCreateArgs<ExtArgs>>): Prisma__PlantillaActivoClient<$Result.GetResult<Prisma.$PlantillaActivoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlantillaActivos.
     * @param {PlantillaActivoCreateManyArgs} args - Arguments to create many PlantillaActivos.
     * @example
     * // Create many PlantillaActivos
     * const plantillaActivo = await prisma.plantillaActivo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlantillaActivoCreateManyArgs>(args?: SelectSubset<T, PlantillaActivoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlantillaActivos and returns the data saved in the database.
     * @param {PlantillaActivoCreateManyAndReturnArgs} args - Arguments to create many PlantillaActivos.
     * @example
     * // Create many PlantillaActivos
     * const plantillaActivo = await prisma.plantillaActivo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlantillaActivos and only return the `id`
     * const plantillaActivoWithIdOnly = await prisma.plantillaActivo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlantillaActivoCreateManyAndReturnArgs>(args?: SelectSubset<T, PlantillaActivoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantillaActivoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlantillaActivo.
     * @param {PlantillaActivoDeleteArgs} args - Arguments to delete one PlantillaActivo.
     * @example
     * // Delete one PlantillaActivo
     * const PlantillaActivo = await prisma.plantillaActivo.delete({
     *   where: {
     *     // ... filter to delete one PlantillaActivo
     *   }
     * })
     * 
     */
    delete<T extends PlantillaActivoDeleteArgs>(args: SelectSubset<T, PlantillaActivoDeleteArgs<ExtArgs>>): Prisma__PlantillaActivoClient<$Result.GetResult<Prisma.$PlantillaActivoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlantillaActivo.
     * @param {PlantillaActivoUpdateArgs} args - Arguments to update one PlantillaActivo.
     * @example
     * // Update one PlantillaActivo
     * const plantillaActivo = await prisma.plantillaActivo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlantillaActivoUpdateArgs>(args: SelectSubset<T, PlantillaActivoUpdateArgs<ExtArgs>>): Prisma__PlantillaActivoClient<$Result.GetResult<Prisma.$PlantillaActivoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlantillaActivos.
     * @param {PlantillaActivoDeleteManyArgs} args - Arguments to filter PlantillaActivos to delete.
     * @example
     * // Delete a few PlantillaActivos
     * const { count } = await prisma.plantillaActivo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlantillaActivoDeleteManyArgs>(args?: SelectSubset<T, PlantillaActivoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantillaActivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantillaActivoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlantillaActivos
     * const plantillaActivo = await prisma.plantillaActivo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlantillaActivoUpdateManyArgs>(args: SelectSubset<T, PlantillaActivoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlantillaActivo.
     * @param {PlantillaActivoUpsertArgs} args - Arguments to update or create a PlantillaActivo.
     * @example
     * // Update or create a PlantillaActivo
     * const plantillaActivo = await prisma.plantillaActivo.upsert({
     *   create: {
     *     // ... data to create a PlantillaActivo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlantillaActivo we want to update
     *   }
     * })
     */
    upsert<T extends PlantillaActivoUpsertArgs>(args: SelectSubset<T, PlantillaActivoUpsertArgs<ExtArgs>>): Prisma__PlantillaActivoClient<$Result.GetResult<Prisma.$PlantillaActivoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlantillaActivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantillaActivoCountArgs} args - Arguments to filter PlantillaActivos to count.
     * @example
     * // Count the number of PlantillaActivos
     * const count = await prisma.plantillaActivo.count({
     *   where: {
     *     // ... the filter for the PlantillaActivos we want to count
     *   }
     * })
    **/
    count<T extends PlantillaActivoCountArgs>(
      args?: Subset<T, PlantillaActivoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlantillaActivoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlantillaActivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantillaActivoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlantillaActivoAggregateArgs>(args: Subset<T, PlantillaActivoAggregateArgs>): Prisma.PrismaPromise<GetPlantillaActivoAggregateType<T>>

    /**
     * Group by PlantillaActivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantillaActivoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlantillaActivoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlantillaActivoGroupByArgs['orderBy'] }
        : { orderBy?: PlantillaActivoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlantillaActivoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlantillaActivoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlantillaActivo model
   */
  readonly fields: PlantillaActivoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlantillaActivo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlantillaActivoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activos<T extends PlantillaActivo$activosArgs<ExtArgs> = {}>(args?: Subset<T, PlantillaActivo$activosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlantillaActivo model
   */ 
  interface PlantillaActivoFieldRefs {
    readonly id: FieldRef<"PlantillaActivo", 'String'>
    readonly nombre: FieldRef<"PlantillaActivo", 'String'>
    readonly tipoActivo: FieldRef<"PlantillaActivo", 'String'>
    readonly descripcion: FieldRef<"PlantillaActivo", 'String'>
    readonly icono: FieldRef<"PlantillaActivo", 'String'>
    readonly color: FieldRef<"PlantillaActivo", 'String'>
    readonly propiedades: FieldRef<"PlantillaActivo", 'String'>
    readonly activo: FieldRef<"PlantillaActivo", 'Boolean'>
    readonly fechaCreacion: FieldRef<"PlantillaActivo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlantillaActivo findUnique
   */
  export type PlantillaActivoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaActivo
     */
    select?: PlantillaActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantillaActivoInclude<ExtArgs> | null
    /**
     * Filter, which PlantillaActivo to fetch.
     */
    where: PlantillaActivoWhereUniqueInput
  }

  /**
   * PlantillaActivo findUniqueOrThrow
   */
  export type PlantillaActivoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaActivo
     */
    select?: PlantillaActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantillaActivoInclude<ExtArgs> | null
    /**
     * Filter, which PlantillaActivo to fetch.
     */
    where: PlantillaActivoWhereUniqueInput
  }

  /**
   * PlantillaActivo findFirst
   */
  export type PlantillaActivoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaActivo
     */
    select?: PlantillaActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantillaActivoInclude<ExtArgs> | null
    /**
     * Filter, which PlantillaActivo to fetch.
     */
    where?: PlantillaActivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantillaActivos to fetch.
     */
    orderBy?: PlantillaActivoOrderByWithRelationInput | PlantillaActivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantillaActivos.
     */
    cursor?: PlantillaActivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantillaActivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantillaActivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantillaActivos.
     */
    distinct?: PlantillaActivoScalarFieldEnum | PlantillaActivoScalarFieldEnum[]
  }

  /**
   * PlantillaActivo findFirstOrThrow
   */
  export type PlantillaActivoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaActivo
     */
    select?: PlantillaActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantillaActivoInclude<ExtArgs> | null
    /**
     * Filter, which PlantillaActivo to fetch.
     */
    where?: PlantillaActivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantillaActivos to fetch.
     */
    orderBy?: PlantillaActivoOrderByWithRelationInput | PlantillaActivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantillaActivos.
     */
    cursor?: PlantillaActivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantillaActivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantillaActivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantillaActivos.
     */
    distinct?: PlantillaActivoScalarFieldEnum | PlantillaActivoScalarFieldEnum[]
  }

  /**
   * PlantillaActivo findMany
   */
  export type PlantillaActivoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaActivo
     */
    select?: PlantillaActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantillaActivoInclude<ExtArgs> | null
    /**
     * Filter, which PlantillaActivos to fetch.
     */
    where?: PlantillaActivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantillaActivos to fetch.
     */
    orderBy?: PlantillaActivoOrderByWithRelationInput | PlantillaActivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlantillaActivos.
     */
    cursor?: PlantillaActivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantillaActivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantillaActivos.
     */
    skip?: number
    distinct?: PlantillaActivoScalarFieldEnum | PlantillaActivoScalarFieldEnum[]
  }

  /**
   * PlantillaActivo create
   */
  export type PlantillaActivoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaActivo
     */
    select?: PlantillaActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantillaActivoInclude<ExtArgs> | null
    /**
     * The data needed to create a PlantillaActivo.
     */
    data: XOR<PlantillaActivoCreateInput, PlantillaActivoUncheckedCreateInput>
  }

  /**
   * PlantillaActivo createMany
   */
  export type PlantillaActivoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlantillaActivos.
     */
    data: PlantillaActivoCreateManyInput | PlantillaActivoCreateManyInput[]
  }

  /**
   * PlantillaActivo createManyAndReturn
   */
  export type PlantillaActivoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaActivo
     */
    select?: PlantillaActivoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlantillaActivos.
     */
    data: PlantillaActivoCreateManyInput | PlantillaActivoCreateManyInput[]
  }

  /**
   * PlantillaActivo update
   */
  export type PlantillaActivoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaActivo
     */
    select?: PlantillaActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantillaActivoInclude<ExtArgs> | null
    /**
     * The data needed to update a PlantillaActivo.
     */
    data: XOR<PlantillaActivoUpdateInput, PlantillaActivoUncheckedUpdateInput>
    /**
     * Choose, which PlantillaActivo to update.
     */
    where: PlantillaActivoWhereUniqueInput
  }

  /**
   * PlantillaActivo updateMany
   */
  export type PlantillaActivoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlantillaActivos.
     */
    data: XOR<PlantillaActivoUpdateManyMutationInput, PlantillaActivoUncheckedUpdateManyInput>
    /**
     * Filter which PlantillaActivos to update
     */
    where?: PlantillaActivoWhereInput
  }

  /**
   * PlantillaActivo upsert
   */
  export type PlantillaActivoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaActivo
     */
    select?: PlantillaActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantillaActivoInclude<ExtArgs> | null
    /**
     * The filter to search for the PlantillaActivo to update in case it exists.
     */
    where: PlantillaActivoWhereUniqueInput
    /**
     * In case the PlantillaActivo found by the `where` argument doesn't exist, create a new PlantillaActivo with this data.
     */
    create: XOR<PlantillaActivoCreateInput, PlantillaActivoUncheckedCreateInput>
    /**
     * In case the PlantillaActivo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlantillaActivoUpdateInput, PlantillaActivoUncheckedUpdateInput>
  }

  /**
   * PlantillaActivo delete
   */
  export type PlantillaActivoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaActivo
     */
    select?: PlantillaActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantillaActivoInclude<ExtArgs> | null
    /**
     * Filter which PlantillaActivo to delete.
     */
    where: PlantillaActivoWhereUniqueInput
  }

  /**
   * PlantillaActivo deleteMany
   */
  export type PlantillaActivoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantillaActivos to delete
     */
    where?: PlantillaActivoWhereInput
  }

  /**
   * PlantillaActivo.activos
   */
  export type PlantillaActivo$activosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activo
     */
    select?: ActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoInclude<ExtArgs> | null
    where?: ActivoWhereInput
    orderBy?: ActivoOrderByWithRelationInput | ActivoOrderByWithRelationInput[]
    cursor?: ActivoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivoScalarFieldEnum | ActivoScalarFieldEnum[]
  }

  /**
   * PlantillaActivo without action
   */
  export type PlantillaActivoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaActivo
     */
    select?: PlantillaActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantillaActivoInclude<ExtArgs> | null
  }


  /**
   * Model Activo
   */

  export type AggregateActivo = {
    _count: ActivoCountAggregateOutputType | null
    _min: ActivoMinAggregateOutputType | null
    _max: ActivoMaxAggregateOutputType | null
  }

  export type ActivoMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    tipo: string | null
    criticidad: string | null
    responsable: string | null
    departamento: string | null
    fechaRegistro: Date | null
    updatedAt: Date | null
    plantillaId: string | null
    propiedadesCustom: string | null
  }

  export type ActivoMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    tipo: string | null
    criticidad: string | null
    responsable: string | null
    departamento: string | null
    fechaRegistro: Date | null
    updatedAt: Date | null
    plantillaId: string | null
    propiedadesCustom: string | null
  }

  export type ActivoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    tipo: number
    criticidad: number
    responsable: number
    departamento: number
    fechaRegistro: number
    updatedAt: number
    plantillaId: number
    propiedadesCustom: number
    _all: number
  }


  export type ActivoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    tipo?: true
    criticidad?: true
    responsable?: true
    departamento?: true
    fechaRegistro?: true
    updatedAt?: true
    plantillaId?: true
    propiedadesCustom?: true
  }

  export type ActivoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    tipo?: true
    criticidad?: true
    responsable?: true
    departamento?: true
    fechaRegistro?: true
    updatedAt?: true
    plantillaId?: true
    propiedadesCustom?: true
  }

  export type ActivoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    tipo?: true
    criticidad?: true
    responsable?: true
    departamento?: true
    fechaRegistro?: true
    updatedAt?: true
    plantillaId?: true
    propiedadesCustom?: true
    _all?: true
  }

  export type ActivoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activo to aggregate.
     */
    where?: ActivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activos to fetch.
     */
    orderBy?: ActivoOrderByWithRelationInput | ActivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activos
    **/
    _count?: true | ActivoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivoMaxAggregateInputType
  }

  export type GetActivoAggregateType<T extends ActivoAggregateArgs> = {
        [P in keyof T & keyof AggregateActivo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivo[P]>
      : GetScalarType<T[P], AggregateActivo[P]>
  }




  export type ActivoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivoWhereInput
    orderBy?: ActivoOrderByWithAggregationInput | ActivoOrderByWithAggregationInput[]
    by: ActivoScalarFieldEnum[] | ActivoScalarFieldEnum
    having?: ActivoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivoCountAggregateInputType | true
    _min?: ActivoMinAggregateInputType
    _max?: ActivoMaxAggregateInputType
  }

  export type ActivoGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string
    tipo: string
    criticidad: string
    responsable: string
    departamento: string
    fechaRegistro: Date
    updatedAt: Date
    plantillaId: string | null
    propiedadesCustom: string | null
    _count: ActivoCountAggregateOutputType | null
    _min: ActivoMinAggregateOutputType | null
    _max: ActivoMaxAggregateOutputType | null
  }

  type GetActivoGroupByPayload<T extends ActivoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivoGroupByOutputType[P]>
            : GetScalarType<T[P], ActivoGroupByOutputType[P]>
        }
      >
    >


  export type ActivoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    tipo?: boolean
    criticidad?: boolean
    responsable?: boolean
    departamento?: boolean
    fechaRegistro?: boolean
    updatedAt?: boolean
    plantillaId?: boolean
    propiedadesCustom?: boolean
    plantilla?: boolean | Activo$plantillaArgs<ExtArgs>
    riesgos?: boolean | Activo$riesgosArgs<ExtArgs>
    incidentes?: boolean | Activo$incidentesArgs<ExtArgs>
    defectos?: boolean | Activo$defectosArgs<ExtArgs>
    _count?: boolean | ActivoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activo"]>

  export type ActivoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    tipo?: boolean
    criticidad?: boolean
    responsable?: boolean
    departamento?: boolean
    fechaRegistro?: boolean
    updatedAt?: boolean
    plantillaId?: boolean
    propiedadesCustom?: boolean
    plantilla?: boolean | Activo$plantillaArgs<ExtArgs>
  }, ExtArgs["result"]["activo"]>

  export type ActivoSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    tipo?: boolean
    criticidad?: boolean
    responsable?: boolean
    departamento?: boolean
    fechaRegistro?: boolean
    updatedAt?: boolean
    plantillaId?: boolean
    propiedadesCustom?: boolean
  }

  export type ActivoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plantilla?: boolean | Activo$plantillaArgs<ExtArgs>
    riesgos?: boolean | Activo$riesgosArgs<ExtArgs>
    incidentes?: boolean | Activo$incidentesArgs<ExtArgs>
    defectos?: boolean | Activo$defectosArgs<ExtArgs>
    _count?: boolean | ActivoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plantilla?: boolean | Activo$plantillaArgs<ExtArgs>
  }

  export type $ActivoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activo"
    objects: {
      plantilla: Prisma.$PlantillaActivoPayload<ExtArgs> | null
      riesgos: Prisma.$RiesgoPayload<ExtArgs>[]
      incidentes: Prisma.$IncidentePayload<ExtArgs>[]
      defectos: Prisma.$DefectoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      descripcion: string
      tipo: string
      criticidad: string
      responsable: string
      departamento: string
      fechaRegistro: Date
      updatedAt: Date
      plantillaId: string | null
      propiedadesCustom: string | null
    }, ExtArgs["result"]["activo"]>
    composites: {}
  }

  type ActivoGetPayload<S extends boolean | null | undefined | ActivoDefaultArgs> = $Result.GetResult<Prisma.$ActivoPayload, S>

  type ActivoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivoCountAggregateInputType | true
    }

  export interface ActivoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activo'], meta: { name: 'Activo' } }
    /**
     * Find zero or one Activo that matches the filter.
     * @param {ActivoFindUniqueArgs} args - Arguments to find a Activo
     * @example
     * // Get one Activo
     * const activo = await prisma.activo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivoFindUniqueArgs>(args: SelectSubset<T, ActivoFindUniqueArgs<ExtArgs>>): Prisma__ActivoClient<$Result.GetResult<Prisma.$ActivoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Activo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivoFindUniqueOrThrowArgs} args - Arguments to find a Activo
     * @example
     * // Get one Activo
     * const activo = await prisma.activo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivoFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivoClient<$Result.GetResult<Prisma.$ActivoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Activo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivoFindFirstArgs} args - Arguments to find a Activo
     * @example
     * // Get one Activo
     * const activo = await prisma.activo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivoFindFirstArgs>(args?: SelectSubset<T, ActivoFindFirstArgs<ExtArgs>>): Prisma__ActivoClient<$Result.GetResult<Prisma.$ActivoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Activo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivoFindFirstOrThrowArgs} args - Arguments to find a Activo
     * @example
     * // Get one Activo
     * const activo = await prisma.activo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivoFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivoClient<$Result.GetResult<Prisma.$ActivoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Activos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activos
     * const activos = await prisma.activo.findMany()
     * 
     * // Get first 10 Activos
     * const activos = await prisma.activo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activoWithIdOnly = await prisma.activo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivoFindManyArgs>(args?: SelectSubset<T, ActivoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Activo.
     * @param {ActivoCreateArgs} args - Arguments to create a Activo.
     * @example
     * // Create one Activo
     * const Activo = await prisma.activo.create({
     *   data: {
     *     // ... data to create a Activo
     *   }
     * })
     * 
     */
    create<T extends ActivoCreateArgs>(args: SelectSubset<T, ActivoCreateArgs<ExtArgs>>): Prisma__ActivoClient<$Result.GetResult<Prisma.$ActivoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Activos.
     * @param {ActivoCreateManyArgs} args - Arguments to create many Activos.
     * @example
     * // Create many Activos
     * const activo = await prisma.activo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivoCreateManyArgs>(args?: SelectSubset<T, ActivoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activos and returns the data saved in the database.
     * @param {ActivoCreateManyAndReturnArgs} args - Arguments to create many Activos.
     * @example
     * // Create many Activos
     * const activo = await prisma.activo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activos and only return the `id`
     * const activoWithIdOnly = await prisma.activo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivoCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Activo.
     * @param {ActivoDeleteArgs} args - Arguments to delete one Activo.
     * @example
     * // Delete one Activo
     * const Activo = await prisma.activo.delete({
     *   where: {
     *     // ... filter to delete one Activo
     *   }
     * })
     * 
     */
    delete<T extends ActivoDeleteArgs>(args: SelectSubset<T, ActivoDeleteArgs<ExtArgs>>): Prisma__ActivoClient<$Result.GetResult<Prisma.$ActivoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Activo.
     * @param {ActivoUpdateArgs} args - Arguments to update one Activo.
     * @example
     * // Update one Activo
     * const activo = await prisma.activo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivoUpdateArgs>(args: SelectSubset<T, ActivoUpdateArgs<ExtArgs>>): Prisma__ActivoClient<$Result.GetResult<Prisma.$ActivoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Activos.
     * @param {ActivoDeleteManyArgs} args - Arguments to filter Activos to delete.
     * @example
     * // Delete a few Activos
     * const { count } = await prisma.activo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivoDeleteManyArgs>(args?: SelectSubset<T, ActivoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activos
     * const activo = await prisma.activo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivoUpdateManyArgs>(args: SelectSubset<T, ActivoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activo.
     * @param {ActivoUpsertArgs} args - Arguments to update or create a Activo.
     * @example
     * // Update or create a Activo
     * const activo = await prisma.activo.upsert({
     *   create: {
     *     // ... data to create a Activo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activo we want to update
     *   }
     * })
     */
    upsert<T extends ActivoUpsertArgs>(args: SelectSubset<T, ActivoUpsertArgs<ExtArgs>>): Prisma__ActivoClient<$Result.GetResult<Prisma.$ActivoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Activos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivoCountArgs} args - Arguments to filter Activos to count.
     * @example
     * // Count the number of Activos
     * const count = await prisma.activo.count({
     *   where: {
     *     // ... the filter for the Activos we want to count
     *   }
     * })
    **/
    count<T extends ActivoCountArgs>(
      args?: Subset<T, ActivoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivoAggregateArgs>(args: Subset<T, ActivoAggregateArgs>): Prisma.PrismaPromise<GetActivoAggregateType<T>>

    /**
     * Group by Activo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivoGroupByArgs['orderBy'] }
        : { orderBy?: ActivoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activo model
   */
  readonly fields: ActivoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plantilla<T extends Activo$plantillaArgs<ExtArgs> = {}>(args?: Subset<T, Activo$plantillaArgs<ExtArgs>>): Prisma__PlantillaActivoClient<$Result.GetResult<Prisma.$PlantillaActivoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    riesgos<T extends Activo$riesgosArgs<ExtArgs> = {}>(args?: Subset<T, Activo$riesgosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiesgoPayload<ExtArgs>, T, "findMany"> | Null>
    incidentes<T extends Activo$incidentesArgs<ExtArgs> = {}>(args?: Subset<T, Activo$incidentesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentePayload<ExtArgs>, T, "findMany"> | Null>
    defectos<T extends Activo$defectosArgs<ExtArgs> = {}>(args?: Subset<T, Activo$defectosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activo model
   */ 
  interface ActivoFieldRefs {
    readonly id: FieldRef<"Activo", 'String'>
    readonly nombre: FieldRef<"Activo", 'String'>
    readonly descripcion: FieldRef<"Activo", 'String'>
    readonly tipo: FieldRef<"Activo", 'String'>
    readonly criticidad: FieldRef<"Activo", 'String'>
    readonly responsable: FieldRef<"Activo", 'String'>
    readonly departamento: FieldRef<"Activo", 'String'>
    readonly fechaRegistro: FieldRef<"Activo", 'DateTime'>
    readonly updatedAt: FieldRef<"Activo", 'DateTime'>
    readonly plantillaId: FieldRef<"Activo", 'String'>
    readonly propiedadesCustom: FieldRef<"Activo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Activo findUnique
   */
  export type ActivoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activo
     */
    select?: ActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoInclude<ExtArgs> | null
    /**
     * Filter, which Activo to fetch.
     */
    where: ActivoWhereUniqueInput
  }

  /**
   * Activo findUniqueOrThrow
   */
  export type ActivoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activo
     */
    select?: ActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoInclude<ExtArgs> | null
    /**
     * Filter, which Activo to fetch.
     */
    where: ActivoWhereUniqueInput
  }

  /**
   * Activo findFirst
   */
  export type ActivoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activo
     */
    select?: ActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoInclude<ExtArgs> | null
    /**
     * Filter, which Activo to fetch.
     */
    where?: ActivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activos to fetch.
     */
    orderBy?: ActivoOrderByWithRelationInput | ActivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activos.
     */
    cursor?: ActivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activos.
     */
    distinct?: ActivoScalarFieldEnum | ActivoScalarFieldEnum[]
  }

  /**
   * Activo findFirstOrThrow
   */
  export type ActivoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activo
     */
    select?: ActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoInclude<ExtArgs> | null
    /**
     * Filter, which Activo to fetch.
     */
    where?: ActivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activos to fetch.
     */
    orderBy?: ActivoOrderByWithRelationInput | ActivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activos.
     */
    cursor?: ActivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activos.
     */
    distinct?: ActivoScalarFieldEnum | ActivoScalarFieldEnum[]
  }

  /**
   * Activo findMany
   */
  export type ActivoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activo
     */
    select?: ActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoInclude<ExtArgs> | null
    /**
     * Filter, which Activos to fetch.
     */
    where?: ActivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activos to fetch.
     */
    orderBy?: ActivoOrderByWithRelationInput | ActivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activos.
     */
    cursor?: ActivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activos.
     */
    skip?: number
    distinct?: ActivoScalarFieldEnum | ActivoScalarFieldEnum[]
  }

  /**
   * Activo create
   */
  export type ActivoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activo
     */
    select?: ActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoInclude<ExtArgs> | null
    /**
     * The data needed to create a Activo.
     */
    data: XOR<ActivoCreateInput, ActivoUncheckedCreateInput>
  }

  /**
   * Activo createMany
   */
  export type ActivoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activos.
     */
    data: ActivoCreateManyInput | ActivoCreateManyInput[]
  }

  /**
   * Activo createManyAndReturn
   */
  export type ActivoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activo
     */
    select?: ActivoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Activos.
     */
    data: ActivoCreateManyInput | ActivoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activo update
   */
  export type ActivoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activo
     */
    select?: ActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoInclude<ExtArgs> | null
    /**
     * The data needed to update a Activo.
     */
    data: XOR<ActivoUpdateInput, ActivoUncheckedUpdateInput>
    /**
     * Choose, which Activo to update.
     */
    where: ActivoWhereUniqueInput
  }

  /**
   * Activo updateMany
   */
  export type ActivoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activos.
     */
    data: XOR<ActivoUpdateManyMutationInput, ActivoUncheckedUpdateManyInput>
    /**
     * Filter which Activos to update
     */
    where?: ActivoWhereInput
  }

  /**
   * Activo upsert
   */
  export type ActivoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activo
     */
    select?: ActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoInclude<ExtArgs> | null
    /**
     * The filter to search for the Activo to update in case it exists.
     */
    where: ActivoWhereUniqueInput
    /**
     * In case the Activo found by the `where` argument doesn't exist, create a new Activo with this data.
     */
    create: XOR<ActivoCreateInput, ActivoUncheckedCreateInput>
    /**
     * In case the Activo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivoUpdateInput, ActivoUncheckedUpdateInput>
  }

  /**
   * Activo delete
   */
  export type ActivoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activo
     */
    select?: ActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoInclude<ExtArgs> | null
    /**
     * Filter which Activo to delete.
     */
    where: ActivoWhereUniqueInput
  }

  /**
   * Activo deleteMany
   */
  export type ActivoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activos to delete
     */
    where?: ActivoWhereInput
  }

  /**
   * Activo.plantilla
   */
  export type Activo$plantillaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaActivo
     */
    select?: PlantillaActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantillaActivoInclude<ExtArgs> | null
    where?: PlantillaActivoWhereInput
  }

  /**
   * Activo.riesgos
   */
  export type Activo$riesgosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riesgo
     */
    select?: RiesgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiesgoInclude<ExtArgs> | null
    where?: RiesgoWhereInput
    orderBy?: RiesgoOrderByWithRelationInput | RiesgoOrderByWithRelationInput[]
    cursor?: RiesgoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RiesgoScalarFieldEnum | RiesgoScalarFieldEnum[]
  }

  /**
   * Activo.incidentes
   */
  export type Activo$incidentesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incidente
     */
    select?: IncidenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidenteInclude<ExtArgs> | null
    where?: IncidenteWhereInput
    orderBy?: IncidenteOrderByWithRelationInput | IncidenteOrderByWithRelationInput[]
    cursor?: IncidenteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidenteScalarFieldEnum | IncidenteScalarFieldEnum[]
  }

  /**
   * Activo.defectos
   */
  export type Activo$defectosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defecto
     */
    select?: DefectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectoInclude<ExtArgs> | null
    where?: DefectoWhereInput
    orderBy?: DefectoOrderByWithRelationInput | DefectoOrderByWithRelationInput[]
    cursor?: DefectoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefectoScalarFieldEnum | DefectoScalarFieldEnum[]
  }

  /**
   * Activo without action
   */
  export type ActivoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activo
     */
    select?: ActivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivoInclude<ExtArgs> | null
  }


  /**
   * Model Riesgo
   */

  export type AggregateRiesgo = {
    _count: RiesgoCountAggregateOutputType | null
    _avg: RiesgoAvgAggregateOutputType | null
    _sum: RiesgoSumAggregateOutputType | null
    _min: RiesgoMinAggregateOutputType | null
    _max: RiesgoMaxAggregateOutputType | null
  }

  export type RiesgoAvgAggregateOutputType = {
    probabilidad: number | null
    impacto: number | null
  }

  export type RiesgoSumAggregateOutputType = {
    probabilidad: number | null
    impacto: number | null
  }

  export type RiesgoMinAggregateOutputType = {
    id: string | null
    activoId: string | null
    descripcion: string | null
    probabilidad: number | null
    impacto: number | null
    estado: string | null
    fechaIdentificacion: Date | null
    responsable: string | null
    updatedAt: Date | null
  }

  export type RiesgoMaxAggregateOutputType = {
    id: string | null
    activoId: string | null
    descripcion: string | null
    probabilidad: number | null
    impacto: number | null
    estado: string | null
    fechaIdentificacion: Date | null
    responsable: string | null
    updatedAt: Date | null
  }

  export type RiesgoCountAggregateOutputType = {
    id: number
    activoId: number
    descripcion: number
    probabilidad: number
    impacto: number
    estado: number
    fechaIdentificacion: number
    responsable: number
    updatedAt: number
    _all: number
  }


  export type RiesgoAvgAggregateInputType = {
    probabilidad?: true
    impacto?: true
  }

  export type RiesgoSumAggregateInputType = {
    probabilidad?: true
    impacto?: true
  }

  export type RiesgoMinAggregateInputType = {
    id?: true
    activoId?: true
    descripcion?: true
    probabilidad?: true
    impacto?: true
    estado?: true
    fechaIdentificacion?: true
    responsable?: true
    updatedAt?: true
  }

  export type RiesgoMaxAggregateInputType = {
    id?: true
    activoId?: true
    descripcion?: true
    probabilidad?: true
    impacto?: true
    estado?: true
    fechaIdentificacion?: true
    responsable?: true
    updatedAt?: true
  }

  export type RiesgoCountAggregateInputType = {
    id?: true
    activoId?: true
    descripcion?: true
    probabilidad?: true
    impacto?: true
    estado?: true
    fechaIdentificacion?: true
    responsable?: true
    updatedAt?: true
    _all?: true
  }

  export type RiesgoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Riesgo to aggregate.
     */
    where?: RiesgoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Riesgos to fetch.
     */
    orderBy?: RiesgoOrderByWithRelationInput | RiesgoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiesgoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Riesgos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Riesgos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Riesgos
    **/
    _count?: true | RiesgoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RiesgoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RiesgoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiesgoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiesgoMaxAggregateInputType
  }

  export type GetRiesgoAggregateType<T extends RiesgoAggregateArgs> = {
        [P in keyof T & keyof AggregateRiesgo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiesgo[P]>
      : GetScalarType<T[P], AggregateRiesgo[P]>
  }




  export type RiesgoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiesgoWhereInput
    orderBy?: RiesgoOrderByWithAggregationInput | RiesgoOrderByWithAggregationInput[]
    by: RiesgoScalarFieldEnum[] | RiesgoScalarFieldEnum
    having?: RiesgoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiesgoCountAggregateInputType | true
    _avg?: RiesgoAvgAggregateInputType
    _sum?: RiesgoSumAggregateInputType
    _min?: RiesgoMinAggregateInputType
    _max?: RiesgoMaxAggregateInputType
  }

  export type RiesgoGroupByOutputType = {
    id: string
    activoId: string
    descripcion: string
    probabilidad: number
    impacto: number
    estado: string
    fechaIdentificacion: Date
    responsable: string
    updatedAt: Date
    _count: RiesgoCountAggregateOutputType | null
    _avg: RiesgoAvgAggregateOutputType | null
    _sum: RiesgoSumAggregateOutputType | null
    _min: RiesgoMinAggregateOutputType | null
    _max: RiesgoMaxAggregateOutputType | null
  }

  type GetRiesgoGroupByPayload<T extends RiesgoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiesgoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiesgoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiesgoGroupByOutputType[P]>
            : GetScalarType<T[P], RiesgoGroupByOutputType[P]>
        }
      >
    >


  export type RiesgoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activoId?: boolean
    descripcion?: boolean
    probabilidad?: boolean
    impacto?: boolean
    estado?: boolean
    fechaIdentificacion?: boolean
    responsable?: boolean
    updatedAt?: boolean
    activo?: boolean | ActivoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riesgo"]>

  export type RiesgoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activoId?: boolean
    descripcion?: boolean
    probabilidad?: boolean
    impacto?: boolean
    estado?: boolean
    fechaIdentificacion?: boolean
    responsable?: boolean
    updatedAt?: boolean
    activo?: boolean | ActivoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riesgo"]>

  export type RiesgoSelectScalar = {
    id?: boolean
    activoId?: boolean
    descripcion?: boolean
    probabilidad?: boolean
    impacto?: boolean
    estado?: boolean
    fechaIdentificacion?: boolean
    responsable?: boolean
    updatedAt?: boolean
  }

  export type RiesgoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activo?: boolean | ActivoDefaultArgs<ExtArgs>
  }
  export type RiesgoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activo?: boolean | ActivoDefaultArgs<ExtArgs>
  }

  export type $RiesgoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Riesgo"
    objects: {
      activo: Prisma.$ActivoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      activoId: string
      descripcion: string
      probabilidad: number
      impacto: number
      estado: string
      fechaIdentificacion: Date
      responsable: string
      updatedAt: Date
    }, ExtArgs["result"]["riesgo"]>
    composites: {}
  }

  type RiesgoGetPayload<S extends boolean | null | undefined | RiesgoDefaultArgs> = $Result.GetResult<Prisma.$RiesgoPayload, S>

  type RiesgoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RiesgoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RiesgoCountAggregateInputType | true
    }

  export interface RiesgoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Riesgo'], meta: { name: 'Riesgo' } }
    /**
     * Find zero or one Riesgo that matches the filter.
     * @param {RiesgoFindUniqueArgs} args - Arguments to find a Riesgo
     * @example
     * // Get one Riesgo
     * const riesgo = await prisma.riesgo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiesgoFindUniqueArgs>(args: SelectSubset<T, RiesgoFindUniqueArgs<ExtArgs>>): Prisma__RiesgoClient<$Result.GetResult<Prisma.$RiesgoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Riesgo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RiesgoFindUniqueOrThrowArgs} args - Arguments to find a Riesgo
     * @example
     * // Get one Riesgo
     * const riesgo = await prisma.riesgo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiesgoFindUniqueOrThrowArgs>(args: SelectSubset<T, RiesgoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiesgoClient<$Result.GetResult<Prisma.$RiesgoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Riesgo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiesgoFindFirstArgs} args - Arguments to find a Riesgo
     * @example
     * // Get one Riesgo
     * const riesgo = await prisma.riesgo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiesgoFindFirstArgs>(args?: SelectSubset<T, RiesgoFindFirstArgs<ExtArgs>>): Prisma__RiesgoClient<$Result.GetResult<Prisma.$RiesgoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Riesgo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiesgoFindFirstOrThrowArgs} args - Arguments to find a Riesgo
     * @example
     * // Get one Riesgo
     * const riesgo = await prisma.riesgo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiesgoFindFirstOrThrowArgs>(args?: SelectSubset<T, RiesgoFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiesgoClient<$Result.GetResult<Prisma.$RiesgoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Riesgos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiesgoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Riesgos
     * const riesgos = await prisma.riesgo.findMany()
     * 
     * // Get first 10 Riesgos
     * const riesgos = await prisma.riesgo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riesgoWithIdOnly = await prisma.riesgo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiesgoFindManyArgs>(args?: SelectSubset<T, RiesgoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiesgoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Riesgo.
     * @param {RiesgoCreateArgs} args - Arguments to create a Riesgo.
     * @example
     * // Create one Riesgo
     * const Riesgo = await prisma.riesgo.create({
     *   data: {
     *     // ... data to create a Riesgo
     *   }
     * })
     * 
     */
    create<T extends RiesgoCreateArgs>(args: SelectSubset<T, RiesgoCreateArgs<ExtArgs>>): Prisma__RiesgoClient<$Result.GetResult<Prisma.$RiesgoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Riesgos.
     * @param {RiesgoCreateManyArgs} args - Arguments to create many Riesgos.
     * @example
     * // Create many Riesgos
     * const riesgo = await prisma.riesgo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiesgoCreateManyArgs>(args?: SelectSubset<T, RiesgoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Riesgos and returns the data saved in the database.
     * @param {RiesgoCreateManyAndReturnArgs} args - Arguments to create many Riesgos.
     * @example
     * // Create many Riesgos
     * const riesgo = await prisma.riesgo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Riesgos and only return the `id`
     * const riesgoWithIdOnly = await prisma.riesgo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiesgoCreateManyAndReturnArgs>(args?: SelectSubset<T, RiesgoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiesgoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Riesgo.
     * @param {RiesgoDeleteArgs} args - Arguments to delete one Riesgo.
     * @example
     * // Delete one Riesgo
     * const Riesgo = await prisma.riesgo.delete({
     *   where: {
     *     // ... filter to delete one Riesgo
     *   }
     * })
     * 
     */
    delete<T extends RiesgoDeleteArgs>(args: SelectSubset<T, RiesgoDeleteArgs<ExtArgs>>): Prisma__RiesgoClient<$Result.GetResult<Prisma.$RiesgoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Riesgo.
     * @param {RiesgoUpdateArgs} args - Arguments to update one Riesgo.
     * @example
     * // Update one Riesgo
     * const riesgo = await prisma.riesgo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiesgoUpdateArgs>(args: SelectSubset<T, RiesgoUpdateArgs<ExtArgs>>): Prisma__RiesgoClient<$Result.GetResult<Prisma.$RiesgoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Riesgos.
     * @param {RiesgoDeleteManyArgs} args - Arguments to filter Riesgos to delete.
     * @example
     * // Delete a few Riesgos
     * const { count } = await prisma.riesgo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiesgoDeleteManyArgs>(args?: SelectSubset<T, RiesgoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Riesgos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiesgoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Riesgos
     * const riesgo = await prisma.riesgo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiesgoUpdateManyArgs>(args: SelectSubset<T, RiesgoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Riesgo.
     * @param {RiesgoUpsertArgs} args - Arguments to update or create a Riesgo.
     * @example
     * // Update or create a Riesgo
     * const riesgo = await prisma.riesgo.upsert({
     *   create: {
     *     // ... data to create a Riesgo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Riesgo we want to update
     *   }
     * })
     */
    upsert<T extends RiesgoUpsertArgs>(args: SelectSubset<T, RiesgoUpsertArgs<ExtArgs>>): Prisma__RiesgoClient<$Result.GetResult<Prisma.$RiesgoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Riesgos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiesgoCountArgs} args - Arguments to filter Riesgos to count.
     * @example
     * // Count the number of Riesgos
     * const count = await prisma.riesgo.count({
     *   where: {
     *     // ... the filter for the Riesgos we want to count
     *   }
     * })
    **/
    count<T extends RiesgoCountArgs>(
      args?: Subset<T, RiesgoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiesgoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Riesgo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiesgoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiesgoAggregateArgs>(args: Subset<T, RiesgoAggregateArgs>): Prisma.PrismaPromise<GetRiesgoAggregateType<T>>

    /**
     * Group by Riesgo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiesgoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiesgoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiesgoGroupByArgs['orderBy'] }
        : { orderBy?: RiesgoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiesgoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiesgoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Riesgo model
   */
  readonly fields: RiesgoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Riesgo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiesgoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activo<T extends ActivoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivoDefaultArgs<ExtArgs>>): Prisma__ActivoClient<$Result.GetResult<Prisma.$ActivoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Riesgo model
   */ 
  interface RiesgoFieldRefs {
    readonly id: FieldRef<"Riesgo", 'String'>
    readonly activoId: FieldRef<"Riesgo", 'String'>
    readonly descripcion: FieldRef<"Riesgo", 'String'>
    readonly probabilidad: FieldRef<"Riesgo", 'Int'>
    readonly impacto: FieldRef<"Riesgo", 'Int'>
    readonly estado: FieldRef<"Riesgo", 'String'>
    readonly fechaIdentificacion: FieldRef<"Riesgo", 'DateTime'>
    readonly responsable: FieldRef<"Riesgo", 'String'>
    readonly updatedAt: FieldRef<"Riesgo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Riesgo findUnique
   */
  export type RiesgoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riesgo
     */
    select?: RiesgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiesgoInclude<ExtArgs> | null
    /**
     * Filter, which Riesgo to fetch.
     */
    where: RiesgoWhereUniqueInput
  }

  /**
   * Riesgo findUniqueOrThrow
   */
  export type RiesgoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riesgo
     */
    select?: RiesgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiesgoInclude<ExtArgs> | null
    /**
     * Filter, which Riesgo to fetch.
     */
    where: RiesgoWhereUniqueInput
  }

  /**
   * Riesgo findFirst
   */
  export type RiesgoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riesgo
     */
    select?: RiesgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiesgoInclude<ExtArgs> | null
    /**
     * Filter, which Riesgo to fetch.
     */
    where?: RiesgoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Riesgos to fetch.
     */
    orderBy?: RiesgoOrderByWithRelationInput | RiesgoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Riesgos.
     */
    cursor?: RiesgoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Riesgos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Riesgos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Riesgos.
     */
    distinct?: RiesgoScalarFieldEnum | RiesgoScalarFieldEnum[]
  }

  /**
   * Riesgo findFirstOrThrow
   */
  export type RiesgoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riesgo
     */
    select?: RiesgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiesgoInclude<ExtArgs> | null
    /**
     * Filter, which Riesgo to fetch.
     */
    where?: RiesgoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Riesgos to fetch.
     */
    orderBy?: RiesgoOrderByWithRelationInput | RiesgoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Riesgos.
     */
    cursor?: RiesgoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Riesgos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Riesgos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Riesgos.
     */
    distinct?: RiesgoScalarFieldEnum | RiesgoScalarFieldEnum[]
  }

  /**
   * Riesgo findMany
   */
  export type RiesgoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riesgo
     */
    select?: RiesgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiesgoInclude<ExtArgs> | null
    /**
     * Filter, which Riesgos to fetch.
     */
    where?: RiesgoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Riesgos to fetch.
     */
    orderBy?: RiesgoOrderByWithRelationInput | RiesgoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Riesgos.
     */
    cursor?: RiesgoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Riesgos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Riesgos.
     */
    skip?: number
    distinct?: RiesgoScalarFieldEnum | RiesgoScalarFieldEnum[]
  }

  /**
   * Riesgo create
   */
  export type RiesgoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riesgo
     */
    select?: RiesgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiesgoInclude<ExtArgs> | null
    /**
     * The data needed to create a Riesgo.
     */
    data: XOR<RiesgoCreateInput, RiesgoUncheckedCreateInput>
  }

  /**
   * Riesgo createMany
   */
  export type RiesgoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Riesgos.
     */
    data: RiesgoCreateManyInput | RiesgoCreateManyInput[]
  }

  /**
   * Riesgo createManyAndReturn
   */
  export type RiesgoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riesgo
     */
    select?: RiesgoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Riesgos.
     */
    data: RiesgoCreateManyInput | RiesgoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiesgoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Riesgo update
   */
  export type RiesgoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riesgo
     */
    select?: RiesgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiesgoInclude<ExtArgs> | null
    /**
     * The data needed to update a Riesgo.
     */
    data: XOR<RiesgoUpdateInput, RiesgoUncheckedUpdateInput>
    /**
     * Choose, which Riesgo to update.
     */
    where: RiesgoWhereUniqueInput
  }

  /**
   * Riesgo updateMany
   */
  export type RiesgoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Riesgos.
     */
    data: XOR<RiesgoUpdateManyMutationInput, RiesgoUncheckedUpdateManyInput>
    /**
     * Filter which Riesgos to update
     */
    where?: RiesgoWhereInput
  }

  /**
   * Riesgo upsert
   */
  export type RiesgoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riesgo
     */
    select?: RiesgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiesgoInclude<ExtArgs> | null
    /**
     * The filter to search for the Riesgo to update in case it exists.
     */
    where: RiesgoWhereUniqueInput
    /**
     * In case the Riesgo found by the `where` argument doesn't exist, create a new Riesgo with this data.
     */
    create: XOR<RiesgoCreateInput, RiesgoUncheckedCreateInput>
    /**
     * In case the Riesgo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiesgoUpdateInput, RiesgoUncheckedUpdateInput>
  }

  /**
   * Riesgo delete
   */
  export type RiesgoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riesgo
     */
    select?: RiesgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiesgoInclude<ExtArgs> | null
    /**
     * Filter which Riesgo to delete.
     */
    where: RiesgoWhereUniqueInput
  }

  /**
   * Riesgo deleteMany
   */
  export type RiesgoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Riesgos to delete
     */
    where?: RiesgoWhereInput
  }

  /**
   * Riesgo without action
   */
  export type RiesgoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riesgo
     */
    select?: RiesgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiesgoInclude<ExtArgs> | null
  }


  /**
   * Model Incidente
   */

  export type AggregateIncidente = {
    _count: IncidenteCountAggregateOutputType | null
    _min: IncidenteMinAggregateOutputType | null
    _max: IncidenteMaxAggregateOutputType | null
  }

  export type IncidenteMinAggregateOutputType = {
    id: string | null
    activoId: string | null
    titulo: string | null
    descripcion: string | null
    severidad: string | null
    estado: string | null
    fechaReporte: Date | null
    reportadoPor: string | null
    updatedAt: Date | null
  }

  export type IncidenteMaxAggregateOutputType = {
    id: string | null
    activoId: string | null
    titulo: string | null
    descripcion: string | null
    severidad: string | null
    estado: string | null
    fechaReporte: Date | null
    reportadoPor: string | null
    updatedAt: Date | null
  }

  export type IncidenteCountAggregateOutputType = {
    id: number
    activoId: number
    titulo: number
    descripcion: number
    severidad: number
    estado: number
    fechaReporte: number
    reportadoPor: number
    updatedAt: number
    _all: number
  }


  export type IncidenteMinAggregateInputType = {
    id?: true
    activoId?: true
    titulo?: true
    descripcion?: true
    severidad?: true
    estado?: true
    fechaReporte?: true
    reportadoPor?: true
    updatedAt?: true
  }

  export type IncidenteMaxAggregateInputType = {
    id?: true
    activoId?: true
    titulo?: true
    descripcion?: true
    severidad?: true
    estado?: true
    fechaReporte?: true
    reportadoPor?: true
    updatedAt?: true
  }

  export type IncidenteCountAggregateInputType = {
    id?: true
    activoId?: true
    titulo?: true
    descripcion?: true
    severidad?: true
    estado?: true
    fechaReporte?: true
    reportadoPor?: true
    updatedAt?: true
    _all?: true
  }

  export type IncidenteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incidente to aggregate.
     */
    where?: IncidenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidentes to fetch.
     */
    orderBy?: IncidenteOrderByWithRelationInput | IncidenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incidentes
    **/
    _count?: true | IncidenteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidenteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidenteMaxAggregateInputType
  }

  export type GetIncidenteAggregateType<T extends IncidenteAggregateArgs> = {
        [P in keyof T & keyof AggregateIncidente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncidente[P]>
      : GetScalarType<T[P], AggregateIncidente[P]>
  }




  export type IncidenteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidenteWhereInput
    orderBy?: IncidenteOrderByWithAggregationInput | IncidenteOrderByWithAggregationInput[]
    by: IncidenteScalarFieldEnum[] | IncidenteScalarFieldEnum
    having?: IncidenteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidenteCountAggregateInputType | true
    _min?: IncidenteMinAggregateInputType
    _max?: IncidenteMaxAggregateInputType
  }

  export type IncidenteGroupByOutputType = {
    id: string
    activoId: string
    titulo: string
    descripcion: string
    severidad: string
    estado: string
    fechaReporte: Date
    reportadoPor: string
    updatedAt: Date
    _count: IncidenteCountAggregateOutputType | null
    _min: IncidenteMinAggregateOutputType | null
    _max: IncidenteMaxAggregateOutputType | null
  }

  type GetIncidenteGroupByPayload<T extends IncidenteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidenteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidenteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidenteGroupByOutputType[P]>
            : GetScalarType<T[P], IncidenteGroupByOutputType[P]>
        }
      >
    >


  export type IncidenteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activoId?: boolean
    titulo?: boolean
    descripcion?: boolean
    severidad?: boolean
    estado?: boolean
    fechaReporte?: boolean
    reportadoPor?: boolean
    updatedAt?: boolean
    activo?: boolean | ActivoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidente"]>

  export type IncidenteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activoId?: boolean
    titulo?: boolean
    descripcion?: boolean
    severidad?: boolean
    estado?: boolean
    fechaReporte?: boolean
    reportadoPor?: boolean
    updatedAt?: boolean
    activo?: boolean | ActivoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidente"]>

  export type IncidenteSelectScalar = {
    id?: boolean
    activoId?: boolean
    titulo?: boolean
    descripcion?: boolean
    severidad?: boolean
    estado?: boolean
    fechaReporte?: boolean
    reportadoPor?: boolean
    updatedAt?: boolean
  }

  export type IncidenteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activo?: boolean | ActivoDefaultArgs<ExtArgs>
  }
  export type IncidenteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activo?: boolean | ActivoDefaultArgs<ExtArgs>
  }

  export type $IncidentePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Incidente"
    objects: {
      activo: Prisma.$ActivoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      activoId: string
      titulo: string
      descripcion: string
      severidad: string
      estado: string
      fechaReporte: Date
      reportadoPor: string
      updatedAt: Date
    }, ExtArgs["result"]["incidente"]>
    composites: {}
  }

  type IncidenteGetPayload<S extends boolean | null | undefined | IncidenteDefaultArgs> = $Result.GetResult<Prisma.$IncidentePayload, S>

  type IncidenteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncidenteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncidenteCountAggregateInputType | true
    }

  export interface IncidenteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Incidente'], meta: { name: 'Incidente' } }
    /**
     * Find zero or one Incidente that matches the filter.
     * @param {IncidenteFindUniqueArgs} args - Arguments to find a Incidente
     * @example
     * // Get one Incidente
     * const incidente = await prisma.incidente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidenteFindUniqueArgs>(args: SelectSubset<T, IncidenteFindUniqueArgs<ExtArgs>>): Prisma__IncidenteClient<$Result.GetResult<Prisma.$IncidentePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Incidente that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncidenteFindUniqueOrThrowArgs} args - Arguments to find a Incidente
     * @example
     * // Get one Incidente
     * const incidente = await prisma.incidente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidenteFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidenteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidenteClient<$Result.GetResult<Prisma.$IncidentePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Incidente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidenteFindFirstArgs} args - Arguments to find a Incidente
     * @example
     * // Get one Incidente
     * const incidente = await prisma.incidente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidenteFindFirstArgs>(args?: SelectSubset<T, IncidenteFindFirstArgs<ExtArgs>>): Prisma__IncidenteClient<$Result.GetResult<Prisma.$IncidentePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Incidente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidenteFindFirstOrThrowArgs} args - Arguments to find a Incidente
     * @example
     * // Get one Incidente
     * const incidente = await prisma.incidente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidenteFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidenteFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidenteClient<$Result.GetResult<Prisma.$IncidentePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Incidentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidenteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incidentes
     * const incidentes = await prisma.incidente.findMany()
     * 
     * // Get first 10 Incidentes
     * const incidentes = await prisma.incidente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidenteWithIdOnly = await prisma.incidente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidenteFindManyArgs>(args?: SelectSubset<T, IncidenteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Incidente.
     * @param {IncidenteCreateArgs} args - Arguments to create a Incidente.
     * @example
     * // Create one Incidente
     * const Incidente = await prisma.incidente.create({
     *   data: {
     *     // ... data to create a Incidente
     *   }
     * })
     * 
     */
    create<T extends IncidenteCreateArgs>(args: SelectSubset<T, IncidenteCreateArgs<ExtArgs>>): Prisma__IncidenteClient<$Result.GetResult<Prisma.$IncidentePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Incidentes.
     * @param {IncidenteCreateManyArgs} args - Arguments to create many Incidentes.
     * @example
     * // Create many Incidentes
     * const incidente = await prisma.incidente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidenteCreateManyArgs>(args?: SelectSubset<T, IncidenteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Incidentes and returns the data saved in the database.
     * @param {IncidenteCreateManyAndReturnArgs} args - Arguments to create many Incidentes.
     * @example
     * // Create many Incidentes
     * const incidente = await prisma.incidente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Incidentes and only return the `id`
     * const incidenteWithIdOnly = await prisma.incidente.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidenteCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidenteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Incidente.
     * @param {IncidenteDeleteArgs} args - Arguments to delete one Incidente.
     * @example
     * // Delete one Incidente
     * const Incidente = await prisma.incidente.delete({
     *   where: {
     *     // ... filter to delete one Incidente
     *   }
     * })
     * 
     */
    delete<T extends IncidenteDeleteArgs>(args: SelectSubset<T, IncidenteDeleteArgs<ExtArgs>>): Prisma__IncidenteClient<$Result.GetResult<Prisma.$IncidentePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Incidente.
     * @param {IncidenteUpdateArgs} args - Arguments to update one Incidente.
     * @example
     * // Update one Incidente
     * const incidente = await prisma.incidente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidenteUpdateArgs>(args: SelectSubset<T, IncidenteUpdateArgs<ExtArgs>>): Prisma__IncidenteClient<$Result.GetResult<Prisma.$IncidentePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Incidentes.
     * @param {IncidenteDeleteManyArgs} args - Arguments to filter Incidentes to delete.
     * @example
     * // Delete a few Incidentes
     * const { count } = await prisma.incidente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidenteDeleteManyArgs>(args?: SelectSubset<T, IncidenteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incidentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidenteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incidentes
     * const incidente = await prisma.incidente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidenteUpdateManyArgs>(args: SelectSubset<T, IncidenteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Incidente.
     * @param {IncidenteUpsertArgs} args - Arguments to update or create a Incidente.
     * @example
     * // Update or create a Incidente
     * const incidente = await prisma.incidente.upsert({
     *   create: {
     *     // ... data to create a Incidente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incidente we want to update
     *   }
     * })
     */
    upsert<T extends IncidenteUpsertArgs>(args: SelectSubset<T, IncidenteUpsertArgs<ExtArgs>>): Prisma__IncidenteClient<$Result.GetResult<Prisma.$IncidentePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Incidentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidenteCountArgs} args - Arguments to filter Incidentes to count.
     * @example
     * // Count the number of Incidentes
     * const count = await prisma.incidente.count({
     *   where: {
     *     // ... the filter for the Incidentes we want to count
     *   }
     * })
    **/
    count<T extends IncidenteCountArgs>(
      args?: Subset<T, IncidenteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidenteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incidente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidenteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidenteAggregateArgs>(args: Subset<T, IncidenteAggregateArgs>): Prisma.PrismaPromise<GetIncidenteAggregateType<T>>

    /**
     * Group by Incidente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidenteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidenteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidenteGroupByArgs['orderBy'] }
        : { orderBy?: IncidenteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidenteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidenteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Incidente model
   */
  readonly fields: IncidenteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Incidente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidenteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activo<T extends ActivoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivoDefaultArgs<ExtArgs>>): Prisma__ActivoClient<$Result.GetResult<Prisma.$ActivoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Incidente model
   */ 
  interface IncidenteFieldRefs {
    readonly id: FieldRef<"Incidente", 'String'>
    readonly activoId: FieldRef<"Incidente", 'String'>
    readonly titulo: FieldRef<"Incidente", 'String'>
    readonly descripcion: FieldRef<"Incidente", 'String'>
    readonly severidad: FieldRef<"Incidente", 'String'>
    readonly estado: FieldRef<"Incidente", 'String'>
    readonly fechaReporte: FieldRef<"Incidente", 'DateTime'>
    readonly reportadoPor: FieldRef<"Incidente", 'String'>
    readonly updatedAt: FieldRef<"Incidente", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Incidente findUnique
   */
  export type IncidenteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incidente
     */
    select?: IncidenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidenteInclude<ExtArgs> | null
    /**
     * Filter, which Incidente to fetch.
     */
    where: IncidenteWhereUniqueInput
  }

  /**
   * Incidente findUniqueOrThrow
   */
  export type IncidenteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incidente
     */
    select?: IncidenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidenteInclude<ExtArgs> | null
    /**
     * Filter, which Incidente to fetch.
     */
    where: IncidenteWhereUniqueInput
  }

  /**
   * Incidente findFirst
   */
  export type IncidenteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incidente
     */
    select?: IncidenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidenteInclude<ExtArgs> | null
    /**
     * Filter, which Incidente to fetch.
     */
    where?: IncidenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidentes to fetch.
     */
    orderBy?: IncidenteOrderByWithRelationInput | IncidenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidentes.
     */
    cursor?: IncidenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidentes.
     */
    distinct?: IncidenteScalarFieldEnum | IncidenteScalarFieldEnum[]
  }

  /**
   * Incidente findFirstOrThrow
   */
  export type IncidenteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incidente
     */
    select?: IncidenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidenteInclude<ExtArgs> | null
    /**
     * Filter, which Incidente to fetch.
     */
    where?: IncidenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidentes to fetch.
     */
    orderBy?: IncidenteOrderByWithRelationInput | IncidenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidentes.
     */
    cursor?: IncidenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidentes.
     */
    distinct?: IncidenteScalarFieldEnum | IncidenteScalarFieldEnum[]
  }

  /**
   * Incidente findMany
   */
  export type IncidenteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incidente
     */
    select?: IncidenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidenteInclude<ExtArgs> | null
    /**
     * Filter, which Incidentes to fetch.
     */
    where?: IncidenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidentes to fetch.
     */
    orderBy?: IncidenteOrderByWithRelationInput | IncidenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incidentes.
     */
    cursor?: IncidenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidentes.
     */
    skip?: number
    distinct?: IncidenteScalarFieldEnum | IncidenteScalarFieldEnum[]
  }

  /**
   * Incidente create
   */
  export type IncidenteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incidente
     */
    select?: IncidenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidenteInclude<ExtArgs> | null
    /**
     * The data needed to create a Incidente.
     */
    data: XOR<IncidenteCreateInput, IncidenteUncheckedCreateInput>
  }

  /**
   * Incidente createMany
   */
  export type IncidenteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Incidentes.
     */
    data: IncidenteCreateManyInput | IncidenteCreateManyInput[]
  }

  /**
   * Incidente createManyAndReturn
   */
  export type IncidenteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incidente
     */
    select?: IncidenteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Incidentes.
     */
    data: IncidenteCreateManyInput | IncidenteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidenteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Incidente update
   */
  export type IncidenteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incidente
     */
    select?: IncidenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidenteInclude<ExtArgs> | null
    /**
     * The data needed to update a Incidente.
     */
    data: XOR<IncidenteUpdateInput, IncidenteUncheckedUpdateInput>
    /**
     * Choose, which Incidente to update.
     */
    where: IncidenteWhereUniqueInput
  }

  /**
   * Incidente updateMany
   */
  export type IncidenteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Incidentes.
     */
    data: XOR<IncidenteUpdateManyMutationInput, IncidenteUncheckedUpdateManyInput>
    /**
     * Filter which Incidentes to update
     */
    where?: IncidenteWhereInput
  }

  /**
   * Incidente upsert
   */
  export type IncidenteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incidente
     */
    select?: IncidenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidenteInclude<ExtArgs> | null
    /**
     * The filter to search for the Incidente to update in case it exists.
     */
    where: IncidenteWhereUniqueInput
    /**
     * In case the Incidente found by the `where` argument doesn't exist, create a new Incidente with this data.
     */
    create: XOR<IncidenteCreateInput, IncidenteUncheckedCreateInput>
    /**
     * In case the Incidente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidenteUpdateInput, IncidenteUncheckedUpdateInput>
  }

  /**
   * Incidente delete
   */
  export type IncidenteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incidente
     */
    select?: IncidenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidenteInclude<ExtArgs> | null
    /**
     * Filter which Incidente to delete.
     */
    where: IncidenteWhereUniqueInput
  }

  /**
   * Incidente deleteMany
   */
  export type IncidenteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incidentes to delete
     */
    where?: IncidenteWhereInput
  }

  /**
   * Incidente without action
   */
  export type IncidenteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incidente
     */
    select?: IncidenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidenteInclude<ExtArgs> | null
  }


  /**
   * Model Defecto
   */

  export type AggregateDefecto = {
    _count: DefectoCountAggregateOutputType | null
    _min: DefectoMinAggregateOutputType | null
    _max: DefectoMaxAggregateOutputType | null
  }

  export type DefectoMinAggregateOutputType = {
    id: string | null
    activoId: string | null
    titulo: string | null
    descripcion: string | null
    tipo: string | null
    prioridad: string | null
    estado: string | null
    fechaDeteccion: Date | null
    detectadoPor: string | null
    updatedAt: Date | null
  }

  export type DefectoMaxAggregateOutputType = {
    id: string | null
    activoId: string | null
    titulo: string | null
    descripcion: string | null
    tipo: string | null
    prioridad: string | null
    estado: string | null
    fechaDeteccion: Date | null
    detectadoPor: string | null
    updatedAt: Date | null
  }

  export type DefectoCountAggregateOutputType = {
    id: number
    activoId: number
    titulo: number
    descripcion: number
    tipo: number
    prioridad: number
    estado: number
    fechaDeteccion: number
    detectadoPor: number
    updatedAt: number
    _all: number
  }


  export type DefectoMinAggregateInputType = {
    id?: true
    activoId?: true
    titulo?: true
    descripcion?: true
    tipo?: true
    prioridad?: true
    estado?: true
    fechaDeteccion?: true
    detectadoPor?: true
    updatedAt?: true
  }

  export type DefectoMaxAggregateInputType = {
    id?: true
    activoId?: true
    titulo?: true
    descripcion?: true
    tipo?: true
    prioridad?: true
    estado?: true
    fechaDeteccion?: true
    detectadoPor?: true
    updatedAt?: true
  }

  export type DefectoCountAggregateInputType = {
    id?: true
    activoId?: true
    titulo?: true
    descripcion?: true
    tipo?: true
    prioridad?: true
    estado?: true
    fechaDeteccion?: true
    detectadoPor?: true
    updatedAt?: true
    _all?: true
  }

  export type DefectoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Defecto to aggregate.
     */
    where?: DefectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defectos to fetch.
     */
    orderBy?: DefectoOrderByWithRelationInput | DefectoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DefectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defectos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defectos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Defectos
    **/
    _count?: true | DefectoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefectoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefectoMaxAggregateInputType
  }

  export type GetDefectoAggregateType<T extends DefectoAggregateArgs> = {
        [P in keyof T & keyof AggregateDefecto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefecto[P]>
      : GetScalarType<T[P], AggregateDefecto[P]>
  }




  export type DefectoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefectoWhereInput
    orderBy?: DefectoOrderByWithAggregationInput | DefectoOrderByWithAggregationInput[]
    by: DefectoScalarFieldEnum[] | DefectoScalarFieldEnum
    having?: DefectoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefectoCountAggregateInputType | true
    _min?: DefectoMinAggregateInputType
    _max?: DefectoMaxAggregateInputType
  }

  export type DefectoGroupByOutputType = {
    id: string
    activoId: string
    titulo: string
    descripcion: string
    tipo: string
    prioridad: string
    estado: string
    fechaDeteccion: Date
    detectadoPor: string
    updatedAt: Date
    _count: DefectoCountAggregateOutputType | null
    _min: DefectoMinAggregateOutputType | null
    _max: DefectoMaxAggregateOutputType | null
  }

  type GetDefectoGroupByPayload<T extends DefectoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DefectoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefectoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefectoGroupByOutputType[P]>
            : GetScalarType<T[P], DefectoGroupByOutputType[P]>
        }
      >
    >


  export type DefectoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activoId?: boolean
    titulo?: boolean
    descripcion?: boolean
    tipo?: boolean
    prioridad?: boolean
    estado?: boolean
    fechaDeteccion?: boolean
    detectadoPor?: boolean
    updatedAt?: boolean
    activo?: boolean | ActivoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defecto"]>

  export type DefectoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activoId?: boolean
    titulo?: boolean
    descripcion?: boolean
    tipo?: boolean
    prioridad?: boolean
    estado?: boolean
    fechaDeteccion?: boolean
    detectadoPor?: boolean
    updatedAt?: boolean
    activo?: boolean | ActivoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defecto"]>

  export type DefectoSelectScalar = {
    id?: boolean
    activoId?: boolean
    titulo?: boolean
    descripcion?: boolean
    tipo?: boolean
    prioridad?: boolean
    estado?: boolean
    fechaDeteccion?: boolean
    detectadoPor?: boolean
    updatedAt?: boolean
  }

  export type DefectoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activo?: boolean | ActivoDefaultArgs<ExtArgs>
  }
  export type DefectoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activo?: boolean | ActivoDefaultArgs<ExtArgs>
  }

  export type $DefectoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Defecto"
    objects: {
      activo: Prisma.$ActivoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      activoId: string
      titulo: string
      descripcion: string
      tipo: string
      prioridad: string
      estado: string
      fechaDeteccion: Date
      detectadoPor: string
      updatedAt: Date
    }, ExtArgs["result"]["defecto"]>
    composites: {}
  }

  type DefectoGetPayload<S extends boolean | null | undefined | DefectoDefaultArgs> = $Result.GetResult<Prisma.$DefectoPayload, S>

  type DefectoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DefectoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DefectoCountAggregateInputType | true
    }

  export interface DefectoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Defecto'], meta: { name: 'Defecto' } }
    /**
     * Find zero or one Defecto that matches the filter.
     * @param {DefectoFindUniqueArgs} args - Arguments to find a Defecto
     * @example
     * // Get one Defecto
     * const defecto = await prisma.defecto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DefectoFindUniqueArgs>(args: SelectSubset<T, DefectoFindUniqueArgs<ExtArgs>>): Prisma__DefectoClient<$Result.GetResult<Prisma.$DefectoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Defecto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DefectoFindUniqueOrThrowArgs} args - Arguments to find a Defecto
     * @example
     * // Get one Defecto
     * const defecto = await prisma.defecto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DefectoFindUniqueOrThrowArgs>(args: SelectSubset<T, DefectoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DefectoClient<$Result.GetResult<Prisma.$DefectoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Defecto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectoFindFirstArgs} args - Arguments to find a Defecto
     * @example
     * // Get one Defecto
     * const defecto = await prisma.defecto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DefectoFindFirstArgs>(args?: SelectSubset<T, DefectoFindFirstArgs<ExtArgs>>): Prisma__DefectoClient<$Result.GetResult<Prisma.$DefectoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Defecto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectoFindFirstOrThrowArgs} args - Arguments to find a Defecto
     * @example
     * // Get one Defecto
     * const defecto = await prisma.defecto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DefectoFindFirstOrThrowArgs>(args?: SelectSubset<T, DefectoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DefectoClient<$Result.GetResult<Prisma.$DefectoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Defectos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Defectos
     * const defectos = await prisma.defecto.findMany()
     * 
     * // Get first 10 Defectos
     * const defectos = await prisma.defecto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const defectoWithIdOnly = await prisma.defecto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DefectoFindManyArgs>(args?: SelectSubset<T, DefectoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Defecto.
     * @param {DefectoCreateArgs} args - Arguments to create a Defecto.
     * @example
     * // Create one Defecto
     * const Defecto = await prisma.defecto.create({
     *   data: {
     *     // ... data to create a Defecto
     *   }
     * })
     * 
     */
    create<T extends DefectoCreateArgs>(args: SelectSubset<T, DefectoCreateArgs<ExtArgs>>): Prisma__DefectoClient<$Result.GetResult<Prisma.$DefectoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Defectos.
     * @param {DefectoCreateManyArgs} args - Arguments to create many Defectos.
     * @example
     * // Create many Defectos
     * const defecto = await prisma.defecto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DefectoCreateManyArgs>(args?: SelectSubset<T, DefectoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Defectos and returns the data saved in the database.
     * @param {DefectoCreateManyAndReturnArgs} args - Arguments to create many Defectos.
     * @example
     * // Create many Defectos
     * const defecto = await prisma.defecto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Defectos and only return the `id`
     * const defectoWithIdOnly = await prisma.defecto.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DefectoCreateManyAndReturnArgs>(args?: SelectSubset<T, DefectoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefectoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Defecto.
     * @param {DefectoDeleteArgs} args - Arguments to delete one Defecto.
     * @example
     * // Delete one Defecto
     * const Defecto = await prisma.defecto.delete({
     *   where: {
     *     // ... filter to delete one Defecto
     *   }
     * })
     * 
     */
    delete<T extends DefectoDeleteArgs>(args: SelectSubset<T, DefectoDeleteArgs<ExtArgs>>): Prisma__DefectoClient<$Result.GetResult<Prisma.$DefectoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Defecto.
     * @param {DefectoUpdateArgs} args - Arguments to update one Defecto.
     * @example
     * // Update one Defecto
     * const defecto = await prisma.defecto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DefectoUpdateArgs>(args: SelectSubset<T, DefectoUpdateArgs<ExtArgs>>): Prisma__DefectoClient<$Result.GetResult<Prisma.$DefectoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Defectos.
     * @param {DefectoDeleteManyArgs} args - Arguments to filter Defectos to delete.
     * @example
     * // Delete a few Defectos
     * const { count } = await prisma.defecto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DefectoDeleteManyArgs>(args?: SelectSubset<T, DefectoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Defectos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Defectos
     * const defecto = await prisma.defecto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DefectoUpdateManyArgs>(args: SelectSubset<T, DefectoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Defecto.
     * @param {DefectoUpsertArgs} args - Arguments to update or create a Defecto.
     * @example
     * // Update or create a Defecto
     * const defecto = await prisma.defecto.upsert({
     *   create: {
     *     // ... data to create a Defecto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Defecto we want to update
     *   }
     * })
     */
    upsert<T extends DefectoUpsertArgs>(args: SelectSubset<T, DefectoUpsertArgs<ExtArgs>>): Prisma__DefectoClient<$Result.GetResult<Prisma.$DefectoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Defectos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectoCountArgs} args - Arguments to filter Defectos to count.
     * @example
     * // Count the number of Defectos
     * const count = await prisma.defecto.count({
     *   where: {
     *     // ... the filter for the Defectos we want to count
     *   }
     * })
    **/
    count<T extends DefectoCountArgs>(
      args?: Subset<T, DefectoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefectoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Defecto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefectoAggregateArgs>(args: Subset<T, DefectoAggregateArgs>): Prisma.PrismaPromise<GetDefectoAggregateType<T>>

    /**
     * Group by Defecto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefectoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefectoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefectoGroupByArgs['orderBy'] }
        : { orderBy?: DefectoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefectoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefectoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Defecto model
   */
  readonly fields: DefectoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Defecto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DefectoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activo<T extends ActivoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivoDefaultArgs<ExtArgs>>): Prisma__ActivoClient<$Result.GetResult<Prisma.$ActivoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Defecto model
   */ 
  interface DefectoFieldRefs {
    readonly id: FieldRef<"Defecto", 'String'>
    readonly activoId: FieldRef<"Defecto", 'String'>
    readonly titulo: FieldRef<"Defecto", 'String'>
    readonly descripcion: FieldRef<"Defecto", 'String'>
    readonly tipo: FieldRef<"Defecto", 'String'>
    readonly prioridad: FieldRef<"Defecto", 'String'>
    readonly estado: FieldRef<"Defecto", 'String'>
    readonly fechaDeteccion: FieldRef<"Defecto", 'DateTime'>
    readonly detectadoPor: FieldRef<"Defecto", 'String'>
    readonly updatedAt: FieldRef<"Defecto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Defecto findUnique
   */
  export type DefectoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defecto
     */
    select?: DefectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectoInclude<ExtArgs> | null
    /**
     * Filter, which Defecto to fetch.
     */
    where: DefectoWhereUniqueInput
  }

  /**
   * Defecto findUniqueOrThrow
   */
  export type DefectoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defecto
     */
    select?: DefectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectoInclude<ExtArgs> | null
    /**
     * Filter, which Defecto to fetch.
     */
    where: DefectoWhereUniqueInput
  }

  /**
   * Defecto findFirst
   */
  export type DefectoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defecto
     */
    select?: DefectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectoInclude<ExtArgs> | null
    /**
     * Filter, which Defecto to fetch.
     */
    where?: DefectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defectos to fetch.
     */
    orderBy?: DefectoOrderByWithRelationInput | DefectoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Defectos.
     */
    cursor?: DefectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defectos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defectos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Defectos.
     */
    distinct?: DefectoScalarFieldEnum | DefectoScalarFieldEnum[]
  }

  /**
   * Defecto findFirstOrThrow
   */
  export type DefectoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defecto
     */
    select?: DefectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectoInclude<ExtArgs> | null
    /**
     * Filter, which Defecto to fetch.
     */
    where?: DefectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defectos to fetch.
     */
    orderBy?: DefectoOrderByWithRelationInput | DefectoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Defectos.
     */
    cursor?: DefectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defectos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defectos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Defectos.
     */
    distinct?: DefectoScalarFieldEnum | DefectoScalarFieldEnum[]
  }

  /**
   * Defecto findMany
   */
  export type DefectoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defecto
     */
    select?: DefectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectoInclude<ExtArgs> | null
    /**
     * Filter, which Defectos to fetch.
     */
    where?: DefectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Defectos to fetch.
     */
    orderBy?: DefectoOrderByWithRelationInput | DefectoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Defectos.
     */
    cursor?: DefectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Defectos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Defectos.
     */
    skip?: number
    distinct?: DefectoScalarFieldEnum | DefectoScalarFieldEnum[]
  }

  /**
   * Defecto create
   */
  export type DefectoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defecto
     */
    select?: DefectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectoInclude<ExtArgs> | null
    /**
     * The data needed to create a Defecto.
     */
    data: XOR<DefectoCreateInput, DefectoUncheckedCreateInput>
  }

  /**
   * Defecto createMany
   */
  export type DefectoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Defectos.
     */
    data: DefectoCreateManyInput | DefectoCreateManyInput[]
  }

  /**
   * Defecto createManyAndReturn
   */
  export type DefectoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defecto
     */
    select?: DefectoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Defectos.
     */
    data: DefectoCreateManyInput | DefectoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Defecto update
   */
  export type DefectoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defecto
     */
    select?: DefectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectoInclude<ExtArgs> | null
    /**
     * The data needed to update a Defecto.
     */
    data: XOR<DefectoUpdateInput, DefectoUncheckedUpdateInput>
    /**
     * Choose, which Defecto to update.
     */
    where: DefectoWhereUniqueInput
  }

  /**
   * Defecto updateMany
   */
  export type DefectoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Defectos.
     */
    data: XOR<DefectoUpdateManyMutationInput, DefectoUncheckedUpdateManyInput>
    /**
     * Filter which Defectos to update
     */
    where?: DefectoWhereInput
  }

  /**
   * Defecto upsert
   */
  export type DefectoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defecto
     */
    select?: DefectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectoInclude<ExtArgs> | null
    /**
     * The filter to search for the Defecto to update in case it exists.
     */
    where: DefectoWhereUniqueInput
    /**
     * In case the Defecto found by the `where` argument doesn't exist, create a new Defecto with this data.
     */
    create: XOR<DefectoCreateInput, DefectoUncheckedCreateInput>
    /**
     * In case the Defecto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DefectoUpdateInput, DefectoUncheckedUpdateInput>
  }

  /**
   * Defecto delete
   */
  export type DefectoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defecto
     */
    select?: DefectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectoInclude<ExtArgs> | null
    /**
     * Filter which Defecto to delete.
     */
    where: DefectoWhereUniqueInput
  }

  /**
   * Defecto deleteMany
   */
  export type DefectoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Defectos to delete
     */
    where?: DefectoWhereInput
  }

  /**
   * Defecto without action
   */
  export type DefectoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Defecto
     */
    select?: DefectoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefectoInclude<ExtArgs> | null
  }


  /**
   * Model Organigrama
   */

  export type AggregateOrganigrama = {
    _count: OrganigramaCountAggregateOutputType | null
    _min: OrganigramaMinAggregateOutputType | null
    _max: OrganigramaMaxAggregateOutputType | null
  }

  export type OrganigramaMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    fechaCreacion: Date | null
    updatedAt: Date | null
  }

  export type OrganigramaMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    fechaCreacion: Date | null
    updatedAt: Date | null
  }

  export type OrganigramaCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    fechaCreacion: number
    updatedAt: number
    _all: number
  }


  export type OrganigramaMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    fechaCreacion?: true
    updatedAt?: true
  }

  export type OrganigramaMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    fechaCreacion?: true
    updatedAt?: true
  }

  export type OrganigramaCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    fechaCreacion?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganigramaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organigrama to aggregate.
     */
    where?: OrganigramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organigramas to fetch.
     */
    orderBy?: OrganigramaOrderByWithRelationInput | OrganigramaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganigramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organigramas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organigramas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organigramas
    **/
    _count?: true | OrganigramaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganigramaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganigramaMaxAggregateInputType
  }

  export type GetOrganigramaAggregateType<T extends OrganigramaAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganigrama]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganigrama[P]>
      : GetScalarType<T[P], AggregateOrganigrama[P]>
  }




  export type OrganigramaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganigramaWhereInput
    orderBy?: OrganigramaOrderByWithAggregationInput | OrganigramaOrderByWithAggregationInput[]
    by: OrganigramaScalarFieldEnum[] | OrganigramaScalarFieldEnum
    having?: OrganigramaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganigramaCountAggregateInputType | true
    _min?: OrganigramaMinAggregateInputType
    _max?: OrganigramaMaxAggregateInputType
  }

  export type OrganigramaGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string
    fechaCreacion: Date
    updatedAt: Date
    _count: OrganigramaCountAggregateOutputType | null
    _min: OrganigramaMinAggregateOutputType | null
    _max: OrganigramaMaxAggregateOutputType | null
  }

  type GetOrganigramaGroupByPayload<T extends OrganigramaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganigramaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganigramaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganigramaGroupByOutputType[P]>
            : GetScalarType<T[P], OrganigramaGroupByOutputType[P]>
        }
      >
    >


  export type OrganigramaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    fechaCreacion?: boolean
    updatedAt?: boolean
    nodos?: boolean | Organigrama$nodosArgs<ExtArgs>
    _count?: boolean | OrganigramaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organigrama"]>

  export type OrganigramaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    fechaCreacion?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organigrama"]>

  export type OrganigramaSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    fechaCreacion?: boolean
    updatedAt?: boolean
  }

  export type OrganigramaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodos?: boolean | Organigrama$nodosArgs<ExtArgs>
    _count?: boolean | OrganigramaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganigramaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganigramaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organigrama"
    objects: {
      nodos: Prisma.$NodoOrganigramaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      descripcion: string
      fechaCreacion: Date
      updatedAt: Date
    }, ExtArgs["result"]["organigrama"]>
    composites: {}
  }

  type OrganigramaGetPayload<S extends boolean | null | undefined | OrganigramaDefaultArgs> = $Result.GetResult<Prisma.$OrganigramaPayload, S>

  type OrganigramaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganigramaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganigramaCountAggregateInputType | true
    }

  export interface OrganigramaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organigrama'], meta: { name: 'Organigrama' } }
    /**
     * Find zero or one Organigrama that matches the filter.
     * @param {OrganigramaFindUniqueArgs} args - Arguments to find a Organigrama
     * @example
     * // Get one Organigrama
     * const organigrama = await prisma.organigrama.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganigramaFindUniqueArgs>(args: SelectSubset<T, OrganigramaFindUniqueArgs<ExtArgs>>): Prisma__OrganigramaClient<$Result.GetResult<Prisma.$OrganigramaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organigrama that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganigramaFindUniqueOrThrowArgs} args - Arguments to find a Organigrama
     * @example
     * // Get one Organigrama
     * const organigrama = await prisma.organigrama.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganigramaFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganigramaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganigramaClient<$Result.GetResult<Prisma.$OrganigramaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organigrama that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganigramaFindFirstArgs} args - Arguments to find a Organigrama
     * @example
     * // Get one Organigrama
     * const organigrama = await prisma.organigrama.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganigramaFindFirstArgs>(args?: SelectSubset<T, OrganigramaFindFirstArgs<ExtArgs>>): Prisma__OrganigramaClient<$Result.GetResult<Prisma.$OrganigramaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organigrama that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganigramaFindFirstOrThrowArgs} args - Arguments to find a Organigrama
     * @example
     * // Get one Organigrama
     * const organigrama = await prisma.organigrama.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganigramaFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganigramaFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganigramaClient<$Result.GetResult<Prisma.$OrganigramaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organigramas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganigramaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organigramas
     * const organigramas = await prisma.organigrama.findMany()
     * 
     * // Get first 10 Organigramas
     * const organigramas = await prisma.organigrama.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organigramaWithIdOnly = await prisma.organigrama.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganigramaFindManyArgs>(args?: SelectSubset<T, OrganigramaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganigramaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organigrama.
     * @param {OrganigramaCreateArgs} args - Arguments to create a Organigrama.
     * @example
     * // Create one Organigrama
     * const Organigrama = await prisma.organigrama.create({
     *   data: {
     *     // ... data to create a Organigrama
     *   }
     * })
     * 
     */
    create<T extends OrganigramaCreateArgs>(args: SelectSubset<T, OrganigramaCreateArgs<ExtArgs>>): Prisma__OrganigramaClient<$Result.GetResult<Prisma.$OrganigramaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organigramas.
     * @param {OrganigramaCreateManyArgs} args - Arguments to create many Organigramas.
     * @example
     * // Create many Organigramas
     * const organigrama = await prisma.organigrama.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganigramaCreateManyArgs>(args?: SelectSubset<T, OrganigramaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organigramas and returns the data saved in the database.
     * @param {OrganigramaCreateManyAndReturnArgs} args - Arguments to create many Organigramas.
     * @example
     * // Create many Organigramas
     * const organigrama = await prisma.organigrama.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organigramas and only return the `id`
     * const organigramaWithIdOnly = await prisma.organigrama.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganigramaCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganigramaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganigramaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Organigrama.
     * @param {OrganigramaDeleteArgs} args - Arguments to delete one Organigrama.
     * @example
     * // Delete one Organigrama
     * const Organigrama = await prisma.organigrama.delete({
     *   where: {
     *     // ... filter to delete one Organigrama
     *   }
     * })
     * 
     */
    delete<T extends OrganigramaDeleteArgs>(args: SelectSubset<T, OrganigramaDeleteArgs<ExtArgs>>): Prisma__OrganigramaClient<$Result.GetResult<Prisma.$OrganigramaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organigrama.
     * @param {OrganigramaUpdateArgs} args - Arguments to update one Organigrama.
     * @example
     * // Update one Organigrama
     * const organigrama = await prisma.organigrama.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganigramaUpdateArgs>(args: SelectSubset<T, OrganigramaUpdateArgs<ExtArgs>>): Prisma__OrganigramaClient<$Result.GetResult<Prisma.$OrganigramaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organigramas.
     * @param {OrganigramaDeleteManyArgs} args - Arguments to filter Organigramas to delete.
     * @example
     * // Delete a few Organigramas
     * const { count } = await prisma.organigrama.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganigramaDeleteManyArgs>(args?: SelectSubset<T, OrganigramaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organigramas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganigramaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organigramas
     * const organigrama = await prisma.organigrama.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganigramaUpdateManyArgs>(args: SelectSubset<T, OrganigramaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organigrama.
     * @param {OrganigramaUpsertArgs} args - Arguments to update or create a Organigrama.
     * @example
     * // Update or create a Organigrama
     * const organigrama = await prisma.organigrama.upsert({
     *   create: {
     *     // ... data to create a Organigrama
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organigrama we want to update
     *   }
     * })
     */
    upsert<T extends OrganigramaUpsertArgs>(args: SelectSubset<T, OrganigramaUpsertArgs<ExtArgs>>): Prisma__OrganigramaClient<$Result.GetResult<Prisma.$OrganigramaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organigramas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganigramaCountArgs} args - Arguments to filter Organigramas to count.
     * @example
     * // Count the number of Organigramas
     * const count = await prisma.organigrama.count({
     *   where: {
     *     // ... the filter for the Organigramas we want to count
     *   }
     * })
    **/
    count<T extends OrganigramaCountArgs>(
      args?: Subset<T, OrganigramaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganigramaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organigrama.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganigramaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganigramaAggregateArgs>(args: Subset<T, OrganigramaAggregateArgs>): Prisma.PrismaPromise<GetOrganigramaAggregateType<T>>

    /**
     * Group by Organigrama.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganigramaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganigramaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganigramaGroupByArgs['orderBy'] }
        : { orderBy?: OrganigramaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganigramaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganigramaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organigrama model
   */
  readonly fields: OrganigramaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organigrama.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganigramaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nodos<T extends Organigrama$nodosArgs<ExtArgs> = {}>(args?: Subset<T, Organigrama$nodosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodoOrganigramaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organigrama model
   */ 
  interface OrganigramaFieldRefs {
    readonly id: FieldRef<"Organigrama", 'String'>
    readonly nombre: FieldRef<"Organigrama", 'String'>
    readonly descripcion: FieldRef<"Organigrama", 'String'>
    readonly fechaCreacion: FieldRef<"Organigrama", 'DateTime'>
    readonly updatedAt: FieldRef<"Organigrama", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organigrama findUnique
   */
  export type OrganigramaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organigrama
     */
    select?: OrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganigramaInclude<ExtArgs> | null
    /**
     * Filter, which Organigrama to fetch.
     */
    where: OrganigramaWhereUniqueInput
  }

  /**
   * Organigrama findUniqueOrThrow
   */
  export type OrganigramaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organigrama
     */
    select?: OrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganigramaInclude<ExtArgs> | null
    /**
     * Filter, which Organigrama to fetch.
     */
    where: OrganigramaWhereUniqueInput
  }

  /**
   * Organigrama findFirst
   */
  export type OrganigramaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organigrama
     */
    select?: OrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganigramaInclude<ExtArgs> | null
    /**
     * Filter, which Organigrama to fetch.
     */
    where?: OrganigramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organigramas to fetch.
     */
    orderBy?: OrganigramaOrderByWithRelationInput | OrganigramaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organigramas.
     */
    cursor?: OrganigramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organigramas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organigramas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organigramas.
     */
    distinct?: OrganigramaScalarFieldEnum | OrganigramaScalarFieldEnum[]
  }

  /**
   * Organigrama findFirstOrThrow
   */
  export type OrganigramaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organigrama
     */
    select?: OrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganigramaInclude<ExtArgs> | null
    /**
     * Filter, which Organigrama to fetch.
     */
    where?: OrganigramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organigramas to fetch.
     */
    orderBy?: OrganigramaOrderByWithRelationInput | OrganigramaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organigramas.
     */
    cursor?: OrganigramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organigramas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organigramas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organigramas.
     */
    distinct?: OrganigramaScalarFieldEnum | OrganigramaScalarFieldEnum[]
  }

  /**
   * Organigrama findMany
   */
  export type OrganigramaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organigrama
     */
    select?: OrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganigramaInclude<ExtArgs> | null
    /**
     * Filter, which Organigramas to fetch.
     */
    where?: OrganigramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organigramas to fetch.
     */
    orderBy?: OrganigramaOrderByWithRelationInput | OrganigramaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organigramas.
     */
    cursor?: OrganigramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organigramas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organigramas.
     */
    skip?: number
    distinct?: OrganigramaScalarFieldEnum | OrganigramaScalarFieldEnum[]
  }

  /**
   * Organigrama create
   */
  export type OrganigramaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organigrama
     */
    select?: OrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganigramaInclude<ExtArgs> | null
    /**
     * The data needed to create a Organigrama.
     */
    data: XOR<OrganigramaCreateInput, OrganigramaUncheckedCreateInput>
  }

  /**
   * Organigrama createMany
   */
  export type OrganigramaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organigramas.
     */
    data: OrganigramaCreateManyInput | OrganigramaCreateManyInput[]
  }

  /**
   * Organigrama createManyAndReturn
   */
  export type OrganigramaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organigrama
     */
    select?: OrganigramaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Organigramas.
     */
    data: OrganigramaCreateManyInput | OrganigramaCreateManyInput[]
  }

  /**
   * Organigrama update
   */
  export type OrganigramaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organigrama
     */
    select?: OrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganigramaInclude<ExtArgs> | null
    /**
     * The data needed to update a Organigrama.
     */
    data: XOR<OrganigramaUpdateInput, OrganigramaUncheckedUpdateInput>
    /**
     * Choose, which Organigrama to update.
     */
    where: OrganigramaWhereUniqueInput
  }

  /**
   * Organigrama updateMany
   */
  export type OrganigramaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organigramas.
     */
    data: XOR<OrganigramaUpdateManyMutationInput, OrganigramaUncheckedUpdateManyInput>
    /**
     * Filter which Organigramas to update
     */
    where?: OrganigramaWhereInput
  }

  /**
   * Organigrama upsert
   */
  export type OrganigramaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organigrama
     */
    select?: OrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganigramaInclude<ExtArgs> | null
    /**
     * The filter to search for the Organigrama to update in case it exists.
     */
    where: OrganigramaWhereUniqueInput
    /**
     * In case the Organigrama found by the `where` argument doesn't exist, create a new Organigrama with this data.
     */
    create: XOR<OrganigramaCreateInput, OrganigramaUncheckedCreateInput>
    /**
     * In case the Organigrama was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganigramaUpdateInput, OrganigramaUncheckedUpdateInput>
  }

  /**
   * Organigrama delete
   */
  export type OrganigramaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organigrama
     */
    select?: OrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganigramaInclude<ExtArgs> | null
    /**
     * Filter which Organigrama to delete.
     */
    where: OrganigramaWhereUniqueInput
  }

  /**
   * Organigrama deleteMany
   */
  export type OrganigramaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organigramas to delete
     */
    where?: OrganigramaWhereInput
  }

  /**
   * Organigrama.nodos
   */
  export type Organigrama$nodosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodoOrganigrama
     */
    select?: NodoOrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodoOrganigramaInclude<ExtArgs> | null
    where?: NodoOrganigramaWhereInput
    orderBy?: NodoOrganigramaOrderByWithRelationInput | NodoOrganigramaOrderByWithRelationInput[]
    cursor?: NodoOrganigramaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NodoOrganigramaScalarFieldEnum | NodoOrganigramaScalarFieldEnum[]
  }

  /**
   * Organigrama without action
   */
  export type OrganigramaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organigrama
     */
    select?: OrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganigramaInclude<ExtArgs> | null
  }


  /**
   * Model NodoOrganigrama
   */

  export type AggregateNodoOrganigrama = {
    _count: NodoOrganigramaCountAggregateOutputType | null
    _min: NodoOrganigramaMinAggregateOutputType | null
    _max: NodoOrganigramaMaxAggregateOutputType | null
  }

  export type NodoOrganigramaMinAggregateOutputType = {
    id: string | null
    organigramaId: string | null
    nombre: string | null
    cargo: string | null
    departamento: string | null
    email: string | null
    telefono: string | null
    foto: string | null
    padreId: string | null
  }

  export type NodoOrganigramaMaxAggregateOutputType = {
    id: string | null
    organigramaId: string | null
    nombre: string | null
    cargo: string | null
    departamento: string | null
    email: string | null
    telefono: string | null
    foto: string | null
    padreId: string | null
  }

  export type NodoOrganigramaCountAggregateOutputType = {
    id: number
    organigramaId: number
    nombre: number
    cargo: number
    departamento: number
    email: number
    telefono: number
    foto: number
    padreId: number
    _all: number
  }


  export type NodoOrganigramaMinAggregateInputType = {
    id?: true
    organigramaId?: true
    nombre?: true
    cargo?: true
    departamento?: true
    email?: true
    telefono?: true
    foto?: true
    padreId?: true
  }

  export type NodoOrganigramaMaxAggregateInputType = {
    id?: true
    organigramaId?: true
    nombre?: true
    cargo?: true
    departamento?: true
    email?: true
    telefono?: true
    foto?: true
    padreId?: true
  }

  export type NodoOrganigramaCountAggregateInputType = {
    id?: true
    organigramaId?: true
    nombre?: true
    cargo?: true
    departamento?: true
    email?: true
    telefono?: true
    foto?: true
    padreId?: true
    _all?: true
  }

  export type NodoOrganigramaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NodoOrganigrama to aggregate.
     */
    where?: NodoOrganigramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodoOrganigramas to fetch.
     */
    orderBy?: NodoOrganigramaOrderByWithRelationInput | NodoOrganigramaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NodoOrganigramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodoOrganigramas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodoOrganigramas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NodoOrganigramas
    **/
    _count?: true | NodoOrganigramaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NodoOrganigramaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NodoOrganigramaMaxAggregateInputType
  }

  export type GetNodoOrganigramaAggregateType<T extends NodoOrganigramaAggregateArgs> = {
        [P in keyof T & keyof AggregateNodoOrganigrama]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNodoOrganigrama[P]>
      : GetScalarType<T[P], AggregateNodoOrganigrama[P]>
  }




  export type NodoOrganigramaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodoOrganigramaWhereInput
    orderBy?: NodoOrganigramaOrderByWithAggregationInput | NodoOrganigramaOrderByWithAggregationInput[]
    by: NodoOrganigramaScalarFieldEnum[] | NodoOrganigramaScalarFieldEnum
    having?: NodoOrganigramaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NodoOrganigramaCountAggregateInputType | true
    _min?: NodoOrganigramaMinAggregateInputType
    _max?: NodoOrganigramaMaxAggregateInputType
  }

  export type NodoOrganigramaGroupByOutputType = {
    id: string
    organigramaId: string
    nombre: string
    cargo: string
    departamento: string
    email: string
    telefono: string | null
    foto: string | null
    padreId: string | null
    _count: NodoOrganigramaCountAggregateOutputType | null
    _min: NodoOrganigramaMinAggregateOutputType | null
    _max: NodoOrganigramaMaxAggregateOutputType | null
  }

  type GetNodoOrganigramaGroupByPayload<T extends NodoOrganigramaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NodoOrganigramaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NodoOrganigramaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NodoOrganigramaGroupByOutputType[P]>
            : GetScalarType<T[P], NodoOrganigramaGroupByOutputType[P]>
        }
      >
    >


  export type NodoOrganigramaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organigramaId?: boolean
    nombre?: boolean
    cargo?: boolean
    departamento?: boolean
    email?: boolean
    telefono?: boolean
    foto?: boolean
    padreId?: boolean
    organigrama?: boolean | OrganigramaDefaultArgs<ExtArgs>
    padre?: boolean | NodoOrganigrama$padreArgs<ExtArgs>
    subordinados?: boolean | NodoOrganigrama$subordinadosArgs<ExtArgs>
    _count?: boolean | NodoOrganigramaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nodoOrganigrama"]>

  export type NodoOrganigramaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organigramaId?: boolean
    nombre?: boolean
    cargo?: boolean
    departamento?: boolean
    email?: boolean
    telefono?: boolean
    foto?: boolean
    padreId?: boolean
    organigrama?: boolean | OrganigramaDefaultArgs<ExtArgs>
    padre?: boolean | NodoOrganigrama$padreArgs<ExtArgs>
  }, ExtArgs["result"]["nodoOrganigrama"]>

  export type NodoOrganigramaSelectScalar = {
    id?: boolean
    organigramaId?: boolean
    nombre?: boolean
    cargo?: boolean
    departamento?: boolean
    email?: boolean
    telefono?: boolean
    foto?: boolean
    padreId?: boolean
  }

  export type NodoOrganigramaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organigrama?: boolean | OrganigramaDefaultArgs<ExtArgs>
    padre?: boolean | NodoOrganigrama$padreArgs<ExtArgs>
    subordinados?: boolean | NodoOrganigrama$subordinadosArgs<ExtArgs>
    _count?: boolean | NodoOrganigramaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NodoOrganigramaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organigrama?: boolean | OrganigramaDefaultArgs<ExtArgs>
    padre?: boolean | NodoOrganigrama$padreArgs<ExtArgs>
  }

  export type $NodoOrganigramaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NodoOrganigrama"
    objects: {
      organigrama: Prisma.$OrganigramaPayload<ExtArgs>
      padre: Prisma.$NodoOrganigramaPayload<ExtArgs> | null
      subordinados: Prisma.$NodoOrganigramaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organigramaId: string
      nombre: string
      cargo: string
      departamento: string
      email: string
      telefono: string | null
      foto: string | null
      padreId: string | null
    }, ExtArgs["result"]["nodoOrganigrama"]>
    composites: {}
  }

  type NodoOrganigramaGetPayload<S extends boolean | null | undefined | NodoOrganigramaDefaultArgs> = $Result.GetResult<Prisma.$NodoOrganigramaPayload, S>

  type NodoOrganigramaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NodoOrganigramaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NodoOrganigramaCountAggregateInputType | true
    }

  export interface NodoOrganigramaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NodoOrganigrama'], meta: { name: 'NodoOrganigrama' } }
    /**
     * Find zero or one NodoOrganigrama that matches the filter.
     * @param {NodoOrganigramaFindUniqueArgs} args - Arguments to find a NodoOrganigrama
     * @example
     * // Get one NodoOrganigrama
     * const nodoOrganigrama = await prisma.nodoOrganigrama.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NodoOrganigramaFindUniqueArgs>(args: SelectSubset<T, NodoOrganigramaFindUniqueArgs<ExtArgs>>): Prisma__NodoOrganigramaClient<$Result.GetResult<Prisma.$NodoOrganigramaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NodoOrganigrama that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NodoOrganigramaFindUniqueOrThrowArgs} args - Arguments to find a NodoOrganigrama
     * @example
     * // Get one NodoOrganigrama
     * const nodoOrganigrama = await prisma.nodoOrganigrama.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NodoOrganigramaFindUniqueOrThrowArgs>(args: SelectSubset<T, NodoOrganigramaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NodoOrganigramaClient<$Result.GetResult<Prisma.$NodoOrganigramaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NodoOrganigrama that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodoOrganigramaFindFirstArgs} args - Arguments to find a NodoOrganigrama
     * @example
     * // Get one NodoOrganigrama
     * const nodoOrganigrama = await prisma.nodoOrganigrama.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NodoOrganigramaFindFirstArgs>(args?: SelectSubset<T, NodoOrganigramaFindFirstArgs<ExtArgs>>): Prisma__NodoOrganigramaClient<$Result.GetResult<Prisma.$NodoOrganigramaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NodoOrganigrama that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodoOrganigramaFindFirstOrThrowArgs} args - Arguments to find a NodoOrganigrama
     * @example
     * // Get one NodoOrganigrama
     * const nodoOrganigrama = await prisma.nodoOrganigrama.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NodoOrganigramaFindFirstOrThrowArgs>(args?: SelectSubset<T, NodoOrganigramaFindFirstOrThrowArgs<ExtArgs>>): Prisma__NodoOrganigramaClient<$Result.GetResult<Prisma.$NodoOrganigramaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NodoOrganigramas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodoOrganigramaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NodoOrganigramas
     * const nodoOrganigramas = await prisma.nodoOrganigrama.findMany()
     * 
     * // Get first 10 NodoOrganigramas
     * const nodoOrganigramas = await prisma.nodoOrganigrama.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nodoOrganigramaWithIdOnly = await prisma.nodoOrganigrama.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NodoOrganigramaFindManyArgs>(args?: SelectSubset<T, NodoOrganigramaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodoOrganigramaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NodoOrganigrama.
     * @param {NodoOrganigramaCreateArgs} args - Arguments to create a NodoOrganigrama.
     * @example
     * // Create one NodoOrganigrama
     * const NodoOrganigrama = await prisma.nodoOrganigrama.create({
     *   data: {
     *     // ... data to create a NodoOrganigrama
     *   }
     * })
     * 
     */
    create<T extends NodoOrganigramaCreateArgs>(args: SelectSubset<T, NodoOrganigramaCreateArgs<ExtArgs>>): Prisma__NodoOrganigramaClient<$Result.GetResult<Prisma.$NodoOrganigramaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NodoOrganigramas.
     * @param {NodoOrganigramaCreateManyArgs} args - Arguments to create many NodoOrganigramas.
     * @example
     * // Create many NodoOrganigramas
     * const nodoOrganigrama = await prisma.nodoOrganigrama.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NodoOrganigramaCreateManyArgs>(args?: SelectSubset<T, NodoOrganigramaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NodoOrganigramas and returns the data saved in the database.
     * @param {NodoOrganigramaCreateManyAndReturnArgs} args - Arguments to create many NodoOrganigramas.
     * @example
     * // Create many NodoOrganigramas
     * const nodoOrganigrama = await prisma.nodoOrganigrama.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NodoOrganigramas and only return the `id`
     * const nodoOrganigramaWithIdOnly = await prisma.nodoOrganigrama.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NodoOrganigramaCreateManyAndReturnArgs>(args?: SelectSubset<T, NodoOrganigramaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodoOrganigramaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NodoOrganigrama.
     * @param {NodoOrganigramaDeleteArgs} args - Arguments to delete one NodoOrganigrama.
     * @example
     * // Delete one NodoOrganigrama
     * const NodoOrganigrama = await prisma.nodoOrganigrama.delete({
     *   where: {
     *     // ... filter to delete one NodoOrganigrama
     *   }
     * })
     * 
     */
    delete<T extends NodoOrganigramaDeleteArgs>(args: SelectSubset<T, NodoOrganigramaDeleteArgs<ExtArgs>>): Prisma__NodoOrganigramaClient<$Result.GetResult<Prisma.$NodoOrganigramaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NodoOrganigrama.
     * @param {NodoOrganigramaUpdateArgs} args - Arguments to update one NodoOrganigrama.
     * @example
     * // Update one NodoOrganigrama
     * const nodoOrganigrama = await prisma.nodoOrganigrama.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NodoOrganigramaUpdateArgs>(args: SelectSubset<T, NodoOrganigramaUpdateArgs<ExtArgs>>): Prisma__NodoOrganigramaClient<$Result.GetResult<Prisma.$NodoOrganigramaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NodoOrganigramas.
     * @param {NodoOrganigramaDeleteManyArgs} args - Arguments to filter NodoOrganigramas to delete.
     * @example
     * // Delete a few NodoOrganigramas
     * const { count } = await prisma.nodoOrganigrama.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NodoOrganigramaDeleteManyArgs>(args?: SelectSubset<T, NodoOrganigramaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NodoOrganigramas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodoOrganigramaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NodoOrganigramas
     * const nodoOrganigrama = await prisma.nodoOrganigrama.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NodoOrganigramaUpdateManyArgs>(args: SelectSubset<T, NodoOrganigramaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NodoOrganigrama.
     * @param {NodoOrganigramaUpsertArgs} args - Arguments to update or create a NodoOrganigrama.
     * @example
     * // Update or create a NodoOrganigrama
     * const nodoOrganigrama = await prisma.nodoOrganigrama.upsert({
     *   create: {
     *     // ... data to create a NodoOrganigrama
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NodoOrganigrama we want to update
     *   }
     * })
     */
    upsert<T extends NodoOrganigramaUpsertArgs>(args: SelectSubset<T, NodoOrganigramaUpsertArgs<ExtArgs>>): Prisma__NodoOrganigramaClient<$Result.GetResult<Prisma.$NodoOrganigramaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NodoOrganigramas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodoOrganigramaCountArgs} args - Arguments to filter NodoOrganigramas to count.
     * @example
     * // Count the number of NodoOrganigramas
     * const count = await prisma.nodoOrganigrama.count({
     *   where: {
     *     // ... the filter for the NodoOrganigramas we want to count
     *   }
     * })
    **/
    count<T extends NodoOrganigramaCountArgs>(
      args?: Subset<T, NodoOrganigramaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NodoOrganigramaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NodoOrganigrama.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodoOrganigramaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NodoOrganigramaAggregateArgs>(args: Subset<T, NodoOrganigramaAggregateArgs>): Prisma.PrismaPromise<GetNodoOrganigramaAggregateType<T>>

    /**
     * Group by NodoOrganigrama.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodoOrganigramaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NodoOrganigramaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NodoOrganigramaGroupByArgs['orderBy'] }
        : { orderBy?: NodoOrganigramaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NodoOrganigramaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNodoOrganigramaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NodoOrganigrama model
   */
  readonly fields: NodoOrganigramaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NodoOrganigrama.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NodoOrganigramaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organigrama<T extends OrganigramaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganigramaDefaultArgs<ExtArgs>>): Prisma__OrganigramaClient<$Result.GetResult<Prisma.$OrganigramaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    padre<T extends NodoOrganigrama$padreArgs<ExtArgs> = {}>(args?: Subset<T, NodoOrganigrama$padreArgs<ExtArgs>>): Prisma__NodoOrganigramaClient<$Result.GetResult<Prisma.$NodoOrganigramaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subordinados<T extends NodoOrganigrama$subordinadosArgs<ExtArgs> = {}>(args?: Subset<T, NodoOrganigrama$subordinadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodoOrganigramaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NodoOrganigrama model
   */ 
  interface NodoOrganigramaFieldRefs {
    readonly id: FieldRef<"NodoOrganigrama", 'String'>
    readonly organigramaId: FieldRef<"NodoOrganigrama", 'String'>
    readonly nombre: FieldRef<"NodoOrganigrama", 'String'>
    readonly cargo: FieldRef<"NodoOrganigrama", 'String'>
    readonly departamento: FieldRef<"NodoOrganigrama", 'String'>
    readonly email: FieldRef<"NodoOrganigrama", 'String'>
    readonly telefono: FieldRef<"NodoOrganigrama", 'String'>
    readonly foto: FieldRef<"NodoOrganigrama", 'String'>
    readonly padreId: FieldRef<"NodoOrganigrama", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NodoOrganigrama findUnique
   */
  export type NodoOrganigramaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodoOrganigrama
     */
    select?: NodoOrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodoOrganigramaInclude<ExtArgs> | null
    /**
     * Filter, which NodoOrganigrama to fetch.
     */
    where: NodoOrganigramaWhereUniqueInput
  }

  /**
   * NodoOrganigrama findUniqueOrThrow
   */
  export type NodoOrganigramaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodoOrganigrama
     */
    select?: NodoOrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodoOrganigramaInclude<ExtArgs> | null
    /**
     * Filter, which NodoOrganigrama to fetch.
     */
    where: NodoOrganigramaWhereUniqueInput
  }

  /**
   * NodoOrganigrama findFirst
   */
  export type NodoOrganigramaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodoOrganigrama
     */
    select?: NodoOrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodoOrganigramaInclude<ExtArgs> | null
    /**
     * Filter, which NodoOrganigrama to fetch.
     */
    where?: NodoOrganigramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodoOrganigramas to fetch.
     */
    orderBy?: NodoOrganigramaOrderByWithRelationInput | NodoOrganigramaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NodoOrganigramas.
     */
    cursor?: NodoOrganigramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodoOrganigramas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodoOrganigramas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NodoOrganigramas.
     */
    distinct?: NodoOrganigramaScalarFieldEnum | NodoOrganigramaScalarFieldEnum[]
  }

  /**
   * NodoOrganigrama findFirstOrThrow
   */
  export type NodoOrganigramaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodoOrganigrama
     */
    select?: NodoOrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodoOrganigramaInclude<ExtArgs> | null
    /**
     * Filter, which NodoOrganigrama to fetch.
     */
    where?: NodoOrganigramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodoOrganigramas to fetch.
     */
    orderBy?: NodoOrganigramaOrderByWithRelationInput | NodoOrganigramaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NodoOrganigramas.
     */
    cursor?: NodoOrganigramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodoOrganigramas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodoOrganigramas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NodoOrganigramas.
     */
    distinct?: NodoOrganigramaScalarFieldEnum | NodoOrganigramaScalarFieldEnum[]
  }

  /**
   * NodoOrganigrama findMany
   */
  export type NodoOrganigramaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodoOrganigrama
     */
    select?: NodoOrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodoOrganigramaInclude<ExtArgs> | null
    /**
     * Filter, which NodoOrganigramas to fetch.
     */
    where?: NodoOrganigramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodoOrganigramas to fetch.
     */
    orderBy?: NodoOrganigramaOrderByWithRelationInput | NodoOrganigramaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NodoOrganigramas.
     */
    cursor?: NodoOrganigramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodoOrganigramas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodoOrganigramas.
     */
    skip?: number
    distinct?: NodoOrganigramaScalarFieldEnum | NodoOrganigramaScalarFieldEnum[]
  }

  /**
   * NodoOrganigrama create
   */
  export type NodoOrganigramaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodoOrganigrama
     */
    select?: NodoOrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodoOrganigramaInclude<ExtArgs> | null
    /**
     * The data needed to create a NodoOrganigrama.
     */
    data: XOR<NodoOrganigramaCreateInput, NodoOrganigramaUncheckedCreateInput>
  }

  /**
   * NodoOrganigrama createMany
   */
  export type NodoOrganigramaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NodoOrganigramas.
     */
    data: NodoOrganigramaCreateManyInput | NodoOrganigramaCreateManyInput[]
  }

  /**
   * NodoOrganigrama createManyAndReturn
   */
  export type NodoOrganigramaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodoOrganigrama
     */
    select?: NodoOrganigramaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NodoOrganigramas.
     */
    data: NodoOrganigramaCreateManyInput | NodoOrganigramaCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodoOrganigramaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NodoOrganigrama update
   */
  export type NodoOrganigramaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodoOrganigrama
     */
    select?: NodoOrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodoOrganigramaInclude<ExtArgs> | null
    /**
     * The data needed to update a NodoOrganigrama.
     */
    data: XOR<NodoOrganigramaUpdateInput, NodoOrganigramaUncheckedUpdateInput>
    /**
     * Choose, which NodoOrganigrama to update.
     */
    where: NodoOrganigramaWhereUniqueInput
  }

  /**
   * NodoOrganigrama updateMany
   */
  export type NodoOrganigramaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NodoOrganigramas.
     */
    data: XOR<NodoOrganigramaUpdateManyMutationInput, NodoOrganigramaUncheckedUpdateManyInput>
    /**
     * Filter which NodoOrganigramas to update
     */
    where?: NodoOrganigramaWhereInput
  }

  /**
   * NodoOrganigrama upsert
   */
  export type NodoOrganigramaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodoOrganigrama
     */
    select?: NodoOrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodoOrganigramaInclude<ExtArgs> | null
    /**
     * The filter to search for the NodoOrganigrama to update in case it exists.
     */
    where: NodoOrganigramaWhereUniqueInput
    /**
     * In case the NodoOrganigrama found by the `where` argument doesn't exist, create a new NodoOrganigrama with this data.
     */
    create: XOR<NodoOrganigramaCreateInput, NodoOrganigramaUncheckedCreateInput>
    /**
     * In case the NodoOrganigrama was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NodoOrganigramaUpdateInput, NodoOrganigramaUncheckedUpdateInput>
  }

  /**
   * NodoOrganigrama delete
   */
  export type NodoOrganigramaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodoOrganigrama
     */
    select?: NodoOrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodoOrganigramaInclude<ExtArgs> | null
    /**
     * Filter which NodoOrganigrama to delete.
     */
    where: NodoOrganigramaWhereUniqueInput
  }

  /**
   * NodoOrganigrama deleteMany
   */
  export type NodoOrganigramaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NodoOrganigramas to delete
     */
    where?: NodoOrganigramaWhereInput
  }

  /**
   * NodoOrganigrama.padre
   */
  export type NodoOrganigrama$padreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodoOrganigrama
     */
    select?: NodoOrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodoOrganigramaInclude<ExtArgs> | null
    where?: NodoOrganigramaWhereInput
  }

  /**
   * NodoOrganigrama.subordinados
   */
  export type NodoOrganigrama$subordinadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodoOrganigrama
     */
    select?: NodoOrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodoOrganigramaInclude<ExtArgs> | null
    where?: NodoOrganigramaWhereInput
    orderBy?: NodoOrganigramaOrderByWithRelationInput | NodoOrganigramaOrderByWithRelationInput[]
    cursor?: NodoOrganigramaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NodoOrganigramaScalarFieldEnum | NodoOrganigramaScalarFieldEnum[]
  }

  /**
   * NodoOrganigrama without action
   */
  export type NodoOrganigramaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodoOrganigrama
     */
    select?: NodoOrganigramaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodoOrganigramaInclude<ExtArgs> | null
  }


  /**
   * Model MarcoNormativo
   */

  export type AggregateMarcoNormativo = {
    _count: MarcoNormativoCountAggregateOutputType | null
    _min: MarcoNormativoMinAggregateOutputType | null
    _max: MarcoNormativoMaxAggregateOutputType | null
  }

  export type MarcoNormativoMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    acronimo: string | null
    version: string | null
    fechaVigencia: Date | null
    descripcion: string | null
    activo: boolean | null
    fechaCreacion: Date | null
  }

  export type MarcoNormativoMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    acronimo: string | null
    version: string | null
    fechaVigencia: Date | null
    descripcion: string | null
    activo: boolean | null
    fechaCreacion: Date | null
  }

  export type MarcoNormativoCountAggregateOutputType = {
    id: number
    nombre: number
    acronimo: number
    version: number
    fechaVigencia: number
    descripcion: number
    activo: number
    fechaCreacion: number
    _all: number
  }


  export type MarcoNormativoMinAggregateInputType = {
    id?: true
    nombre?: true
    acronimo?: true
    version?: true
    fechaVigencia?: true
    descripcion?: true
    activo?: true
    fechaCreacion?: true
  }

  export type MarcoNormativoMaxAggregateInputType = {
    id?: true
    nombre?: true
    acronimo?: true
    version?: true
    fechaVigencia?: true
    descripcion?: true
    activo?: true
    fechaCreacion?: true
  }

  export type MarcoNormativoCountAggregateInputType = {
    id?: true
    nombre?: true
    acronimo?: true
    version?: true
    fechaVigencia?: true
    descripcion?: true
    activo?: true
    fechaCreacion?: true
    _all?: true
  }

  export type MarcoNormativoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarcoNormativo to aggregate.
     */
    where?: MarcoNormativoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarcoNormativos to fetch.
     */
    orderBy?: MarcoNormativoOrderByWithRelationInput | MarcoNormativoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarcoNormativoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarcoNormativos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarcoNormativos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarcoNormativos
    **/
    _count?: true | MarcoNormativoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarcoNormativoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarcoNormativoMaxAggregateInputType
  }

  export type GetMarcoNormativoAggregateType<T extends MarcoNormativoAggregateArgs> = {
        [P in keyof T & keyof AggregateMarcoNormativo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarcoNormativo[P]>
      : GetScalarType<T[P], AggregateMarcoNormativo[P]>
  }




  export type MarcoNormativoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarcoNormativoWhereInput
    orderBy?: MarcoNormativoOrderByWithAggregationInput | MarcoNormativoOrderByWithAggregationInput[]
    by: MarcoNormativoScalarFieldEnum[] | MarcoNormativoScalarFieldEnum
    having?: MarcoNormativoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarcoNormativoCountAggregateInputType | true
    _min?: MarcoNormativoMinAggregateInputType
    _max?: MarcoNormativoMaxAggregateInputType
  }

  export type MarcoNormativoGroupByOutputType = {
    id: string
    nombre: string
    acronimo: string
    version: string
    fechaVigencia: Date
    descripcion: string
    activo: boolean
    fechaCreacion: Date
    _count: MarcoNormativoCountAggregateOutputType | null
    _min: MarcoNormativoMinAggregateOutputType | null
    _max: MarcoNormativoMaxAggregateOutputType | null
  }

  type GetMarcoNormativoGroupByPayload<T extends MarcoNormativoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarcoNormativoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarcoNormativoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarcoNormativoGroupByOutputType[P]>
            : GetScalarType<T[P], MarcoNormativoGroupByOutputType[P]>
        }
      >
    >


  export type MarcoNormativoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    acronimo?: boolean
    version?: boolean
    fechaVigencia?: boolean
    descripcion?: boolean
    activo?: boolean
    fechaCreacion?: boolean
    requisitos?: boolean | MarcoNormativo$requisitosArgs<ExtArgs>
    cuestionarios?: boolean | MarcoNormativo$cuestionariosArgs<ExtArgs>
    _count?: boolean | MarcoNormativoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marcoNormativo"]>

  export type MarcoNormativoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    acronimo?: boolean
    version?: boolean
    fechaVigencia?: boolean
    descripcion?: boolean
    activo?: boolean
    fechaCreacion?: boolean
  }, ExtArgs["result"]["marcoNormativo"]>

  export type MarcoNormativoSelectScalar = {
    id?: boolean
    nombre?: boolean
    acronimo?: boolean
    version?: boolean
    fechaVigencia?: boolean
    descripcion?: boolean
    activo?: boolean
    fechaCreacion?: boolean
  }

  export type MarcoNormativoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requisitos?: boolean | MarcoNormativo$requisitosArgs<ExtArgs>
    cuestionarios?: boolean | MarcoNormativo$cuestionariosArgs<ExtArgs>
    _count?: boolean | MarcoNormativoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MarcoNormativoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MarcoNormativoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarcoNormativo"
    objects: {
      requisitos: Prisma.$RequisitoNormativoPayload<ExtArgs>[]
      cuestionarios: Prisma.$CuestionarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      acronimo: string
      version: string
      fechaVigencia: Date
      descripcion: string
      activo: boolean
      fechaCreacion: Date
    }, ExtArgs["result"]["marcoNormativo"]>
    composites: {}
  }

  type MarcoNormativoGetPayload<S extends boolean | null | undefined | MarcoNormativoDefaultArgs> = $Result.GetResult<Prisma.$MarcoNormativoPayload, S>

  type MarcoNormativoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarcoNormativoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarcoNormativoCountAggregateInputType | true
    }

  export interface MarcoNormativoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarcoNormativo'], meta: { name: 'MarcoNormativo' } }
    /**
     * Find zero or one MarcoNormativo that matches the filter.
     * @param {MarcoNormativoFindUniqueArgs} args - Arguments to find a MarcoNormativo
     * @example
     * // Get one MarcoNormativo
     * const marcoNormativo = await prisma.marcoNormativo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarcoNormativoFindUniqueArgs>(args: SelectSubset<T, MarcoNormativoFindUniqueArgs<ExtArgs>>): Prisma__MarcoNormativoClient<$Result.GetResult<Prisma.$MarcoNormativoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MarcoNormativo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarcoNormativoFindUniqueOrThrowArgs} args - Arguments to find a MarcoNormativo
     * @example
     * // Get one MarcoNormativo
     * const marcoNormativo = await prisma.marcoNormativo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarcoNormativoFindUniqueOrThrowArgs>(args: SelectSubset<T, MarcoNormativoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarcoNormativoClient<$Result.GetResult<Prisma.$MarcoNormativoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MarcoNormativo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcoNormativoFindFirstArgs} args - Arguments to find a MarcoNormativo
     * @example
     * // Get one MarcoNormativo
     * const marcoNormativo = await prisma.marcoNormativo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarcoNormativoFindFirstArgs>(args?: SelectSubset<T, MarcoNormativoFindFirstArgs<ExtArgs>>): Prisma__MarcoNormativoClient<$Result.GetResult<Prisma.$MarcoNormativoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MarcoNormativo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcoNormativoFindFirstOrThrowArgs} args - Arguments to find a MarcoNormativo
     * @example
     * // Get one MarcoNormativo
     * const marcoNormativo = await prisma.marcoNormativo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarcoNormativoFindFirstOrThrowArgs>(args?: SelectSubset<T, MarcoNormativoFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarcoNormativoClient<$Result.GetResult<Prisma.$MarcoNormativoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MarcoNormativos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcoNormativoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarcoNormativos
     * const marcoNormativos = await prisma.marcoNormativo.findMany()
     * 
     * // Get first 10 MarcoNormativos
     * const marcoNormativos = await prisma.marcoNormativo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marcoNormativoWithIdOnly = await prisma.marcoNormativo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarcoNormativoFindManyArgs>(args?: SelectSubset<T, MarcoNormativoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarcoNormativoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MarcoNormativo.
     * @param {MarcoNormativoCreateArgs} args - Arguments to create a MarcoNormativo.
     * @example
     * // Create one MarcoNormativo
     * const MarcoNormativo = await prisma.marcoNormativo.create({
     *   data: {
     *     // ... data to create a MarcoNormativo
     *   }
     * })
     * 
     */
    create<T extends MarcoNormativoCreateArgs>(args: SelectSubset<T, MarcoNormativoCreateArgs<ExtArgs>>): Prisma__MarcoNormativoClient<$Result.GetResult<Prisma.$MarcoNormativoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MarcoNormativos.
     * @param {MarcoNormativoCreateManyArgs} args - Arguments to create many MarcoNormativos.
     * @example
     * // Create many MarcoNormativos
     * const marcoNormativo = await prisma.marcoNormativo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarcoNormativoCreateManyArgs>(args?: SelectSubset<T, MarcoNormativoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarcoNormativos and returns the data saved in the database.
     * @param {MarcoNormativoCreateManyAndReturnArgs} args - Arguments to create many MarcoNormativos.
     * @example
     * // Create many MarcoNormativos
     * const marcoNormativo = await prisma.marcoNormativo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarcoNormativos and only return the `id`
     * const marcoNormativoWithIdOnly = await prisma.marcoNormativo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarcoNormativoCreateManyAndReturnArgs>(args?: SelectSubset<T, MarcoNormativoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarcoNormativoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MarcoNormativo.
     * @param {MarcoNormativoDeleteArgs} args - Arguments to delete one MarcoNormativo.
     * @example
     * // Delete one MarcoNormativo
     * const MarcoNormativo = await prisma.marcoNormativo.delete({
     *   where: {
     *     // ... filter to delete one MarcoNormativo
     *   }
     * })
     * 
     */
    delete<T extends MarcoNormativoDeleteArgs>(args: SelectSubset<T, MarcoNormativoDeleteArgs<ExtArgs>>): Prisma__MarcoNormativoClient<$Result.GetResult<Prisma.$MarcoNormativoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MarcoNormativo.
     * @param {MarcoNormativoUpdateArgs} args - Arguments to update one MarcoNormativo.
     * @example
     * // Update one MarcoNormativo
     * const marcoNormativo = await prisma.marcoNormativo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarcoNormativoUpdateArgs>(args: SelectSubset<T, MarcoNormativoUpdateArgs<ExtArgs>>): Prisma__MarcoNormativoClient<$Result.GetResult<Prisma.$MarcoNormativoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MarcoNormativos.
     * @param {MarcoNormativoDeleteManyArgs} args - Arguments to filter MarcoNormativos to delete.
     * @example
     * // Delete a few MarcoNormativos
     * const { count } = await prisma.marcoNormativo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarcoNormativoDeleteManyArgs>(args?: SelectSubset<T, MarcoNormativoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarcoNormativos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcoNormativoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarcoNormativos
     * const marcoNormativo = await prisma.marcoNormativo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarcoNormativoUpdateManyArgs>(args: SelectSubset<T, MarcoNormativoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarcoNormativo.
     * @param {MarcoNormativoUpsertArgs} args - Arguments to update or create a MarcoNormativo.
     * @example
     * // Update or create a MarcoNormativo
     * const marcoNormativo = await prisma.marcoNormativo.upsert({
     *   create: {
     *     // ... data to create a MarcoNormativo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarcoNormativo we want to update
     *   }
     * })
     */
    upsert<T extends MarcoNormativoUpsertArgs>(args: SelectSubset<T, MarcoNormativoUpsertArgs<ExtArgs>>): Prisma__MarcoNormativoClient<$Result.GetResult<Prisma.$MarcoNormativoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MarcoNormativos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcoNormativoCountArgs} args - Arguments to filter MarcoNormativos to count.
     * @example
     * // Count the number of MarcoNormativos
     * const count = await prisma.marcoNormativo.count({
     *   where: {
     *     // ... the filter for the MarcoNormativos we want to count
     *   }
     * })
    **/
    count<T extends MarcoNormativoCountArgs>(
      args?: Subset<T, MarcoNormativoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarcoNormativoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarcoNormativo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcoNormativoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarcoNormativoAggregateArgs>(args: Subset<T, MarcoNormativoAggregateArgs>): Prisma.PrismaPromise<GetMarcoNormativoAggregateType<T>>

    /**
     * Group by MarcoNormativo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcoNormativoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarcoNormativoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarcoNormativoGroupByArgs['orderBy'] }
        : { orderBy?: MarcoNormativoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarcoNormativoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarcoNormativoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarcoNormativo model
   */
  readonly fields: MarcoNormativoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarcoNormativo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarcoNormativoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requisitos<T extends MarcoNormativo$requisitosArgs<ExtArgs> = {}>(args?: Subset<T, MarcoNormativo$requisitosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequisitoNormativoPayload<ExtArgs>, T, "findMany"> | Null>
    cuestionarios<T extends MarcoNormativo$cuestionariosArgs<ExtArgs> = {}>(args?: Subset<T, MarcoNormativo$cuestionariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CuestionarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarcoNormativo model
   */ 
  interface MarcoNormativoFieldRefs {
    readonly id: FieldRef<"MarcoNormativo", 'String'>
    readonly nombre: FieldRef<"MarcoNormativo", 'String'>
    readonly acronimo: FieldRef<"MarcoNormativo", 'String'>
    readonly version: FieldRef<"MarcoNormativo", 'String'>
    readonly fechaVigencia: FieldRef<"MarcoNormativo", 'DateTime'>
    readonly descripcion: FieldRef<"MarcoNormativo", 'String'>
    readonly activo: FieldRef<"MarcoNormativo", 'Boolean'>
    readonly fechaCreacion: FieldRef<"MarcoNormativo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarcoNormativo findUnique
   */
  export type MarcoNormativoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarcoNormativo
     */
    select?: MarcoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcoNormativoInclude<ExtArgs> | null
    /**
     * Filter, which MarcoNormativo to fetch.
     */
    where: MarcoNormativoWhereUniqueInput
  }

  /**
   * MarcoNormativo findUniqueOrThrow
   */
  export type MarcoNormativoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarcoNormativo
     */
    select?: MarcoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcoNormativoInclude<ExtArgs> | null
    /**
     * Filter, which MarcoNormativo to fetch.
     */
    where: MarcoNormativoWhereUniqueInput
  }

  /**
   * MarcoNormativo findFirst
   */
  export type MarcoNormativoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarcoNormativo
     */
    select?: MarcoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcoNormativoInclude<ExtArgs> | null
    /**
     * Filter, which MarcoNormativo to fetch.
     */
    where?: MarcoNormativoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarcoNormativos to fetch.
     */
    orderBy?: MarcoNormativoOrderByWithRelationInput | MarcoNormativoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarcoNormativos.
     */
    cursor?: MarcoNormativoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarcoNormativos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarcoNormativos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarcoNormativos.
     */
    distinct?: MarcoNormativoScalarFieldEnum | MarcoNormativoScalarFieldEnum[]
  }

  /**
   * MarcoNormativo findFirstOrThrow
   */
  export type MarcoNormativoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarcoNormativo
     */
    select?: MarcoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcoNormativoInclude<ExtArgs> | null
    /**
     * Filter, which MarcoNormativo to fetch.
     */
    where?: MarcoNormativoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarcoNormativos to fetch.
     */
    orderBy?: MarcoNormativoOrderByWithRelationInput | MarcoNormativoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarcoNormativos.
     */
    cursor?: MarcoNormativoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarcoNormativos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarcoNormativos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarcoNormativos.
     */
    distinct?: MarcoNormativoScalarFieldEnum | MarcoNormativoScalarFieldEnum[]
  }

  /**
   * MarcoNormativo findMany
   */
  export type MarcoNormativoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarcoNormativo
     */
    select?: MarcoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcoNormativoInclude<ExtArgs> | null
    /**
     * Filter, which MarcoNormativos to fetch.
     */
    where?: MarcoNormativoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarcoNormativos to fetch.
     */
    orderBy?: MarcoNormativoOrderByWithRelationInput | MarcoNormativoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarcoNormativos.
     */
    cursor?: MarcoNormativoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarcoNormativos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarcoNormativos.
     */
    skip?: number
    distinct?: MarcoNormativoScalarFieldEnum | MarcoNormativoScalarFieldEnum[]
  }

  /**
   * MarcoNormativo create
   */
  export type MarcoNormativoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarcoNormativo
     */
    select?: MarcoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcoNormativoInclude<ExtArgs> | null
    /**
     * The data needed to create a MarcoNormativo.
     */
    data: XOR<MarcoNormativoCreateInput, MarcoNormativoUncheckedCreateInput>
  }

  /**
   * MarcoNormativo createMany
   */
  export type MarcoNormativoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarcoNormativos.
     */
    data: MarcoNormativoCreateManyInput | MarcoNormativoCreateManyInput[]
  }

  /**
   * MarcoNormativo createManyAndReturn
   */
  export type MarcoNormativoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarcoNormativo
     */
    select?: MarcoNormativoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MarcoNormativos.
     */
    data: MarcoNormativoCreateManyInput | MarcoNormativoCreateManyInput[]
  }

  /**
   * MarcoNormativo update
   */
  export type MarcoNormativoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarcoNormativo
     */
    select?: MarcoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcoNormativoInclude<ExtArgs> | null
    /**
     * The data needed to update a MarcoNormativo.
     */
    data: XOR<MarcoNormativoUpdateInput, MarcoNormativoUncheckedUpdateInput>
    /**
     * Choose, which MarcoNormativo to update.
     */
    where: MarcoNormativoWhereUniqueInput
  }

  /**
   * MarcoNormativo updateMany
   */
  export type MarcoNormativoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarcoNormativos.
     */
    data: XOR<MarcoNormativoUpdateManyMutationInput, MarcoNormativoUncheckedUpdateManyInput>
    /**
     * Filter which MarcoNormativos to update
     */
    where?: MarcoNormativoWhereInput
  }

  /**
   * MarcoNormativo upsert
   */
  export type MarcoNormativoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarcoNormativo
     */
    select?: MarcoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcoNormativoInclude<ExtArgs> | null
    /**
     * The filter to search for the MarcoNormativo to update in case it exists.
     */
    where: MarcoNormativoWhereUniqueInput
    /**
     * In case the MarcoNormativo found by the `where` argument doesn't exist, create a new MarcoNormativo with this data.
     */
    create: XOR<MarcoNormativoCreateInput, MarcoNormativoUncheckedCreateInput>
    /**
     * In case the MarcoNormativo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarcoNormativoUpdateInput, MarcoNormativoUncheckedUpdateInput>
  }

  /**
   * MarcoNormativo delete
   */
  export type MarcoNormativoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarcoNormativo
     */
    select?: MarcoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcoNormativoInclude<ExtArgs> | null
    /**
     * Filter which MarcoNormativo to delete.
     */
    where: MarcoNormativoWhereUniqueInput
  }

  /**
   * MarcoNormativo deleteMany
   */
  export type MarcoNormativoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarcoNormativos to delete
     */
    where?: MarcoNormativoWhereInput
  }

  /**
   * MarcoNormativo.requisitos
   */
  export type MarcoNormativo$requisitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequisitoNormativo
     */
    select?: RequisitoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitoNormativoInclude<ExtArgs> | null
    where?: RequisitoNormativoWhereInput
    orderBy?: RequisitoNormativoOrderByWithRelationInput | RequisitoNormativoOrderByWithRelationInput[]
    cursor?: RequisitoNormativoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequisitoNormativoScalarFieldEnum | RequisitoNormativoScalarFieldEnum[]
  }

  /**
   * MarcoNormativo.cuestionarios
   */
  export type MarcoNormativo$cuestionariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuestionario
     */
    select?: CuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuestionarioInclude<ExtArgs> | null
    where?: CuestionarioWhereInput
    orderBy?: CuestionarioOrderByWithRelationInput | CuestionarioOrderByWithRelationInput[]
    cursor?: CuestionarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CuestionarioScalarFieldEnum | CuestionarioScalarFieldEnum[]
  }

  /**
   * MarcoNormativo without action
   */
  export type MarcoNormativoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarcoNormativo
     */
    select?: MarcoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcoNormativoInclude<ExtArgs> | null
  }


  /**
   * Model RequisitoNormativo
   */

  export type AggregateRequisitoNormativo = {
    _count: RequisitoNormativoCountAggregateOutputType | null
    _min: RequisitoNormativoMinAggregateOutputType | null
    _max: RequisitoNormativoMaxAggregateOutputType | null
  }

  export type RequisitoNormativoMinAggregateOutputType = {
    id: string | null
    codigo: string | null
    nombre: string | null
    descripcion: string | null
    marcoId: string | null
    controlesAsociados: string | null
  }

  export type RequisitoNormativoMaxAggregateOutputType = {
    id: string | null
    codigo: string | null
    nombre: string | null
    descripcion: string | null
    marcoId: string | null
    controlesAsociados: string | null
  }

  export type RequisitoNormativoCountAggregateOutputType = {
    id: number
    codigo: number
    nombre: number
    descripcion: number
    marcoId: number
    controlesAsociados: number
    _all: number
  }


  export type RequisitoNormativoMinAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    descripcion?: true
    marcoId?: true
    controlesAsociados?: true
  }

  export type RequisitoNormativoMaxAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    descripcion?: true
    marcoId?: true
    controlesAsociados?: true
  }

  export type RequisitoNormativoCountAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    descripcion?: true
    marcoId?: true
    controlesAsociados?: true
    _all?: true
  }

  export type RequisitoNormativoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequisitoNormativo to aggregate.
     */
    where?: RequisitoNormativoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequisitoNormativos to fetch.
     */
    orderBy?: RequisitoNormativoOrderByWithRelationInput | RequisitoNormativoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequisitoNormativoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequisitoNormativos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequisitoNormativos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequisitoNormativos
    **/
    _count?: true | RequisitoNormativoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequisitoNormativoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequisitoNormativoMaxAggregateInputType
  }

  export type GetRequisitoNormativoAggregateType<T extends RequisitoNormativoAggregateArgs> = {
        [P in keyof T & keyof AggregateRequisitoNormativo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequisitoNormativo[P]>
      : GetScalarType<T[P], AggregateRequisitoNormativo[P]>
  }




  export type RequisitoNormativoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequisitoNormativoWhereInput
    orderBy?: RequisitoNormativoOrderByWithAggregationInput | RequisitoNormativoOrderByWithAggregationInput[]
    by: RequisitoNormativoScalarFieldEnum[] | RequisitoNormativoScalarFieldEnum
    having?: RequisitoNormativoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequisitoNormativoCountAggregateInputType | true
    _min?: RequisitoNormativoMinAggregateInputType
    _max?: RequisitoNormativoMaxAggregateInputType
  }

  export type RequisitoNormativoGroupByOutputType = {
    id: string
    codigo: string
    nombre: string
    descripcion: string
    marcoId: string
    controlesAsociados: string
    _count: RequisitoNormativoCountAggregateOutputType | null
    _min: RequisitoNormativoMinAggregateOutputType | null
    _max: RequisitoNormativoMaxAggregateOutputType | null
  }

  type GetRequisitoNormativoGroupByPayload<T extends RequisitoNormativoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequisitoNormativoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequisitoNormativoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequisitoNormativoGroupByOutputType[P]>
            : GetScalarType<T[P], RequisitoNormativoGroupByOutputType[P]>
        }
      >
    >


  export type RequisitoNormativoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    marcoId?: boolean
    controlesAsociados?: boolean
    marco?: boolean | MarcoNormativoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requisitoNormativo"]>

  export type RequisitoNormativoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    marcoId?: boolean
    controlesAsociados?: boolean
    marco?: boolean | MarcoNormativoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requisitoNormativo"]>

  export type RequisitoNormativoSelectScalar = {
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    marcoId?: boolean
    controlesAsociados?: boolean
  }

  export type RequisitoNormativoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marco?: boolean | MarcoNormativoDefaultArgs<ExtArgs>
  }
  export type RequisitoNormativoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marco?: boolean | MarcoNormativoDefaultArgs<ExtArgs>
  }

  export type $RequisitoNormativoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequisitoNormativo"
    objects: {
      marco: Prisma.$MarcoNormativoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      codigo: string
      nombre: string
      descripcion: string
      marcoId: string
      controlesAsociados: string
    }, ExtArgs["result"]["requisitoNormativo"]>
    composites: {}
  }

  type RequisitoNormativoGetPayload<S extends boolean | null | undefined | RequisitoNormativoDefaultArgs> = $Result.GetResult<Prisma.$RequisitoNormativoPayload, S>

  type RequisitoNormativoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RequisitoNormativoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RequisitoNormativoCountAggregateInputType | true
    }

  export interface RequisitoNormativoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequisitoNormativo'], meta: { name: 'RequisitoNormativo' } }
    /**
     * Find zero or one RequisitoNormativo that matches the filter.
     * @param {RequisitoNormativoFindUniqueArgs} args - Arguments to find a RequisitoNormativo
     * @example
     * // Get one RequisitoNormativo
     * const requisitoNormativo = await prisma.requisitoNormativo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequisitoNormativoFindUniqueArgs>(args: SelectSubset<T, RequisitoNormativoFindUniqueArgs<ExtArgs>>): Prisma__RequisitoNormativoClient<$Result.GetResult<Prisma.$RequisitoNormativoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RequisitoNormativo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RequisitoNormativoFindUniqueOrThrowArgs} args - Arguments to find a RequisitoNormativo
     * @example
     * // Get one RequisitoNormativo
     * const requisitoNormativo = await prisma.requisitoNormativo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequisitoNormativoFindUniqueOrThrowArgs>(args: SelectSubset<T, RequisitoNormativoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequisitoNormativoClient<$Result.GetResult<Prisma.$RequisitoNormativoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RequisitoNormativo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequisitoNormativoFindFirstArgs} args - Arguments to find a RequisitoNormativo
     * @example
     * // Get one RequisitoNormativo
     * const requisitoNormativo = await prisma.requisitoNormativo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequisitoNormativoFindFirstArgs>(args?: SelectSubset<T, RequisitoNormativoFindFirstArgs<ExtArgs>>): Prisma__RequisitoNormativoClient<$Result.GetResult<Prisma.$RequisitoNormativoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RequisitoNormativo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequisitoNormativoFindFirstOrThrowArgs} args - Arguments to find a RequisitoNormativo
     * @example
     * // Get one RequisitoNormativo
     * const requisitoNormativo = await prisma.requisitoNormativo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequisitoNormativoFindFirstOrThrowArgs>(args?: SelectSubset<T, RequisitoNormativoFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequisitoNormativoClient<$Result.GetResult<Prisma.$RequisitoNormativoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RequisitoNormativos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequisitoNormativoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequisitoNormativos
     * const requisitoNormativos = await prisma.requisitoNormativo.findMany()
     * 
     * // Get first 10 RequisitoNormativos
     * const requisitoNormativos = await prisma.requisitoNormativo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requisitoNormativoWithIdOnly = await prisma.requisitoNormativo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequisitoNormativoFindManyArgs>(args?: SelectSubset<T, RequisitoNormativoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequisitoNormativoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RequisitoNormativo.
     * @param {RequisitoNormativoCreateArgs} args - Arguments to create a RequisitoNormativo.
     * @example
     * // Create one RequisitoNormativo
     * const RequisitoNormativo = await prisma.requisitoNormativo.create({
     *   data: {
     *     // ... data to create a RequisitoNormativo
     *   }
     * })
     * 
     */
    create<T extends RequisitoNormativoCreateArgs>(args: SelectSubset<T, RequisitoNormativoCreateArgs<ExtArgs>>): Prisma__RequisitoNormativoClient<$Result.GetResult<Prisma.$RequisitoNormativoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RequisitoNormativos.
     * @param {RequisitoNormativoCreateManyArgs} args - Arguments to create many RequisitoNormativos.
     * @example
     * // Create many RequisitoNormativos
     * const requisitoNormativo = await prisma.requisitoNormativo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequisitoNormativoCreateManyArgs>(args?: SelectSubset<T, RequisitoNormativoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequisitoNormativos and returns the data saved in the database.
     * @param {RequisitoNormativoCreateManyAndReturnArgs} args - Arguments to create many RequisitoNormativos.
     * @example
     * // Create many RequisitoNormativos
     * const requisitoNormativo = await prisma.requisitoNormativo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequisitoNormativos and only return the `id`
     * const requisitoNormativoWithIdOnly = await prisma.requisitoNormativo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequisitoNormativoCreateManyAndReturnArgs>(args?: SelectSubset<T, RequisitoNormativoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequisitoNormativoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RequisitoNormativo.
     * @param {RequisitoNormativoDeleteArgs} args - Arguments to delete one RequisitoNormativo.
     * @example
     * // Delete one RequisitoNormativo
     * const RequisitoNormativo = await prisma.requisitoNormativo.delete({
     *   where: {
     *     // ... filter to delete one RequisitoNormativo
     *   }
     * })
     * 
     */
    delete<T extends RequisitoNormativoDeleteArgs>(args: SelectSubset<T, RequisitoNormativoDeleteArgs<ExtArgs>>): Prisma__RequisitoNormativoClient<$Result.GetResult<Prisma.$RequisitoNormativoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RequisitoNormativo.
     * @param {RequisitoNormativoUpdateArgs} args - Arguments to update one RequisitoNormativo.
     * @example
     * // Update one RequisitoNormativo
     * const requisitoNormativo = await prisma.requisitoNormativo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequisitoNormativoUpdateArgs>(args: SelectSubset<T, RequisitoNormativoUpdateArgs<ExtArgs>>): Prisma__RequisitoNormativoClient<$Result.GetResult<Prisma.$RequisitoNormativoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RequisitoNormativos.
     * @param {RequisitoNormativoDeleteManyArgs} args - Arguments to filter RequisitoNormativos to delete.
     * @example
     * // Delete a few RequisitoNormativos
     * const { count } = await prisma.requisitoNormativo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequisitoNormativoDeleteManyArgs>(args?: SelectSubset<T, RequisitoNormativoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequisitoNormativos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequisitoNormativoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequisitoNormativos
     * const requisitoNormativo = await prisma.requisitoNormativo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequisitoNormativoUpdateManyArgs>(args: SelectSubset<T, RequisitoNormativoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RequisitoNormativo.
     * @param {RequisitoNormativoUpsertArgs} args - Arguments to update or create a RequisitoNormativo.
     * @example
     * // Update or create a RequisitoNormativo
     * const requisitoNormativo = await prisma.requisitoNormativo.upsert({
     *   create: {
     *     // ... data to create a RequisitoNormativo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequisitoNormativo we want to update
     *   }
     * })
     */
    upsert<T extends RequisitoNormativoUpsertArgs>(args: SelectSubset<T, RequisitoNormativoUpsertArgs<ExtArgs>>): Prisma__RequisitoNormativoClient<$Result.GetResult<Prisma.$RequisitoNormativoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RequisitoNormativos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequisitoNormativoCountArgs} args - Arguments to filter RequisitoNormativos to count.
     * @example
     * // Count the number of RequisitoNormativos
     * const count = await prisma.requisitoNormativo.count({
     *   where: {
     *     // ... the filter for the RequisitoNormativos we want to count
     *   }
     * })
    **/
    count<T extends RequisitoNormativoCountArgs>(
      args?: Subset<T, RequisitoNormativoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequisitoNormativoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequisitoNormativo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequisitoNormativoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequisitoNormativoAggregateArgs>(args: Subset<T, RequisitoNormativoAggregateArgs>): Prisma.PrismaPromise<GetRequisitoNormativoAggregateType<T>>

    /**
     * Group by RequisitoNormativo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequisitoNormativoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequisitoNormativoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequisitoNormativoGroupByArgs['orderBy'] }
        : { orderBy?: RequisitoNormativoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequisitoNormativoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequisitoNormativoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequisitoNormativo model
   */
  readonly fields: RequisitoNormativoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequisitoNormativo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequisitoNormativoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    marco<T extends MarcoNormativoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarcoNormativoDefaultArgs<ExtArgs>>): Prisma__MarcoNormativoClient<$Result.GetResult<Prisma.$MarcoNormativoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequisitoNormativo model
   */ 
  interface RequisitoNormativoFieldRefs {
    readonly id: FieldRef<"RequisitoNormativo", 'String'>
    readonly codigo: FieldRef<"RequisitoNormativo", 'String'>
    readonly nombre: FieldRef<"RequisitoNormativo", 'String'>
    readonly descripcion: FieldRef<"RequisitoNormativo", 'String'>
    readonly marcoId: FieldRef<"RequisitoNormativo", 'String'>
    readonly controlesAsociados: FieldRef<"RequisitoNormativo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RequisitoNormativo findUnique
   */
  export type RequisitoNormativoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequisitoNormativo
     */
    select?: RequisitoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitoNormativoInclude<ExtArgs> | null
    /**
     * Filter, which RequisitoNormativo to fetch.
     */
    where: RequisitoNormativoWhereUniqueInput
  }

  /**
   * RequisitoNormativo findUniqueOrThrow
   */
  export type RequisitoNormativoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequisitoNormativo
     */
    select?: RequisitoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitoNormativoInclude<ExtArgs> | null
    /**
     * Filter, which RequisitoNormativo to fetch.
     */
    where: RequisitoNormativoWhereUniqueInput
  }

  /**
   * RequisitoNormativo findFirst
   */
  export type RequisitoNormativoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequisitoNormativo
     */
    select?: RequisitoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitoNormativoInclude<ExtArgs> | null
    /**
     * Filter, which RequisitoNormativo to fetch.
     */
    where?: RequisitoNormativoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequisitoNormativos to fetch.
     */
    orderBy?: RequisitoNormativoOrderByWithRelationInput | RequisitoNormativoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequisitoNormativos.
     */
    cursor?: RequisitoNormativoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequisitoNormativos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequisitoNormativos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequisitoNormativos.
     */
    distinct?: RequisitoNormativoScalarFieldEnum | RequisitoNormativoScalarFieldEnum[]
  }

  /**
   * RequisitoNormativo findFirstOrThrow
   */
  export type RequisitoNormativoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequisitoNormativo
     */
    select?: RequisitoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitoNormativoInclude<ExtArgs> | null
    /**
     * Filter, which RequisitoNormativo to fetch.
     */
    where?: RequisitoNormativoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequisitoNormativos to fetch.
     */
    orderBy?: RequisitoNormativoOrderByWithRelationInput | RequisitoNormativoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequisitoNormativos.
     */
    cursor?: RequisitoNormativoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequisitoNormativos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequisitoNormativos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequisitoNormativos.
     */
    distinct?: RequisitoNormativoScalarFieldEnum | RequisitoNormativoScalarFieldEnum[]
  }

  /**
   * RequisitoNormativo findMany
   */
  export type RequisitoNormativoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequisitoNormativo
     */
    select?: RequisitoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitoNormativoInclude<ExtArgs> | null
    /**
     * Filter, which RequisitoNormativos to fetch.
     */
    where?: RequisitoNormativoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequisitoNormativos to fetch.
     */
    orderBy?: RequisitoNormativoOrderByWithRelationInput | RequisitoNormativoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequisitoNormativos.
     */
    cursor?: RequisitoNormativoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequisitoNormativos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequisitoNormativos.
     */
    skip?: number
    distinct?: RequisitoNormativoScalarFieldEnum | RequisitoNormativoScalarFieldEnum[]
  }

  /**
   * RequisitoNormativo create
   */
  export type RequisitoNormativoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequisitoNormativo
     */
    select?: RequisitoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitoNormativoInclude<ExtArgs> | null
    /**
     * The data needed to create a RequisitoNormativo.
     */
    data: XOR<RequisitoNormativoCreateInput, RequisitoNormativoUncheckedCreateInput>
  }

  /**
   * RequisitoNormativo createMany
   */
  export type RequisitoNormativoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequisitoNormativos.
     */
    data: RequisitoNormativoCreateManyInput | RequisitoNormativoCreateManyInput[]
  }

  /**
   * RequisitoNormativo createManyAndReturn
   */
  export type RequisitoNormativoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequisitoNormativo
     */
    select?: RequisitoNormativoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RequisitoNormativos.
     */
    data: RequisitoNormativoCreateManyInput | RequisitoNormativoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitoNormativoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequisitoNormativo update
   */
  export type RequisitoNormativoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequisitoNormativo
     */
    select?: RequisitoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitoNormativoInclude<ExtArgs> | null
    /**
     * The data needed to update a RequisitoNormativo.
     */
    data: XOR<RequisitoNormativoUpdateInput, RequisitoNormativoUncheckedUpdateInput>
    /**
     * Choose, which RequisitoNormativo to update.
     */
    where: RequisitoNormativoWhereUniqueInput
  }

  /**
   * RequisitoNormativo updateMany
   */
  export type RequisitoNormativoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequisitoNormativos.
     */
    data: XOR<RequisitoNormativoUpdateManyMutationInput, RequisitoNormativoUncheckedUpdateManyInput>
    /**
     * Filter which RequisitoNormativos to update
     */
    where?: RequisitoNormativoWhereInput
  }

  /**
   * RequisitoNormativo upsert
   */
  export type RequisitoNormativoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequisitoNormativo
     */
    select?: RequisitoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitoNormativoInclude<ExtArgs> | null
    /**
     * The filter to search for the RequisitoNormativo to update in case it exists.
     */
    where: RequisitoNormativoWhereUniqueInput
    /**
     * In case the RequisitoNormativo found by the `where` argument doesn't exist, create a new RequisitoNormativo with this data.
     */
    create: XOR<RequisitoNormativoCreateInput, RequisitoNormativoUncheckedCreateInput>
    /**
     * In case the RequisitoNormativo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequisitoNormativoUpdateInput, RequisitoNormativoUncheckedUpdateInput>
  }

  /**
   * RequisitoNormativo delete
   */
  export type RequisitoNormativoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequisitoNormativo
     */
    select?: RequisitoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitoNormativoInclude<ExtArgs> | null
    /**
     * Filter which RequisitoNormativo to delete.
     */
    where: RequisitoNormativoWhereUniqueInput
  }

  /**
   * RequisitoNormativo deleteMany
   */
  export type RequisitoNormativoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequisitoNormativos to delete
     */
    where?: RequisitoNormativoWhereInput
  }

  /**
   * RequisitoNormativo without action
   */
  export type RequisitoNormativoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequisitoNormativo
     */
    select?: RequisitoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitoNormativoInclude<ExtArgs> | null
  }


  /**
   * Model Cuestionario
   */

  export type AggregateCuestionario = {
    _count: CuestionarioCountAggregateOutputType | null
    _avg: CuestionarioAvgAggregateOutputType | null
    _sum: CuestionarioSumAggregateOutputType | null
    _min: CuestionarioMinAggregateOutputType | null
    _max: CuestionarioMaxAggregateOutputType | null
  }

  export type CuestionarioAvgAggregateOutputType = {
    tasaCompletado: number | null
  }

  export type CuestionarioSumAggregateOutputType = {
    tasaCompletado: number | null
  }

  export type CuestionarioMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    categoria: string | null
    tipo: string | null
    tipoEvaluacion: string | null
    estado: string | null
    marcoNormativoId: string | null
    periodicidad: string | null
    tasaCompletado: number | null
    fechaCreacion: Date | null
    fechaModificacion: Date | null
    umbrales: string | null
    areasObjetivo: string | null
    responsables: string | null
  }

  export type CuestionarioMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    categoria: string | null
    tipo: string | null
    tipoEvaluacion: string | null
    estado: string | null
    marcoNormativoId: string | null
    periodicidad: string | null
    tasaCompletado: number | null
    fechaCreacion: Date | null
    fechaModificacion: Date | null
    umbrales: string | null
    areasObjetivo: string | null
    responsables: string | null
  }

  export type CuestionarioCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    categoria: number
    tipo: number
    tipoEvaluacion: number
    estado: number
    marcoNormativoId: number
    periodicidad: number
    tasaCompletado: number
    fechaCreacion: number
    fechaModificacion: number
    umbrales: number
    areasObjetivo: number
    responsables: number
    _all: number
  }


  export type CuestionarioAvgAggregateInputType = {
    tasaCompletado?: true
  }

  export type CuestionarioSumAggregateInputType = {
    tasaCompletado?: true
  }

  export type CuestionarioMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    categoria?: true
    tipo?: true
    tipoEvaluacion?: true
    estado?: true
    marcoNormativoId?: true
    periodicidad?: true
    tasaCompletado?: true
    fechaCreacion?: true
    fechaModificacion?: true
    umbrales?: true
    areasObjetivo?: true
    responsables?: true
  }

  export type CuestionarioMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    categoria?: true
    tipo?: true
    tipoEvaluacion?: true
    estado?: true
    marcoNormativoId?: true
    periodicidad?: true
    tasaCompletado?: true
    fechaCreacion?: true
    fechaModificacion?: true
    umbrales?: true
    areasObjetivo?: true
    responsables?: true
  }

  export type CuestionarioCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    categoria?: true
    tipo?: true
    tipoEvaluacion?: true
    estado?: true
    marcoNormativoId?: true
    periodicidad?: true
    tasaCompletado?: true
    fechaCreacion?: true
    fechaModificacion?: true
    umbrales?: true
    areasObjetivo?: true
    responsables?: true
    _all?: true
  }

  export type CuestionarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cuestionario to aggregate.
     */
    where?: CuestionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuestionarios to fetch.
     */
    orderBy?: CuestionarioOrderByWithRelationInput | CuestionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CuestionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuestionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuestionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cuestionarios
    **/
    _count?: true | CuestionarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CuestionarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CuestionarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CuestionarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CuestionarioMaxAggregateInputType
  }

  export type GetCuestionarioAggregateType<T extends CuestionarioAggregateArgs> = {
        [P in keyof T & keyof AggregateCuestionario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCuestionario[P]>
      : GetScalarType<T[P], AggregateCuestionario[P]>
  }




  export type CuestionarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CuestionarioWhereInput
    orderBy?: CuestionarioOrderByWithAggregationInput | CuestionarioOrderByWithAggregationInput[]
    by: CuestionarioScalarFieldEnum[] | CuestionarioScalarFieldEnum
    having?: CuestionarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CuestionarioCountAggregateInputType | true
    _avg?: CuestionarioAvgAggregateInputType
    _sum?: CuestionarioSumAggregateInputType
    _min?: CuestionarioMinAggregateInputType
    _max?: CuestionarioMaxAggregateInputType
  }

  export type CuestionarioGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string
    categoria: string
    tipo: string
    tipoEvaluacion: string
    estado: string
    marcoNormativoId: string | null
    periodicidad: string
    tasaCompletado: number
    fechaCreacion: Date
    fechaModificacion: Date
    umbrales: string
    areasObjetivo: string
    responsables: string
    _count: CuestionarioCountAggregateOutputType | null
    _avg: CuestionarioAvgAggregateOutputType | null
    _sum: CuestionarioSumAggregateOutputType | null
    _min: CuestionarioMinAggregateOutputType | null
    _max: CuestionarioMaxAggregateOutputType | null
  }

  type GetCuestionarioGroupByPayload<T extends CuestionarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CuestionarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CuestionarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CuestionarioGroupByOutputType[P]>
            : GetScalarType<T[P], CuestionarioGroupByOutputType[P]>
        }
      >
    >


  export type CuestionarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    categoria?: boolean
    tipo?: boolean
    tipoEvaluacion?: boolean
    estado?: boolean
    marcoNormativoId?: boolean
    periodicidad?: boolean
    tasaCompletado?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
    umbrales?: boolean
    areasObjetivo?: boolean
    responsables?: boolean
    marcoNormativo?: boolean | Cuestionario$marcoNormativoArgs<ExtArgs>
    secciones?: boolean | Cuestionario$seccionesArgs<ExtArgs>
    asignaciones?: boolean | Cuestionario$asignacionesArgs<ExtArgs>
    _count?: boolean | CuestionarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cuestionario"]>

  export type CuestionarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    categoria?: boolean
    tipo?: boolean
    tipoEvaluacion?: boolean
    estado?: boolean
    marcoNormativoId?: boolean
    periodicidad?: boolean
    tasaCompletado?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
    umbrales?: boolean
    areasObjetivo?: boolean
    responsables?: boolean
    marcoNormativo?: boolean | Cuestionario$marcoNormativoArgs<ExtArgs>
  }, ExtArgs["result"]["cuestionario"]>

  export type CuestionarioSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    categoria?: boolean
    tipo?: boolean
    tipoEvaluacion?: boolean
    estado?: boolean
    marcoNormativoId?: boolean
    periodicidad?: boolean
    tasaCompletado?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
    umbrales?: boolean
    areasObjetivo?: boolean
    responsables?: boolean
  }

  export type CuestionarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marcoNormativo?: boolean | Cuestionario$marcoNormativoArgs<ExtArgs>
    secciones?: boolean | Cuestionario$seccionesArgs<ExtArgs>
    asignaciones?: boolean | Cuestionario$asignacionesArgs<ExtArgs>
    _count?: boolean | CuestionarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CuestionarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marcoNormativo?: boolean | Cuestionario$marcoNormativoArgs<ExtArgs>
  }

  export type $CuestionarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cuestionario"
    objects: {
      marcoNormativo: Prisma.$MarcoNormativoPayload<ExtArgs> | null
      secciones: Prisma.$SeccionPayload<ExtArgs>[]
      asignaciones: Prisma.$AsignacionCuestionarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      descripcion: string
      categoria: string
      tipo: string
      tipoEvaluacion: string
      estado: string
      marcoNormativoId: string | null
      periodicidad: string
      tasaCompletado: number
      fechaCreacion: Date
      fechaModificacion: Date
      umbrales: string
      areasObjetivo: string
      responsables: string
    }, ExtArgs["result"]["cuestionario"]>
    composites: {}
  }

  type CuestionarioGetPayload<S extends boolean | null | undefined | CuestionarioDefaultArgs> = $Result.GetResult<Prisma.$CuestionarioPayload, S>

  type CuestionarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CuestionarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CuestionarioCountAggregateInputType | true
    }

  export interface CuestionarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cuestionario'], meta: { name: 'Cuestionario' } }
    /**
     * Find zero or one Cuestionario that matches the filter.
     * @param {CuestionarioFindUniqueArgs} args - Arguments to find a Cuestionario
     * @example
     * // Get one Cuestionario
     * const cuestionario = await prisma.cuestionario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CuestionarioFindUniqueArgs>(args: SelectSubset<T, CuestionarioFindUniqueArgs<ExtArgs>>): Prisma__CuestionarioClient<$Result.GetResult<Prisma.$CuestionarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cuestionario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CuestionarioFindUniqueOrThrowArgs} args - Arguments to find a Cuestionario
     * @example
     * // Get one Cuestionario
     * const cuestionario = await prisma.cuestionario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CuestionarioFindUniqueOrThrowArgs>(args: SelectSubset<T, CuestionarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CuestionarioClient<$Result.GetResult<Prisma.$CuestionarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cuestionario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuestionarioFindFirstArgs} args - Arguments to find a Cuestionario
     * @example
     * // Get one Cuestionario
     * const cuestionario = await prisma.cuestionario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CuestionarioFindFirstArgs>(args?: SelectSubset<T, CuestionarioFindFirstArgs<ExtArgs>>): Prisma__CuestionarioClient<$Result.GetResult<Prisma.$CuestionarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cuestionario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuestionarioFindFirstOrThrowArgs} args - Arguments to find a Cuestionario
     * @example
     * // Get one Cuestionario
     * const cuestionario = await prisma.cuestionario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CuestionarioFindFirstOrThrowArgs>(args?: SelectSubset<T, CuestionarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__CuestionarioClient<$Result.GetResult<Prisma.$CuestionarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cuestionarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuestionarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cuestionarios
     * const cuestionarios = await prisma.cuestionario.findMany()
     * 
     * // Get first 10 Cuestionarios
     * const cuestionarios = await prisma.cuestionario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cuestionarioWithIdOnly = await prisma.cuestionario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CuestionarioFindManyArgs>(args?: SelectSubset<T, CuestionarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CuestionarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cuestionario.
     * @param {CuestionarioCreateArgs} args - Arguments to create a Cuestionario.
     * @example
     * // Create one Cuestionario
     * const Cuestionario = await prisma.cuestionario.create({
     *   data: {
     *     // ... data to create a Cuestionario
     *   }
     * })
     * 
     */
    create<T extends CuestionarioCreateArgs>(args: SelectSubset<T, CuestionarioCreateArgs<ExtArgs>>): Prisma__CuestionarioClient<$Result.GetResult<Prisma.$CuestionarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cuestionarios.
     * @param {CuestionarioCreateManyArgs} args - Arguments to create many Cuestionarios.
     * @example
     * // Create many Cuestionarios
     * const cuestionario = await prisma.cuestionario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CuestionarioCreateManyArgs>(args?: SelectSubset<T, CuestionarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cuestionarios and returns the data saved in the database.
     * @param {CuestionarioCreateManyAndReturnArgs} args - Arguments to create many Cuestionarios.
     * @example
     * // Create many Cuestionarios
     * const cuestionario = await prisma.cuestionario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cuestionarios and only return the `id`
     * const cuestionarioWithIdOnly = await prisma.cuestionario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CuestionarioCreateManyAndReturnArgs>(args?: SelectSubset<T, CuestionarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CuestionarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cuestionario.
     * @param {CuestionarioDeleteArgs} args - Arguments to delete one Cuestionario.
     * @example
     * // Delete one Cuestionario
     * const Cuestionario = await prisma.cuestionario.delete({
     *   where: {
     *     // ... filter to delete one Cuestionario
     *   }
     * })
     * 
     */
    delete<T extends CuestionarioDeleteArgs>(args: SelectSubset<T, CuestionarioDeleteArgs<ExtArgs>>): Prisma__CuestionarioClient<$Result.GetResult<Prisma.$CuestionarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cuestionario.
     * @param {CuestionarioUpdateArgs} args - Arguments to update one Cuestionario.
     * @example
     * // Update one Cuestionario
     * const cuestionario = await prisma.cuestionario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CuestionarioUpdateArgs>(args: SelectSubset<T, CuestionarioUpdateArgs<ExtArgs>>): Prisma__CuestionarioClient<$Result.GetResult<Prisma.$CuestionarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cuestionarios.
     * @param {CuestionarioDeleteManyArgs} args - Arguments to filter Cuestionarios to delete.
     * @example
     * // Delete a few Cuestionarios
     * const { count } = await prisma.cuestionario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CuestionarioDeleteManyArgs>(args?: SelectSubset<T, CuestionarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cuestionarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuestionarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cuestionarios
     * const cuestionario = await prisma.cuestionario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CuestionarioUpdateManyArgs>(args: SelectSubset<T, CuestionarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cuestionario.
     * @param {CuestionarioUpsertArgs} args - Arguments to update or create a Cuestionario.
     * @example
     * // Update or create a Cuestionario
     * const cuestionario = await prisma.cuestionario.upsert({
     *   create: {
     *     // ... data to create a Cuestionario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cuestionario we want to update
     *   }
     * })
     */
    upsert<T extends CuestionarioUpsertArgs>(args: SelectSubset<T, CuestionarioUpsertArgs<ExtArgs>>): Prisma__CuestionarioClient<$Result.GetResult<Prisma.$CuestionarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cuestionarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuestionarioCountArgs} args - Arguments to filter Cuestionarios to count.
     * @example
     * // Count the number of Cuestionarios
     * const count = await prisma.cuestionario.count({
     *   where: {
     *     // ... the filter for the Cuestionarios we want to count
     *   }
     * })
    **/
    count<T extends CuestionarioCountArgs>(
      args?: Subset<T, CuestionarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CuestionarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cuestionario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuestionarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CuestionarioAggregateArgs>(args: Subset<T, CuestionarioAggregateArgs>): Prisma.PrismaPromise<GetCuestionarioAggregateType<T>>

    /**
     * Group by Cuestionario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuestionarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CuestionarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CuestionarioGroupByArgs['orderBy'] }
        : { orderBy?: CuestionarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CuestionarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCuestionarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cuestionario model
   */
  readonly fields: CuestionarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cuestionario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CuestionarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    marcoNormativo<T extends Cuestionario$marcoNormativoArgs<ExtArgs> = {}>(args?: Subset<T, Cuestionario$marcoNormativoArgs<ExtArgs>>): Prisma__MarcoNormativoClient<$Result.GetResult<Prisma.$MarcoNormativoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    secciones<T extends Cuestionario$seccionesArgs<ExtArgs> = {}>(args?: Subset<T, Cuestionario$seccionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeccionPayload<ExtArgs>, T, "findMany"> | Null>
    asignaciones<T extends Cuestionario$asignacionesArgs<ExtArgs> = {}>(args?: Subset<T, Cuestionario$asignacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AsignacionCuestionarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cuestionario model
   */ 
  interface CuestionarioFieldRefs {
    readonly id: FieldRef<"Cuestionario", 'String'>
    readonly nombre: FieldRef<"Cuestionario", 'String'>
    readonly descripcion: FieldRef<"Cuestionario", 'String'>
    readonly categoria: FieldRef<"Cuestionario", 'String'>
    readonly tipo: FieldRef<"Cuestionario", 'String'>
    readonly tipoEvaluacion: FieldRef<"Cuestionario", 'String'>
    readonly estado: FieldRef<"Cuestionario", 'String'>
    readonly marcoNormativoId: FieldRef<"Cuestionario", 'String'>
    readonly periodicidad: FieldRef<"Cuestionario", 'String'>
    readonly tasaCompletado: FieldRef<"Cuestionario", 'Float'>
    readonly fechaCreacion: FieldRef<"Cuestionario", 'DateTime'>
    readonly fechaModificacion: FieldRef<"Cuestionario", 'DateTime'>
    readonly umbrales: FieldRef<"Cuestionario", 'String'>
    readonly areasObjetivo: FieldRef<"Cuestionario", 'String'>
    readonly responsables: FieldRef<"Cuestionario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Cuestionario findUnique
   */
  export type CuestionarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuestionario
     */
    select?: CuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuestionarioInclude<ExtArgs> | null
    /**
     * Filter, which Cuestionario to fetch.
     */
    where: CuestionarioWhereUniqueInput
  }

  /**
   * Cuestionario findUniqueOrThrow
   */
  export type CuestionarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuestionario
     */
    select?: CuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuestionarioInclude<ExtArgs> | null
    /**
     * Filter, which Cuestionario to fetch.
     */
    where: CuestionarioWhereUniqueInput
  }

  /**
   * Cuestionario findFirst
   */
  export type CuestionarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuestionario
     */
    select?: CuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuestionarioInclude<ExtArgs> | null
    /**
     * Filter, which Cuestionario to fetch.
     */
    where?: CuestionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuestionarios to fetch.
     */
    orderBy?: CuestionarioOrderByWithRelationInput | CuestionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cuestionarios.
     */
    cursor?: CuestionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuestionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuestionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cuestionarios.
     */
    distinct?: CuestionarioScalarFieldEnum | CuestionarioScalarFieldEnum[]
  }

  /**
   * Cuestionario findFirstOrThrow
   */
  export type CuestionarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuestionario
     */
    select?: CuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuestionarioInclude<ExtArgs> | null
    /**
     * Filter, which Cuestionario to fetch.
     */
    where?: CuestionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuestionarios to fetch.
     */
    orderBy?: CuestionarioOrderByWithRelationInput | CuestionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cuestionarios.
     */
    cursor?: CuestionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuestionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuestionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cuestionarios.
     */
    distinct?: CuestionarioScalarFieldEnum | CuestionarioScalarFieldEnum[]
  }

  /**
   * Cuestionario findMany
   */
  export type CuestionarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuestionario
     */
    select?: CuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuestionarioInclude<ExtArgs> | null
    /**
     * Filter, which Cuestionarios to fetch.
     */
    where?: CuestionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuestionarios to fetch.
     */
    orderBy?: CuestionarioOrderByWithRelationInput | CuestionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cuestionarios.
     */
    cursor?: CuestionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuestionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuestionarios.
     */
    skip?: number
    distinct?: CuestionarioScalarFieldEnum | CuestionarioScalarFieldEnum[]
  }

  /**
   * Cuestionario create
   */
  export type CuestionarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuestionario
     */
    select?: CuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuestionarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Cuestionario.
     */
    data: XOR<CuestionarioCreateInput, CuestionarioUncheckedCreateInput>
  }

  /**
   * Cuestionario createMany
   */
  export type CuestionarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cuestionarios.
     */
    data: CuestionarioCreateManyInput | CuestionarioCreateManyInput[]
  }

  /**
   * Cuestionario createManyAndReturn
   */
  export type CuestionarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuestionario
     */
    select?: CuestionarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Cuestionarios.
     */
    data: CuestionarioCreateManyInput | CuestionarioCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuestionarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cuestionario update
   */
  export type CuestionarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuestionario
     */
    select?: CuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuestionarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Cuestionario.
     */
    data: XOR<CuestionarioUpdateInput, CuestionarioUncheckedUpdateInput>
    /**
     * Choose, which Cuestionario to update.
     */
    where: CuestionarioWhereUniqueInput
  }

  /**
   * Cuestionario updateMany
   */
  export type CuestionarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cuestionarios.
     */
    data: XOR<CuestionarioUpdateManyMutationInput, CuestionarioUncheckedUpdateManyInput>
    /**
     * Filter which Cuestionarios to update
     */
    where?: CuestionarioWhereInput
  }

  /**
   * Cuestionario upsert
   */
  export type CuestionarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuestionario
     */
    select?: CuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuestionarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Cuestionario to update in case it exists.
     */
    where: CuestionarioWhereUniqueInput
    /**
     * In case the Cuestionario found by the `where` argument doesn't exist, create a new Cuestionario with this data.
     */
    create: XOR<CuestionarioCreateInput, CuestionarioUncheckedCreateInput>
    /**
     * In case the Cuestionario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CuestionarioUpdateInput, CuestionarioUncheckedUpdateInput>
  }

  /**
   * Cuestionario delete
   */
  export type CuestionarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuestionario
     */
    select?: CuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuestionarioInclude<ExtArgs> | null
    /**
     * Filter which Cuestionario to delete.
     */
    where: CuestionarioWhereUniqueInput
  }

  /**
   * Cuestionario deleteMany
   */
  export type CuestionarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cuestionarios to delete
     */
    where?: CuestionarioWhereInput
  }

  /**
   * Cuestionario.marcoNormativo
   */
  export type Cuestionario$marcoNormativoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarcoNormativo
     */
    select?: MarcoNormativoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcoNormativoInclude<ExtArgs> | null
    where?: MarcoNormativoWhereInput
  }

  /**
   * Cuestionario.secciones
   */
  export type Cuestionario$seccionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seccion
     */
    select?: SeccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeccionInclude<ExtArgs> | null
    where?: SeccionWhereInput
    orderBy?: SeccionOrderByWithRelationInput | SeccionOrderByWithRelationInput[]
    cursor?: SeccionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeccionScalarFieldEnum | SeccionScalarFieldEnum[]
  }

  /**
   * Cuestionario.asignaciones
   */
  export type Cuestionario$asignacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsignacionCuestionario
     */
    select?: AsignacionCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsignacionCuestionarioInclude<ExtArgs> | null
    where?: AsignacionCuestionarioWhereInput
    orderBy?: AsignacionCuestionarioOrderByWithRelationInput | AsignacionCuestionarioOrderByWithRelationInput[]
    cursor?: AsignacionCuestionarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AsignacionCuestionarioScalarFieldEnum | AsignacionCuestionarioScalarFieldEnum[]
  }

  /**
   * Cuestionario without action
   */
  export type CuestionarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuestionario
     */
    select?: CuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuestionarioInclude<ExtArgs> | null
  }


  /**
   * Model Seccion
   */

  export type AggregateSeccion = {
    _count: SeccionCountAggregateOutputType | null
    _avg: SeccionAvgAggregateOutputType | null
    _sum: SeccionSumAggregateOutputType | null
    _min: SeccionMinAggregateOutputType | null
    _max: SeccionMaxAggregateOutputType | null
  }

  export type SeccionAvgAggregateOutputType = {
    peso: number | null
    orden: number | null
  }

  export type SeccionSumAggregateOutputType = {
    peso: number | null
    orden: number | null
  }

  export type SeccionMinAggregateOutputType = {
    id: string | null
    cuestionarioId: string | null
    nombre: string | null
    descripcion: string | null
    peso: number | null
    requerida: boolean | null
    orden: number | null
  }

  export type SeccionMaxAggregateOutputType = {
    id: string | null
    cuestionarioId: string | null
    nombre: string | null
    descripcion: string | null
    peso: number | null
    requerida: boolean | null
    orden: number | null
  }

  export type SeccionCountAggregateOutputType = {
    id: number
    cuestionarioId: number
    nombre: number
    descripcion: number
    peso: number
    requerida: number
    orden: number
    _all: number
  }


  export type SeccionAvgAggregateInputType = {
    peso?: true
    orden?: true
  }

  export type SeccionSumAggregateInputType = {
    peso?: true
    orden?: true
  }

  export type SeccionMinAggregateInputType = {
    id?: true
    cuestionarioId?: true
    nombre?: true
    descripcion?: true
    peso?: true
    requerida?: true
    orden?: true
  }

  export type SeccionMaxAggregateInputType = {
    id?: true
    cuestionarioId?: true
    nombre?: true
    descripcion?: true
    peso?: true
    requerida?: true
    orden?: true
  }

  export type SeccionCountAggregateInputType = {
    id?: true
    cuestionarioId?: true
    nombre?: true
    descripcion?: true
    peso?: true
    requerida?: true
    orden?: true
    _all?: true
  }

  export type SeccionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seccion to aggregate.
     */
    where?: SeccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seccions to fetch.
     */
    orderBy?: SeccionOrderByWithRelationInput | SeccionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seccions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seccions
    **/
    _count?: true | SeccionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeccionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeccionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeccionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeccionMaxAggregateInputType
  }

  export type GetSeccionAggregateType<T extends SeccionAggregateArgs> = {
        [P in keyof T & keyof AggregateSeccion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeccion[P]>
      : GetScalarType<T[P], AggregateSeccion[P]>
  }




  export type SeccionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeccionWhereInput
    orderBy?: SeccionOrderByWithAggregationInput | SeccionOrderByWithAggregationInput[]
    by: SeccionScalarFieldEnum[] | SeccionScalarFieldEnum
    having?: SeccionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeccionCountAggregateInputType | true
    _avg?: SeccionAvgAggregateInputType
    _sum?: SeccionSumAggregateInputType
    _min?: SeccionMinAggregateInputType
    _max?: SeccionMaxAggregateInputType
  }

  export type SeccionGroupByOutputType = {
    id: string
    cuestionarioId: string
    nombre: string
    descripcion: string
    peso: number
    requerida: boolean
    orden: number
    _count: SeccionCountAggregateOutputType | null
    _avg: SeccionAvgAggregateOutputType | null
    _sum: SeccionSumAggregateOutputType | null
    _min: SeccionMinAggregateOutputType | null
    _max: SeccionMaxAggregateOutputType | null
  }

  type GetSeccionGroupByPayload<T extends SeccionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeccionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeccionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeccionGroupByOutputType[P]>
            : GetScalarType<T[P], SeccionGroupByOutputType[P]>
        }
      >
    >


  export type SeccionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cuestionarioId?: boolean
    nombre?: boolean
    descripcion?: boolean
    peso?: boolean
    requerida?: boolean
    orden?: boolean
    cuestionario?: boolean | CuestionarioDefaultArgs<ExtArgs>
    preguntas?: boolean | Seccion$preguntasArgs<ExtArgs>
    _count?: boolean | SeccionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seccion"]>

  export type SeccionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cuestionarioId?: boolean
    nombre?: boolean
    descripcion?: boolean
    peso?: boolean
    requerida?: boolean
    orden?: boolean
    cuestionario?: boolean | CuestionarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seccion"]>

  export type SeccionSelectScalar = {
    id?: boolean
    cuestionarioId?: boolean
    nombre?: boolean
    descripcion?: boolean
    peso?: boolean
    requerida?: boolean
    orden?: boolean
  }

  export type SeccionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cuestionario?: boolean | CuestionarioDefaultArgs<ExtArgs>
    preguntas?: boolean | Seccion$preguntasArgs<ExtArgs>
    _count?: boolean | SeccionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeccionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cuestionario?: boolean | CuestionarioDefaultArgs<ExtArgs>
  }

  export type $SeccionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Seccion"
    objects: {
      cuestionario: Prisma.$CuestionarioPayload<ExtArgs>
      preguntas: Prisma.$PreguntaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cuestionarioId: string
      nombre: string
      descripcion: string
      peso: number
      requerida: boolean
      orden: number
    }, ExtArgs["result"]["seccion"]>
    composites: {}
  }

  type SeccionGetPayload<S extends boolean | null | undefined | SeccionDefaultArgs> = $Result.GetResult<Prisma.$SeccionPayload, S>

  type SeccionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeccionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeccionCountAggregateInputType | true
    }

  export interface SeccionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Seccion'], meta: { name: 'Seccion' } }
    /**
     * Find zero or one Seccion that matches the filter.
     * @param {SeccionFindUniqueArgs} args - Arguments to find a Seccion
     * @example
     * // Get one Seccion
     * const seccion = await prisma.seccion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeccionFindUniqueArgs>(args: SelectSubset<T, SeccionFindUniqueArgs<ExtArgs>>): Prisma__SeccionClient<$Result.GetResult<Prisma.$SeccionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Seccion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeccionFindUniqueOrThrowArgs} args - Arguments to find a Seccion
     * @example
     * // Get one Seccion
     * const seccion = await prisma.seccion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeccionFindUniqueOrThrowArgs>(args: SelectSubset<T, SeccionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeccionClient<$Result.GetResult<Prisma.$SeccionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Seccion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeccionFindFirstArgs} args - Arguments to find a Seccion
     * @example
     * // Get one Seccion
     * const seccion = await prisma.seccion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeccionFindFirstArgs>(args?: SelectSubset<T, SeccionFindFirstArgs<ExtArgs>>): Prisma__SeccionClient<$Result.GetResult<Prisma.$SeccionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Seccion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeccionFindFirstOrThrowArgs} args - Arguments to find a Seccion
     * @example
     * // Get one Seccion
     * const seccion = await prisma.seccion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeccionFindFirstOrThrowArgs>(args?: SelectSubset<T, SeccionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeccionClient<$Result.GetResult<Prisma.$SeccionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Seccions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeccionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seccions
     * const seccions = await prisma.seccion.findMany()
     * 
     * // Get first 10 Seccions
     * const seccions = await prisma.seccion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seccionWithIdOnly = await prisma.seccion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeccionFindManyArgs>(args?: SelectSubset<T, SeccionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeccionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Seccion.
     * @param {SeccionCreateArgs} args - Arguments to create a Seccion.
     * @example
     * // Create one Seccion
     * const Seccion = await prisma.seccion.create({
     *   data: {
     *     // ... data to create a Seccion
     *   }
     * })
     * 
     */
    create<T extends SeccionCreateArgs>(args: SelectSubset<T, SeccionCreateArgs<ExtArgs>>): Prisma__SeccionClient<$Result.GetResult<Prisma.$SeccionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Seccions.
     * @param {SeccionCreateManyArgs} args - Arguments to create many Seccions.
     * @example
     * // Create many Seccions
     * const seccion = await prisma.seccion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeccionCreateManyArgs>(args?: SelectSubset<T, SeccionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seccions and returns the data saved in the database.
     * @param {SeccionCreateManyAndReturnArgs} args - Arguments to create many Seccions.
     * @example
     * // Create many Seccions
     * const seccion = await prisma.seccion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seccions and only return the `id`
     * const seccionWithIdOnly = await prisma.seccion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeccionCreateManyAndReturnArgs>(args?: SelectSubset<T, SeccionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeccionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Seccion.
     * @param {SeccionDeleteArgs} args - Arguments to delete one Seccion.
     * @example
     * // Delete one Seccion
     * const Seccion = await prisma.seccion.delete({
     *   where: {
     *     // ... filter to delete one Seccion
     *   }
     * })
     * 
     */
    delete<T extends SeccionDeleteArgs>(args: SelectSubset<T, SeccionDeleteArgs<ExtArgs>>): Prisma__SeccionClient<$Result.GetResult<Prisma.$SeccionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Seccion.
     * @param {SeccionUpdateArgs} args - Arguments to update one Seccion.
     * @example
     * // Update one Seccion
     * const seccion = await prisma.seccion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeccionUpdateArgs>(args: SelectSubset<T, SeccionUpdateArgs<ExtArgs>>): Prisma__SeccionClient<$Result.GetResult<Prisma.$SeccionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Seccions.
     * @param {SeccionDeleteManyArgs} args - Arguments to filter Seccions to delete.
     * @example
     * // Delete a few Seccions
     * const { count } = await prisma.seccion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeccionDeleteManyArgs>(args?: SelectSubset<T, SeccionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seccions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeccionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seccions
     * const seccion = await prisma.seccion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeccionUpdateManyArgs>(args: SelectSubset<T, SeccionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seccion.
     * @param {SeccionUpsertArgs} args - Arguments to update or create a Seccion.
     * @example
     * // Update or create a Seccion
     * const seccion = await prisma.seccion.upsert({
     *   create: {
     *     // ... data to create a Seccion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seccion we want to update
     *   }
     * })
     */
    upsert<T extends SeccionUpsertArgs>(args: SelectSubset<T, SeccionUpsertArgs<ExtArgs>>): Prisma__SeccionClient<$Result.GetResult<Prisma.$SeccionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Seccions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeccionCountArgs} args - Arguments to filter Seccions to count.
     * @example
     * // Count the number of Seccions
     * const count = await prisma.seccion.count({
     *   where: {
     *     // ... the filter for the Seccions we want to count
     *   }
     * })
    **/
    count<T extends SeccionCountArgs>(
      args?: Subset<T, SeccionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeccionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seccion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeccionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeccionAggregateArgs>(args: Subset<T, SeccionAggregateArgs>): Prisma.PrismaPromise<GetSeccionAggregateType<T>>

    /**
     * Group by Seccion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeccionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeccionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeccionGroupByArgs['orderBy'] }
        : { orderBy?: SeccionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeccionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeccionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Seccion model
   */
  readonly fields: SeccionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Seccion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeccionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cuestionario<T extends CuestionarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CuestionarioDefaultArgs<ExtArgs>>): Prisma__CuestionarioClient<$Result.GetResult<Prisma.$CuestionarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    preguntas<T extends Seccion$preguntasArgs<ExtArgs> = {}>(args?: Subset<T, Seccion$preguntasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreguntaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Seccion model
   */ 
  interface SeccionFieldRefs {
    readonly id: FieldRef<"Seccion", 'String'>
    readonly cuestionarioId: FieldRef<"Seccion", 'String'>
    readonly nombre: FieldRef<"Seccion", 'String'>
    readonly descripcion: FieldRef<"Seccion", 'String'>
    readonly peso: FieldRef<"Seccion", 'Float'>
    readonly requerida: FieldRef<"Seccion", 'Boolean'>
    readonly orden: FieldRef<"Seccion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Seccion findUnique
   */
  export type SeccionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seccion
     */
    select?: SeccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeccionInclude<ExtArgs> | null
    /**
     * Filter, which Seccion to fetch.
     */
    where: SeccionWhereUniqueInput
  }

  /**
   * Seccion findUniqueOrThrow
   */
  export type SeccionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seccion
     */
    select?: SeccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeccionInclude<ExtArgs> | null
    /**
     * Filter, which Seccion to fetch.
     */
    where: SeccionWhereUniqueInput
  }

  /**
   * Seccion findFirst
   */
  export type SeccionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seccion
     */
    select?: SeccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeccionInclude<ExtArgs> | null
    /**
     * Filter, which Seccion to fetch.
     */
    where?: SeccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seccions to fetch.
     */
    orderBy?: SeccionOrderByWithRelationInput | SeccionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seccions.
     */
    cursor?: SeccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seccions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seccions.
     */
    distinct?: SeccionScalarFieldEnum | SeccionScalarFieldEnum[]
  }

  /**
   * Seccion findFirstOrThrow
   */
  export type SeccionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seccion
     */
    select?: SeccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeccionInclude<ExtArgs> | null
    /**
     * Filter, which Seccion to fetch.
     */
    where?: SeccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seccions to fetch.
     */
    orderBy?: SeccionOrderByWithRelationInput | SeccionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seccions.
     */
    cursor?: SeccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seccions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seccions.
     */
    distinct?: SeccionScalarFieldEnum | SeccionScalarFieldEnum[]
  }

  /**
   * Seccion findMany
   */
  export type SeccionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seccion
     */
    select?: SeccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeccionInclude<ExtArgs> | null
    /**
     * Filter, which Seccions to fetch.
     */
    where?: SeccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seccions to fetch.
     */
    orderBy?: SeccionOrderByWithRelationInput | SeccionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seccions.
     */
    cursor?: SeccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seccions.
     */
    skip?: number
    distinct?: SeccionScalarFieldEnum | SeccionScalarFieldEnum[]
  }

  /**
   * Seccion create
   */
  export type SeccionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seccion
     */
    select?: SeccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeccionInclude<ExtArgs> | null
    /**
     * The data needed to create a Seccion.
     */
    data: XOR<SeccionCreateInput, SeccionUncheckedCreateInput>
  }

  /**
   * Seccion createMany
   */
  export type SeccionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seccions.
     */
    data: SeccionCreateManyInput | SeccionCreateManyInput[]
  }

  /**
   * Seccion createManyAndReturn
   */
  export type SeccionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seccion
     */
    select?: SeccionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Seccions.
     */
    data: SeccionCreateManyInput | SeccionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeccionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Seccion update
   */
  export type SeccionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seccion
     */
    select?: SeccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeccionInclude<ExtArgs> | null
    /**
     * The data needed to update a Seccion.
     */
    data: XOR<SeccionUpdateInput, SeccionUncheckedUpdateInput>
    /**
     * Choose, which Seccion to update.
     */
    where: SeccionWhereUniqueInput
  }

  /**
   * Seccion updateMany
   */
  export type SeccionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seccions.
     */
    data: XOR<SeccionUpdateManyMutationInput, SeccionUncheckedUpdateManyInput>
    /**
     * Filter which Seccions to update
     */
    where?: SeccionWhereInput
  }

  /**
   * Seccion upsert
   */
  export type SeccionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seccion
     */
    select?: SeccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeccionInclude<ExtArgs> | null
    /**
     * The filter to search for the Seccion to update in case it exists.
     */
    where: SeccionWhereUniqueInput
    /**
     * In case the Seccion found by the `where` argument doesn't exist, create a new Seccion with this data.
     */
    create: XOR<SeccionCreateInput, SeccionUncheckedCreateInput>
    /**
     * In case the Seccion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeccionUpdateInput, SeccionUncheckedUpdateInput>
  }

  /**
   * Seccion delete
   */
  export type SeccionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seccion
     */
    select?: SeccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeccionInclude<ExtArgs> | null
    /**
     * Filter which Seccion to delete.
     */
    where: SeccionWhereUniqueInput
  }

  /**
   * Seccion deleteMany
   */
  export type SeccionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seccions to delete
     */
    where?: SeccionWhereInput
  }

  /**
   * Seccion.preguntas
   */
  export type Seccion$preguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreguntaInclude<ExtArgs> | null
    where?: PreguntaWhereInput
    orderBy?: PreguntaOrderByWithRelationInput | PreguntaOrderByWithRelationInput[]
    cursor?: PreguntaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreguntaScalarFieldEnum | PreguntaScalarFieldEnum[]
  }

  /**
   * Seccion without action
   */
  export type SeccionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seccion
     */
    select?: SeccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeccionInclude<ExtArgs> | null
  }


  /**
   * Model Pregunta
   */

  export type AggregatePregunta = {
    _count: PreguntaCountAggregateOutputType | null
    _avg: PreguntaAvgAggregateOutputType | null
    _sum: PreguntaSumAggregateOutputType | null
    _min: PreguntaMinAggregateOutputType | null
    _max: PreguntaMaxAggregateOutputType | null
  }

  export type PreguntaAvgAggregateOutputType = {
    peso: number | null
    escalaMin: number | null
    escalaMax: number | null
    maxStars: number | null
    orden: number | null
  }

  export type PreguntaSumAggregateOutputType = {
    peso: number | null
    escalaMin: number | null
    escalaMax: number | null
    maxStars: number | null
    orden: number | null
  }

  export type PreguntaMinAggregateOutputType = {
    id: string | null
    seccionId: string | null
    texto: string | null
    tipo: string | null
    requerida: boolean | null
    peso: number | null
    opciones: string | null
    escalaMin: number | null
    escalaMax: number | null
    ayuda: string | null
    placeholder: string | null
    requisitoNormativoId: string | null
    controlAsociado: string | null
    requiereEvidencia: boolean | null
    maxStars: number | null
    leftAnchor: string | null
    rightAnchor: string | null
    likertLabels: string | null
    displayConditionQuestionId: string | null
    displayConditionAnswer: string | null
    logicaCondicional: string | null
    isCalculated: boolean | null
    formula: string | null
    orden: number | null
  }

  export type PreguntaMaxAggregateOutputType = {
    id: string | null
    seccionId: string | null
    texto: string | null
    tipo: string | null
    requerida: boolean | null
    peso: number | null
    opciones: string | null
    escalaMin: number | null
    escalaMax: number | null
    ayuda: string | null
    placeholder: string | null
    requisitoNormativoId: string | null
    controlAsociado: string | null
    requiereEvidencia: boolean | null
    maxStars: number | null
    leftAnchor: string | null
    rightAnchor: string | null
    likertLabels: string | null
    displayConditionQuestionId: string | null
    displayConditionAnswer: string | null
    logicaCondicional: string | null
    isCalculated: boolean | null
    formula: string | null
    orden: number | null
  }

  export type PreguntaCountAggregateOutputType = {
    id: number
    seccionId: number
    texto: number
    tipo: number
    requerida: number
    peso: number
    opciones: number
    escalaMin: number
    escalaMax: number
    ayuda: number
    placeholder: number
    requisitoNormativoId: number
    controlAsociado: number
    requiereEvidencia: number
    maxStars: number
    leftAnchor: number
    rightAnchor: number
    likertLabels: number
    displayConditionQuestionId: number
    displayConditionAnswer: number
    logicaCondicional: number
    isCalculated: number
    formula: number
    orden: number
    _all: number
  }


  export type PreguntaAvgAggregateInputType = {
    peso?: true
    escalaMin?: true
    escalaMax?: true
    maxStars?: true
    orden?: true
  }

  export type PreguntaSumAggregateInputType = {
    peso?: true
    escalaMin?: true
    escalaMax?: true
    maxStars?: true
    orden?: true
  }

  export type PreguntaMinAggregateInputType = {
    id?: true
    seccionId?: true
    texto?: true
    tipo?: true
    requerida?: true
    peso?: true
    opciones?: true
    escalaMin?: true
    escalaMax?: true
    ayuda?: true
    placeholder?: true
    requisitoNormativoId?: true
    controlAsociado?: true
    requiereEvidencia?: true
    maxStars?: true
    leftAnchor?: true
    rightAnchor?: true
    likertLabels?: true
    displayConditionQuestionId?: true
    displayConditionAnswer?: true
    logicaCondicional?: true
    isCalculated?: true
    formula?: true
    orden?: true
  }

  export type PreguntaMaxAggregateInputType = {
    id?: true
    seccionId?: true
    texto?: true
    tipo?: true
    requerida?: true
    peso?: true
    opciones?: true
    escalaMin?: true
    escalaMax?: true
    ayuda?: true
    placeholder?: true
    requisitoNormativoId?: true
    controlAsociado?: true
    requiereEvidencia?: true
    maxStars?: true
    leftAnchor?: true
    rightAnchor?: true
    likertLabels?: true
    displayConditionQuestionId?: true
    displayConditionAnswer?: true
    logicaCondicional?: true
    isCalculated?: true
    formula?: true
    orden?: true
  }

  export type PreguntaCountAggregateInputType = {
    id?: true
    seccionId?: true
    texto?: true
    tipo?: true
    requerida?: true
    peso?: true
    opciones?: true
    escalaMin?: true
    escalaMax?: true
    ayuda?: true
    placeholder?: true
    requisitoNormativoId?: true
    controlAsociado?: true
    requiereEvidencia?: true
    maxStars?: true
    leftAnchor?: true
    rightAnchor?: true
    likertLabels?: true
    displayConditionQuestionId?: true
    displayConditionAnswer?: true
    logicaCondicional?: true
    isCalculated?: true
    formula?: true
    orden?: true
    _all?: true
  }

  export type PreguntaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pregunta to aggregate.
     */
    where?: PreguntaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preguntas to fetch.
     */
    orderBy?: PreguntaOrderByWithRelationInput | PreguntaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PreguntaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Preguntas
    **/
    _count?: true | PreguntaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreguntaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreguntaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreguntaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreguntaMaxAggregateInputType
  }

  export type GetPreguntaAggregateType<T extends PreguntaAggregateArgs> = {
        [P in keyof T & keyof AggregatePregunta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePregunta[P]>
      : GetScalarType<T[P], AggregatePregunta[P]>
  }




  export type PreguntaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreguntaWhereInput
    orderBy?: PreguntaOrderByWithAggregationInput | PreguntaOrderByWithAggregationInput[]
    by: PreguntaScalarFieldEnum[] | PreguntaScalarFieldEnum
    having?: PreguntaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreguntaCountAggregateInputType | true
    _avg?: PreguntaAvgAggregateInputType
    _sum?: PreguntaSumAggregateInputType
    _min?: PreguntaMinAggregateInputType
    _max?: PreguntaMaxAggregateInputType
  }

  export type PreguntaGroupByOutputType = {
    id: string
    seccionId: string
    texto: string
    tipo: string
    requerida: boolean
    peso: number
    opciones: string | null
    escalaMin: number | null
    escalaMax: number | null
    ayuda: string | null
    placeholder: string | null
    requisitoNormativoId: string | null
    controlAsociado: string | null
    requiereEvidencia: boolean
    maxStars: number | null
    leftAnchor: string | null
    rightAnchor: string | null
    likertLabels: string | null
    displayConditionQuestionId: string | null
    displayConditionAnswer: string | null
    logicaCondicional: string | null
    isCalculated: boolean
    formula: string | null
    orden: number
    _count: PreguntaCountAggregateOutputType | null
    _avg: PreguntaAvgAggregateOutputType | null
    _sum: PreguntaSumAggregateOutputType | null
    _min: PreguntaMinAggregateOutputType | null
    _max: PreguntaMaxAggregateOutputType | null
  }

  type GetPreguntaGroupByPayload<T extends PreguntaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreguntaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreguntaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreguntaGroupByOutputType[P]>
            : GetScalarType<T[P], PreguntaGroupByOutputType[P]>
        }
      >
    >


  export type PreguntaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seccionId?: boolean
    texto?: boolean
    tipo?: boolean
    requerida?: boolean
    peso?: boolean
    opciones?: boolean
    escalaMin?: boolean
    escalaMax?: boolean
    ayuda?: boolean
    placeholder?: boolean
    requisitoNormativoId?: boolean
    controlAsociado?: boolean
    requiereEvidencia?: boolean
    maxStars?: boolean
    leftAnchor?: boolean
    rightAnchor?: boolean
    likertLabels?: boolean
    displayConditionQuestionId?: boolean
    displayConditionAnswer?: boolean
    logicaCondicional?: boolean
    isCalculated?: boolean
    formula?: boolean
    orden?: boolean
    seccion?: boolean | SeccionDefaultArgs<ExtArgs>
    respuestas?: boolean | Pregunta$respuestasArgs<ExtArgs>
    hallazgos?: boolean | Pregunta$hallazgosArgs<ExtArgs>
    _count?: boolean | PreguntaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pregunta"]>

  export type PreguntaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seccionId?: boolean
    texto?: boolean
    tipo?: boolean
    requerida?: boolean
    peso?: boolean
    opciones?: boolean
    escalaMin?: boolean
    escalaMax?: boolean
    ayuda?: boolean
    placeholder?: boolean
    requisitoNormativoId?: boolean
    controlAsociado?: boolean
    requiereEvidencia?: boolean
    maxStars?: boolean
    leftAnchor?: boolean
    rightAnchor?: boolean
    likertLabels?: boolean
    displayConditionQuestionId?: boolean
    displayConditionAnswer?: boolean
    logicaCondicional?: boolean
    isCalculated?: boolean
    formula?: boolean
    orden?: boolean
    seccion?: boolean | SeccionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pregunta"]>

  export type PreguntaSelectScalar = {
    id?: boolean
    seccionId?: boolean
    texto?: boolean
    tipo?: boolean
    requerida?: boolean
    peso?: boolean
    opciones?: boolean
    escalaMin?: boolean
    escalaMax?: boolean
    ayuda?: boolean
    placeholder?: boolean
    requisitoNormativoId?: boolean
    controlAsociado?: boolean
    requiereEvidencia?: boolean
    maxStars?: boolean
    leftAnchor?: boolean
    rightAnchor?: boolean
    likertLabels?: boolean
    displayConditionQuestionId?: boolean
    displayConditionAnswer?: boolean
    logicaCondicional?: boolean
    isCalculated?: boolean
    formula?: boolean
    orden?: boolean
  }

  export type PreguntaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seccion?: boolean | SeccionDefaultArgs<ExtArgs>
    respuestas?: boolean | Pregunta$respuestasArgs<ExtArgs>
    hallazgos?: boolean | Pregunta$hallazgosArgs<ExtArgs>
    _count?: boolean | PreguntaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PreguntaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seccion?: boolean | SeccionDefaultArgs<ExtArgs>
  }

  export type $PreguntaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pregunta"
    objects: {
      seccion: Prisma.$SeccionPayload<ExtArgs>
      respuestas: Prisma.$RespuestaPreguntaPayload<ExtArgs>[]
      hallazgos: Prisma.$HallazgoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seccionId: string
      texto: string
      tipo: string
      requerida: boolean
      peso: number
      opciones: string | null
      escalaMin: number | null
      escalaMax: number | null
      ayuda: string | null
      placeholder: string | null
      requisitoNormativoId: string | null
      controlAsociado: string | null
      requiereEvidencia: boolean
      maxStars: number | null
      leftAnchor: string | null
      rightAnchor: string | null
      likertLabels: string | null
      displayConditionQuestionId: string | null
      displayConditionAnswer: string | null
      logicaCondicional: string | null
      isCalculated: boolean
      formula: string | null
      orden: number
    }, ExtArgs["result"]["pregunta"]>
    composites: {}
  }

  type PreguntaGetPayload<S extends boolean | null | undefined | PreguntaDefaultArgs> = $Result.GetResult<Prisma.$PreguntaPayload, S>

  type PreguntaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PreguntaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PreguntaCountAggregateInputType | true
    }

  export interface PreguntaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pregunta'], meta: { name: 'Pregunta' } }
    /**
     * Find zero or one Pregunta that matches the filter.
     * @param {PreguntaFindUniqueArgs} args - Arguments to find a Pregunta
     * @example
     * // Get one Pregunta
     * const pregunta = await prisma.pregunta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PreguntaFindUniqueArgs>(args: SelectSubset<T, PreguntaFindUniqueArgs<ExtArgs>>): Prisma__PreguntaClient<$Result.GetResult<Prisma.$PreguntaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pregunta that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PreguntaFindUniqueOrThrowArgs} args - Arguments to find a Pregunta
     * @example
     * // Get one Pregunta
     * const pregunta = await prisma.pregunta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PreguntaFindUniqueOrThrowArgs>(args: SelectSubset<T, PreguntaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PreguntaClient<$Result.GetResult<Prisma.$PreguntaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pregunta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreguntaFindFirstArgs} args - Arguments to find a Pregunta
     * @example
     * // Get one Pregunta
     * const pregunta = await prisma.pregunta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PreguntaFindFirstArgs>(args?: SelectSubset<T, PreguntaFindFirstArgs<ExtArgs>>): Prisma__PreguntaClient<$Result.GetResult<Prisma.$PreguntaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pregunta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreguntaFindFirstOrThrowArgs} args - Arguments to find a Pregunta
     * @example
     * // Get one Pregunta
     * const pregunta = await prisma.pregunta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PreguntaFindFirstOrThrowArgs>(args?: SelectSubset<T, PreguntaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PreguntaClient<$Result.GetResult<Prisma.$PreguntaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Preguntas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreguntaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Preguntas
     * const preguntas = await prisma.pregunta.findMany()
     * 
     * // Get first 10 Preguntas
     * const preguntas = await prisma.pregunta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preguntaWithIdOnly = await prisma.pregunta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PreguntaFindManyArgs>(args?: SelectSubset<T, PreguntaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreguntaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pregunta.
     * @param {PreguntaCreateArgs} args - Arguments to create a Pregunta.
     * @example
     * // Create one Pregunta
     * const Pregunta = await prisma.pregunta.create({
     *   data: {
     *     // ... data to create a Pregunta
     *   }
     * })
     * 
     */
    create<T extends PreguntaCreateArgs>(args: SelectSubset<T, PreguntaCreateArgs<ExtArgs>>): Prisma__PreguntaClient<$Result.GetResult<Prisma.$PreguntaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Preguntas.
     * @param {PreguntaCreateManyArgs} args - Arguments to create many Preguntas.
     * @example
     * // Create many Preguntas
     * const pregunta = await prisma.pregunta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PreguntaCreateManyArgs>(args?: SelectSubset<T, PreguntaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Preguntas and returns the data saved in the database.
     * @param {PreguntaCreateManyAndReturnArgs} args - Arguments to create many Preguntas.
     * @example
     * // Create many Preguntas
     * const pregunta = await prisma.pregunta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Preguntas and only return the `id`
     * const preguntaWithIdOnly = await prisma.pregunta.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PreguntaCreateManyAndReturnArgs>(args?: SelectSubset<T, PreguntaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreguntaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pregunta.
     * @param {PreguntaDeleteArgs} args - Arguments to delete one Pregunta.
     * @example
     * // Delete one Pregunta
     * const Pregunta = await prisma.pregunta.delete({
     *   where: {
     *     // ... filter to delete one Pregunta
     *   }
     * })
     * 
     */
    delete<T extends PreguntaDeleteArgs>(args: SelectSubset<T, PreguntaDeleteArgs<ExtArgs>>): Prisma__PreguntaClient<$Result.GetResult<Prisma.$PreguntaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pregunta.
     * @param {PreguntaUpdateArgs} args - Arguments to update one Pregunta.
     * @example
     * // Update one Pregunta
     * const pregunta = await prisma.pregunta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PreguntaUpdateArgs>(args: SelectSubset<T, PreguntaUpdateArgs<ExtArgs>>): Prisma__PreguntaClient<$Result.GetResult<Prisma.$PreguntaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Preguntas.
     * @param {PreguntaDeleteManyArgs} args - Arguments to filter Preguntas to delete.
     * @example
     * // Delete a few Preguntas
     * const { count } = await prisma.pregunta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PreguntaDeleteManyArgs>(args?: SelectSubset<T, PreguntaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Preguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreguntaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Preguntas
     * const pregunta = await prisma.pregunta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PreguntaUpdateManyArgs>(args: SelectSubset<T, PreguntaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pregunta.
     * @param {PreguntaUpsertArgs} args - Arguments to update or create a Pregunta.
     * @example
     * // Update or create a Pregunta
     * const pregunta = await prisma.pregunta.upsert({
     *   create: {
     *     // ... data to create a Pregunta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pregunta we want to update
     *   }
     * })
     */
    upsert<T extends PreguntaUpsertArgs>(args: SelectSubset<T, PreguntaUpsertArgs<ExtArgs>>): Prisma__PreguntaClient<$Result.GetResult<Prisma.$PreguntaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Preguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreguntaCountArgs} args - Arguments to filter Preguntas to count.
     * @example
     * // Count the number of Preguntas
     * const count = await prisma.pregunta.count({
     *   where: {
     *     // ... the filter for the Preguntas we want to count
     *   }
     * })
    **/
    count<T extends PreguntaCountArgs>(
      args?: Subset<T, PreguntaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreguntaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pregunta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreguntaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreguntaAggregateArgs>(args: Subset<T, PreguntaAggregateArgs>): Prisma.PrismaPromise<GetPreguntaAggregateType<T>>

    /**
     * Group by Pregunta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreguntaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreguntaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreguntaGroupByArgs['orderBy'] }
        : { orderBy?: PreguntaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreguntaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreguntaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pregunta model
   */
  readonly fields: PreguntaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pregunta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreguntaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seccion<T extends SeccionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeccionDefaultArgs<ExtArgs>>): Prisma__SeccionClient<$Result.GetResult<Prisma.$SeccionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    respuestas<T extends Pregunta$respuestasArgs<ExtArgs> = {}>(args?: Subset<T, Pregunta$respuestasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RespuestaPreguntaPayload<ExtArgs>, T, "findMany"> | Null>
    hallazgos<T extends Pregunta$hallazgosArgs<ExtArgs> = {}>(args?: Subset<T, Pregunta$hallazgosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HallazgoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pregunta model
   */ 
  interface PreguntaFieldRefs {
    readonly id: FieldRef<"Pregunta", 'String'>
    readonly seccionId: FieldRef<"Pregunta", 'String'>
    readonly texto: FieldRef<"Pregunta", 'String'>
    readonly tipo: FieldRef<"Pregunta", 'String'>
    readonly requerida: FieldRef<"Pregunta", 'Boolean'>
    readonly peso: FieldRef<"Pregunta", 'Float'>
    readonly opciones: FieldRef<"Pregunta", 'String'>
    readonly escalaMin: FieldRef<"Pregunta", 'Int'>
    readonly escalaMax: FieldRef<"Pregunta", 'Int'>
    readonly ayuda: FieldRef<"Pregunta", 'String'>
    readonly placeholder: FieldRef<"Pregunta", 'String'>
    readonly requisitoNormativoId: FieldRef<"Pregunta", 'String'>
    readonly controlAsociado: FieldRef<"Pregunta", 'String'>
    readonly requiereEvidencia: FieldRef<"Pregunta", 'Boolean'>
    readonly maxStars: FieldRef<"Pregunta", 'Int'>
    readonly leftAnchor: FieldRef<"Pregunta", 'String'>
    readonly rightAnchor: FieldRef<"Pregunta", 'String'>
    readonly likertLabels: FieldRef<"Pregunta", 'String'>
    readonly displayConditionQuestionId: FieldRef<"Pregunta", 'String'>
    readonly displayConditionAnswer: FieldRef<"Pregunta", 'String'>
    readonly logicaCondicional: FieldRef<"Pregunta", 'String'>
    readonly isCalculated: FieldRef<"Pregunta", 'Boolean'>
    readonly formula: FieldRef<"Pregunta", 'String'>
    readonly orden: FieldRef<"Pregunta", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Pregunta findUnique
   */
  export type PreguntaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreguntaInclude<ExtArgs> | null
    /**
     * Filter, which Pregunta to fetch.
     */
    where: PreguntaWhereUniqueInput
  }

  /**
   * Pregunta findUniqueOrThrow
   */
  export type PreguntaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreguntaInclude<ExtArgs> | null
    /**
     * Filter, which Pregunta to fetch.
     */
    where: PreguntaWhereUniqueInput
  }

  /**
   * Pregunta findFirst
   */
  export type PreguntaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreguntaInclude<ExtArgs> | null
    /**
     * Filter, which Pregunta to fetch.
     */
    where?: PreguntaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preguntas to fetch.
     */
    orderBy?: PreguntaOrderByWithRelationInput | PreguntaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Preguntas.
     */
    cursor?: PreguntaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Preguntas.
     */
    distinct?: PreguntaScalarFieldEnum | PreguntaScalarFieldEnum[]
  }

  /**
   * Pregunta findFirstOrThrow
   */
  export type PreguntaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreguntaInclude<ExtArgs> | null
    /**
     * Filter, which Pregunta to fetch.
     */
    where?: PreguntaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preguntas to fetch.
     */
    orderBy?: PreguntaOrderByWithRelationInput | PreguntaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Preguntas.
     */
    cursor?: PreguntaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Preguntas.
     */
    distinct?: PreguntaScalarFieldEnum | PreguntaScalarFieldEnum[]
  }

  /**
   * Pregunta findMany
   */
  export type PreguntaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreguntaInclude<ExtArgs> | null
    /**
     * Filter, which Preguntas to fetch.
     */
    where?: PreguntaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preguntas to fetch.
     */
    orderBy?: PreguntaOrderByWithRelationInput | PreguntaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Preguntas.
     */
    cursor?: PreguntaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preguntas.
     */
    skip?: number
    distinct?: PreguntaScalarFieldEnum | PreguntaScalarFieldEnum[]
  }

  /**
   * Pregunta create
   */
  export type PreguntaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreguntaInclude<ExtArgs> | null
    /**
     * The data needed to create a Pregunta.
     */
    data: XOR<PreguntaCreateInput, PreguntaUncheckedCreateInput>
  }

  /**
   * Pregunta createMany
   */
  export type PreguntaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Preguntas.
     */
    data: PreguntaCreateManyInput | PreguntaCreateManyInput[]
  }

  /**
   * Pregunta createManyAndReturn
   */
  export type PreguntaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Preguntas.
     */
    data: PreguntaCreateManyInput | PreguntaCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreguntaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pregunta update
   */
  export type PreguntaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreguntaInclude<ExtArgs> | null
    /**
     * The data needed to update a Pregunta.
     */
    data: XOR<PreguntaUpdateInput, PreguntaUncheckedUpdateInput>
    /**
     * Choose, which Pregunta to update.
     */
    where: PreguntaWhereUniqueInput
  }

  /**
   * Pregunta updateMany
   */
  export type PreguntaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Preguntas.
     */
    data: XOR<PreguntaUpdateManyMutationInput, PreguntaUncheckedUpdateManyInput>
    /**
     * Filter which Preguntas to update
     */
    where?: PreguntaWhereInput
  }

  /**
   * Pregunta upsert
   */
  export type PreguntaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreguntaInclude<ExtArgs> | null
    /**
     * The filter to search for the Pregunta to update in case it exists.
     */
    where: PreguntaWhereUniqueInput
    /**
     * In case the Pregunta found by the `where` argument doesn't exist, create a new Pregunta with this data.
     */
    create: XOR<PreguntaCreateInput, PreguntaUncheckedCreateInput>
    /**
     * In case the Pregunta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreguntaUpdateInput, PreguntaUncheckedUpdateInput>
  }

  /**
   * Pregunta delete
   */
  export type PreguntaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreguntaInclude<ExtArgs> | null
    /**
     * Filter which Pregunta to delete.
     */
    where: PreguntaWhereUniqueInput
  }

  /**
   * Pregunta deleteMany
   */
  export type PreguntaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Preguntas to delete
     */
    where?: PreguntaWhereInput
  }

  /**
   * Pregunta.respuestas
   */
  export type Pregunta$respuestasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaPregunta
     */
    select?: RespuestaPreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaPreguntaInclude<ExtArgs> | null
    where?: RespuestaPreguntaWhereInput
    orderBy?: RespuestaPreguntaOrderByWithRelationInput | RespuestaPreguntaOrderByWithRelationInput[]
    cursor?: RespuestaPreguntaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RespuestaPreguntaScalarFieldEnum | RespuestaPreguntaScalarFieldEnum[]
  }

  /**
   * Pregunta.hallazgos
   */
  export type Pregunta$hallazgosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallazgo
     */
    select?: HallazgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallazgoInclude<ExtArgs> | null
    where?: HallazgoWhereInput
    orderBy?: HallazgoOrderByWithRelationInput | HallazgoOrderByWithRelationInput[]
    cursor?: HallazgoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HallazgoScalarFieldEnum | HallazgoScalarFieldEnum[]
  }

  /**
   * Pregunta without action
   */
  export type PreguntaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pregunta
     */
    select?: PreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreguntaInclude<ExtArgs> | null
  }


  /**
   * Model AsignacionCuestionario
   */

  export type AggregateAsignacionCuestionario = {
    _count: AsignacionCuestionarioCountAggregateOutputType | null
    _avg: AsignacionCuestionarioAvgAggregateOutputType | null
    _sum: AsignacionCuestionarioSumAggregateOutputType | null
    _min: AsignacionCuestionarioMinAggregateOutputType | null
    _max: AsignacionCuestionarioMaxAggregateOutputType | null
  }

  export type AsignacionCuestionarioAvgAggregateOutputType = {
    progreso: number | null
  }

  export type AsignacionCuestionarioSumAggregateOutputType = {
    progreso: number | null
  }

  export type AsignacionCuestionarioMinAggregateOutputType = {
    id: string | null
    cuestionarioId: string | null
    cuestionarioIds: string | null
    titulo: string | null
    descripcion: string | null
    tipoRevision: string | null
    usuariosAsignados: string | null
    usuariosAsignadosNombres: string | null
    emailsExternos: string | null
    contrasenaAcceso: string | null
    activosObjetivo: string | null
    activosObjetivoNombres: string | null
    procesosObjetivo: string | null
    procesosObjetivoNombres: string | null
    aprobadores: string | null
    aprobadoresNombres: string | null
    evaluadosInternos: string | null
    evaluadosInternosNombres: string | null
    areaId: string | null
    areaNombre: string | null
    responsableId: string | null
    responsableNombre: string | null
    fechaAsignacion: Date | null
    fechaInicio: Date | null
    fechaVencimiento: Date | null
    estado: string | null
    progreso: number | null
    instrucciones: string | null
    recordatorios: boolean | null
    tokenAccesoExterno: string | null
    recurrencia: string | null
  }

  export type AsignacionCuestionarioMaxAggregateOutputType = {
    id: string | null
    cuestionarioId: string | null
    cuestionarioIds: string | null
    titulo: string | null
    descripcion: string | null
    tipoRevision: string | null
    usuariosAsignados: string | null
    usuariosAsignadosNombres: string | null
    emailsExternos: string | null
    contrasenaAcceso: string | null
    activosObjetivo: string | null
    activosObjetivoNombres: string | null
    procesosObjetivo: string | null
    procesosObjetivoNombres: string | null
    aprobadores: string | null
    aprobadoresNombres: string | null
    evaluadosInternos: string | null
    evaluadosInternosNombres: string | null
    areaId: string | null
    areaNombre: string | null
    responsableId: string | null
    responsableNombre: string | null
    fechaAsignacion: Date | null
    fechaInicio: Date | null
    fechaVencimiento: Date | null
    estado: string | null
    progreso: number | null
    instrucciones: string | null
    recordatorios: boolean | null
    tokenAccesoExterno: string | null
    recurrencia: string | null
  }

  export type AsignacionCuestionarioCountAggregateOutputType = {
    id: number
    cuestionarioId: number
    cuestionarioIds: number
    titulo: number
    descripcion: number
    tipoRevision: number
    usuariosAsignados: number
    usuariosAsignadosNombres: number
    emailsExternos: number
    contrasenaAcceso: number
    activosObjetivo: number
    activosObjetivoNombres: number
    procesosObjetivo: number
    procesosObjetivoNombres: number
    aprobadores: number
    aprobadoresNombres: number
    evaluadosInternos: number
    evaluadosInternosNombres: number
    areaId: number
    areaNombre: number
    responsableId: number
    responsableNombre: number
    fechaAsignacion: number
    fechaInicio: number
    fechaVencimiento: number
    estado: number
    progreso: number
    instrucciones: number
    recordatorios: number
    tokenAccesoExterno: number
    recurrencia: number
    _all: number
  }


  export type AsignacionCuestionarioAvgAggregateInputType = {
    progreso?: true
  }

  export type AsignacionCuestionarioSumAggregateInputType = {
    progreso?: true
  }

  export type AsignacionCuestionarioMinAggregateInputType = {
    id?: true
    cuestionarioId?: true
    cuestionarioIds?: true
    titulo?: true
    descripcion?: true
    tipoRevision?: true
    usuariosAsignados?: true
    usuariosAsignadosNombres?: true
    emailsExternos?: true
    contrasenaAcceso?: true
    activosObjetivo?: true
    activosObjetivoNombres?: true
    procesosObjetivo?: true
    procesosObjetivoNombres?: true
    aprobadores?: true
    aprobadoresNombres?: true
    evaluadosInternos?: true
    evaluadosInternosNombres?: true
    areaId?: true
    areaNombre?: true
    responsableId?: true
    responsableNombre?: true
    fechaAsignacion?: true
    fechaInicio?: true
    fechaVencimiento?: true
    estado?: true
    progreso?: true
    instrucciones?: true
    recordatorios?: true
    tokenAccesoExterno?: true
    recurrencia?: true
  }

  export type AsignacionCuestionarioMaxAggregateInputType = {
    id?: true
    cuestionarioId?: true
    cuestionarioIds?: true
    titulo?: true
    descripcion?: true
    tipoRevision?: true
    usuariosAsignados?: true
    usuariosAsignadosNombres?: true
    emailsExternos?: true
    contrasenaAcceso?: true
    activosObjetivo?: true
    activosObjetivoNombres?: true
    procesosObjetivo?: true
    procesosObjetivoNombres?: true
    aprobadores?: true
    aprobadoresNombres?: true
    evaluadosInternos?: true
    evaluadosInternosNombres?: true
    areaId?: true
    areaNombre?: true
    responsableId?: true
    responsableNombre?: true
    fechaAsignacion?: true
    fechaInicio?: true
    fechaVencimiento?: true
    estado?: true
    progreso?: true
    instrucciones?: true
    recordatorios?: true
    tokenAccesoExterno?: true
    recurrencia?: true
  }

  export type AsignacionCuestionarioCountAggregateInputType = {
    id?: true
    cuestionarioId?: true
    cuestionarioIds?: true
    titulo?: true
    descripcion?: true
    tipoRevision?: true
    usuariosAsignados?: true
    usuariosAsignadosNombres?: true
    emailsExternos?: true
    contrasenaAcceso?: true
    activosObjetivo?: true
    activosObjetivoNombres?: true
    procesosObjetivo?: true
    procesosObjetivoNombres?: true
    aprobadores?: true
    aprobadoresNombres?: true
    evaluadosInternos?: true
    evaluadosInternosNombres?: true
    areaId?: true
    areaNombre?: true
    responsableId?: true
    responsableNombre?: true
    fechaAsignacion?: true
    fechaInicio?: true
    fechaVencimiento?: true
    estado?: true
    progreso?: true
    instrucciones?: true
    recordatorios?: true
    tokenAccesoExterno?: true
    recurrencia?: true
    _all?: true
  }

  export type AsignacionCuestionarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AsignacionCuestionario to aggregate.
     */
    where?: AsignacionCuestionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AsignacionCuestionarios to fetch.
     */
    orderBy?: AsignacionCuestionarioOrderByWithRelationInput | AsignacionCuestionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AsignacionCuestionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AsignacionCuestionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AsignacionCuestionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AsignacionCuestionarios
    **/
    _count?: true | AsignacionCuestionarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AsignacionCuestionarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AsignacionCuestionarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AsignacionCuestionarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AsignacionCuestionarioMaxAggregateInputType
  }

  export type GetAsignacionCuestionarioAggregateType<T extends AsignacionCuestionarioAggregateArgs> = {
        [P in keyof T & keyof AggregateAsignacionCuestionario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsignacionCuestionario[P]>
      : GetScalarType<T[P], AggregateAsignacionCuestionario[P]>
  }




  export type AsignacionCuestionarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AsignacionCuestionarioWhereInput
    orderBy?: AsignacionCuestionarioOrderByWithAggregationInput | AsignacionCuestionarioOrderByWithAggregationInput[]
    by: AsignacionCuestionarioScalarFieldEnum[] | AsignacionCuestionarioScalarFieldEnum
    having?: AsignacionCuestionarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AsignacionCuestionarioCountAggregateInputType | true
    _avg?: AsignacionCuestionarioAvgAggregateInputType
    _sum?: AsignacionCuestionarioSumAggregateInputType
    _min?: AsignacionCuestionarioMinAggregateInputType
    _max?: AsignacionCuestionarioMaxAggregateInputType
  }

  export type AsignacionCuestionarioGroupByOutputType = {
    id: string
    cuestionarioId: string
    cuestionarioIds: string | null
    titulo: string
    descripcion: string | null
    tipoRevision: string
    usuariosAsignados: string
    usuariosAsignadosNombres: string
    emailsExternos: string | null
    contrasenaAcceso: string | null
    activosObjetivo: string
    activosObjetivoNombres: string
    procesosObjetivo: string
    procesosObjetivoNombres: string
    aprobadores: string
    aprobadoresNombres: string
    evaluadosInternos: string | null
    evaluadosInternosNombres: string | null
    areaId: string
    areaNombre: string
    responsableId: string
    responsableNombre: string
    fechaAsignacion: Date
    fechaInicio: Date
    fechaVencimiento: Date
    estado: string
    progreso: number
    instrucciones: string | null
    recordatorios: boolean
    tokenAccesoExterno: string | null
    recurrencia: string | null
    _count: AsignacionCuestionarioCountAggregateOutputType | null
    _avg: AsignacionCuestionarioAvgAggregateOutputType | null
    _sum: AsignacionCuestionarioSumAggregateOutputType | null
    _min: AsignacionCuestionarioMinAggregateOutputType | null
    _max: AsignacionCuestionarioMaxAggregateOutputType | null
  }

  type GetAsignacionCuestionarioGroupByPayload<T extends AsignacionCuestionarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AsignacionCuestionarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AsignacionCuestionarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AsignacionCuestionarioGroupByOutputType[P]>
            : GetScalarType<T[P], AsignacionCuestionarioGroupByOutputType[P]>
        }
      >
    >


  export type AsignacionCuestionarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cuestionarioId?: boolean
    cuestionarioIds?: boolean
    titulo?: boolean
    descripcion?: boolean
    tipoRevision?: boolean
    usuariosAsignados?: boolean
    usuariosAsignadosNombres?: boolean
    emailsExternos?: boolean
    contrasenaAcceso?: boolean
    activosObjetivo?: boolean
    activosObjetivoNombres?: boolean
    procesosObjetivo?: boolean
    procesosObjetivoNombres?: boolean
    aprobadores?: boolean
    aprobadoresNombres?: boolean
    evaluadosInternos?: boolean
    evaluadosInternosNombres?: boolean
    areaId?: boolean
    areaNombre?: boolean
    responsableId?: boolean
    responsableNombre?: boolean
    fechaAsignacion?: boolean
    fechaInicio?: boolean
    fechaVencimiento?: boolean
    estado?: boolean
    progreso?: boolean
    instrucciones?: boolean
    recordatorios?: boolean
    tokenAccesoExterno?: boolean
    recurrencia?: boolean
    cuestionario?: boolean | CuestionarioDefaultArgs<ExtArgs>
    evaluadosExternos?: boolean | AsignacionCuestionario$evaluadosExternosArgs<ExtArgs>
    respuestas?: boolean | AsignacionCuestionario$respuestasArgs<ExtArgs>
    mensajesChat?: boolean | AsignacionCuestionario$mensajesChatArgs<ExtArgs>
    _count?: boolean | AsignacionCuestionarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asignacionCuestionario"]>

  export type AsignacionCuestionarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cuestionarioId?: boolean
    cuestionarioIds?: boolean
    titulo?: boolean
    descripcion?: boolean
    tipoRevision?: boolean
    usuariosAsignados?: boolean
    usuariosAsignadosNombres?: boolean
    emailsExternos?: boolean
    contrasenaAcceso?: boolean
    activosObjetivo?: boolean
    activosObjetivoNombres?: boolean
    procesosObjetivo?: boolean
    procesosObjetivoNombres?: boolean
    aprobadores?: boolean
    aprobadoresNombres?: boolean
    evaluadosInternos?: boolean
    evaluadosInternosNombres?: boolean
    areaId?: boolean
    areaNombre?: boolean
    responsableId?: boolean
    responsableNombre?: boolean
    fechaAsignacion?: boolean
    fechaInicio?: boolean
    fechaVencimiento?: boolean
    estado?: boolean
    progreso?: boolean
    instrucciones?: boolean
    recordatorios?: boolean
    tokenAccesoExterno?: boolean
    recurrencia?: boolean
    cuestionario?: boolean | CuestionarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asignacionCuestionario"]>

  export type AsignacionCuestionarioSelectScalar = {
    id?: boolean
    cuestionarioId?: boolean
    cuestionarioIds?: boolean
    titulo?: boolean
    descripcion?: boolean
    tipoRevision?: boolean
    usuariosAsignados?: boolean
    usuariosAsignadosNombres?: boolean
    emailsExternos?: boolean
    contrasenaAcceso?: boolean
    activosObjetivo?: boolean
    activosObjetivoNombres?: boolean
    procesosObjetivo?: boolean
    procesosObjetivoNombres?: boolean
    aprobadores?: boolean
    aprobadoresNombres?: boolean
    evaluadosInternos?: boolean
    evaluadosInternosNombres?: boolean
    areaId?: boolean
    areaNombre?: boolean
    responsableId?: boolean
    responsableNombre?: boolean
    fechaAsignacion?: boolean
    fechaInicio?: boolean
    fechaVencimiento?: boolean
    estado?: boolean
    progreso?: boolean
    instrucciones?: boolean
    recordatorios?: boolean
    tokenAccesoExterno?: boolean
    recurrencia?: boolean
  }

  export type AsignacionCuestionarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cuestionario?: boolean | CuestionarioDefaultArgs<ExtArgs>
    evaluadosExternos?: boolean | AsignacionCuestionario$evaluadosExternosArgs<ExtArgs>
    respuestas?: boolean | AsignacionCuestionario$respuestasArgs<ExtArgs>
    mensajesChat?: boolean | AsignacionCuestionario$mensajesChatArgs<ExtArgs>
    _count?: boolean | AsignacionCuestionarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AsignacionCuestionarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cuestionario?: boolean | CuestionarioDefaultArgs<ExtArgs>
  }

  export type $AsignacionCuestionarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AsignacionCuestionario"
    objects: {
      cuestionario: Prisma.$CuestionarioPayload<ExtArgs>
      evaluadosExternos: Prisma.$EvaluadoExternoPayload<ExtArgs>[]
      respuestas: Prisma.$RespuestaCuestionarioPayload<ExtArgs>[]
      mensajesChat: Prisma.$MensajeChatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cuestionarioId: string
      cuestionarioIds: string | null
      titulo: string
      descripcion: string | null
      tipoRevision: string
      usuariosAsignados: string
      usuariosAsignadosNombres: string
      emailsExternos: string | null
      contrasenaAcceso: string | null
      activosObjetivo: string
      activosObjetivoNombres: string
      procesosObjetivo: string
      procesosObjetivoNombres: string
      aprobadores: string
      aprobadoresNombres: string
      evaluadosInternos: string | null
      evaluadosInternosNombres: string | null
      areaId: string
      areaNombre: string
      responsableId: string
      responsableNombre: string
      fechaAsignacion: Date
      fechaInicio: Date
      fechaVencimiento: Date
      estado: string
      progreso: number
      instrucciones: string | null
      recordatorios: boolean
      tokenAccesoExterno: string | null
      recurrencia: string | null
    }, ExtArgs["result"]["asignacionCuestionario"]>
    composites: {}
  }

  type AsignacionCuestionarioGetPayload<S extends boolean | null | undefined | AsignacionCuestionarioDefaultArgs> = $Result.GetResult<Prisma.$AsignacionCuestionarioPayload, S>

  type AsignacionCuestionarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AsignacionCuestionarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AsignacionCuestionarioCountAggregateInputType | true
    }

  export interface AsignacionCuestionarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AsignacionCuestionario'], meta: { name: 'AsignacionCuestionario' } }
    /**
     * Find zero or one AsignacionCuestionario that matches the filter.
     * @param {AsignacionCuestionarioFindUniqueArgs} args - Arguments to find a AsignacionCuestionario
     * @example
     * // Get one AsignacionCuestionario
     * const asignacionCuestionario = await prisma.asignacionCuestionario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AsignacionCuestionarioFindUniqueArgs>(args: SelectSubset<T, AsignacionCuestionarioFindUniqueArgs<ExtArgs>>): Prisma__AsignacionCuestionarioClient<$Result.GetResult<Prisma.$AsignacionCuestionarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AsignacionCuestionario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AsignacionCuestionarioFindUniqueOrThrowArgs} args - Arguments to find a AsignacionCuestionario
     * @example
     * // Get one AsignacionCuestionario
     * const asignacionCuestionario = await prisma.asignacionCuestionario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AsignacionCuestionarioFindUniqueOrThrowArgs>(args: SelectSubset<T, AsignacionCuestionarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AsignacionCuestionarioClient<$Result.GetResult<Prisma.$AsignacionCuestionarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AsignacionCuestionario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsignacionCuestionarioFindFirstArgs} args - Arguments to find a AsignacionCuestionario
     * @example
     * // Get one AsignacionCuestionario
     * const asignacionCuestionario = await prisma.asignacionCuestionario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AsignacionCuestionarioFindFirstArgs>(args?: SelectSubset<T, AsignacionCuestionarioFindFirstArgs<ExtArgs>>): Prisma__AsignacionCuestionarioClient<$Result.GetResult<Prisma.$AsignacionCuestionarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AsignacionCuestionario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsignacionCuestionarioFindFirstOrThrowArgs} args - Arguments to find a AsignacionCuestionario
     * @example
     * // Get one AsignacionCuestionario
     * const asignacionCuestionario = await prisma.asignacionCuestionario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AsignacionCuestionarioFindFirstOrThrowArgs>(args?: SelectSubset<T, AsignacionCuestionarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__AsignacionCuestionarioClient<$Result.GetResult<Prisma.$AsignacionCuestionarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AsignacionCuestionarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsignacionCuestionarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AsignacionCuestionarios
     * const asignacionCuestionarios = await prisma.asignacionCuestionario.findMany()
     * 
     * // Get first 10 AsignacionCuestionarios
     * const asignacionCuestionarios = await prisma.asignacionCuestionario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const asignacionCuestionarioWithIdOnly = await prisma.asignacionCuestionario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AsignacionCuestionarioFindManyArgs>(args?: SelectSubset<T, AsignacionCuestionarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AsignacionCuestionarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AsignacionCuestionario.
     * @param {AsignacionCuestionarioCreateArgs} args - Arguments to create a AsignacionCuestionario.
     * @example
     * // Create one AsignacionCuestionario
     * const AsignacionCuestionario = await prisma.asignacionCuestionario.create({
     *   data: {
     *     // ... data to create a AsignacionCuestionario
     *   }
     * })
     * 
     */
    create<T extends AsignacionCuestionarioCreateArgs>(args: SelectSubset<T, AsignacionCuestionarioCreateArgs<ExtArgs>>): Prisma__AsignacionCuestionarioClient<$Result.GetResult<Prisma.$AsignacionCuestionarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AsignacionCuestionarios.
     * @param {AsignacionCuestionarioCreateManyArgs} args - Arguments to create many AsignacionCuestionarios.
     * @example
     * // Create many AsignacionCuestionarios
     * const asignacionCuestionario = await prisma.asignacionCuestionario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AsignacionCuestionarioCreateManyArgs>(args?: SelectSubset<T, AsignacionCuestionarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AsignacionCuestionarios and returns the data saved in the database.
     * @param {AsignacionCuestionarioCreateManyAndReturnArgs} args - Arguments to create many AsignacionCuestionarios.
     * @example
     * // Create many AsignacionCuestionarios
     * const asignacionCuestionario = await prisma.asignacionCuestionario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AsignacionCuestionarios and only return the `id`
     * const asignacionCuestionarioWithIdOnly = await prisma.asignacionCuestionario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AsignacionCuestionarioCreateManyAndReturnArgs>(args?: SelectSubset<T, AsignacionCuestionarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AsignacionCuestionarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AsignacionCuestionario.
     * @param {AsignacionCuestionarioDeleteArgs} args - Arguments to delete one AsignacionCuestionario.
     * @example
     * // Delete one AsignacionCuestionario
     * const AsignacionCuestionario = await prisma.asignacionCuestionario.delete({
     *   where: {
     *     // ... filter to delete one AsignacionCuestionario
     *   }
     * })
     * 
     */
    delete<T extends AsignacionCuestionarioDeleteArgs>(args: SelectSubset<T, AsignacionCuestionarioDeleteArgs<ExtArgs>>): Prisma__AsignacionCuestionarioClient<$Result.GetResult<Prisma.$AsignacionCuestionarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AsignacionCuestionario.
     * @param {AsignacionCuestionarioUpdateArgs} args - Arguments to update one AsignacionCuestionario.
     * @example
     * // Update one AsignacionCuestionario
     * const asignacionCuestionario = await prisma.asignacionCuestionario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AsignacionCuestionarioUpdateArgs>(args: SelectSubset<T, AsignacionCuestionarioUpdateArgs<ExtArgs>>): Prisma__AsignacionCuestionarioClient<$Result.GetResult<Prisma.$AsignacionCuestionarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AsignacionCuestionarios.
     * @param {AsignacionCuestionarioDeleteManyArgs} args - Arguments to filter AsignacionCuestionarios to delete.
     * @example
     * // Delete a few AsignacionCuestionarios
     * const { count } = await prisma.asignacionCuestionario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AsignacionCuestionarioDeleteManyArgs>(args?: SelectSubset<T, AsignacionCuestionarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AsignacionCuestionarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsignacionCuestionarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AsignacionCuestionarios
     * const asignacionCuestionario = await prisma.asignacionCuestionario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AsignacionCuestionarioUpdateManyArgs>(args: SelectSubset<T, AsignacionCuestionarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AsignacionCuestionario.
     * @param {AsignacionCuestionarioUpsertArgs} args - Arguments to update or create a AsignacionCuestionario.
     * @example
     * // Update or create a AsignacionCuestionario
     * const asignacionCuestionario = await prisma.asignacionCuestionario.upsert({
     *   create: {
     *     // ... data to create a AsignacionCuestionario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AsignacionCuestionario we want to update
     *   }
     * })
     */
    upsert<T extends AsignacionCuestionarioUpsertArgs>(args: SelectSubset<T, AsignacionCuestionarioUpsertArgs<ExtArgs>>): Prisma__AsignacionCuestionarioClient<$Result.GetResult<Prisma.$AsignacionCuestionarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AsignacionCuestionarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsignacionCuestionarioCountArgs} args - Arguments to filter AsignacionCuestionarios to count.
     * @example
     * // Count the number of AsignacionCuestionarios
     * const count = await prisma.asignacionCuestionario.count({
     *   where: {
     *     // ... the filter for the AsignacionCuestionarios we want to count
     *   }
     * })
    **/
    count<T extends AsignacionCuestionarioCountArgs>(
      args?: Subset<T, AsignacionCuestionarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AsignacionCuestionarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AsignacionCuestionario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsignacionCuestionarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AsignacionCuestionarioAggregateArgs>(args: Subset<T, AsignacionCuestionarioAggregateArgs>): Prisma.PrismaPromise<GetAsignacionCuestionarioAggregateType<T>>

    /**
     * Group by AsignacionCuestionario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsignacionCuestionarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AsignacionCuestionarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AsignacionCuestionarioGroupByArgs['orderBy'] }
        : { orderBy?: AsignacionCuestionarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AsignacionCuestionarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAsignacionCuestionarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AsignacionCuestionario model
   */
  readonly fields: AsignacionCuestionarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AsignacionCuestionario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AsignacionCuestionarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cuestionario<T extends CuestionarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CuestionarioDefaultArgs<ExtArgs>>): Prisma__CuestionarioClient<$Result.GetResult<Prisma.$CuestionarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    evaluadosExternos<T extends AsignacionCuestionario$evaluadosExternosArgs<ExtArgs> = {}>(args?: Subset<T, AsignacionCuestionario$evaluadosExternosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluadoExternoPayload<ExtArgs>, T, "findMany"> | Null>
    respuestas<T extends AsignacionCuestionario$respuestasArgs<ExtArgs> = {}>(args?: Subset<T, AsignacionCuestionario$respuestasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RespuestaCuestionarioPayload<ExtArgs>, T, "findMany"> | Null>
    mensajesChat<T extends AsignacionCuestionario$mensajesChatArgs<ExtArgs> = {}>(args?: Subset<T, AsignacionCuestionario$mensajesChatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensajeChatPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AsignacionCuestionario model
   */ 
  interface AsignacionCuestionarioFieldRefs {
    readonly id: FieldRef<"AsignacionCuestionario", 'String'>
    readonly cuestionarioId: FieldRef<"AsignacionCuestionario", 'String'>
    readonly cuestionarioIds: FieldRef<"AsignacionCuestionario", 'String'>
    readonly titulo: FieldRef<"AsignacionCuestionario", 'String'>
    readonly descripcion: FieldRef<"AsignacionCuestionario", 'String'>
    readonly tipoRevision: FieldRef<"AsignacionCuestionario", 'String'>
    readonly usuariosAsignados: FieldRef<"AsignacionCuestionario", 'String'>
    readonly usuariosAsignadosNombres: FieldRef<"AsignacionCuestionario", 'String'>
    readonly emailsExternos: FieldRef<"AsignacionCuestionario", 'String'>
    readonly contrasenaAcceso: FieldRef<"AsignacionCuestionario", 'String'>
    readonly activosObjetivo: FieldRef<"AsignacionCuestionario", 'String'>
    readonly activosObjetivoNombres: FieldRef<"AsignacionCuestionario", 'String'>
    readonly procesosObjetivo: FieldRef<"AsignacionCuestionario", 'String'>
    readonly procesosObjetivoNombres: FieldRef<"AsignacionCuestionario", 'String'>
    readonly aprobadores: FieldRef<"AsignacionCuestionario", 'String'>
    readonly aprobadoresNombres: FieldRef<"AsignacionCuestionario", 'String'>
    readonly evaluadosInternos: FieldRef<"AsignacionCuestionario", 'String'>
    readonly evaluadosInternosNombres: FieldRef<"AsignacionCuestionario", 'String'>
    readonly areaId: FieldRef<"AsignacionCuestionario", 'String'>
    readonly areaNombre: FieldRef<"AsignacionCuestionario", 'String'>
    readonly responsableId: FieldRef<"AsignacionCuestionario", 'String'>
    readonly responsableNombre: FieldRef<"AsignacionCuestionario", 'String'>
    readonly fechaAsignacion: FieldRef<"AsignacionCuestionario", 'DateTime'>
    readonly fechaInicio: FieldRef<"AsignacionCuestionario", 'DateTime'>
    readonly fechaVencimiento: FieldRef<"AsignacionCuestionario", 'DateTime'>
    readonly estado: FieldRef<"AsignacionCuestionario", 'String'>
    readonly progreso: FieldRef<"AsignacionCuestionario", 'Float'>
    readonly instrucciones: FieldRef<"AsignacionCuestionario", 'String'>
    readonly recordatorios: FieldRef<"AsignacionCuestionario", 'Boolean'>
    readonly tokenAccesoExterno: FieldRef<"AsignacionCuestionario", 'String'>
    readonly recurrencia: FieldRef<"AsignacionCuestionario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AsignacionCuestionario findUnique
   */
  export type AsignacionCuestionarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsignacionCuestionario
     */
    select?: AsignacionCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsignacionCuestionarioInclude<ExtArgs> | null
    /**
     * Filter, which AsignacionCuestionario to fetch.
     */
    where: AsignacionCuestionarioWhereUniqueInput
  }

  /**
   * AsignacionCuestionario findUniqueOrThrow
   */
  export type AsignacionCuestionarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsignacionCuestionario
     */
    select?: AsignacionCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsignacionCuestionarioInclude<ExtArgs> | null
    /**
     * Filter, which AsignacionCuestionario to fetch.
     */
    where: AsignacionCuestionarioWhereUniqueInput
  }

  /**
   * AsignacionCuestionario findFirst
   */
  export type AsignacionCuestionarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsignacionCuestionario
     */
    select?: AsignacionCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsignacionCuestionarioInclude<ExtArgs> | null
    /**
     * Filter, which AsignacionCuestionario to fetch.
     */
    where?: AsignacionCuestionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AsignacionCuestionarios to fetch.
     */
    orderBy?: AsignacionCuestionarioOrderByWithRelationInput | AsignacionCuestionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AsignacionCuestionarios.
     */
    cursor?: AsignacionCuestionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AsignacionCuestionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AsignacionCuestionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AsignacionCuestionarios.
     */
    distinct?: AsignacionCuestionarioScalarFieldEnum | AsignacionCuestionarioScalarFieldEnum[]
  }

  /**
   * AsignacionCuestionario findFirstOrThrow
   */
  export type AsignacionCuestionarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsignacionCuestionario
     */
    select?: AsignacionCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsignacionCuestionarioInclude<ExtArgs> | null
    /**
     * Filter, which AsignacionCuestionario to fetch.
     */
    where?: AsignacionCuestionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AsignacionCuestionarios to fetch.
     */
    orderBy?: AsignacionCuestionarioOrderByWithRelationInput | AsignacionCuestionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AsignacionCuestionarios.
     */
    cursor?: AsignacionCuestionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AsignacionCuestionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AsignacionCuestionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AsignacionCuestionarios.
     */
    distinct?: AsignacionCuestionarioScalarFieldEnum | AsignacionCuestionarioScalarFieldEnum[]
  }

  /**
   * AsignacionCuestionario findMany
   */
  export type AsignacionCuestionarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsignacionCuestionario
     */
    select?: AsignacionCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsignacionCuestionarioInclude<ExtArgs> | null
    /**
     * Filter, which AsignacionCuestionarios to fetch.
     */
    where?: AsignacionCuestionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AsignacionCuestionarios to fetch.
     */
    orderBy?: AsignacionCuestionarioOrderByWithRelationInput | AsignacionCuestionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AsignacionCuestionarios.
     */
    cursor?: AsignacionCuestionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AsignacionCuestionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AsignacionCuestionarios.
     */
    skip?: number
    distinct?: AsignacionCuestionarioScalarFieldEnum | AsignacionCuestionarioScalarFieldEnum[]
  }

  /**
   * AsignacionCuestionario create
   */
  export type AsignacionCuestionarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsignacionCuestionario
     */
    select?: AsignacionCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsignacionCuestionarioInclude<ExtArgs> | null
    /**
     * The data needed to create a AsignacionCuestionario.
     */
    data: XOR<AsignacionCuestionarioCreateInput, AsignacionCuestionarioUncheckedCreateInput>
  }

  /**
   * AsignacionCuestionario createMany
   */
  export type AsignacionCuestionarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AsignacionCuestionarios.
     */
    data: AsignacionCuestionarioCreateManyInput | AsignacionCuestionarioCreateManyInput[]
  }

  /**
   * AsignacionCuestionario createManyAndReturn
   */
  export type AsignacionCuestionarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsignacionCuestionario
     */
    select?: AsignacionCuestionarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AsignacionCuestionarios.
     */
    data: AsignacionCuestionarioCreateManyInput | AsignacionCuestionarioCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsignacionCuestionarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AsignacionCuestionario update
   */
  export type AsignacionCuestionarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsignacionCuestionario
     */
    select?: AsignacionCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsignacionCuestionarioInclude<ExtArgs> | null
    /**
     * The data needed to update a AsignacionCuestionario.
     */
    data: XOR<AsignacionCuestionarioUpdateInput, AsignacionCuestionarioUncheckedUpdateInput>
    /**
     * Choose, which AsignacionCuestionario to update.
     */
    where: AsignacionCuestionarioWhereUniqueInput
  }

  /**
   * AsignacionCuestionario updateMany
   */
  export type AsignacionCuestionarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AsignacionCuestionarios.
     */
    data: XOR<AsignacionCuestionarioUpdateManyMutationInput, AsignacionCuestionarioUncheckedUpdateManyInput>
    /**
     * Filter which AsignacionCuestionarios to update
     */
    where?: AsignacionCuestionarioWhereInput
  }

  /**
   * AsignacionCuestionario upsert
   */
  export type AsignacionCuestionarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsignacionCuestionario
     */
    select?: AsignacionCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsignacionCuestionarioInclude<ExtArgs> | null
    /**
     * The filter to search for the AsignacionCuestionario to update in case it exists.
     */
    where: AsignacionCuestionarioWhereUniqueInput
    /**
     * In case the AsignacionCuestionario found by the `where` argument doesn't exist, create a new AsignacionCuestionario with this data.
     */
    create: XOR<AsignacionCuestionarioCreateInput, AsignacionCuestionarioUncheckedCreateInput>
    /**
     * In case the AsignacionCuestionario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AsignacionCuestionarioUpdateInput, AsignacionCuestionarioUncheckedUpdateInput>
  }

  /**
   * AsignacionCuestionario delete
   */
  export type AsignacionCuestionarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsignacionCuestionario
     */
    select?: AsignacionCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsignacionCuestionarioInclude<ExtArgs> | null
    /**
     * Filter which AsignacionCuestionario to delete.
     */
    where: AsignacionCuestionarioWhereUniqueInput
  }

  /**
   * AsignacionCuestionario deleteMany
   */
  export type AsignacionCuestionarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AsignacionCuestionarios to delete
     */
    where?: AsignacionCuestionarioWhereInput
  }

  /**
   * AsignacionCuestionario.evaluadosExternos
   */
  export type AsignacionCuestionario$evaluadosExternosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluadoExterno
     */
    select?: EvaluadoExternoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluadoExternoInclude<ExtArgs> | null
    where?: EvaluadoExternoWhereInput
    orderBy?: EvaluadoExternoOrderByWithRelationInput | EvaluadoExternoOrderByWithRelationInput[]
    cursor?: EvaluadoExternoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluadoExternoScalarFieldEnum | EvaluadoExternoScalarFieldEnum[]
  }

  /**
   * AsignacionCuestionario.respuestas
   */
  export type AsignacionCuestionario$respuestasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaCuestionario
     */
    select?: RespuestaCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaCuestionarioInclude<ExtArgs> | null
    where?: RespuestaCuestionarioWhereInput
    orderBy?: RespuestaCuestionarioOrderByWithRelationInput | RespuestaCuestionarioOrderByWithRelationInput[]
    cursor?: RespuestaCuestionarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RespuestaCuestionarioScalarFieldEnum | RespuestaCuestionarioScalarFieldEnum[]
  }

  /**
   * AsignacionCuestionario.mensajesChat
   */
  export type AsignacionCuestionario$mensajesChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensajeChat
     */
    select?: MensajeChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeChatInclude<ExtArgs> | null
    where?: MensajeChatWhereInput
    orderBy?: MensajeChatOrderByWithRelationInput | MensajeChatOrderByWithRelationInput[]
    cursor?: MensajeChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MensajeChatScalarFieldEnum | MensajeChatScalarFieldEnum[]
  }

  /**
   * AsignacionCuestionario without action
   */
  export type AsignacionCuestionarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AsignacionCuestionario
     */
    select?: AsignacionCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsignacionCuestionarioInclude<ExtArgs> | null
  }


  /**
   * Model EvaluadoExterno
   */

  export type AggregateEvaluadoExterno = {
    _count: EvaluadoExternoCountAggregateOutputType | null
    _min: EvaluadoExternoMinAggregateOutputType | null
    _max: EvaluadoExternoMaxAggregateOutputType | null
  }

  export type EvaluadoExternoMinAggregateOutputType = {
    id: string | null
    asignacionId: string | null
    nombre: string | null
    email: string | null
    password: string | null
    invitacionEnviada: boolean | null
    fechaInvitacion: Date | null
    haRespondido: boolean | null
    fechaRespuesta: Date | null
  }

  export type EvaluadoExternoMaxAggregateOutputType = {
    id: string | null
    asignacionId: string | null
    nombre: string | null
    email: string | null
    password: string | null
    invitacionEnviada: boolean | null
    fechaInvitacion: Date | null
    haRespondido: boolean | null
    fechaRespuesta: Date | null
  }

  export type EvaluadoExternoCountAggregateOutputType = {
    id: number
    asignacionId: number
    nombre: number
    email: number
    password: number
    invitacionEnviada: number
    fechaInvitacion: number
    haRespondido: number
    fechaRespuesta: number
    _all: number
  }


  export type EvaluadoExternoMinAggregateInputType = {
    id?: true
    asignacionId?: true
    nombre?: true
    email?: true
    password?: true
    invitacionEnviada?: true
    fechaInvitacion?: true
    haRespondido?: true
    fechaRespuesta?: true
  }

  export type EvaluadoExternoMaxAggregateInputType = {
    id?: true
    asignacionId?: true
    nombre?: true
    email?: true
    password?: true
    invitacionEnviada?: true
    fechaInvitacion?: true
    haRespondido?: true
    fechaRespuesta?: true
  }

  export type EvaluadoExternoCountAggregateInputType = {
    id?: true
    asignacionId?: true
    nombre?: true
    email?: true
    password?: true
    invitacionEnviada?: true
    fechaInvitacion?: true
    haRespondido?: true
    fechaRespuesta?: true
    _all?: true
  }

  export type EvaluadoExternoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluadoExterno to aggregate.
     */
    where?: EvaluadoExternoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluadoExternos to fetch.
     */
    orderBy?: EvaluadoExternoOrderByWithRelationInput | EvaluadoExternoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluadoExternoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluadoExternos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluadoExternos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvaluadoExternos
    **/
    _count?: true | EvaluadoExternoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluadoExternoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluadoExternoMaxAggregateInputType
  }

  export type GetEvaluadoExternoAggregateType<T extends EvaluadoExternoAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluadoExterno]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluadoExterno[P]>
      : GetScalarType<T[P], AggregateEvaluadoExterno[P]>
  }




  export type EvaluadoExternoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluadoExternoWhereInput
    orderBy?: EvaluadoExternoOrderByWithAggregationInput | EvaluadoExternoOrderByWithAggregationInput[]
    by: EvaluadoExternoScalarFieldEnum[] | EvaluadoExternoScalarFieldEnum
    having?: EvaluadoExternoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluadoExternoCountAggregateInputType | true
    _min?: EvaluadoExternoMinAggregateInputType
    _max?: EvaluadoExternoMaxAggregateInputType
  }

  export type EvaluadoExternoGroupByOutputType = {
    id: string
    asignacionId: string
    nombre: string
    email: string
    password: string | null
    invitacionEnviada: boolean
    fechaInvitacion: Date | null
    haRespondido: boolean
    fechaRespuesta: Date | null
    _count: EvaluadoExternoCountAggregateOutputType | null
    _min: EvaluadoExternoMinAggregateOutputType | null
    _max: EvaluadoExternoMaxAggregateOutputType | null
  }

  type GetEvaluadoExternoGroupByPayload<T extends EvaluadoExternoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluadoExternoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluadoExternoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluadoExternoGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluadoExternoGroupByOutputType[P]>
        }
      >
    >


  export type EvaluadoExternoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asignacionId?: boolean
    nombre?: boolean
    email?: boolean
    password?: boolean
    invitacionEnviada?: boolean
    fechaInvitacion?: boolean
    haRespondido?: boolean
    fechaRespuesta?: boolean
    asignacion?: boolean | AsignacionCuestionarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluadoExterno"]>

  export type EvaluadoExternoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asignacionId?: boolean
    nombre?: boolean
    email?: boolean
    password?: boolean
    invitacionEnviada?: boolean
    fechaInvitacion?: boolean
    haRespondido?: boolean
    fechaRespuesta?: boolean
    asignacion?: boolean | AsignacionCuestionarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluadoExterno"]>

  export type EvaluadoExternoSelectScalar = {
    id?: boolean
    asignacionId?: boolean
    nombre?: boolean
    email?: boolean
    password?: boolean
    invitacionEnviada?: boolean
    fechaInvitacion?: boolean
    haRespondido?: boolean
    fechaRespuesta?: boolean
  }

  export type EvaluadoExternoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asignacion?: boolean | AsignacionCuestionarioDefaultArgs<ExtArgs>
  }
  export type EvaluadoExternoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asignacion?: boolean | AsignacionCuestionarioDefaultArgs<ExtArgs>
  }

  export type $EvaluadoExternoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvaluadoExterno"
    objects: {
      asignacion: Prisma.$AsignacionCuestionarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      asignacionId: string
      nombre: string
      email: string
      password: string | null
      invitacionEnviada: boolean
      fechaInvitacion: Date | null
      haRespondido: boolean
      fechaRespuesta: Date | null
    }, ExtArgs["result"]["evaluadoExterno"]>
    composites: {}
  }

  type EvaluadoExternoGetPayload<S extends boolean | null | undefined | EvaluadoExternoDefaultArgs> = $Result.GetResult<Prisma.$EvaluadoExternoPayload, S>

  type EvaluadoExternoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvaluadoExternoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvaluadoExternoCountAggregateInputType | true
    }

  export interface EvaluadoExternoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvaluadoExterno'], meta: { name: 'EvaluadoExterno' } }
    /**
     * Find zero or one EvaluadoExterno that matches the filter.
     * @param {EvaluadoExternoFindUniqueArgs} args - Arguments to find a EvaluadoExterno
     * @example
     * // Get one EvaluadoExterno
     * const evaluadoExterno = await prisma.evaluadoExterno.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluadoExternoFindUniqueArgs>(args: SelectSubset<T, EvaluadoExternoFindUniqueArgs<ExtArgs>>): Prisma__EvaluadoExternoClient<$Result.GetResult<Prisma.$EvaluadoExternoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EvaluadoExterno that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvaluadoExternoFindUniqueOrThrowArgs} args - Arguments to find a EvaluadoExterno
     * @example
     * // Get one EvaluadoExterno
     * const evaluadoExterno = await prisma.evaluadoExterno.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluadoExternoFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluadoExternoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluadoExternoClient<$Result.GetResult<Prisma.$EvaluadoExternoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EvaluadoExterno that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluadoExternoFindFirstArgs} args - Arguments to find a EvaluadoExterno
     * @example
     * // Get one EvaluadoExterno
     * const evaluadoExterno = await prisma.evaluadoExterno.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluadoExternoFindFirstArgs>(args?: SelectSubset<T, EvaluadoExternoFindFirstArgs<ExtArgs>>): Prisma__EvaluadoExternoClient<$Result.GetResult<Prisma.$EvaluadoExternoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EvaluadoExterno that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluadoExternoFindFirstOrThrowArgs} args - Arguments to find a EvaluadoExterno
     * @example
     * // Get one EvaluadoExterno
     * const evaluadoExterno = await prisma.evaluadoExterno.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluadoExternoFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluadoExternoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluadoExternoClient<$Result.GetResult<Prisma.$EvaluadoExternoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EvaluadoExternos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluadoExternoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvaluadoExternos
     * const evaluadoExternos = await prisma.evaluadoExterno.findMany()
     * 
     * // Get first 10 EvaluadoExternos
     * const evaluadoExternos = await prisma.evaluadoExterno.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluadoExternoWithIdOnly = await prisma.evaluadoExterno.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaluadoExternoFindManyArgs>(args?: SelectSubset<T, EvaluadoExternoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluadoExternoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EvaluadoExterno.
     * @param {EvaluadoExternoCreateArgs} args - Arguments to create a EvaluadoExterno.
     * @example
     * // Create one EvaluadoExterno
     * const EvaluadoExterno = await prisma.evaluadoExterno.create({
     *   data: {
     *     // ... data to create a EvaluadoExterno
     *   }
     * })
     * 
     */
    create<T extends EvaluadoExternoCreateArgs>(args: SelectSubset<T, EvaluadoExternoCreateArgs<ExtArgs>>): Prisma__EvaluadoExternoClient<$Result.GetResult<Prisma.$EvaluadoExternoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EvaluadoExternos.
     * @param {EvaluadoExternoCreateManyArgs} args - Arguments to create many EvaluadoExternos.
     * @example
     * // Create many EvaluadoExternos
     * const evaluadoExterno = await prisma.evaluadoExterno.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluadoExternoCreateManyArgs>(args?: SelectSubset<T, EvaluadoExternoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvaluadoExternos and returns the data saved in the database.
     * @param {EvaluadoExternoCreateManyAndReturnArgs} args - Arguments to create many EvaluadoExternos.
     * @example
     * // Create many EvaluadoExternos
     * const evaluadoExterno = await prisma.evaluadoExterno.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvaluadoExternos and only return the `id`
     * const evaluadoExternoWithIdOnly = await prisma.evaluadoExterno.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvaluadoExternoCreateManyAndReturnArgs>(args?: SelectSubset<T, EvaluadoExternoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluadoExternoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EvaluadoExterno.
     * @param {EvaluadoExternoDeleteArgs} args - Arguments to delete one EvaluadoExterno.
     * @example
     * // Delete one EvaluadoExterno
     * const EvaluadoExterno = await prisma.evaluadoExterno.delete({
     *   where: {
     *     // ... filter to delete one EvaluadoExterno
     *   }
     * })
     * 
     */
    delete<T extends EvaluadoExternoDeleteArgs>(args: SelectSubset<T, EvaluadoExternoDeleteArgs<ExtArgs>>): Prisma__EvaluadoExternoClient<$Result.GetResult<Prisma.$EvaluadoExternoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EvaluadoExterno.
     * @param {EvaluadoExternoUpdateArgs} args - Arguments to update one EvaluadoExterno.
     * @example
     * // Update one EvaluadoExterno
     * const evaluadoExterno = await prisma.evaluadoExterno.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluadoExternoUpdateArgs>(args: SelectSubset<T, EvaluadoExternoUpdateArgs<ExtArgs>>): Prisma__EvaluadoExternoClient<$Result.GetResult<Prisma.$EvaluadoExternoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EvaluadoExternos.
     * @param {EvaluadoExternoDeleteManyArgs} args - Arguments to filter EvaluadoExternos to delete.
     * @example
     * // Delete a few EvaluadoExternos
     * const { count } = await prisma.evaluadoExterno.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluadoExternoDeleteManyArgs>(args?: SelectSubset<T, EvaluadoExternoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvaluadoExternos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluadoExternoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvaluadoExternos
     * const evaluadoExterno = await prisma.evaluadoExterno.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluadoExternoUpdateManyArgs>(args: SelectSubset<T, EvaluadoExternoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EvaluadoExterno.
     * @param {EvaluadoExternoUpsertArgs} args - Arguments to update or create a EvaluadoExterno.
     * @example
     * // Update or create a EvaluadoExterno
     * const evaluadoExterno = await prisma.evaluadoExterno.upsert({
     *   create: {
     *     // ... data to create a EvaluadoExterno
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvaluadoExterno we want to update
     *   }
     * })
     */
    upsert<T extends EvaluadoExternoUpsertArgs>(args: SelectSubset<T, EvaluadoExternoUpsertArgs<ExtArgs>>): Prisma__EvaluadoExternoClient<$Result.GetResult<Prisma.$EvaluadoExternoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EvaluadoExternos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluadoExternoCountArgs} args - Arguments to filter EvaluadoExternos to count.
     * @example
     * // Count the number of EvaluadoExternos
     * const count = await prisma.evaluadoExterno.count({
     *   where: {
     *     // ... the filter for the EvaluadoExternos we want to count
     *   }
     * })
    **/
    count<T extends EvaluadoExternoCountArgs>(
      args?: Subset<T, EvaluadoExternoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluadoExternoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvaluadoExterno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluadoExternoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluadoExternoAggregateArgs>(args: Subset<T, EvaluadoExternoAggregateArgs>): Prisma.PrismaPromise<GetEvaluadoExternoAggregateType<T>>

    /**
     * Group by EvaluadoExterno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluadoExternoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluadoExternoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluadoExternoGroupByArgs['orderBy'] }
        : { orderBy?: EvaluadoExternoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluadoExternoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluadoExternoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvaluadoExterno model
   */
  readonly fields: EvaluadoExternoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvaluadoExterno.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluadoExternoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asignacion<T extends AsignacionCuestionarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AsignacionCuestionarioDefaultArgs<ExtArgs>>): Prisma__AsignacionCuestionarioClient<$Result.GetResult<Prisma.$AsignacionCuestionarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvaluadoExterno model
   */ 
  interface EvaluadoExternoFieldRefs {
    readonly id: FieldRef<"EvaluadoExterno", 'String'>
    readonly asignacionId: FieldRef<"EvaluadoExterno", 'String'>
    readonly nombre: FieldRef<"EvaluadoExterno", 'String'>
    readonly email: FieldRef<"EvaluadoExterno", 'String'>
    readonly password: FieldRef<"EvaluadoExterno", 'String'>
    readonly invitacionEnviada: FieldRef<"EvaluadoExterno", 'Boolean'>
    readonly fechaInvitacion: FieldRef<"EvaluadoExterno", 'DateTime'>
    readonly haRespondido: FieldRef<"EvaluadoExterno", 'Boolean'>
    readonly fechaRespuesta: FieldRef<"EvaluadoExterno", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EvaluadoExterno findUnique
   */
  export type EvaluadoExternoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluadoExterno
     */
    select?: EvaluadoExternoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluadoExternoInclude<ExtArgs> | null
    /**
     * Filter, which EvaluadoExterno to fetch.
     */
    where: EvaluadoExternoWhereUniqueInput
  }

  /**
   * EvaluadoExterno findUniqueOrThrow
   */
  export type EvaluadoExternoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluadoExterno
     */
    select?: EvaluadoExternoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluadoExternoInclude<ExtArgs> | null
    /**
     * Filter, which EvaluadoExterno to fetch.
     */
    where: EvaluadoExternoWhereUniqueInput
  }

  /**
   * EvaluadoExterno findFirst
   */
  export type EvaluadoExternoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluadoExterno
     */
    select?: EvaluadoExternoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluadoExternoInclude<ExtArgs> | null
    /**
     * Filter, which EvaluadoExterno to fetch.
     */
    where?: EvaluadoExternoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluadoExternos to fetch.
     */
    orderBy?: EvaluadoExternoOrderByWithRelationInput | EvaluadoExternoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluadoExternos.
     */
    cursor?: EvaluadoExternoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluadoExternos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluadoExternos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluadoExternos.
     */
    distinct?: EvaluadoExternoScalarFieldEnum | EvaluadoExternoScalarFieldEnum[]
  }

  /**
   * EvaluadoExterno findFirstOrThrow
   */
  export type EvaluadoExternoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluadoExterno
     */
    select?: EvaluadoExternoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluadoExternoInclude<ExtArgs> | null
    /**
     * Filter, which EvaluadoExterno to fetch.
     */
    where?: EvaluadoExternoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluadoExternos to fetch.
     */
    orderBy?: EvaluadoExternoOrderByWithRelationInput | EvaluadoExternoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluadoExternos.
     */
    cursor?: EvaluadoExternoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluadoExternos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluadoExternos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluadoExternos.
     */
    distinct?: EvaluadoExternoScalarFieldEnum | EvaluadoExternoScalarFieldEnum[]
  }

  /**
   * EvaluadoExterno findMany
   */
  export type EvaluadoExternoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluadoExterno
     */
    select?: EvaluadoExternoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluadoExternoInclude<ExtArgs> | null
    /**
     * Filter, which EvaluadoExternos to fetch.
     */
    where?: EvaluadoExternoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluadoExternos to fetch.
     */
    orderBy?: EvaluadoExternoOrderByWithRelationInput | EvaluadoExternoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvaluadoExternos.
     */
    cursor?: EvaluadoExternoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluadoExternos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluadoExternos.
     */
    skip?: number
    distinct?: EvaluadoExternoScalarFieldEnum | EvaluadoExternoScalarFieldEnum[]
  }

  /**
   * EvaluadoExterno create
   */
  export type EvaluadoExternoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluadoExterno
     */
    select?: EvaluadoExternoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluadoExternoInclude<ExtArgs> | null
    /**
     * The data needed to create a EvaluadoExterno.
     */
    data: XOR<EvaluadoExternoCreateInput, EvaluadoExternoUncheckedCreateInput>
  }

  /**
   * EvaluadoExterno createMany
   */
  export type EvaluadoExternoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvaluadoExternos.
     */
    data: EvaluadoExternoCreateManyInput | EvaluadoExternoCreateManyInput[]
  }

  /**
   * EvaluadoExterno createManyAndReturn
   */
  export type EvaluadoExternoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluadoExterno
     */
    select?: EvaluadoExternoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EvaluadoExternos.
     */
    data: EvaluadoExternoCreateManyInput | EvaluadoExternoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluadoExternoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvaluadoExterno update
   */
  export type EvaluadoExternoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluadoExterno
     */
    select?: EvaluadoExternoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluadoExternoInclude<ExtArgs> | null
    /**
     * The data needed to update a EvaluadoExterno.
     */
    data: XOR<EvaluadoExternoUpdateInput, EvaluadoExternoUncheckedUpdateInput>
    /**
     * Choose, which EvaluadoExterno to update.
     */
    where: EvaluadoExternoWhereUniqueInput
  }

  /**
   * EvaluadoExterno updateMany
   */
  export type EvaluadoExternoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvaluadoExternos.
     */
    data: XOR<EvaluadoExternoUpdateManyMutationInput, EvaluadoExternoUncheckedUpdateManyInput>
    /**
     * Filter which EvaluadoExternos to update
     */
    where?: EvaluadoExternoWhereInput
  }

  /**
   * EvaluadoExterno upsert
   */
  export type EvaluadoExternoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluadoExterno
     */
    select?: EvaluadoExternoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluadoExternoInclude<ExtArgs> | null
    /**
     * The filter to search for the EvaluadoExterno to update in case it exists.
     */
    where: EvaluadoExternoWhereUniqueInput
    /**
     * In case the EvaluadoExterno found by the `where` argument doesn't exist, create a new EvaluadoExterno with this data.
     */
    create: XOR<EvaluadoExternoCreateInput, EvaluadoExternoUncheckedCreateInput>
    /**
     * In case the EvaluadoExterno was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluadoExternoUpdateInput, EvaluadoExternoUncheckedUpdateInput>
  }

  /**
   * EvaluadoExterno delete
   */
  export type EvaluadoExternoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluadoExterno
     */
    select?: EvaluadoExternoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluadoExternoInclude<ExtArgs> | null
    /**
     * Filter which EvaluadoExterno to delete.
     */
    where: EvaluadoExternoWhereUniqueInput
  }

  /**
   * EvaluadoExterno deleteMany
   */
  export type EvaluadoExternoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluadoExternos to delete
     */
    where?: EvaluadoExternoWhereInput
  }

  /**
   * EvaluadoExterno without action
   */
  export type EvaluadoExternoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluadoExterno
     */
    select?: EvaluadoExternoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluadoExternoInclude<ExtArgs> | null
  }


  /**
   * Model RespuestaCuestionario
   */

  export type AggregateRespuestaCuestionario = {
    _count: RespuestaCuestionarioCountAggregateOutputType | null
    _avg: RespuestaCuestionarioAvgAggregateOutputType | null
    _sum: RespuestaCuestionarioSumAggregateOutputType | null
    _min: RespuestaCuestionarioMinAggregateOutputType | null
    _max: RespuestaCuestionarioMaxAggregateOutputType | null
  }

  export type RespuestaCuestionarioAvgAggregateOutputType = {
    puntuacionTotal: number | null
  }

  export type RespuestaCuestionarioSumAggregateOutputType = {
    puntuacionTotal: number | null
  }

  export type RespuestaCuestionarioMinAggregateOutputType = {
    id: string | null
    asignacionId: string | null
    cuestionarioId: string | null
    respondidoPorId: string | null
    fechaInicio: Date | null
    fechaEnvio: Date | null
    estado: string | null
    puntuacionTotal: number | null
    nivelCumplimiento: string | null
    comentariosGenerales: string | null
  }

  export type RespuestaCuestionarioMaxAggregateOutputType = {
    id: string | null
    asignacionId: string | null
    cuestionarioId: string | null
    respondidoPorId: string | null
    fechaInicio: Date | null
    fechaEnvio: Date | null
    estado: string | null
    puntuacionTotal: number | null
    nivelCumplimiento: string | null
    comentariosGenerales: string | null
  }

  export type RespuestaCuestionarioCountAggregateOutputType = {
    id: number
    asignacionId: number
    cuestionarioId: number
    respondidoPorId: number
    fechaInicio: number
    fechaEnvio: number
    estado: number
    puntuacionTotal: number
    nivelCumplimiento: number
    comentariosGenerales: number
    _all: number
  }


  export type RespuestaCuestionarioAvgAggregateInputType = {
    puntuacionTotal?: true
  }

  export type RespuestaCuestionarioSumAggregateInputType = {
    puntuacionTotal?: true
  }

  export type RespuestaCuestionarioMinAggregateInputType = {
    id?: true
    asignacionId?: true
    cuestionarioId?: true
    respondidoPorId?: true
    fechaInicio?: true
    fechaEnvio?: true
    estado?: true
    puntuacionTotal?: true
    nivelCumplimiento?: true
    comentariosGenerales?: true
  }

  export type RespuestaCuestionarioMaxAggregateInputType = {
    id?: true
    asignacionId?: true
    cuestionarioId?: true
    respondidoPorId?: true
    fechaInicio?: true
    fechaEnvio?: true
    estado?: true
    puntuacionTotal?: true
    nivelCumplimiento?: true
    comentariosGenerales?: true
  }

  export type RespuestaCuestionarioCountAggregateInputType = {
    id?: true
    asignacionId?: true
    cuestionarioId?: true
    respondidoPorId?: true
    fechaInicio?: true
    fechaEnvio?: true
    estado?: true
    puntuacionTotal?: true
    nivelCumplimiento?: true
    comentariosGenerales?: true
    _all?: true
  }

  export type RespuestaCuestionarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RespuestaCuestionario to aggregate.
     */
    where?: RespuestaCuestionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RespuestaCuestionarios to fetch.
     */
    orderBy?: RespuestaCuestionarioOrderByWithRelationInput | RespuestaCuestionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RespuestaCuestionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RespuestaCuestionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RespuestaCuestionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RespuestaCuestionarios
    **/
    _count?: true | RespuestaCuestionarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RespuestaCuestionarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RespuestaCuestionarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RespuestaCuestionarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RespuestaCuestionarioMaxAggregateInputType
  }

  export type GetRespuestaCuestionarioAggregateType<T extends RespuestaCuestionarioAggregateArgs> = {
        [P in keyof T & keyof AggregateRespuestaCuestionario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRespuestaCuestionario[P]>
      : GetScalarType<T[P], AggregateRespuestaCuestionario[P]>
  }




  export type RespuestaCuestionarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RespuestaCuestionarioWhereInput
    orderBy?: RespuestaCuestionarioOrderByWithAggregationInput | RespuestaCuestionarioOrderByWithAggregationInput[]
    by: RespuestaCuestionarioScalarFieldEnum[] | RespuestaCuestionarioScalarFieldEnum
    having?: RespuestaCuestionarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RespuestaCuestionarioCountAggregateInputType | true
    _avg?: RespuestaCuestionarioAvgAggregateInputType
    _sum?: RespuestaCuestionarioSumAggregateInputType
    _min?: RespuestaCuestionarioMinAggregateInputType
    _max?: RespuestaCuestionarioMaxAggregateInputType
  }

  export type RespuestaCuestionarioGroupByOutputType = {
    id: string
    asignacionId: string
    cuestionarioId: string
    respondidoPorId: string
    fechaInicio: Date
    fechaEnvio: Date | null
    estado: string
    puntuacionTotal: number
    nivelCumplimiento: string | null
    comentariosGenerales: string | null
    _count: RespuestaCuestionarioCountAggregateOutputType | null
    _avg: RespuestaCuestionarioAvgAggregateOutputType | null
    _sum: RespuestaCuestionarioSumAggregateOutputType | null
    _min: RespuestaCuestionarioMinAggregateOutputType | null
    _max: RespuestaCuestionarioMaxAggregateOutputType | null
  }

  type GetRespuestaCuestionarioGroupByPayload<T extends RespuestaCuestionarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RespuestaCuestionarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RespuestaCuestionarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RespuestaCuestionarioGroupByOutputType[P]>
            : GetScalarType<T[P], RespuestaCuestionarioGroupByOutputType[P]>
        }
      >
    >


  export type RespuestaCuestionarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asignacionId?: boolean
    cuestionarioId?: boolean
    respondidoPorId?: boolean
    fechaInicio?: boolean
    fechaEnvio?: boolean
    estado?: boolean
    puntuacionTotal?: boolean
    nivelCumplimiento?: boolean
    comentariosGenerales?: boolean
    asignacion?: boolean | AsignacionCuestionarioDefaultArgs<ExtArgs>
    respondidoPor?: boolean | UsuarioDefaultArgs<ExtArgs>
    respuestas?: boolean | RespuestaCuestionario$respuestasArgs<ExtArgs>
    _count?: boolean | RespuestaCuestionarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["respuestaCuestionario"]>

  export type RespuestaCuestionarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asignacionId?: boolean
    cuestionarioId?: boolean
    respondidoPorId?: boolean
    fechaInicio?: boolean
    fechaEnvio?: boolean
    estado?: boolean
    puntuacionTotal?: boolean
    nivelCumplimiento?: boolean
    comentariosGenerales?: boolean
    asignacion?: boolean | AsignacionCuestionarioDefaultArgs<ExtArgs>
    respondidoPor?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["respuestaCuestionario"]>

  export type RespuestaCuestionarioSelectScalar = {
    id?: boolean
    asignacionId?: boolean
    cuestionarioId?: boolean
    respondidoPorId?: boolean
    fechaInicio?: boolean
    fechaEnvio?: boolean
    estado?: boolean
    puntuacionTotal?: boolean
    nivelCumplimiento?: boolean
    comentariosGenerales?: boolean
  }

  export type RespuestaCuestionarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asignacion?: boolean | AsignacionCuestionarioDefaultArgs<ExtArgs>
    respondidoPor?: boolean | UsuarioDefaultArgs<ExtArgs>
    respuestas?: boolean | RespuestaCuestionario$respuestasArgs<ExtArgs>
    _count?: boolean | RespuestaCuestionarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RespuestaCuestionarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asignacion?: boolean | AsignacionCuestionarioDefaultArgs<ExtArgs>
    respondidoPor?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $RespuestaCuestionarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RespuestaCuestionario"
    objects: {
      asignacion: Prisma.$AsignacionCuestionarioPayload<ExtArgs>
      respondidoPor: Prisma.$UsuarioPayload<ExtArgs>
      respuestas: Prisma.$RespuestaPreguntaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      asignacionId: string
      cuestionarioId: string
      respondidoPorId: string
      fechaInicio: Date
      fechaEnvio: Date | null
      estado: string
      puntuacionTotal: number
      nivelCumplimiento: string | null
      comentariosGenerales: string | null
    }, ExtArgs["result"]["respuestaCuestionario"]>
    composites: {}
  }

  type RespuestaCuestionarioGetPayload<S extends boolean | null | undefined | RespuestaCuestionarioDefaultArgs> = $Result.GetResult<Prisma.$RespuestaCuestionarioPayload, S>

  type RespuestaCuestionarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RespuestaCuestionarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RespuestaCuestionarioCountAggregateInputType | true
    }

  export interface RespuestaCuestionarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RespuestaCuestionario'], meta: { name: 'RespuestaCuestionario' } }
    /**
     * Find zero or one RespuestaCuestionario that matches the filter.
     * @param {RespuestaCuestionarioFindUniqueArgs} args - Arguments to find a RespuestaCuestionario
     * @example
     * // Get one RespuestaCuestionario
     * const respuestaCuestionario = await prisma.respuestaCuestionario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RespuestaCuestionarioFindUniqueArgs>(args: SelectSubset<T, RespuestaCuestionarioFindUniqueArgs<ExtArgs>>): Prisma__RespuestaCuestionarioClient<$Result.GetResult<Prisma.$RespuestaCuestionarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RespuestaCuestionario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RespuestaCuestionarioFindUniqueOrThrowArgs} args - Arguments to find a RespuestaCuestionario
     * @example
     * // Get one RespuestaCuestionario
     * const respuestaCuestionario = await prisma.respuestaCuestionario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RespuestaCuestionarioFindUniqueOrThrowArgs>(args: SelectSubset<T, RespuestaCuestionarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RespuestaCuestionarioClient<$Result.GetResult<Prisma.$RespuestaCuestionarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RespuestaCuestionario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaCuestionarioFindFirstArgs} args - Arguments to find a RespuestaCuestionario
     * @example
     * // Get one RespuestaCuestionario
     * const respuestaCuestionario = await prisma.respuestaCuestionario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RespuestaCuestionarioFindFirstArgs>(args?: SelectSubset<T, RespuestaCuestionarioFindFirstArgs<ExtArgs>>): Prisma__RespuestaCuestionarioClient<$Result.GetResult<Prisma.$RespuestaCuestionarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RespuestaCuestionario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaCuestionarioFindFirstOrThrowArgs} args - Arguments to find a RespuestaCuestionario
     * @example
     * // Get one RespuestaCuestionario
     * const respuestaCuestionario = await prisma.respuestaCuestionario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RespuestaCuestionarioFindFirstOrThrowArgs>(args?: SelectSubset<T, RespuestaCuestionarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__RespuestaCuestionarioClient<$Result.GetResult<Prisma.$RespuestaCuestionarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RespuestaCuestionarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaCuestionarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RespuestaCuestionarios
     * const respuestaCuestionarios = await prisma.respuestaCuestionario.findMany()
     * 
     * // Get first 10 RespuestaCuestionarios
     * const respuestaCuestionarios = await prisma.respuestaCuestionario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const respuestaCuestionarioWithIdOnly = await prisma.respuestaCuestionario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RespuestaCuestionarioFindManyArgs>(args?: SelectSubset<T, RespuestaCuestionarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RespuestaCuestionarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RespuestaCuestionario.
     * @param {RespuestaCuestionarioCreateArgs} args - Arguments to create a RespuestaCuestionario.
     * @example
     * // Create one RespuestaCuestionario
     * const RespuestaCuestionario = await prisma.respuestaCuestionario.create({
     *   data: {
     *     // ... data to create a RespuestaCuestionario
     *   }
     * })
     * 
     */
    create<T extends RespuestaCuestionarioCreateArgs>(args: SelectSubset<T, RespuestaCuestionarioCreateArgs<ExtArgs>>): Prisma__RespuestaCuestionarioClient<$Result.GetResult<Prisma.$RespuestaCuestionarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RespuestaCuestionarios.
     * @param {RespuestaCuestionarioCreateManyArgs} args - Arguments to create many RespuestaCuestionarios.
     * @example
     * // Create many RespuestaCuestionarios
     * const respuestaCuestionario = await prisma.respuestaCuestionario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RespuestaCuestionarioCreateManyArgs>(args?: SelectSubset<T, RespuestaCuestionarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RespuestaCuestionarios and returns the data saved in the database.
     * @param {RespuestaCuestionarioCreateManyAndReturnArgs} args - Arguments to create many RespuestaCuestionarios.
     * @example
     * // Create many RespuestaCuestionarios
     * const respuestaCuestionario = await prisma.respuestaCuestionario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RespuestaCuestionarios and only return the `id`
     * const respuestaCuestionarioWithIdOnly = await prisma.respuestaCuestionario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RespuestaCuestionarioCreateManyAndReturnArgs>(args?: SelectSubset<T, RespuestaCuestionarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RespuestaCuestionarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RespuestaCuestionario.
     * @param {RespuestaCuestionarioDeleteArgs} args - Arguments to delete one RespuestaCuestionario.
     * @example
     * // Delete one RespuestaCuestionario
     * const RespuestaCuestionario = await prisma.respuestaCuestionario.delete({
     *   where: {
     *     // ... filter to delete one RespuestaCuestionario
     *   }
     * })
     * 
     */
    delete<T extends RespuestaCuestionarioDeleteArgs>(args: SelectSubset<T, RespuestaCuestionarioDeleteArgs<ExtArgs>>): Prisma__RespuestaCuestionarioClient<$Result.GetResult<Prisma.$RespuestaCuestionarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RespuestaCuestionario.
     * @param {RespuestaCuestionarioUpdateArgs} args - Arguments to update one RespuestaCuestionario.
     * @example
     * // Update one RespuestaCuestionario
     * const respuestaCuestionario = await prisma.respuestaCuestionario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RespuestaCuestionarioUpdateArgs>(args: SelectSubset<T, RespuestaCuestionarioUpdateArgs<ExtArgs>>): Prisma__RespuestaCuestionarioClient<$Result.GetResult<Prisma.$RespuestaCuestionarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RespuestaCuestionarios.
     * @param {RespuestaCuestionarioDeleteManyArgs} args - Arguments to filter RespuestaCuestionarios to delete.
     * @example
     * // Delete a few RespuestaCuestionarios
     * const { count } = await prisma.respuestaCuestionario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RespuestaCuestionarioDeleteManyArgs>(args?: SelectSubset<T, RespuestaCuestionarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RespuestaCuestionarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaCuestionarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RespuestaCuestionarios
     * const respuestaCuestionario = await prisma.respuestaCuestionario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RespuestaCuestionarioUpdateManyArgs>(args: SelectSubset<T, RespuestaCuestionarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RespuestaCuestionario.
     * @param {RespuestaCuestionarioUpsertArgs} args - Arguments to update or create a RespuestaCuestionario.
     * @example
     * // Update or create a RespuestaCuestionario
     * const respuestaCuestionario = await prisma.respuestaCuestionario.upsert({
     *   create: {
     *     // ... data to create a RespuestaCuestionario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RespuestaCuestionario we want to update
     *   }
     * })
     */
    upsert<T extends RespuestaCuestionarioUpsertArgs>(args: SelectSubset<T, RespuestaCuestionarioUpsertArgs<ExtArgs>>): Prisma__RespuestaCuestionarioClient<$Result.GetResult<Prisma.$RespuestaCuestionarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RespuestaCuestionarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaCuestionarioCountArgs} args - Arguments to filter RespuestaCuestionarios to count.
     * @example
     * // Count the number of RespuestaCuestionarios
     * const count = await prisma.respuestaCuestionario.count({
     *   where: {
     *     // ... the filter for the RespuestaCuestionarios we want to count
     *   }
     * })
    **/
    count<T extends RespuestaCuestionarioCountArgs>(
      args?: Subset<T, RespuestaCuestionarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RespuestaCuestionarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RespuestaCuestionario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaCuestionarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RespuestaCuestionarioAggregateArgs>(args: Subset<T, RespuestaCuestionarioAggregateArgs>): Prisma.PrismaPromise<GetRespuestaCuestionarioAggregateType<T>>

    /**
     * Group by RespuestaCuestionario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaCuestionarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RespuestaCuestionarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RespuestaCuestionarioGroupByArgs['orderBy'] }
        : { orderBy?: RespuestaCuestionarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RespuestaCuestionarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRespuestaCuestionarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RespuestaCuestionario model
   */
  readonly fields: RespuestaCuestionarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RespuestaCuestionario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RespuestaCuestionarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asignacion<T extends AsignacionCuestionarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AsignacionCuestionarioDefaultArgs<ExtArgs>>): Prisma__AsignacionCuestionarioClient<$Result.GetResult<Prisma.$AsignacionCuestionarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    respondidoPor<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    respuestas<T extends RespuestaCuestionario$respuestasArgs<ExtArgs> = {}>(args?: Subset<T, RespuestaCuestionario$respuestasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RespuestaPreguntaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RespuestaCuestionario model
   */ 
  interface RespuestaCuestionarioFieldRefs {
    readonly id: FieldRef<"RespuestaCuestionario", 'String'>
    readonly asignacionId: FieldRef<"RespuestaCuestionario", 'String'>
    readonly cuestionarioId: FieldRef<"RespuestaCuestionario", 'String'>
    readonly respondidoPorId: FieldRef<"RespuestaCuestionario", 'String'>
    readonly fechaInicio: FieldRef<"RespuestaCuestionario", 'DateTime'>
    readonly fechaEnvio: FieldRef<"RespuestaCuestionario", 'DateTime'>
    readonly estado: FieldRef<"RespuestaCuestionario", 'String'>
    readonly puntuacionTotal: FieldRef<"RespuestaCuestionario", 'Float'>
    readonly nivelCumplimiento: FieldRef<"RespuestaCuestionario", 'String'>
    readonly comentariosGenerales: FieldRef<"RespuestaCuestionario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RespuestaCuestionario findUnique
   */
  export type RespuestaCuestionarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaCuestionario
     */
    select?: RespuestaCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaCuestionarioInclude<ExtArgs> | null
    /**
     * Filter, which RespuestaCuestionario to fetch.
     */
    where: RespuestaCuestionarioWhereUniqueInput
  }

  /**
   * RespuestaCuestionario findUniqueOrThrow
   */
  export type RespuestaCuestionarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaCuestionario
     */
    select?: RespuestaCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaCuestionarioInclude<ExtArgs> | null
    /**
     * Filter, which RespuestaCuestionario to fetch.
     */
    where: RespuestaCuestionarioWhereUniqueInput
  }

  /**
   * RespuestaCuestionario findFirst
   */
  export type RespuestaCuestionarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaCuestionario
     */
    select?: RespuestaCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaCuestionarioInclude<ExtArgs> | null
    /**
     * Filter, which RespuestaCuestionario to fetch.
     */
    where?: RespuestaCuestionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RespuestaCuestionarios to fetch.
     */
    orderBy?: RespuestaCuestionarioOrderByWithRelationInput | RespuestaCuestionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RespuestaCuestionarios.
     */
    cursor?: RespuestaCuestionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RespuestaCuestionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RespuestaCuestionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RespuestaCuestionarios.
     */
    distinct?: RespuestaCuestionarioScalarFieldEnum | RespuestaCuestionarioScalarFieldEnum[]
  }

  /**
   * RespuestaCuestionario findFirstOrThrow
   */
  export type RespuestaCuestionarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaCuestionario
     */
    select?: RespuestaCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaCuestionarioInclude<ExtArgs> | null
    /**
     * Filter, which RespuestaCuestionario to fetch.
     */
    where?: RespuestaCuestionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RespuestaCuestionarios to fetch.
     */
    orderBy?: RespuestaCuestionarioOrderByWithRelationInput | RespuestaCuestionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RespuestaCuestionarios.
     */
    cursor?: RespuestaCuestionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RespuestaCuestionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RespuestaCuestionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RespuestaCuestionarios.
     */
    distinct?: RespuestaCuestionarioScalarFieldEnum | RespuestaCuestionarioScalarFieldEnum[]
  }

  /**
   * RespuestaCuestionario findMany
   */
  export type RespuestaCuestionarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaCuestionario
     */
    select?: RespuestaCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaCuestionarioInclude<ExtArgs> | null
    /**
     * Filter, which RespuestaCuestionarios to fetch.
     */
    where?: RespuestaCuestionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RespuestaCuestionarios to fetch.
     */
    orderBy?: RespuestaCuestionarioOrderByWithRelationInput | RespuestaCuestionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RespuestaCuestionarios.
     */
    cursor?: RespuestaCuestionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RespuestaCuestionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RespuestaCuestionarios.
     */
    skip?: number
    distinct?: RespuestaCuestionarioScalarFieldEnum | RespuestaCuestionarioScalarFieldEnum[]
  }

  /**
   * RespuestaCuestionario create
   */
  export type RespuestaCuestionarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaCuestionario
     */
    select?: RespuestaCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaCuestionarioInclude<ExtArgs> | null
    /**
     * The data needed to create a RespuestaCuestionario.
     */
    data: XOR<RespuestaCuestionarioCreateInput, RespuestaCuestionarioUncheckedCreateInput>
  }

  /**
   * RespuestaCuestionario createMany
   */
  export type RespuestaCuestionarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RespuestaCuestionarios.
     */
    data: RespuestaCuestionarioCreateManyInput | RespuestaCuestionarioCreateManyInput[]
  }

  /**
   * RespuestaCuestionario createManyAndReturn
   */
  export type RespuestaCuestionarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaCuestionario
     */
    select?: RespuestaCuestionarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RespuestaCuestionarios.
     */
    data: RespuestaCuestionarioCreateManyInput | RespuestaCuestionarioCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaCuestionarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RespuestaCuestionario update
   */
  export type RespuestaCuestionarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaCuestionario
     */
    select?: RespuestaCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaCuestionarioInclude<ExtArgs> | null
    /**
     * The data needed to update a RespuestaCuestionario.
     */
    data: XOR<RespuestaCuestionarioUpdateInput, RespuestaCuestionarioUncheckedUpdateInput>
    /**
     * Choose, which RespuestaCuestionario to update.
     */
    where: RespuestaCuestionarioWhereUniqueInput
  }

  /**
   * RespuestaCuestionario updateMany
   */
  export type RespuestaCuestionarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RespuestaCuestionarios.
     */
    data: XOR<RespuestaCuestionarioUpdateManyMutationInput, RespuestaCuestionarioUncheckedUpdateManyInput>
    /**
     * Filter which RespuestaCuestionarios to update
     */
    where?: RespuestaCuestionarioWhereInput
  }

  /**
   * RespuestaCuestionario upsert
   */
  export type RespuestaCuestionarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaCuestionario
     */
    select?: RespuestaCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaCuestionarioInclude<ExtArgs> | null
    /**
     * The filter to search for the RespuestaCuestionario to update in case it exists.
     */
    where: RespuestaCuestionarioWhereUniqueInput
    /**
     * In case the RespuestaCuestionario found by the `where` argument doesn't exist, create a new RespuestaCuestionario with this data.
     */
    create: XOR<RespuestaCuestionarioCreateInput, RespuestaCuestionarioUncheckedCreateInput>
    /**
     * In case the RespuestaCuestionario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RespuestaCuestionarioUpdateInput, RespuestaCuestionarioUncheckedUpdateInput>
  }

  /**
   * RespuestaCuestionario delete
   */
  export type RespuestaCuestionarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaCuestionario
     */
    select?: RespuestaCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaCuestionarioInclude<ExtArgs> | null
    /**
     * Filter which RespuestaCuestionario to delete.
     */
    where: RespuestaCuestionarioWhereUniqueInput
  }

  /**
   * RespuestaCuestionario deleteMany
   */
  export type RespuestaCuestionarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RespuestaCuestionarios to delete
     */
    where?: RespuestaCuestionarioWhereInput
  }

  /**
   * RespuestaCuestionario.respuestas
   */
  export type RespuestaCuestionario$respuestasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaPregunta
     */
    select?: RespuestaPreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaPreguntaInclude<ExtArgs> | null
    where?: RespuestaPreguntaWhereInput
    orderBy?: RespuestaPreguntaOrderByWithRelationInput | RespuestaPreguntaOrderByWithRelationInput[]
    cursor?: RespuestaPreguntaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RespuestaPreguntaScalarFieldEnum | RespuestaPreguntaScalarFieldEnum[]
  }

  /**
   * RespuestaCuestionario without action
   */
  export type RespuestaCuestionarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaCuestionario
     */
    select?: RespuestaCuestionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaCuestionarioInclude<ExtArgs> | null
  }


  /**
   * Model RespuestaPregunta
   */

  export type AggregateRespuestaPregunta = {
    _count: RespuestaPreguntaCountAggregateOutputType | null
    _min: RespuestaPreguntaMinAggregateOutputType | null
    _max: RespuestaPreguntaMaxAggregateOutputType | null
  }

  export type RespuestaPreguntaMinAggregateOutputType = {
    id: string | null
    respuestaCuestionarioId: string | null
    preguntaId: string | null
    valor: string | null
    comentario: string | null
    archivosAdjuntos: string | null
    marcadaParaRevision: boolean | null
    estadoRevision: string | null
    comentarioRevisor: string | null
  }

  export type RespuestaPreguntaMaxAggregateOutputType = {
    id: string | null
    respuestaCuestionarioId: string | null
    preguntaId: string | null
    valor: string | null
    comentario: string | null
    archivosAdjuntos: string | null
    marcadaParaRevision: boolean | null
    estadoRevision: string | null
    comentarioRevisor: string | null
  }

  export type RespuestaPreguntaCountAggregateOutputType = {
    id: number
    respuestaCuestionarioId: number
    preguntaId: number
    valor: number
    comentario: number
    archivosAdjuntos: number
    marcadaParaRevision: number
    estadoRevision: number
    comentarioRevisor: number
    _all: number
  }


  export type RespuestaPreguntaMinAggregateInputType = {
    id?: true
    respuestaCuestionarioId?: true
    preguntaId?: true
    valor?: true
    comentario?: true
    archivosAdjuntos?: true
    marcadaParaRevision?: true
    estadoRevision?: true
    comentarioRevisor?: true
  }

  export type RespuestaPreguntaMaxAggregateInputType = {
    id?: true
    respuestaCuestionarioId?: true
    preguntaId?: true
    valor?: true
    comentario?: true
    archivosAdjuntos?: true
    marcadaParaRevision?: true
    estadoRevision?: true
    comentarioRevisor?: true
  }

  export type RespuestaPreguntaCountAggregateInputType = {
    id?: true
    respuestaCuestionarioId?: true
    preguntaId?: true
    valor?: true
    comentario?: true
    archivosAdjuntos?: true
    marcadaParaRevision?: true
    estadoRevision?: true
    comentarioRevisor?: true
    _all?: true
  }

  export type RespuestaPreguntaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RespuestaPregunta to aggregate.
     */
    where?: RespuestaPreguntaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RespuestaPreguntas to fetch.
     */
    orderBy?: RespuestaPreguntaOrderByWithRelationInput | RespuestaPreguntaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RespuestaPreguntaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RespuestaPreguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RespuestaPreguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RespuestaPreguntas
    **/
    _count?: true | RespuestaPreguntaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RespuestaPreguntaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RespuestaPreguntaMaxAggregateInputType
  }

  export type GetRespuestaPreguntaAggregateType<T extends RespuestaPreguntaAggregateArgs> = {
        [P in keyof T & keyof AggregateRespuestaPregunta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRespuestaPregunta[P]>
      : GetScalarType<T[P], AggregateRespuestaPregunta[P]>
  }




  export type RespuestaPreguntaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RespuestaPreguntaWhereInput
    orderBy?: RespuestaPreguntaOrderByWithAggregationInput | RespuestaPreguntaOrderByWithAggregationInput[]
    by: RespuestaPreguntaScalarFieldEnum[] | RespuestaPreguntaScalarFieldEnum
    having?: RespuestaPreguntaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RespuestaPreguntaCountAggregateInputType | true
    _min?: RespuestaPreguntaMinAggregateInputType
    _max?: RespuestaPreguntaMaxAggregateInputType
  }

  export type RespuestaPreguntaGroupByOutputType = {
    id: string
    respuestaCuestionarioId: string
    preguntaId: string
    valor: string | null
    comentario: string | null
    archivosAdjuntos: string | null
    marcadaParaRevision: boolean
    estadoRevision: string
    comentarioRevisor: string | null
    _count: RespuestaPreguntaCountAggregateOutputType | null
    _min: RespuestaPreguntaMinAggregateOutputType | null
    _max: RespuestaPreguntaMaxAggregateOutputType | null
  }

  type GetRespuestaPreguntaGroupByPayload<T extends RespuestaPreguntaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RespuestaPreguntaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RespuestaPreguntaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RespuestaPreguntaGroupByOutputType[P]>
            : GetScalarType<T[P], RespuestaPreguntaGroupByOutputType[P]>
        }
      >
    >


  export type RespuestaPreguntaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    respuestaCuestionarioId?: boolean
    preguntaId?: boolean
    valor?: boolean
    comentario?: boolean
    archivosAdjuntos?: boolean
    marcadaParaRevision?: boolean
    estadoRevision?: boolean
    comentarioRevisor?: boolean
    respuestaCuestionario?: boolean | RespuestaCuestionarioDefaultArgs<ExtArgs>
    pregunta?: boolean | PreguntaDefaultArgs<ExtArgs>
    evidencias?: boolean | RespuestaPregunta$evidenciasArgs<ExtArgs>
    _count?: boolean | RespuestaPreguntaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["respuestaPregunta"]>

  export type RespuestaPreguntaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    respuestaCuestionarioId?: boolean
    preguntaId?: boolean
    valor?: boolean
    comentario?: boolean
    archivosAdjuntos?: boolean
    marcadaParaRevision?: boolean
    estadoRevision?: boolean
    comentarioRevisor?: boolean
    respuestaCuestionario?: boolean | RespuestaCuestionarioDefaultArgs<ExtArgs>
    pregunta?: boolean | PreguntaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["respuestaPregunta"]>

  export type RespuestaPreguntaSelectScalar = {
    id?: boolean
    respuestaCuestionarioId?: boolean
    preguntaId?: boolean
    valor?: boolean
    comentario?: boolean
    archivosAdjuntos?: boolean
    marcadaParaRevision?: boolean
    estadoRevision?: boolean
    comentarioRevisor?: boolean
  }

  export type RespuestaPreguntaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    respuestaCuestionario?: boolean | RespuestaCuestionarioDefaultArgs<ExtArgs>
    pregunta?: boolean | PreguntaDefaultArgs<ExtArgs>
    evidencias?: boolean | RespuestaPregunta$evidenciasArgs<ExtArgs>
    _count?: boolean | RespuestaPreguntaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RespuestaPreguntaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    respuestaCuestionario?: boolean | RespuestaCuestionarioDefaultArgs<ExtArgs>
    pregunta?: boolean | PreguntaDefaultArgs<ExtArgs>
  }

  export type $RespuestaPreguntaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RespuestaPregunta"
    objects: {
      respuestaCuestionario: Prisma.$RespuestaCuestionarioPayload<ExtArgs>
      pregunta: Prisma.$PreguntaPayload<ExtArgs>
      evidencias: Prisma.$EvidenciaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      respuestaCuestionarioId: string
      preguntaId: string
      valor: string | null
      comentario: string | null
      archivosAdjuntos: string | null
      marcadaParaRevision: boolean
      estadoRevision: string
      comentarioRevisor: string | null
    }, ExtArgs["result"]["respuestaPregunta"]>
    composites: {}
  }

  type RespuestaPreguntaGetPayload<S extends boolean | null | undefined | RespuestaPreguntaDefaultArgs> = $Result.GetResult<Prisma.$RespuestaPreguntaPayload, S>

  type RespuestaPreguntaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RespuestaPreguntaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RespuestaPreguntaCountAggregateInputType | true
    }

  export interface RespuestaPreguntaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RespuestaPregunta'], meta: { name: 'RespuestaPregunta' } }
    /**
     * Find zero or one RespuestaPregunta that matches the filter.
     * @param {RespuestaPreguntaFindUniqueArgs} args - Arguments to find a RespuestaPregunta
     * @example
     * // Get one RespuestaPregunta
     * const respuestaPregunta = await prisma.respuestaPregunta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RespuestaPreguntaFindUniqueArgs>(args: SelectSubset<T, RespuestaPreguntaFindUniqueArgs<ExtArgs>>): Prisma__RespuestaPreguntaClient<$Result.GetResult<Prisma.$RespuestaPreguntaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RespuestaPregunta that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RespuestaPreguntaFindUniqueOrThrowArgs} args - Arguments to find a RespuestaPregunta
     * @example
     * // Get one RespuestaPregunta
     * const respuestaPregunta = await prisma.respuestaPregunta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RespuestaPreguntaFindUniqueOrThrowArgs>(args: SelectSubset<T, RespuestaPreguntaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RespuestaPreguntaClient<$Result.GetResult<Prisma.$RespuestaPreguntaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RespuestaPregunta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaPreguntaFindFirstArgs} args - Arguments to find a RespuestaPregunta
     * @example
     * // Get one RespuestaPregunta
     * const respuestaPregunta = await prisma.respuestaPregunta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RespuestaPreguntaFindFirstArgs>(args?: SelectSubset<T, RespuestaPreguntaFindFirstArgs<ExtArgs>>): Prisma__RespuestaPreguntaClient<$Result.GetResult<Prisma.$RespuestaPreguntaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RespuestaPregunta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaPreguntaFindFirstOrThrowArgs} args - Arguments to find a RespuestaPregunta
     * @example
     * // Get one RespuestaPregunta
     * const respuestaPregunta = await prisma.respuestaPregunta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RespuestaPreguntaFindFirstOrThrowArgs>(args?: SelectSubset<T, RespuestaPreguntaFindFirstOrThrowArgs<ExtArgs>>): Prisma__RespuestaPreguntaClient<$Result.GetResult<Prisma.$RespuestaPreguntaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RespuestaPreguntas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaPreguntaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RespuestaPreguntas
     * const respuestaPreguntas = await prisma.respuestaPregunta.findMany()
     * 
     * // Get first 10 RespuestaPreguntas
     * const respuestaPreguntas = await prisma.respuestaPregunta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const respuestaPreguntaWithIdOnly = await prisma.respuestaPregunta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RespuestaPreguntaFindManyArgs>(args?: SelectSubset<T, RespuestaPreguntaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RespuestaPreguntaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RespuestaPregunta.
     * @param {RespuestaPreguntaCreateArgs} args - Arguments to create a RespuestaPregunta.
     * @example
     * // Create one RespuestaPregunta
     * const RespuestaPregunta = await prisma.respuestaPregunta.create({
     *   data: {
     *     // ... data to create a RespuestaPregunta
     *   }
     * })
     * 
     */
    create<T extends RespuestaPreguntaCreateArgs>(args: SelectSubset<T, RespuestaPreguntaCreateArgs<ExtArgs>>): Prisma__RespuestaPreguntaClient<$Result.GetResult<Prisma.$RespuestaPreguntaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RespuestaPreguntas.
     * @param {RespuestaPreguntaCreateManyArgs} args - Arguments to create many RespuestaPreguntas.
     * @example
     * // Create many RespuestaPreguntas
     * const respuestaPregunta = await prisma.respuestaPregunta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RespuestaPreguntaCreateManyArgs>(args?: SelectSubset<T, RespuestaPreguntaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RespuestaPreguntas and returns the data saved in the database.
     * @param {RespuestaPreguntaCreateManyAndReturnArgs} args - Arguments to create many RespuestaPreguntas.
     * @example
     * // Create many RespuestaPreguntas
     * const respuestaPregunta = await prisma.respuestaPregunta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RespuestaPreguntas and only return the `id`
     * const respuestaPreguntaWithIdOnly = await prisma.respuestaPregunta.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RespuestaPreguntaCreateManyAndReturnArgs>(args?: SelectSubset<T, RespuestaPreguntaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RespuestaPreguntaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RespuestaPregunta.
     * @param {RespuestaPreguntaDeleteArgs} args - Arguments to delete one RespuestaPregunta.
     * @example
     * // Delete one RespuestaPregunta
     * const RespuestaPregunta = await prisma.respuestaPregunta.delete({
     *   where: {
     *     // ... filter to delete one RespuestaPregunta
     *   }
     * })
     * 
     */
    delete<T extends RespuestaPreguntaDeleteArgs>(args: SelectSubset<T, RespuestaPreguntaDeleteArgs<ExtArgs>>): Prisma__RespuestaPreguntaClient<$Result.GetResult<Prisma.$RespuestaPreguntaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RespuestaPregunta.
     * @param {RespuestaPreguntaUpdateArgs} args - Arguments to update one RespuestaPregunta.
     * @example
     * // Update one RespuestaPregunta
     * const respuestaPregunta = await prisma.respuestaPregunta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RespuestaPreguntaUpdateArgs>(args: SelectSubset<T, RespuestaPreguntaUpdateArgs<ExtArgs>>): Prisma__RespuestaPreguntaClient<$Result.GetResult<Prisma.$RespuestaPreguntaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RespuestaPreguntas.
     * @param {RespuestaPreguntaDeleteManyArgs} args - Arguments to filter RespuestaPreguntas to delete.
     * @example
     * // Delete a few RespuestaPreguntas
     * const { count } = await prisma.respuestaPregunta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RespuestaPreguntaDeleteManyArgs>(args?: SelectSubset<T, RespuestaPreguntaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RespuestaPreguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaPreguntaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RespuestaPreguntas
     * const respuestaPregunta = await prisma.respuestaPregunta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RespuestaPreguntaUpdateManyArgs>(args: SelectSubset<T, RespuestaPreguntaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RespuestaPregunta.
     * @param {RespuestaPreguntaUpsertArgs} args - Arguments to update or create a RespuestaPregunta.
     * @example
     * // Update or create a RespuestaPregunta
     * const respuestaPregunta = await prisma.respuestaPregunta.upsert({
     *   create: {
     *     // ... data to create a RespuestaPregunta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RespuestaPregunta we want to update
     *   }
     * })
     */
    upsert<T extends RespuestaPreguntaUpsertArgs>(args: SelectSubset<T, RespuestaPreguntaUpsertArgs<ExtArgs>>): Prisma__RespuestaPreguntaClient<$Result.GetResult<Prisma.$RespuestaPreguntaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RespuestaPreguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaPreguntaCountArgs} args - Arguments to filter RespuestaPreguntas to count.
     * @example
     * // Count the number of RespuestaPreguntas
     * const count = await prisma.respuestaPregunta.count({
     *   where: {
     *     // ... the filter for the RespuestaPreguntas we want to count
     *   }
     * })
    **/
    count<T extends RespuestaPreguntaCountArgs>(
      args?: Subset<T, RespuestaPreguntaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RespuestaPreguntaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RespuestaPregunta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaPreguntaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RespuestaPreguntaAggregateArgs>(args: Subset<T, RespuestaPreguntaAggregateArgs>): Prisma.PrismaPromise<GetRespuestaPreguntaAggregateType<T>>

    /**
     * Group by RespuestaPregunta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestaPreguntaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RespuestaPreguntaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RespuestaPreguntaGroupByArgs['orderBy'] }
        : { orderBy?: RespuestaPreguntaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RespuestaPreguntaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRespuestaPreguntaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RespuestaPregunta model
   */
  readonly fields: RespuestaPreguntaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RespuestaPregunta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RespuestaPreguntaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    respuestaCuestionario<T extends RespuestaCuestionarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RespuestaCuestionarioDefaultArgs<ExtArgs>>): Prisma__RespuestaCuestionarioClient<$Result.GetResult<Prisma.$RespuestaCuestionarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pregunta<T extends PreguntaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PreguntaDefaultArgs<ExtArgs>>): Prisma__PreguntaClient<$Result.GetResult<Prisma.$PreguntaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    evidencias<T extends RespuestaPregunta$evidenciasArgs<ExtArgs> = {}>(args?: Subset<T, RespuestaPregunta$evidenciasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RespuestaPregunta model
   */ 
  interface RespuestaPreguntaFieldRefs {
    readonly id: FieldRef<"RespuestaPregunta", 'String'>
    readonly respuestaCuestionarioId: FieldRef<"RespuestaPregunta", 'String'>
    readonly preguntaId: FieldRef<"RespuestaPregunta", 'String'>
    readonly valor: FieldRef<"RespuestaPregunta", 'String'>
    readonly comentario: FieldRef<"RespuestaPregunta", 'String'>
    readonly archivosAdjuntos: FieldRef<"RespuestaPregunta", 'String'>
    readonly marcadaParaRevision: FieldRef<"RespuestaPregunta", 'Boolean'>
    readonly estadoRevision: FieldRef<"RespuestaPregunta", 'String'>
    readonly comentarioRevisor: FieldRef<"RespuestaPregunta", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RespuestaPregunta findUnique
   */
  export type RespuestaPreguntaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaPregunta
     */
    select?: RespuestaPreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaPreguntaInclude<ExtArgs> | null
    /**
     * Filter, which RespuestaPregunta to fetch.
     */
    where: RespuestaPreguntaWhereUniqueInput
  }

  /**
   * RespuestaPregunta findUniqueOrThrow
   */
  export type RespuestaPreguntaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaPregunta
     */
    select?: RespuestaPreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaPreguntaInclude<ExtArgs> | null
    /**
     * Filter, which RespuestaPregunta to fetch.
     */
    where: RespuestaPreguntaWhereUniqueInput
  }

  /**
   * RespuestaPregunta findFirst
   */
  export type RespuestaPreguntaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaPregunta
     */
    select?: RespuestaPreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaPreguntaInclude<ExtArgs> | null
    /**
     * Filter, which RespuestaPregunta to fetch.
     */
    where?: RespuestaPreguntaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RespuestaPreguntas to fetch.
     */
    orderBy?: RespuestaPreguntaOrderByWithRelationInput | RespuestaPreguntaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RespuestaPreguntas.
     */
    cursor?: RespuestaPreguntaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RespuestaPreguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RespuestaPreguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RespuestaPreguntas.
     */
    distinct?: RespuestaPreguntaScalarFieldEnum | RespuestaPreguntaScalarFieldEnum[]
  }

  /**
   * RespuestaPregunta findFirstOrThrow
   */
  export type RespuestaPreguntaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaPregunta
     */
    select?: RespuestaPreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaPreguntaInclude<ExtArgs> | null
    /**
     * Filter, which RespuestaPregunta to fetch.
     */
    where?: RespuestaPreguntaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RespuestaPreguntas to fetch.
     */
    orderBy?: RespuestaPreguntaOrderByWithRelationInput | RespuestaPreguntaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RespuestaPreguntas.
     */
    cursor?: RespuestaPreguntaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RespuestaPreguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RespuestaPreguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RespuestaPreguntas.
     */
    distinct?: RespuestaPreguntaScalarFieldEnum | RespuestaPreguntaScalarFieldEnum[]
  }

  /**
   * RespuestaPregunta findMany
   */
  export type RespuestaPreguntaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaPregunta
     */
    select?: RespuestaPreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaPreguntaInclude<ExtArgs> | null
    /**
     * Filter, which RespuestaPreguntas to fetch.
     */
    where?: RespuestaPreguntaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RespuestaPreguntas to fetch.
     */
    orderBy?: RespuestaPreguntaOrderByWithRelationInput | RespuestaPreguntaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RespuestaPreguntas.
     */
    cursor?: RespuestaPreguntaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RespuestaPreguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RespuestaPreguntas.
     */
    skip?: number
    distinct?: RespuestaPreguntaScalarFieldEnum | RespuestaPreguntaScalarFieldEnum[]
  }

  /**
   * RespuestaPregunta create
   */
  export type RespuestaPreguntaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaPregunta
     */
    select?: RespuestaPreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaPreguntaInclude<ExtArgs> | null
    /**
     * The data needed to create a RespuestaPregunta.
     */
    data: XOR<RespuestaPreguntaCreateInput, RespuestaPreguntaUncheckedCreateInput>
  }

  /**
   * RespuestaPregunta createMany
   */
  export type RespuestaPreguntaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RespuestaPreguntas.
     */
    data: RespuestaPreguntaCreateManyInput | RespuestaPreguntaCreateManyInput[]
  }

  /**
   * RespuestaPregunta createManyAndReturn
   */
  export type RespuestaPreguntaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaPregunta
     */
    select?: RespuestaPreguntaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RespuestaPreguntas.
     */
    data: RespuestaPreguntaCreateManyInput | RespuestaPreguntaCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaPreguntaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RespuestaPregunta update
   */
  export type RespuestaPreguntaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaPregunta
     */
    select?: RespuestaPreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaPreguntaInclude<ExtArgs> | null
    /**
     * The data needed to update a RespuestaPregunta.
     */
    data: XOR<RespuestaPreguntaUpdateInput, RespuestaPreguntaUncheckedUpdateInput>
    /**
     * Choose, which RespuestaPregunta to update.
     */
    where: RespuestaPreguntaWhereUniqueInput
  }

  /**
   * RespuestaPregunta updateMany
   */
  export type RespuestaPreguntaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RespuestaPreguntas.
     */
    data: XOR<RespuestaPreguntaUpdateManyMutationInput, RespuestaPreguntaUncheckedUpdateManyInput>
    /**
     * Filter which RespuestaPreguntas to update
     */
    where?: RespuestaPreguntaWhereInput
  }

  /**
   * RespuestaPregunta upsert
   */
  export type RespuestaPreguntaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaPregunta
     */
    select?: RespuestaPreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaPreguntaInclude<ExtArgs> | null
    /**
     * The filter to search for the RespuestaPregunta to update in case it exists.
     */
    where: RespuestaPreguntaWhereUniqueInput
    /**
     * In case the RespuestaPregunta found by the `where` argument doesn't exist, create a new RespuestaPregunta with this data.
     */
    create: XOR<RespuestaPreguntaCreateInput, RespuestaPreguntaUncheckedCreateInput>
    /**
     * In case the RespuestaPregunta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RespuestaPreguntaUpdateInput, RespuestaPreguntaUncheckedUpdateInput>
  }

  /**
   * RespuestaPregunta delete
   */
  export type RespuestaPreguntaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaPregunta
     */
    select?: RespuestaPreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaPreguntaInclude<ExtArgs> | null
    /**
     * Filter which RespuestaPregunta to delete.
     */
    where: RespuestaPreguntaWhereUniqueInput
  }

  /**
   * RespuestaPregunta deleteMany
   */
  export type RespuestaPreguntaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RespuestaPreguntas to delete
     */
    where?: RespuestaPreguntaWhereInput
  }

  /**
   * RespuestaPregunta.evidencias
   */
  export type RespuestaPregunta$evidenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    where?: EvidenciaWhereInput
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    cursor?: EvidenciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * RespuestaPregunta without action
   */
  export type RespuestaPreguntaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RespuestaPregunta
     */
    select?: RespuestaPreguntaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RespuestaPreguntaInclude<ExtArgs> | null
  }


  /**
   * Model Evidencia
   */

  export type AggregateEvidencia = {
    _count: EvidenciaCountAggregateOutputType | null
    _avg: EvidenciaAvgAggregateOutputType | null
    _sum: EvidenciaSumAggregateOutputType | null
    _min: EvidenciaMinAggregateOutputType | null
    _max: EvidenciaMaxAggregateOutputType | null
  }

  export type EvidenciaAvgAggregateOutputType = {
    tamano: number | null
  }

  export type EvidenciaSumAggregateOutputType = {
    tamano: number | null
  }

  export type EvidenciaMinAggregateOutputType = {
    id: string | null
    respuestaPreguntaId: string | null
    nombre: string | null
    tipo: string | null
    tamano: number | null
    fechaCarga: Date | null
    url: string | null
    descripcion: string | null
    vigencia: Date | null
    estado: string | null
  }

  export type EvidenciaMaxAggregateOutputType = {
    id: string | null
    respuestaPreguntaId: string | null
    nombre: string | null
    tipo: string | null
    tamano: number | null
    fechaCarga: Date | null
    url: string | null
    descripcion: string | null
    vigencia: Date | null
    estado: string | null
  }

  export type EvidenciaCountAggregateOutputType = {
    id: number
    respuestaPreguntaId: number
    nombre: number
    tipo: number
    tamano: number
    fechaCarga: number
    url: number
    descripcion: number
    vigencia: number
    estado: number
    _all: number
  }


  export type EvidenciaAvgAggregateInputType = {
    tamano?: true
  }

  export type EvidenciaSumAggregateInputType = {
    tamano?: true
  }

  export type EvidenciaMinAggregateInputType = {
    id?: true
    respuestaPreguntaId?: true
    nombre?: true
    tipo?: true
    tamano?: true
    fechaCarga?: true
    url?: true
    descripcion?: true
    vigencia?: true
    estado?: true
  }

  export type EvidenciaMaxAggregateInputType = {
    id?: true
    respuestaPreguntaId?: true
    nombre?: true
    tipo?: true
    tamano?: true
    fechaCarga?: true
    url?: true
    descripcion?: true
    vigencia?: true
    estado?: true
  }

  export type EvidenciaCountAggregateInputType = {
    id?: true
    respuestaPreguntaId?: true
    nombre?: true
    tipo?: true
    tamano?: true
    fechaCarga?: true
    url?: true
    descripcion?: true
    vigencia?: true
    estado?: true
    _all?: true
  }

  export type EvidenciaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evidencia to aggregate.
     */
    where?: EvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidencias to fetch.
     */
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evidencias
    **/
    _count?: true | EvidenciaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvidenciaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvidenciaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvidenciaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvidenciaMaxAggregateInputType
  }

  export type GetEvidenciaAggregateType<T extends EvidenciaAggregateArgs> = {
        [P in keyof T & keyof AggregateEvidencia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvidencia[P]>
      : GetScalarType<T[P], AggregateEvidencia[P]>
  }




  export type EvidenciaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenciaWhereInput
    orderBy?: EvidenciaOrderByWithAggregationInput | EvidenciaOrderByWithAggregationInput[]
    by: EvidenciaScalarFieldEnum[] | EvidenciaScalarFieldEnum
    having?: EvidenciaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvidenciaCountAggregateInputType | true
    _avg?: EvidenciaAvgAggregateInputType
    _sum?: EvidenciaSumAggregateInputType
    _min?: EvidenciaMinAggregateInputType
    _max?: EvidenciaMaxAggregateInputType
  }

  export type EvidenciaGroupByOutputType = {
    id: string
    respuestaPreguntaId: string
    nombre: string
    tipo: string
    tamano: number
    fechaCarga: Date
    url: string
    descripcion: string | null
    vigencia: Date | null
    estado: string
    _count: EvidenciaCountAggregateOutputType | null
    _avg: EvidenciaAvgAggregateOutputType | null
    _sum: EvidenciaSumAggregateOutputType | null
    _min: EvidenciaMinAggregateOutputType | null
    _max: EvidenciaMaxAggregateOutputType | null
  }

  type GetEvidenciaGroupByPayload<T extends EvidenciaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvidenciaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvidenciaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvidenciaGroupByOutputType[P]>
            : GetScalarType<T[P], EvidenciaGroupByOutputType[P]>
        }
      >
    >


  export type EvidenciaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    respuestaPreguntaId?: boolean
    nombre?: boolean
    tipo?: boolean
    tamano?: boolean
    fechaCarga?: boolean
    url?: boolean
    descripcion?: boolean
    vigencia?: boolean
    estado?: boolean
    respuestaPregunta?: boolean | RespuestaPreguntaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidencia"]>

  export type EvidenciaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    respuestaPreguntaId?: boolean
    nombre?: boolean
    tipo?: boolean
    tamano?: boolean
    fechaCarga?: boolean
    url?: boolean
    descripcion?: boolean
    vigencia?: boolean
    estado?: boolean
    respuestaPregunta?: boolean | RespuestaPreguntaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidencia"]>

  export type EvidenciaSelectScalar = {
    id?: boolean
    respuestaPreguntaId?: boolean
    nombre?: boolean
    tipo?: boolean
    tamano?: boolean
    fechaCarga?: boolean
    url?: boolean
    descripcion?: boolean
    vigencia?: boolean
    estado?: boolean
  }

  export type EvidenciaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    respuestaPregunta?: boolean | RespuestaPreguntaDefaultArgs<ExtArgs>
  }
  export type EvidenciaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    respuestaPregunta?: boolean | RespuestaPreguntaDefaultArgs<ExtArgs>
  }

  export type $EvidenciaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evidencia"
    objects: {
      respuestaPregunta: Prisma.$RespuestaPreguntaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      respuestaPreguntaId: string
      nombre: string
      tipo: string
      tamano: number
      fechaCarga: Date
      url: string
      descripcion: string | null
      vigencia: Date | null
      estado: string
    }, ExtArgs["result"]["evidencia"]>
    composites: {}
  }

  type EvidenciaGetPayload<S extends boolean | null | undefined | EvidenciaDefaultArgs> = $Result.GetResult<Prisma.$EvidenciaPayload, S>

  type EvidenciaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvidenciaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvidenciaCountAggregateInputType | true
    }

  export interface EvidenciaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evidencia'], meta: { name: 'Evidencia' } }
    /**
     * Find zero or one Evidencia that matches the filter.
     * @param {EvidenciaFindUniqueArgs} args - Arguments to find a Evidencia
     * @example
     * // Get one Evidencia
     * const evidencia = await prisma.evidencia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvidenciaFindUniqueArgs>(args: SelectSubset<T, EvidenciaFindUniqueArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Evidencia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvidenciaFindUniqueOrThrowArgs} args - Arguments to find a Evidencia
     * @example
     * // Get one Evidencia
     * const evidencia = await prisma.evidencia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvidenciaFindUniqueOrThrowArgs>(args: SelectSubset<T, EvidenciaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Evidencia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaFindFirstArgs} args - Arguments to find a Evidencia
     * @example
     * // Get one Evidencia
     * const evidencia = await prisma.evidencia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvidenciaFindFirstArgs>(args?: SelectSubset<T, EvidenciaFindFirstArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Evidencia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaFindFirstOrThrowArgs} args - Arguments to find a Evidencia
     * @example
     * // Get one Evidencia
     * const evidencia = await prisma.evidencia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvidenciaFindFirstOrThrowArgs>(args?: SelectSubset<T, EvidenciaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Evidencias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evidencias
     * const evidencias = await prisma.evidencia.findMany()
     * 
     * // Get first 10 Evidencias
     * const evidencias = await prisma.evidencia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evidenciaWithIdOnly = await prisma.evidencia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvidenciaFindManyArgs>(args?: SelectSubset<T, EvidenciaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Evidencia.
     * @param {EvidenciaCreateArgs} args - Arguments to create a Evidencia.
     * @example
     * // Create one Evidencia
     * const Evidencia = await prisma.evidencia.create({
     *   data: {
     *     // ... data to create a Evidencia
     *   }
     * })
     * 
     */
    create<T extends EvidenciaCreateArgs>(args: SelectSubset<T, EvidenciaCreateArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Evidencias.
     * @param {EvidenciaCreateManyArgs} args - Arguments to create many Evidencias.
     * @example
     * // Create many Evidencias
     * const evidencia = await prisma.evidencia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvidenciaCreateManyArgs>(args?: SelectSubset<T, EvidenciaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evidencias and returns the data saved in the database.
     * @param {EvidenciaCreateManyAndReturnArgs} args - Arguments to create many Evidencias.
     * @example
     * // Create many Evidencias
     * const evidencia = await prisma.evidencia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evidencias and only return the `id`
     * const evidenciaWithIdOnly = await prisma.evidencia.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvidenciaCreateManyAndReturnArgs>(args?: SelectSubset<T, EvidenciaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Evidencia.
     * @param {EvidenciaDeleteArgs} args - Arguments to delete one Evidencia.
     * @example
     * // Delete one Evidencia
     * const Evidencia = await prisma.evidencia.delete({
     *   where: {
     *     // ... filter to delete one Evidencia
     *   }
     * })
     * 
     */
    delete<T extends EvidenciaDeleteArgs>(args: SelectSubset<T, EvidenciaDeleteArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Evidencia.
     * @param {EvidenciaUpdateArgs} args - Arguments to update one Evidencia.
     * @example
     * // Update one Evidencia
     * const evidencia = await prisma.evidencia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvidenciaUpdateArgs>(args: SelectSubset<T, EvidenciaUpdateArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Evidencias.
     * @param {EvidenciaDeleteManyArgs} args - Arguments to filter Evidencias to delete.
     * @example
     * // Delete a few Evidencias
     * const { count } = await prisma.evidencia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvidenciaDeleteManyArgs>(args?: SelectSubset<T, EvidenciaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evidencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evidencias
     * const evidencia = await prisma.evidencia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvidenciaUpdateManyArgs>(args: SelectSubset<T, EvidenciaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evidencia.
     * @param {EvidenciaUpsertArgs} args - Arguments to update or create a Evidencia.
     * @example
     * // Update or create a Evidencia
     * const evidencia = await prisma.evidencia.upsert({
     *   create: {
     *     // ... data to create a Evidencia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evidencia we want to update
     *   }
     * })
     */
    upsert<T extends EvidenciaUpsertArgs>(args: SelectSubset<T, EvidenciaUpsertArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Evidencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaCountArgs} args - Arguments to filter Evidencias to count.
     * @example
     * // Count the number of Evidencias
     * const count = await prisma.evidencia.count({
     *   where: {
     *     // ... the filter for the Evidencias we want to count
     *   }
     * })
    **/
    count<T extends EvidenciaCountArgs>(
      args?: Subset<T, EvidenciaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvidenciaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evidencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvidenciaAggregateArgs>(args: Subset<T, EvidenciaAggregateArgs>): Prisma.PrismaPromise<GetEvidenciaAggregateType<T>>

    /**
     * Group by Evidencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvidenciaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvidenciaGroupByArgs['orderBy'] }
        : { orderBy?: EvidenciaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvidenciaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvidenciaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evidencia model
   */
  readonly fields: EvidenciaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evidencia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvidenciaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    respuestaPregunta<T extends RespuestaPreguntaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RespuestaPreguntaDefaultArgs<ExtArgs>>): Prisma__RespuestaPreguntaClient<$Result.GetResult<Prisma.$RespuestaPreguntaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evidencia model
   */ 
  interface EvidenciaFieldRefs {
    readonly id: FieldRef<"Evidencia", 'String'>
    readonly respuestaPreguntaId: FieldRef<"Evidencia", 'String'>
    readonly nombre: FieldRef<"Evidencia", 'String'>
    readonly tipo: FieldRef<"Evidencia", 'String'>
    readonly tamano: FieldRef<"Evidencia", 'Int'>
    readonly fechaCarga: FieldRef<"Evidencia", 'DateTime'>
    readonly url: FieldRef<"Evidencia", 'String'>
    readonly descripcion: FieldRef<"Evidencia", 'String'>
    readonly vigencia: FieldRef<"Evidencia", 'DateTime'>
    readonly estado: FieldRef<"Evidencia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Evidencia findUnique
   */
  export type EvidenciaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencia to fetch.
     */
    where: EvidenciaWhereUniqueInput
  }

  /**
   * Evidencia findUniqueOrThrow
   */
  export type EvidenciaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencia to fetch.
     */
    where: EvidenciaWhereUniqueInput
  }

  /**
   * Evidencia findFirst
   */
  export type EvidenciaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencia to fetch.
     */
    where?: EvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidencias to fetch.
     */
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evidencias.
     */
    cursor?: EvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evidencias.
     */
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Evidencia findFirstOrThrow
   */
  export type EvidenciaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencia to fetch.
     */
    where?: EvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidencias to fetch.
     */
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evidencias.
     */
    cursor?: EvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evidencias.
     */
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Evidencia findMany
   */
  export type EvidenciaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencias to fetch.
     */
    where?: EvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidencias to fetch.
     */
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evidencias.
     */
    cursor?: EvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidencias.
     */
    skip?: number
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Evidencia create
   */
  export type EvidenciaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * The data needed to create a Evidencia.
     */
    data: XOR<EvidenciaCreateInput, EvidenciaUncheckedCreateInput>
  }

  /**
   * Evidencia createMany
   */
  export type EvidenciaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evidencias.
     */
    data: EvidenciaCreateManyInput | EvidenciaCreateManyInput[]
  }

  /**
   * Evidencia createManyAndReturn
   */
  export type EvidenciaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Evidencias.
     */
    data: EvidenciaCreateManyInput | EvidenciaCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evidencia update
   */
  export type EvidenciaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * The data needed to update a Evidencia.
     */
    data: XOR<EvidenciaUpdateInput, EvidenciaUncheckedUpdateInput>
    /**
     * Choose, which Evidencia to update.
     */
    where: EvidenciaWhereUniqueInput
  }

  /**
   * Evidencia updateMany
   */
  export type EvidenciaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evidencias.
     */
    data: XOR<EvidenciaUpdateManyMutationInput, EvidenciaUncheckedUpdateManyInput>
    /**
     * Filter which Evidencias to update
     */
    where?: EvidenciaWhereInput
  }

  /**
   * Evidencia upsert
   */
  export type EvidenciaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * The filter to search for the Evidencia to update in case it exists.
     */
    where: EvidenciaWhereUniqueInput
    /**
     * In case the Evidencia found by the `where` argument doesn't exist, create a new Evidencia with this data.
     */
    create: XOR<EvidenciaCreateInput, EvidenciaUncheckedCreateInput>
    /**
     * In case the Evidencia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvidenciaUpdateInput, EvidenciaUncheckedUpdateInput>
  }

  /**
   * Evidencia delete
   */
  export type EvidenciaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter which Evidencia to delete.
     */
    where: EvidenciaWhereUniqueInput
  }

  /**
   * Evidencia deleteMany
   */
  export type EvidenciaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evidencias to delete
     */
    where?: EvidenciaWhereInput
  }

  /**
   * Evidencia without action
   */
  export type EvidenciaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
  }


  /**
   * Model Hallazgo
   */

  export type AggregateHallazgo = {
    _count: HallazgoCountAggregateOutputType | null
    _min: HallazgoMinAggregateOutputType | null
    _max: HallazgoMaxAggregateOutputType | null
  }

  export type HallazgoMinAggregateOutputType = {
    id: string | null
    preguntaId: string | null
    tipo: string | null
    descripcion: string | null
    requisitoNormativo: string | null
    accionCorrectiva: string | null
    responsable: string | null
    fechaLimite: Date | null
    estado: string | null
    fechaCreacion: Date | null
  }

  export type HallazgoMaxAggregateOutputType = {
    id: string | null
    preguntaId: string | null
    tipo: string | null
    descripcion: string | null
    requisitoNormativo: string | null
    accionCorrectiva: string | null
    responsable: string | null
    fechaLimite: Date | null
    estado: string | null
    fechaCreacion: Date | null
  }

  export type HallazgoCountAggregateOutputType = {
    id: number
    preguntaId: number
    tipo: number
    descripcion: number
    requisitoNormativo: number
    accionCorrectiva: number
    responsable: number
    fechaLimite: number
    estado: number
    fechaCreacion: number
    _all: number
  }


  export type HallazgoMinAggregateInputType = {
    id?: true
    preguntaId?: true
    tipo?: true
    descripcion?: true
    requisitoNormativo?: true
    accionCorrectiva?: true
    responsable?: true
    fechaLimite?: true
    estado?: true
    fechaCreacion?: true
  }

  export type HallazgoMaxAggregateInputType = {
    id?: true
    preguntaId?: true
    tipo?: true
    descripcion?: true
    requisitoNormativo?: true
    accionCorrectiva?: true
    responsable?: true
    fechaLimite?: true
    estado?: true
    fechaCreacion?: true
  }

  export type HallazgoCountAggregateInputType = {
    id?: true
    preguntaId?: true
    tipo?: true
    descripcion?: true
    requisitoNormativo?: true
    accionCorrectiva?: true
    responsable?: true
    fechaLimite?: true
    estado?: true
    fechaCreacion?: true
    _all?: true
  }

  export type HallazgoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hallazgo to aggregate.
     */
    where?: HallazgoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hallazgos to fetch.
     */
    orderBy?: HallazgoOrderByWithRelationInput | HallazgoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HallazgoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hallazgos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hallazgos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hallazgos
    **/
    _count?: true | HallazgoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HallazgoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HallazgoMaxAggregateInputType
  }

  export type GetHallazgoAggregateType<T extends HallazgoAggregateArgs> = {
        [P in keyof T & keyof AggregateHallazgo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHallazgo[P]>
      : GetScalarType<T[P], AggregateHallazgo[P]>
  }




  export type HallazgoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HallazgoWhereInput
    orderBy?: HallazgoOrderByWithAggregationInput | HallazgoOrderByWithAggregationInput[]
    by: HallazgoScalarFieldEnum[] | HallazgoScalarFieldEnum
    having?: HallazgoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HallazgoCountAggregateInputType | true
    _min?: HallazgoMinAggregateInputType
    _max?: HallazgoMaxAggregateInputType
  }

  export type HallazgoGroupByOutputType = {
    id: string
    preguntaId: string
    tipo: string
    descripcion: string
    requisitoNormativo: string | null
    accionCorrectiva: string | null
    responsable: string
    fechaLimite: Date | null
    estado: string
    fechaCreacion: Date
    _count: HallazgoCountAggregateOutputType | null
    _min: HallazgoMinAggregateOutputType | null
    _max: HallazgoMaxAggregateOutputType | null
  }

  type GetHallazgoGroupByPayload<T extends HallazgoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HallazgoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HallazgoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HallazgoGroupByOutputType[P]>
            : GetScalarType<T[P], HallazgoGroupByOutputType[P]>
        }
      >
    >


  export type HallazgoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    preguntaId?: boolean
    tipo?: boolean
    descripcion?: boolean
    requisitoNormativo?: boolean
    accionCorrectiva?: boolean
    responsable?: boolean
    fechaLimite?: boolean
    estado?: boolean
    fechaCreacion?: boolean
    pregunta?: boolean | PreguntaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hallazgo"]>

  export type HallazgoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    preguntaId?: boolean
    tipo?: boolean
    descripcion?: boolean
    requisitoNormativo?: boolean
    accionCorrectiva?: boolean
    responsable?: boolean
    fechaLimite?: boolean
    estado?: boolean
    fechaCreacion?: boolean
    pregunta?: boolean | PreguntaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hallazgo"]>

  export type HallazgoSelectScalar = {
    id?: boolean
    preguntaId?: boolean
    tipo?: boolean
    descripcion?: boolean
    requisitoNormativo?: boolean
    accionCorrectiva?: boolean
    responsable?: boolean
    fechaLimite?: boolean
    estado?: boolean
    fechaCreacion?: boolean
  }

  export type HallazgoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pregunta?: boolean | PreguntaDefaultArgs<ExtArgs>
  }
  export type HallazgoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pregunta?: boolean | PreguntaDefaultArgs<ExtArgs>
  }

  export type $HallazgoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hallazgo"
    objects: {
      pregunta: Prisma.$PreguntaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      preguntaId: string
      tipo: string
      descripcion: string
      requisitoNormativo: string | null
      accionCorrectiva: string | null
      responsable: string
      fechaLimite: Date | null
      estado: string
      fechaCreacion: Date
    }, ExtArgs["result"]["hallazgo"]>
    composites: {}
  }

  type HallazgoGetPayload<S extends boolean | null | undefined | HallazgoDefaultArgs> = $Result.GetResult<Prisma.$HallazgoPayload, S>

  type HallazgoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HallazgoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HallazgoCountAggregateInputType | true
    }

  export interface HallazgoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hallazgo'], meta: { name: 'Hallazgo' } }
    /**
     * Find zero or one Hallazgo that matches the filter.
     * @param {HallazgoFindUniqueArgs} args - Arguments to find a Hallazgo
     * @example
     * // Get one Hallazgo
     * const hallazgo = await prisma.hallazgo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HallazgoFindUniqueArgs>(args: SelectSubset<T, HallazgoFindUniqueArgs<ExtArgs>>): Prisma__HallazgoClient<$Result.GetResult<Prisma.$HallazgoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Hallazgo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HallazgoFindUniqueOrThrowArgs} args - Arguments to find a Hallazgo
     * @example
     * // Get one Hallazgo
     * const hallazgo = await prisma.hallazgo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HallazgoFindUniqueOrThrowArgs>(args: SelectSubset<T, HallazgoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HallazgoClient<$Result.GetResult<Prisma.$HallazgoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Hallazgo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallazgoFindFirstArgs} args - Arguments to find a Hallazgo
     * @example
     * // Get one Hallazgo
     * const hallazgo = await prisma.hallazgo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HallazgoFindFirstArgs>(args?: SelectSubset<T, HallazgoFindFirstArgs<ExtArgs>>): Prisma__HallazgoClient<$Result.GetResult<Prisma.$HallazgoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Hallazgo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallazgoFindFirstOrThrowArgs} args - Arguments to find a Hallazgo
     * @example
     * // Get one Hallazgo
     * const hallazgo = await prisma.hallazgo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HallazgoFindFirstOrThrowArgs>(args?: SelectSubset<T, HallazgoFindFirstOrThrowArgs<ExtArgs>>): Prisma__HallazgoClient<$Result.GetResult<Prisma.$HallazgoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Hallazgos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallazgoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hallazgos
     * const hallazgos = await prisma.hallazgo.findMany()
     * 
     * // Get first 10 Hallazgos
     * const hallazgos = await prisma.hallazgo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hallazgoWithIdOnly = await prisma.hallazgo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HallazgoFindManyArgs>(args?: SelectSubset<T, HallazgoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HallazgoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Hallazgo.
     * @param {HallazgoCreateArgs} args - Arguments to create a Hallazgo.
     * @example
     * // Create one Hallazgo
     * const Hallazgo = await prisma.hallazgo.create({
     *   data: {
     *     // ... data to create a Hallazgo
     *   }
     * })
     * 
     */
    create<T extends HallazgoCreateArgs>(args: SelectSubset<T, HallazgoCreateArgs<ExtArgs>>): Prisma__HallazgoClient<$Result.GetResult<Prisma.$HallazgoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Hallazgos.
     * @param {HallazgoCreateManyArgs} args - Arguments to create many Hallazgos.
     * @example
     * // Create many Hallazgos
     * const hallazgo = await prisma.hallazgo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HallazgoCreateManyArgs>(args?: SelectSubset<T, HallazgoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hallazgos and returns the data saved in the database.
     * @param {HallazgoCreateManyAndReturnArgs} args - Arguments to create many Hallazgos.
     * @example
     * // Create many Hallazgos
     * const hallazgo = await prisma.hallazgo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hallazgos and only return the `id`
     * const hallazgoWithIdOnly = await prisma.hallazgo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HallazgoCreateManyAndReturnArgs>(args?: SelectSubset<T, HallazgoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HallazgoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Hallazgo.
     * @param {HallazgoDeleteArgs} args - Arguments to delete one Hallazgo.
     * @example
     * // Delete one Hallazgo
     * const Hallazgo = await prisma.hallazgo.delete({
     *   where: {
     *     // ... filter to delete one Hallazgo
     *   }
     * })
     * 
     */
    delete<T extends HallazgoDeleteArgs>(args: SelectSubset<T, HallazgoDeleteArgs<ExtArgs>>): Prisma__HallazgoClient<$Result.GetResult<Prisma.$HallazgoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Hallazgo.
     * @param {HallazgoUpdateArgs} args - Arguments to update one Hallazgo.
     * @example
     * // Update one Hallazgo
     * const hallazgo = await prisma.hallazgo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HallazgoUpdateArgs>(args: SelectSubset<T, HallazgoUpdateArgs<ExtArgs>>): Prisma__HallazgoClient<$Result.GetResult<Prisma.$HallazgoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Hallazgos.
     * @param {HallazgoDeleteManyArgs} args - Arguments to filter Hallazgos to delete.
     * @example
     * // Delete a few Hallazgos
     * const { count } = await prisma.hallazgo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HallazgoDeleteManyArgs>(args?: SelectSubset<T, HallazgoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hallazgos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallazgoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hallazgos
     * const hallazgo = await prisma.hallazgo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HallazgoUpdateManyArgs>(args: SelectSubset<T, HallazgoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hallazgo.
     * @param {HallazgoUpsertArgs} args - Arguments to update or create a Hallazgo.
     * @example
     * // Update or create a Hallazgo
     * const hallazgo = await prisma.hallazgo.upsert({
     *   create: {
     *     // ... data to create a Hallazgo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hallazgo we want to update
     *   }
     * })
     */
    upsert<T extends HallazgoUpsertArgs>(args: SelectSubset<T, HallazgoUpsertArgs<ExtArgs>>): Prisma__HallazgoClient<$Result.GetResult<Prisma.$HallazgoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Hallazgos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallazgoCountArgs} args - Arguments to filter Hallazgos to count.
     * @example
     * // Count the number of Hallazgos
     * const count = await prisma.hallazgo.count({
     *   where: {
     *     // ... the filter for the Hallazgos we want to count
     *   }
     * })
    **/
    count<T extends HallazgoCountArgs>(
      args?: Subset<T, HallazgoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HallazgoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hallazgo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallazgoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HallazgoAggregateArgs>(args: Subset<T, HallazgoAggregateArgs>): Prisma.PrismaPromise<GetHallazgoAggregateType<T>>

    /**
     * Group by Hallazgo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallazgoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HallazgoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HallazgoGroupByArgs['orderBy'] }
        : { orderBy?: HallazgoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HallazgoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHallazgoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hallazgo model
   */
  readonly fields: HallazgoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hallazgo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HallazgoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pregunta<T extends PreguntaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PreguntaDefaultArgs<ExtArgs>>): Prisma__PreguntaClient<$Result.GetResult<Prisma.$PreguntaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hallazgo model
   */ 
  interface HallazgoFieldRefs {
    readonly id: FieldRef<"Hallazgo", 'String'>
    readonly preguntaId: FieldRef<"Hallazgo", 'String'>
    readonly tipo: FieldRef<"Hallazgo", 'String'>
    readonly descripcion: FieldRef<"Hallazgo", 'String'>
    readonly requisitoNormativo: FieldRef<"Hallazgo", 'String'>
    readonly accionCorrectiva: FieldRef<"Hallazgo", 'String'>
    readonly responsable: FieldRef<"Hallazgo", 'String'>
    readonly fechaLimite: FieldRef<"Hallazgo", 'DateTime'>
    readonly estado: FieldRef<"Hallazgo", 'String'>
    readonly fechaCreacion: FieldRef<"Hallazgo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Hallazgo findUnique
   */
  export type HallazgoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallazgo
     */
    select?: HallazgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallazgoInclude<ExtArgs> | null
    /**
     * Filter, which Hallazgo to fetch.
     */
    where: HallazgoWhereUniqueInput
  }

  /**
   * Hallazgo findUniqueOrThrow
   */
  export type HallazgoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallazgo
     */
    select?: HallazgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallazgoInclude<ExtArgs> | null
    /**
     * Filter, which Hallazgo to fetch.
     */
    where: HallazgoWhereUniqueInput
  }

  /**
   * Hallazgo findFirst
   */
  export type HallazgoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallazgo
     */
    select?: HallazgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallazgoInclude<ExtArgs> | null
    /**
     * Filter, which Hallazgo to fetch.
     */
    where?: HallazgoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hallazgos to fetch.
     */
    orderBy?: HallazgoOrderByWithRelationInput | HallazgoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hallazgos.
     */
    cursor?: HallazgoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hallazgos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hallazgos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hallazgos.
     */
    distinct?: HallazgoScalarFieldEnum | HallazgoScalarFieldEnum[]
  }

  /**
   * Hallazgo findFirstOrThrow
   */
  export type HallazgoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallazgo
     */
    select?: HallazgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallazgoInclude<ExtArgs> | null
    /**
     * Filter, which Hallazgo to fetch.
     */
    where?: HallazgoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hallazgos to fetch.
     */
    orderBy?: HallazgoOrderByWithRelationInput | HallazgoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hallazgos.
     */
    cursor?: HallazgoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hallazgos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hallazgos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hallazgos.
     */
    distinct?: HallazgoScalarFieldEnum | HallazgoScalarFieldEnum[]
  }

  /**
   * Hallazgo findMany
   */
  export type HallazgoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallazgo
     */
    select?: HallazgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallazgoInclude<ExtArgs> | null
    /**
     * Filter, which Hallazgos to fetch.
     */
    where?: HallazgoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hallazgos to fetch.
     */
    orderBy?: HallazgoOrderByWithRelationInput | HallazgoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hallazgos.
     */
    cursor?: HallazgoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hallazgos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hallazgos.
     */
    skip?: number
    distinct?: HallazgoScalarFieldEnum | HallazgoScalarFieldEnum[]
  }

  /**
   * Hallazgo create
   */
  export type HallazgoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallazgo
     */
    select?: HallazgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallazgoInclude<ExtArgs> | null
    /**
     * The data needed to create a Hallazgo.
     */
    data: XOR<HallazgoCreateInput, HallazgoUncheckedCreateInput>
  }

  /**
   * Hallazgo createMany
   */
  export type HallazgoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hallazgos.
     */
    data: HallazgoCreateManyInput | HallazgoCreateManyInput[]
  }

  /**
   * Hallazgo createManyAndReturn
   */
  export type HallazgoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallazgo
     */
    select?: HallazgoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Hallazgos.
     */
    data: HallazgoCreateManyInput | HallazgoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallazgoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hallazgo update
   */
  export type HallazgoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallazgo
     */
    select?: HallazgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallazgoInclude<ExtArgs> | null
    /**
     * The data needed to update a Hallazgo.
     */
    data: XOR<HallazgoUpdateInput, HallazgoUncheckedUpdateInput>
    /**
     * Choose, which Hallazgo to update.
     */
    where: HallazgoWhereUniqueInput
  }

  /**
   * Hallazgo updateMany
   */
  export type HallazgoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hallazgos.
     */
    data: XOR<HallazgoUpdateManyMutationInput, HallazgoUncheckedUpdateManyInput>
    /**
     * Filter which Hallazgos to update
     */
    where?: HallazgoWhereInput
  }

  /**
   * Hallazgo upsert
   */
  export type HallazgoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallazgo
     */
    select?: HallazgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallazgoInclude<ExtArgs> | null
    /**
     * The filter to search for the Hallazgo to update in case it exists.
     */
    where: HallazgoWhereUniqueInput
    /**
     * In case the Hallazgo found by the `where` argument doesn't exist, create a new Hallazgo with this data.
     */
    create: XOR<HallazgoCreateInput, HallazgoUncheckedCreateInput>
    /**
     * In case the Hallazgo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HallazgoUpdateInput, HallazgoUncheckedUpdateInput>
  }

  /**
   * Hallazgo delete
   */
  export type HallazgoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallazgo
     */
    select?: HallazgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallazgoInclude<ExtArgs> | null
    /**
     * Filter which Hallazgo to delete.
     */
    where: HallazgoWhereUniqueInput
  }

  /**
   * Hallazgo deleteMany
   */
  export type HallazgoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hallazgos to delete
     */
    where?: HallazgoWhereInput
  }

  /**
   * Hallazgo without action
   */
  export type HallazgoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallazgo
     */
    select?: HallazgoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallazgoInclude<ExtArgs> | null
  }


  /**
   * Model MensajeChat
   */

  export type AggregateMensajeChat = {
    _count: MensajeChatCountAggregateOutputType | null
    _min: MensajeChatMinAggregateOutputType | null
    _max: MensajeChatMaxAggregateOutputType | null
  }

  export type MensajeChatMinAggregateOutputType = {
    id: string | null
    asignacionId: string | null
    cuestionarioId: string | null
    activoProcesoId: string | null
    usuarioId: string | null
    usuarioNombre: string | null
    usuarioRol: string | null
    mensaje: string | null
    fecha: Date | null
    leido: boolean | null
  }

  export type MensajeChatMaxAggregateOutputType = {
    id: string | null
    asignacionId: string | null
    cuestionarioId: string | null
    activoProcesoId: string | null
    usuarioId: string | null
    usuarioNombre: string | null
    usuarioRol: string | null
    mensaje: string | null
    fecha: Date | null
    leido: boolean | null
  }

  export type MensajeChatCountAggregateOutputType = {
    id: number
    asignacionId: number
    cuestionarioId: number
    activoProcesoId: number
    usuarioId: number
    usuarioNombre: number
    usuarioRol: number
    mensaje: number
    fecha: number
    leido: number
    _all: number
  }


  export type MensajeChatMinAggregateInputType = {
    id?: true
    asignacionId?: true
    cuestionarioId?: true
    activoProcesoId?: true
    usuarioId?: true
    usuarioNombre?: true
    usuarioRol?: true
    mensaje?: true
    fecha?: true
    leido?: true
  }

  export type MensajeChatMaxAggregateInputType = {
    id?: true
    asignacionId?: true
    cuestionarioId?: true
    activoProcesoId?: true
    usuarioId?: true
    usuarioNombre?: true
    usuarioRol?: true
    mensaje?: true
    fecha?: true
    leido?: true
  }

  export type MensajeChatCountAggregateInputType = {
    id?: true
    asignacionId?: true
    cuestionarioId?: true
    activoProcesoId?: true
    usuarioId?: true
    usuarioNombre?: true
    usuarioRol?: true
    mensaje?: true
    fecha?: true
    leido?: true
    _all?: true
  }

  export type MensajeChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MensajeChat to aggregate.
     */
    where?: MensajeChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MensajeChats to fetch.
     */
    orderBy?: MensajeChatOrderByWithRelationInput | MensajeChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MensajeChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MensajeChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MensajeChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MensajeChats
    **/
    _count?: true | MensajeChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MensajeChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MensajeChatMaxAggregateInputType
  }

  export type GetMensajeChatAggregateType<T extends MensajeChatAggregateArgs> = {
        [P in keyof T & keyof AggregateMensajeChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMensajeChat[P]>
      : GetScalarType<T[P], AggregateMensajeChat[P]>
  }




  export type MensajeChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MensajeChatWhereInput
    orderBy?: MensajeChatOrderByWithAggregationInput | MensajeChatOrderByWithAggregationInput[]
    by: MensajeChatScalarFieldEnum[] | MensajeChatScalarFieldEnum
    having?: MensajeChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MensajeChatCountAggregateInputType | true
    _min?: MensajeChatMinAggregateInputType
    _max?: MensajeChatMaxAggregateInputType
  }

  export type MensajeChatGroupByOutputType = {
    id: string
    asignacionId: string
    cuestionarioId: string | null
    activoProcesoId: string | null
    usuarioId: string
    usuarioNombre: string
    usuarioRol: string
    mensaje: string
    fecha: Date
    leido: boolean
    _count: MensajeChatCountAggregateOutputType | null
    _min: MensajeChatMinAggregateOutputType | null
    _max: MensajeChatMaxAggregateOutputType | null
  }

  type GetMensajeChatGroupByPayload<T extends MensajeChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MensajeChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MensajeChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MensajeChatGroupByOutputType[P]>
            : GetScalarType<T[P], MensajeChatGroupByOutputType[P]>
        }
      >
    >


  export type MensajeChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asignacionId?: boolean
    cuestionarioId?: boolean
    activoProcesoId?: boolean
    usuarioId?: boolean
    usuarioNombre?: boolean
    usuarioRol?: boolean
    mensaje?: boolean
    fecha?: boolean
    leido?: boolean
    asignacion?: boolean | AsignacionCuestionarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mensajeChat"]>

  export type MensajeChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asignacionId?: boolean
    cuestionarioId?: boolean
    activoProcesoId?: boolean
    usuarioId?: boolean
    usuarioNombre?: boolean
    usuarioRol?: boolean
    mensaje?: boolean
    fecha?: boolean
    leido?: boolean
    asignacion?: boolean | AsignacionCuestionarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mensajeChat"]>

  export type MensajeChatSelectScalar = {
    id?: boolean
    asignacionId?: boolean
    cuestionarioId?: boolean
    activoProcesoId?: boolean
    usuarioId?: boolean
    usuarioNombre?: boolean
    usuarioRol?: boolean
    mensaje?: boolean
    fecha?: boolean
    leido?: boolean
  }

  export type MensajeChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asignacion?: boolean | AsignacionCuestionarioDefaultArgs<ExtArgs>
  }
  export type MensajeChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asignacion?: boolean | AsignacionCuestionarioDefaultArgs<ExtArgs>
  }

  export type $MensajeChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MensajeChat"
    objects: {
      asignacion: Prisma.$AsignacionCuestionarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      asignacionId: string
      cuestionarioId: string | null
      activoProcesoId: string | null
      usuarioId: string
      usuarioNombre: string
      usuarioRol: string
      mensaje: string
      fecha: Date
      leido: boolean
    }, ExtArgs["result"]["mensajeChat"]>
    composites: {}
  }

  type MensajeChatGetPayload<S extends boolean | null | undefined | MensajeChatDefaultArgs> = $Result.GetResult<Prisma.$MensajeChatPayload, S>

  type MensajeChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MensajeChatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MensajeChatCountAggregateInputType | true
    }

  export interface MensajeChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MensajeChat'], meta: { name: 'MensajeChat' } }
    /**
     * Find zero or one MensajeChat that matches the filter.
     * @param {MensajeChatFindUniqueArgs} args - Arguments to find a MensajeChat
     * @example
     * // Get one MensajeChat
     * const mensajeChat = await prisma.mensajeChat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MensajeChatFindUniqueArgs>(args: SelectSubset<T, MensajeChatFindUniqueArgs<ExtArgs>>): Prisma__MensajeChatClient<$Result.GetResult<Prisma.$MensajeChatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MensajeChat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MensajeChatFindUniqueOrThrowArgs} args - Arguments to find a MensajeChat
     * @example
     * // Get one MensajeChat
     * const mensajeChat = await prisma.mensajeChat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MensajeChatFindUniqueOrThrowArgs>(args: SelectSubset<T, MensajeChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MensajeChatClient<$Result.GetResult<Prisma.$MensajeChatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MensajeChat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeChatFindFirstArgs} args - Arguments to find a MensajeChat
     * @example
     * // Get one MensajeChat
     * const mensajeChat = await prisma.mensajeChat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MensajeChatFindFirstArgs>(args?: SelectSubset<T, MensajeChatFindFirstArgs<ExtArgs>>): Prisma__MensajeChatClient<$Result.GetResult<Prisma.$MensajeChatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MensajeChat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeChatFindFirstOrThrowArgs} args - Arguments to find a MensajeChat
     * @example
     * // Get one MensajeChat
     * const mensajeChat = await prisma.mensajeChat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MensajeChatFindFirstOrThrowArgs>(args?: SelectSubset<T, MensajeChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__MensajeChatClient<$Result.GetResult<Prisma.$MensajeChatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MensajeChats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MensajeChats
     * const mensajeChats = await prisma.mensajeChat.findMany()
     * 
     * // Get first 10 MensajeChats
     * const mensajeChats = await prisma.mensajeChat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mensajeChatWithIdOnly = await prisma.mensajeChat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MensajeChatFindManyArgs>(args?: SelectSubset<T, MensajeChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensajeChatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MensajeChat.
     * @param {MensajeChatCreateArgs} args - Arguments to create a MensajeChat.
     * @example
     * // Create one MensajeChat
     * const MensajeChat = await prisma.mensajeChat.create({
     *   data: {
     *     // ... data to create a MensajeChat
     *   }
     * })
     * 
     */
    create<T extends MensajeChatCreateArgs>(args: SelectSubset<T, MensajeChatCreateArgs<ExtArgs>>): Prisma__MensajeChatClient<$Result.GetResult<Prisma.$MensajeChatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MensajeChats.
     * @param {MensajeChatCreateManyArgs} args - Arguments to create many MensajeChats.
     * @example
     * // Create many MensajeChats
     * const mensajeChat = await prisma.mensajeChat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MensajeChatCreateManyArgs>(args?: SelectSubset<T, MensajeChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MensajeChats and returns the data saved in the database.
     * @param {MensajeChatCreateManyAndReturnArgs} args - Arguments to create many MensajeChats.
     * @example
     * // Create many MensajeChats
     * const mensajeChat = await prisma.mensajeChat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MensajeChats and only return the `id`
     * const mensajeChatWithIdOnly = await prisma.mensajeChat.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MensajeChatCreateManyAndReturnArgs>(args?: SelectSubset<T, MensajeChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensajeChatPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MensajeChat.
     * @param {MensajeChatDeleteArgs} args - Arguments to delete one MensajeChat.
     * @example
     * // Delete one MensajeChat
     * const MensajeChat = await prisma.mensajeChat.delete({
     *   where: {
     *     // ... filter to delete one MensajeChat
     *   }
     * })
     * 
     */
    delete<T extends MensajeChatDeleteArgs>(args: SelectSubset<T, MensajeChatDeleteArgs<ExtArgs>>): Prisma__MensajeChatClient<$Result.GetResult<Prisma.$MensajeChatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MensajeChat.
     * @param {MensajeChatUpdateArgs} args - Arguments to update one MensajeChat.
     * @example
     * // Update one MensajeChat
     * const mensajeChat = await prisma.mensajeChat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MensajeChatUpdateArgs>(args: SelectSubset<T, MensajeChatUpdateArgs<ExtArgs>>): Prisma__MensajeChatClient<$Result.GetResult<Prisma.$MensajeChatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MensajeChats.
     * @param {MensajeChatDeleteManyArgs} args - Arguments to filter MensajeChats to delete.
     * @example
     * // Delete a few MensajeChats
     * const { count } = await prisma.mensajeChat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MensajeChatDeleteManyArgs>(args?: SelectSubset<T, MensajeChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MensajeChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MensajeChats
     * const mensajeChat = await prisma.mensajeChat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MensajeChatUpdateManyArgs>(args: SelectSubset<T, MensajeChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MensajeChat.
     * @param {MensajeChatUpsertArgs} args - Arguments to update or create a MensajeChat.
     * @example
     * // Update or create a MensajeChat
     * const mensajeChat = await prisma.mensajeChat.upsert({
     *   create: {
     *     // ... data to create a MensajeChat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MensajeChat we want to update
     *   }
     * })
     */
    upsert<T extends MensajeChatUpsertArgs>(args: SelectSubset<T, MensajeChatUpsertArgs<ExtArgs>>): Prisma__MensajeChatClient<$Result.GetResult<Prisma.$MensajeChatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MensajeChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeChatCountArgs} args - Arguments to filter MensajeChats to count.
     * @example
     * // Count the number of MensajeChats
     * const count = await prisma.mensajeChat.count({
     *   where: {
     *     // ... the filter for the MensajeChats we want to count
     *   }
     * })
    **/
    count<T extends MensajeChatCountArgs>(
      args?: Subset<T, MensajeChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MensajeChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MensajeChat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MensajeChatAggregateArgs>(args: Subset<T, MensajeChatAggregateArgs>): Prisma.PrismaPromise<GetMensajeChatAggregateType<T>>

    /**
     * Group by MensajeChat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MensajeChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MensajeChatGroupByArgs['orderBy'] }
        : { orderBy?: MensajeChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MensajeChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMensajeChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MensajeChat model
   */
  readonly fields: MensajeChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MensajeChat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MensajeChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asignacion<T extends AsignacionCuestionarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AsignacionCuestionarioDefaultArgs<ExtArgs>>): Prisma__AsignacionCuestionarioClient<$Result.GetResult<Prisma.$AsignacionCuestionarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MensajeChat model
   */ 
  interface MensajeChatFieldRefs {
    readonly id: FieldRef<"MensajeChat", 'String'>
    readonly asignacionId: FieldRef<"MensajeChat", 'String'>
    readonly cuestionarioId: FieldRef<"MensajeChat", 'String'>
    readonly activoProcesoId: FieldRef<"MensajeChat", 'String'>
    readonly usuarioId: FieldRef<"MensajeChat", 'String'>
    readonly usuarioNombre: FieldRef<"MensajeChat", 'String'>
    readonly usuarioRol: FieldRef<"MensajeChat", 'String'>
    readonly mensaje: FieldRef<"MensajeChat", 'String'>
    readonly fecha: FieldRef<"MensajeChat", 'DateTime'>
    readonly leido: FieldRef<"MensajeChat", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * MensajeChat findUnique
   */
  export type MensajeChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensajeChat
     */
    select?: MensajeChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeChatInclude<ExtArgs> | null
    /**
     * Filter, which MensajeChat to fetch.
     */
    where: MensajeChatWhereUniqueInput
  }

  /**
   * MensajeChat findUniqueOrThrow
   */
  export type MensajeChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensajeChat
     */
    select?: MensajeChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeChatInclude<ExtArgs> | null
    /**
     * Filter, which MensajeChat to fetch.
     */
    where: MensajeChatWhereUniqueInput
  }

  /**
   * MensajeChat findFirst
   */
  export type MensajeChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensajeChat
     */
    select?: MensajeChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeChatInclude<ExtArgs> | null
    /**
     * Filter, which MensajeChat to fetch.
     */
    where?: MensajeChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MensajeChats to fetch.
     */
    orderBy?: MensajeChatOrderByWithRelationInput | MensajeChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MensajeChats.
     */
    cursor?: MensajeChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MensajeChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MensajeChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MensajeChats.
     */
    distinct?: MensajeChatScalarFieldEnum | MensajeChatScalarFieldEnum[]
  }

  /**
   * MensajeChat findFirstOrThrow
   */
  export type MensajeChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensajeChat
     */
    select?: MensajeChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeChatInclude<ExtArgs> | null
    /**
     * Filter, which MensajeChat to fetch.
     */
    where?: MensajeChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MensajeChats to fetch.
     */
    orderBy?: MensajeChatOrderByWithRelationInput | MensajeChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MensajeChats.
     */
    cursor?: MensajeChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MensajeChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MensajeChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MensajeChats.
     */
    distinct?: MensajeChatScalarFieldEnum | MensajeChatScalarFieldEnum[]
  }

  /**
   * MensajeChat findMany
   */
  export type MensajeChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensajeChat
     */
    select?: MensajeChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeChatInclude<ExtArgs> | null
    /**
     * Filter, which MensajeChats to fetch.
     */
    where?: MensajeChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MensajeChats to fetch.
     */
    orderBy?: MensajeChatOrderByWithRelationInput | MensajeChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MensajeChats.
     */
    cursor?: MensajeChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MensajeChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MensajeChats.
     */
    skip?: number
    distinct?: MensajeChatScalarFieldEnum | MensajeChatScalarFieldEnum[]
  }

  /**
   * MensajeChat create
   */
  export type MensajeChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensajeChat
     */
    select?: MensajeChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeChatInclude<ExtArgs> | null
    /**
     * The data needed to create a MensajeChat.
     */
    data: XOR<MensajeChatCreateInput, MensajeChatUncheckedCreateInput>
  }

  /**
   * MensajeChat createMany
   */
  export type MensajeChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MensajeChats.
     */
    data: MensajeChatCreateManyInput | MensajeChatCreateManyInput[]
  }

  /**
   * MensajeChat createManyAndReturn
   */
  export type MensajeChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensajeChat
     */
    select?: MensajeChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MensajeChats.
     */
    data: MensajeChatCreateManyInput | MensajeChatCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MensajeChat update
   */
  export type MensajeChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensajeChat
     */
    select?: MensajeChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeChatInclude<ExtArgs> | null
    /**
     * The data needed to update a MensajeChat.
     */
    data: XOR<MensajeChatUpdateInput, MensajeChatUncheckedUpdateInput>
    /**
     * Choose, which MensajeChat to update.
     */
    where: MensajeChatWhereUniqueInput
  }

  /**
   * MensajeChat updateMany
   */
  export type MensajeChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MensajeChats.
     */
    data: XOR<MensajeChatUpdateManyMutationInput, MensajeChatUncheckedUpdateManyInput>
    /**
     * Filter which MensajeChats to update
     */
    where?: MensajeChatWhereInput
  }

  /**
   * MensajeChat upsert
   */
  export type MensajeChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensajeChat
     */
    select?: MensajeChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeChatInclude<ExtArgs> | null
    /**
     * The filter to search for the MensajeChat to update in case it exists.
     */
    where: MensajeChatWhereUniqueInput
    /**
     * In case the MensajeChat found by the `where` argument doesn't exist, create a new MensajeChat with this data.
     */
    create: XOR<MensajeChatCreateInput, MensajeChatUncheckedCreateInput>
    /**
     * In case the MensajeChat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MensajeChatUpdateInput, MensajeChatUncheckedUpdateInput>
  }

  /**
   * MensajeChat delete
   */
  export type MensajeChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensajeChat
     */
    select?: MensajeChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeChatInclude<ExtArgs> | null
    /**
     * Filter which MensajeChat to delete.
     */
    where: MensajeChatWhereUniqueInput
  }

  /**
   * MensajeChat deleteMany
   */
  export type MensajeChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MensajeChats to delete
     */
    where?: MensajeChatWhereInput
  }

  /**
   * MensajeChat without action
   */
  export type MensajeChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensajeChat
     */
    select?: MensajeChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeChatInclude<ExtArgs> | null
  }


  /**
   * Model AlertaCumplimiento
   */

  export type AggregateAlertaCumplimiento = {
    _count: AlertaCumplimientoCountAggregateOutputType | null
    _min: AlertaCumplimientoMinAggregateOutputType | null
    _max: AlertaCumplimientoMaxAggregateOutputType | null
  }

  export type AlertaCumplimientoMinAggregateOutputType = {
    id: string | null
    tipo: string | null
    severidad: string | null
    titulo: string | null
    descripcion: string | null
    entidadId: string | null
    entidadTipo: string | null
    fechaGeneracion: Date | null
    estado: string | null
    responsable: string | null
    marcoNormativo: string | null
  }

  export type AlertaCumplimientoMaxAggregateOutputType = {
    id: string | null
    tipo: string | null
    severidad: string | null
    titulo: string | null
    descripcion: string | null
    entidadId: string | null
    entidadTipo: string | null
    fechaGeneracion: Date | null
    estado: string | null
    responsable: string | null
    marcoNormativo: string | null
  }

  export type AlertaCumplimientoCountAggregateOutputType = {
    id: number
    tipo: number
    severidad: number
    titulo: number
    descripcion: number
    entidadId: number
    entidadTipo: number
    fechaGeneracion: number
    estado: number
    responsable: number
    marcoNormativo: number
    _all: number
  }


  export type AlertaCumplimientoMinAggregateInputType = {
    id?: true
    tipo?: true
    severidad?: true
    titulo?: true
    descripcion?: true
    entidadId?: true
    entidadTipo?: true
    fechaGeneracion?: true
    estado?: true
    responsable?: true
    marcoNormativo?: true
  }

  export type AlertaCumplimientoMaxAggregateInputType = {
    id?: true
    tipo?: true
    severidad?: true
    titulo?: true
    descripcion?: true
    entidadId?: true
    entidadTipo?: true
    fechaGeneracion?: true
    estado?: true
    responsable?: true
    marcoNormativo?: true
  }

  export type AlertaCumplimientoCountAggregateInputType = {
    id?: true
    tipo?: true
    severidad?: true
    titulo?: true
    descripcion?: true
    entidadId?: true
    entidadTipo?: true
    fechaGeneracion?: true
    estado?: true
    responsable?: true
    marcoNormativo?: true
    _all?: true
  }

  export type AlertaCumplimientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertaCumplimiento to aggregate.
     */
    where?: AlertaCumplimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertaCumplimientos to fetch.
     */
    orderBy?: AlertaCumplimientoOrderByWithRelationInput | AlertaCumplimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertaCumplimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertaCumplimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertaCumplimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlertaCumplimientos
    **/
    _count?: true | AlertaCumplimientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertaCumplimientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertaCumplimientoMaxAggregateInputType
  }

  export type GetAlertaCumplimientoAggregateType<T extends AlertaCumplimientoAggregateArgs> = {
        [P in keyof T & keyof AggregateAlertaCumplimiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlertaCumplimiento[P]>
      : GetScalarType<T[P], AggregateAlertaCumplimiento[P]>
  }




  export type AlertaCumplimientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertaCumplimientoWhereInput
    orderBy?: AlertaCumplimientoOrderByWithAggregationInput | AlertaCumplimientoOrderByWithAggregationInput[]
    by: AlertaCumplimientoScalarFieldEnum[] | AlertaCumplimientoScalarFieldEnum
    having?: AlertaCumplimientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertaCumplimientoCountAggregateInputType | true
    _min?: AlertaCumplimientoMinAggregateInputType
    _max?: AlertaCumplimientoMaxAggregateInputType
  }

  export type AlertaCumplimientoGroupByOutputType = {
    id: string
    tipo: string
    severidad: string
    titulo: string
    descripcion: string
    entidadId: string
    entidadTipo: string
    fechaGeneracion: Date
    estado: string
    responsable: string | null
    marcoNormativo: string | null
    _count: AlertaCumplimientoCountAggregateOutputType | null
    _min: AlertaCumplimientoMinAggregateOutputType | null
    _max: AlertaCumplimientoMaxAggregateOutputType | null
  }

  type GetAlertaCumplimientoGroupByPayload<T extends AlertaCumplimientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertaCumplimientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertaCumplimientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertaCumplimientoGroupByOutputType[P]>
            : GetScalarType<T[P], AlertaCumplimientoGroupByOutputType[P]>
        }
      >
    >


  export type AlertaCumplimientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    severidad?: boolean
    titulo?: boolean
    descripcion?: boolean
    entidadId?: boolean
    entidadTipo?: boolean
    fechaGeneracion?: boolean
    estado?: boolean
    responsable?: boolean
    marcoNormativo?: boolean
  }, ExtArgs["result"]["alertaCumplimiento"]>

  export type AlertaCumplimientoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    severidad?: boolean
    titulo?: boolean
    descripcion?: boolean
    entidadId?: boolean
    entidadTipo?: boolean
    fechaGeneracion?: boolean
    estado?: boolean
    responsable?: boolean
    marcoNormativo?: boolean
  }, ExtArgs["result"]["alertaCumplimiento"]>

  export type AlertaCumplimientoSelectScalar = {
    id?: boolean
    tipo?: boolean
    severidad?: boolean
    titulo?: boolean
    descripcion?: boolean
    entidadId?: boolean
    entidadTipo?: boolean
    fechaGeneracion?: boolean
    estado?: boolean
    responsable?: boolean
    marcoNormativo?: boolean
  }


  export type $AlertaCumplimientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlertaCumplimiento"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tipo: string
      severidad: string
      titulo: string
      descripcion: string
      entidadId: string
      entidadTipo: string
      fechaGeneracion: Date
      estado: string
      responsable: string | null
      marcoNormativo: string | null
    }, ExtArgs["result"]["alertaCumplimiento"]>
    composites: {}
  }

  type AlertaCumplimientoGetPayload<S extends boolean | null | undefined | AlertaCumplimientoDefaultArgs> = $Result.GetResult<Prisma.$AlertaCumplimientoPayload, S>

  type AlertaCumplimientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlertaCumplimientoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertaCumplimientoCountAggregateInputType | true
    }

  export interface AlertaCumplimientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlertaCumplimiento'], meta: { name: 'AlertaCumplimiento' } }
    /**
     * Find zero or one AlertaCumplimiento that matches the filter.
     * @param {AlertaCumplimientoFindUniqueArgs} args - Arguments to find a AlertaCumplimiento
     * @example
     * // Get one AlertaCumplimiento
     * const alertaCumplimiento = await prisma.alertaCumplimiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertaCumplimientoFindUniqueArgs>(args: SelectSubset<T, AlertaCumplimientoFindUniqueArgs<ExtArgs>>): Prisma__AlertaCumplimientoClient<$Result.GetResult<Prisma.$AlertaCumplimientoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AlertaCumplimiento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlertaCumplimientoFindUniqueOrThrowArgs} args - Arguments to find a AlertaCumplimiento
     * @example
     * // Get one AlertaCumplimiento
     * const alertaCumplimiento = await prisma.alertaCumplimiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertaCumplimientoFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertaCumplimientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertaCumplimientoClient<$Result.GetResult<Prisma.$AlertaCumplimientoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AlertaCumplimiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertaCumplimientoFindFirstArgs} args - Arguments to find a AlertaCumplimiento
     * @example
     * // Get one AlertaCumplimiento
     * const alertaCumplimiento = await prisma.alertaCumplimiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertaCumplimientoFindFirstArgs>(args?: SelectSubset<T, AlertaCumplimientoFindFirstArgs<ExtArgs>>): Prisma__AlertaCumplimientoClient<$Result.GetResult<Prisma.$AlertaCumplimientoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AlertaCumplimiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertaCumplimientoFindFirstOrThrowArgs} args - Arguments to find a AlertaCumplimiento
     * @example
     * // Get one AlertaCumplimiento
     * const alertaCumplimiento = await prisma.alertaCumplimiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertaCumplimientoFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertaCumplimientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertaCumplimientoClient<$Result.GetResult<Prisma.$AlertaCumplimientoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AlertaCumplimientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertaCumplimientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlertaCumplimientos
     * const alertaCumplimientos = await prisma.alertaCumplimiento.findMany()
     * 
     * // Get first 10 AlertaCumplimientos
     * const alertaCumplimientos = await prisma.alertaCumplimiento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertaCumplimientoWithIdOnly = await prisma.alertaCumplimiento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertaCumplimientoFindManyArgs>(args?: SelectSubset<T, AlertaCumplimientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertaCumplimientoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AlertaCumplimiento.
     * @param {AlertaCumplimientoCreateArgs} args - Arguments to create a AlertaCumplimiento.
     * @example
     * // Create one AlertaCumplimiento
     * const AlertaCumplimiento = await prisma.alertaCumplimiento.create({
     *   data: {
     *     // ... data to create a AlertaCumplimiento
     *   }
     * })
     * 
     */
    create<T extends AlertaCumplimientoCreateArgs>(args: SelectSubset<T, AlertaCumplimientoCreateArgs<ExtArgs>>): Prisma__AlertaCumplimientoClient<$Result.GetResult<Prisma.$AlertaCumplimientoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AlertaCumplimientos.
     * @param {AlertaCumplimientoCreateManyArgs} args - Arguments to create many AlertaCumplimientos.
     * @example
     * // Create many AlertaCumplimientos
     * const alertaCumplimiento = await prisma.alertaCumplimiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertaCumplimientoCreateManyArgs>(args?: SelectSubset<T, AlertaCumplimientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlertaCumplimientos and returns the data saved in the database.
     * @param {AlertaCumplimientoCreateManyAndReturnArgs} args - Arguments to create many AlertaCumplimientos.
     * @example
     * // Create many AlertaCumplimientos
     * const alertaCumplimiento = await prisma.alertaCumplimiento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlertaCumplimientos and only return the `id`
     * const alertaCumplimientoWithIdOnly = await prisma.alertaCumplimiento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertaCumplimientoCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertaCumplimientoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertaCumplimientoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AlertaCumplimiento.
     * @param {AlertaCumplimientoDeleteArgs} args - Arguments to delete one AlertaCumplimiento.
     * @example
     * // Delete one AlertaCumplimiento
     * const AlertaCumplimiento = await prisma.alertaCumplimiento.delete({
     *   where: {
     *     // ... filter to delete one AlertaCumplimiento
     *   }
     * })
     * 
     */
    delete<T extends AlertaCumplimientoDeleteArgs>(args: SelectSubset<T, AlertaCumplimientoDeleteArgs<ExtArgs>>): Prisma__AlertaCumplimientoClient<$Result.GetResult<Prisma.$AlertaCumplimientoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AlertaCumplimiento.
     * @param {AlertaCumplimientoUpdateArgs} args - Arguments to update one AlertaCumplimiento.
     * @example
     * // Update one AlertaCumplimiento
     * const alertaCumplimiento = await prisma.alertaCumplimiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertaCumplimientoUpdateArgs>(args: SelectSubset<T, AlertaCumplimientoUpdateArgs<ExtArgs>>): Prisma__AlertaCumplimientoClient<$Result.GetResult<Prisma.$AlertaCumplimientoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AlertaCumplimientos.
     * @param {AlertaCumplimientoDeleteManyArgs} args - Arguments to filter AlertaCumplimientos to delete.
     * @example
     * // Delete a few AlertaCumplimientos
     * const { count } = await prisma.alertaCumplimiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertaCumplimientoDeleteManyArgs>(args?: SelectSubset<T, AlertaCumplimientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertaCumplimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertaCumplimientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlertaCumplimientos
     * const alertaCumplimiento = await prisma.alertaCumplimiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertaCumplimientoUpdateManyArgs>(args: SelectSubset<T, AlertaCumplimientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AlertaCumplimiento.
     * @param {AlertaCumplimientoUpsertArgs} args - Arguments to update or create a AlertaCumplimiento.
     * @example
     * // Update or create a AlertaCumplimiento
     * const alertaCumplimiento = await prisma.alertaCumplimiento.upsert({
     *   create: {
     *     // ... data to create a AlertaCumplimiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlertaCumplimiento we want to update
     *   }
     * })
     */
    upsert<T extends AlertaCumplimientoUpsertArgs>(args: SelectSubset<T, AlertaCumplimientoUpsertArgs<ExtArgs>>): Prisma__AlertaCumplimientoClient<$Result.GetResult<Prisma.$AlertaCumplimientoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AlertaCumplimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertaCumplimientoCountArgs} args - Arguments to filter AlertaCumplimientos to count.
     * @example
     * // Count the number of AlertaCumplimientos
     * const count = await prisma.alertaCumplimiento.count({
     *   where: {
     *     // ... the filter for the AlertaCumplimientos we want to count
     *   }
     * })
    **/
    count<T extends AlertaCumplimientoCountArgs>(
      args?: Subset<T, AlertaCumplimientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertaCumplimientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlertaCumplimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertaCumplimientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertaCumplimientoAggregateArgs>(args: Subset<T, AlertaCumplimientoAggregateArgs>): Prisma.PrismaPromise<GetAlertaCumplimientoAggregateType<T>>

    /**
     * Group by AlertaCumplimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertaCumplimientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertaCumplimientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertaCumplimientoGroupByArgs['orderBy'] }
        : { orderBy?: AlertaCumplimientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertaCumplimientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertaCumplimientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlertaCumplimiento model
   */
  readonly fields: AlertaCumplimientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlertaCumplimiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertaCumplimientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlertaCumplimiento model
   */ 
  interface AlertaCumplimientoFieldRefs {
    readonly id: FieldRef<"AlertaCumplimiento", 'String'>
    readonly tipo: FieldRef<"AlertaCumplimiento", 'String'>
    readonly severidad: FieldRef<"AlertaCumplimiento", 'String'>
    readonly titulo: FieldRef<"AlertaCumplimiento", 'String'>
    readonly descripcion: FieldRef<"AlertaCumplimiento", 'String'>
    readonly entidadId: FieldRef<"AlertaCumplimiento", 'String'>
    readonly entidadTipo: FieldRef<"AlertaCumplimiento", 'String'>
    readonly fechaGeneracion: FieldRef<"AlertaCumplimiento", 'DateTime'>
    readonly estado: FieldRef<"AlertaCumplimiento", 'String'>
    readonly responsable: FieldRef<"AlertaCumplimiento", 'String'>
    readonly marcoNormativo: FieldRef<"AlertaCumplimiento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AlertaCumplimiento findUnique
   */
  export type AlertaCumplimientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertaCumplimiento
     */
    select?: AlertaCumplimientoSelect<ExtArgs> | null
    /**
     * Filter, which AlertaCumplimiento to fetch.
     */
    where: AlertaCumplimientoWhereUniqueInput
  }

  /**
   * AlertaCumplimiento findUniqueOrThrow
   */
  export type AlertaCumplimientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertaCumplimiento
     */
    select?: AlertaCumplimientoSelect<ExtArgs> | null
    /**
     * Filter, which AlertaCumplimiento to fetch.
     */
    where: AlertaCumplimientoWhereUniqueInput
  }

  /**
   * AlertaCumplimiento findFirst
   */
  export type AlertaCumplimientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertaCumplimiento
     */
    select?: AlertaCumplimientoSelect<ExtArgs> | null
    /**
     * Filter, which AlertaCumplimiento to fetch.
     */
    where?: AlertaCumplimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertaCumplimientos to fetch.
     */
    orderBy?: AlertaCumplimientoOrderByWithRelationInput | AlertaCumplimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertaCumplimientos.
     */
    cursor?: AlertaCumplimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertaCumplimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertaCumplimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertaCumplimientos.
     */
    distinct?: AlertaCumplimientoScalarFieldEnum | AlertaCumplimientoScalarFieldEnum[]
  }

  /**
   * AlertaCumplimiento findFirstOrThrow
   */
  export type AlertaCumplimientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertaCumplimiento
     */
    select?: AlertaCumplimientoSelect<ExtArgs> | null
    /**
     * Filter, which AlertaCumplimiento to fetch.
     */
    where?: AlertaCumplimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertaCumplimientos to fetch.
     */
    orderBy?: AlertaCumplimientoOrderByWithRelationInput | AlertaCumplimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertaCumplimientos.
     */
    cursor?: AlertaCumplimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertaCumplimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertaCumplimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertaCumplimientos.
     */
    distinct?: AlertaCumplimientoScalarFieldEnum | AlertaCumplimientoScalarFieldEnum[]
  }

  /**
   * AlertaCumplimiento findMany
   */
  export type AlertaCumplimientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertaCumplimiento
     */
    select?: AlertaCumplimientoSelect<ExtArgs> | null
    /**
     * Filter, which AlertaCumplimientos to fetch.
     */
    where?: AlertaCumplimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertaCumplimientos to fetch.
     */
    orderBy?: AlertaCumplimientoOrderByWithRelationInput | AlertaCumplimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlertaCumplimientos.
     */
    cursor?: AlertaCumplimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertaCumplimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertaCumplimientos.
     */
    skip?: number
    distinct?: AlertaCumplimientoScalarFieldEnum | AlertaCumplimientoScalarFieldEnum[]
  }

  /**
   * AlertaCumplimiento create
   */
  export type AlertaCumplimientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertaCumplimiento
     */
    select?: AlertaCumplimientoSelect<ExtArgs> | null
    /**
     * The data needed to create a AlertaCumplimiento.
     */
    data: XOR<AlertaCumplimientoCreateInput, AlertaCumplimientoUncheckedCreateInput>
  }

  /**
   * AlertaCumplimiento createMany
   */
  export type AlertaCumplimientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlertaCumplimientos.
     */
    data: AlertaCumplimientoCreateManyInput | AlertaCumplimientoCreateManyInput[]
  }

  /**
   * AlertaCumplimiento createManyAndReturn
   */
  export type AlertaCumplimientoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertaCumplimiento
     */
    select?: AlertaCumplimientoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AlertaCumplimientos.
     */
    data: AlertaCumplimientoCreateManyInput | AlertaCumplimientoCreateManyInput[]
  }

  /**
   * AlertaCumplimiento update
   */
  export type AlertaCumplimientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertaCumplimiento
     */
    select?: AlertaCumplimientoSelect<ExtArgs> | null
    /**
     * The data needed to update a AlertaCumplimiento.
     */
    data: XOR<AlertaCumplimientoUpdateInput, AlertaCumplimientoUncheckedUpdateInput>
    /**
     * Choose, which AlertaCumplimiento to update.
     */
    where: AlertaCumplimientoWhereUniqueInput
  }

  /**
   * AlertaCumplimiento updateMany
   */
  export type AlertaCumplimientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlertaCumplimientos.
     */
    data: XOR<AlertaCumplimientoUpdateManyMutationInput, AlertaCumplimientoUncheckedUpdateManyInput>
    /**
     * Filter which AlertaCumplimientos to update
     */
    where?: AlertaCumplimientoWhereInput
  }

  /**
   * AlertaCumplimiento upsert
   */
  export type AlertaCumplimientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertaCumplimiento
     */
    select?: AlertaCumplimientoSelect<ExtArgs> | null
    /**
     * The filter to search for the AlertaCumplimiento to update in case it exists.
     */
    where: AlertaCumplimientoWhereUniqueInput
    /**
     * In case the AlertaCumplimiento found by the `where` argument doesn't exist, create a new AlertaCumplimiento with this data.
     */
    create: XOR<AlertaCumplimientoCreateInput, AlertaCumplimientoUncheckedCreateInput>
    /**
     * In case the AlertaCumplimiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertaCumplimientoUpdateInput, AlertaCumplimientoUncheckedUpdateInput>
  }

  /**
   * AlertaCumplimiento delete
   */
  export type AlertaCumplimientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertaCumplimiento
     */
    select?: AlertaCumplimientoSelect<ExtArgs> | null
    /**
     * Filter which AlertaCumplimiento to delete.
     */
    where: AlertaCumplimientoWhereUniqueInput
  }

  /**
   * AlertaCumplimiento deleteMany
   */
  export type AlertaCumplimientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertaCumplimientos to delete
     */
    where?: AlertaCumplimientoWhereInput
  }

  /**
   * AlertaCumplimiento without action
   */
  export type AlertaCumplimientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertaCumplimiento
     */
    select?: AlertaCumplimientoSelect<ExtArgs> | null
  }


  /**
   * Model Proceso
   */

  export type AggregateProceso = {
    _count: ProcesoCountAggregateOutputType | null
    _min: ProcesoMinAggregateOutputType | null
    _max: ProcesoMaxAggregateOutputType | null
  }

  export type ProcesoMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    version: string | null
    estado: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type ProcesoMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    version: string | null
    estado: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type ProcesoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    version: number
    estado: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type ProcesoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    version?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type ProcesoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    version?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type ProcesoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    version?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type ProcesoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proceso to aggregate.
     */
    where?: ProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procesos to fetch.
     */
    orderBy?: ProcesoOrderByWithRelationInput | ProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Procesos
    **/
    _count?: true | ProcesoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcesoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcesoMaxAggregateInputType
  }

  export type GetProcesoAggregateType<T extends ProcesoAggregateArgs> = {
        [P in keyof T & keyof AggregateProceso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProceso[P]>
      : GetScalarType<T[P], AggregateProceso[P]>
  }




  export type ProcesoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcesoWhereInput
    orderBy?: ProcesoOrderByWithAggregationInput | ProcesoOrderByWithAggregationInput[]
    by: ProcesoScalarFieldEnum[] | ProcesoScalarFieldEnum
    having?: ProcesoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcesoCountAggregateInputType | true
    _min?: ProcesoMinAggregateInputType
    _max?: ProcesoMaxAggregateInputType
  }

  export type ProcesoGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string
    version: string
    estado: string
    createdAt: Date
    updatedAt: Date
    createdBy: string
    _count: ProcesoCountAggregateOutputType | null
    _min: ProcesoMinAggregateOutputType | null
    _max: ProcesoMaxAggregateOutputType | null
  }

  type GetProcesoGroupByPayload<T extends ProcesoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcesoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcesoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcesoGroupByOutputType[P]>
            : GetScalarType<T[P], ProcesoGroupByOutputType[P]>
        }
      >
    >


  export type ProcesoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    version?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    nodos?: boolean | Proceso$nodosArgs<ExtArgs>
    edges?: boolean | Proceso$edgesArgs<ExtArgs>
    objetivos?: boolean | Proceso$objetivosArgs<ExtArgs>
    kpis?: boolean | Proceso$kpisArgs<ExtArgs>
    _count?: boolean | ProcesoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proceso"]>

  export type ProcesoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    version?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["proceso"]>

  export type ProcesoSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    version?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type ProcesoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodos?: boolean | Proceso$nodosArgs<ExtArgs>
    edges?: boolean | Proceso$edgesArgs<ExtArgs>
    objetivos?: boolean | Proceso$objetivosArgs<ExtArgs>
    kpis?: boolean | Proceso$kpisArgs<ExtArgs>
    _count?: boolean | ProcesoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProcesoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProcesoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proceso"
    objects: {
      nodos: Prisma.$ProcessNodePayload<ExtArgs>[]
      edges: Prisma.$ProcessEdgePayload<ExtArgs>[]
      objetivos: Prisma.$ObjetivoProcesoPayload<ExtArgs>[]
      kpis: Prisma.$KpiProcesoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      descripcion: string
      version: string
      estado: string
      createdAt: Date
      updatedAt: Date
      createdBy: string
    }, ExtArgs["result"]["proceso"]>
    composites: {}
  }

  type ProcesoGetPayload<S extends boolean | null | undefined | ProcesoDefaultArgs> = $Result.GetResult<Prisma.$ProcesoPayload, S>

  type ProcesoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcesoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcesoCountAggregateInputType | true
    }

  export interface ProcesoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proceso'], meta: { name: 'Proceso' } }
    /**
     * Find zero or one Proceso that matches the filter.
     * @param {ProcesoFindUniqueArgs} args - Arguments to find a Proceso
     * @example
     * // Get one Proceso
     * const proceso = await prisma.proceso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcesoFindUniqueArgs>(args: SelectSubset<T, ProcesoFindUniqueArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Proceso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcesoFindUniqueOrThrowArgs} args - Arguments to find a Proceso
     * @example
     * // Get one Proceso
     * const proceso = await prisma.proceso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcesoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcesoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Proceso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoFindFirstArgs} args - Arguments to find a Proceso
     * @example
     * // Get one Proceso
     * const proceso = await prisma.proceso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcesoFindFirstArgs>(args?: SelectSubset<T, ProcesoFindFirstArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Proceso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoFindFirstOrThrowArgs} args - Arguments to find a Proceso
     * @example
     * // Get one Proceso
     * const proceso = await prisma.proceso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcesoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcesoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Procesos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Procesos
     * const procesos = await prisma.proceso.findMany()
     * 
     * // Get first 10 Procesos
     * const procesos = await prisma.proceso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const procesoWithIdOnly = await prisma.proceso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcesoFindManyArgs>(args?: SelectSubset<T, ProcesoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Proceso.
     * @param {ProcesoCreateArgs} args - Arguments to create a Proceso.
     * @example
     * // Create one Proceso
     * const Proceso = await prisma.proceso.create({
     *   data: {
     *     // ... data to create a Proceso
     *   }
     * })
     * 
     */
    create<T extends ProcesoCreateArgs>(args: SelectSubset<T, ProcesoCreateArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Procesos.
     * @param {ProcesoCreateManyArgs} args - Arguments to create many Procesos.
     * @example
     * // Create many Procesos
     * const proceso = await prisma.proceso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcesoCreateManyArgs>(args?: SelectSubset<T, ProcesoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Procesos and returns the data saved in the database.
     * @param {ProcesoCreateManyAndReturnArgs} args - Arguments to create many Procesos.
     * @example
     * // Create many Procesos
     * const proceso = await prisma.proceso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Procesos and only return the `id`
     * const procesoWithIdOnly = await prisma.proceso.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcesoCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcesoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Proceso.
     * @param {ProcesoDeleteArgs} args - Arguments to delete one Proceso.
     * @example
     * // Delete one Proceso
     * const Proceso = await prisma.proceso.delete({
     *   where: {
     *     // ... filter to delete one Proceso
     *   }
     * })
     * 
     */
    delete<T extends ProcesoDeleteArgs>(args: SelectSubset<T, ProcesoDeleteArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Proceso.
     * @param {ProcesoUpdateArgs} args - Arguments to update one Proceso.
     * @example
     * // Update one Proceso
     * const proceso = await prisma.proceso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcesoUpdateArgs>(args: SelectSubset<T, ProcesoUpdateArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Procesos.
     * @param {ProcesoDeleteManyArgs} args - Arguments to filter Procesos to delete.
     * @example
     * // Delete a few Procesos
     * const { count } = await prisma.proceso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcesoDeleteManyArgs>(args?: SelectSubset<T, ProcesoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Procesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Procesos
     * const proceso = await prisma.proceso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcesoUpdateManyArgs>(args: SelectSubset<T, ProcesoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proceso.
     * @param {ProcesoUpsertArgs} args - Arguments to update or create a Proceso.
     * @example
     * // Update or create a Proceso
     * const proceso = await prisma.proceso.upsert({
     *   create: {
     *     // ... data to create a Proceso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proceso we want to update
     *   }
     * })
     */
    upsert<T extends ProcesoUpsertArgs>(args: SelectSubset<T, ProcesoUpsertArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Procesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoCountArgs} args - Arguments to filter Procesos to count.
     * @example
     * // Count the number of Procesos
     * const count = await prisma.proceso.count({
     *   where: {
     *     // ... the filter for the Procesos we want to count
     *   }
     * })
    **/
    count<T extends ProcesoCountArgs>(
      args?: Subset<T, ProcesoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcesoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proceso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcesoAggregateArgs>(args: Subset<T, ProcesoAggregateArgs>): Prisma.PrismaPromise<GetProcesoAggregateType<T>>

    /**
     * Group by Proceso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcesoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcesoGroupByArgs['orderBy'] }
        : { orderBy?: ProcesoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcesoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcesoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proceso model
   */
  readonly fields: ProcesoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proceso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcesoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nodos<T extends Proceso$nodosArgs<ExtArgs> = {}>(args?: Subset<T, Proceso$nodosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessNodePayload<ExtArgs>, T, "findMany"> | Null>
    edges<T extends Proceso$edgesArgs<ExtArgs> = {}>(args?: Subset<T, Proceso$edgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessEdgePayload<ExtArgs>, T, "findMany"> | Null>
    objetivos<T extends Proceso$objetivosArgs<ExtArgs> = {}>(args?: Subset<T, Proceso$objetivosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjetivoProcesoPayload<ExtArgs>, T, "findMany"> | Null>
    kpis<T extends Proceso$kpisArgs<ExtArgs> = {}>(args?: Subset<T, Proceso$kpisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiProcesoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proceso model
   */ 
  interface ProcesoFieldRefs {
    readonly id: FieldRef<"Proceso", 'String'>
    readonly nombre: FieldRef<"Proceso", 'String'>
    readonly descripcion: FieldRef<"Proceso", 'String'>
    readonly version: FieldRef<"Proceso", 'String'>
    readonly estado: FieldRef<"Proceso", 'String'>
    readonly createdAt: FieldRef<"Proceso", 'DateTime'>
    readonly updatedAt: FieldRef<"Proceso", 'DateTime'>
    readonly createdBy: FieldRef<"Proceso", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Proceso findUnique
   */
  export type ProcesoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * Filter, which Proceso to fetch.
     */
    where: ProcesoWhereUniqueInput
  }

  /**
   * Proceso findUniqueOrThrow
   */
  export type ProcesoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * Filter, which Proceso to fetch.
     */
    where: ProcesoWhereUniqueInput
  }

  /**
   * Proceso findFirst
   */
  export type ProcesoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * Filter, which Proceso to fetch.
     */
    where?: ProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procesos to fetch.
     */
    orderBy?: ProcesoOrderByWithRelationInput | ProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procesos.
     */
    cursor?: ProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procesos.
     */
    distinct?: ProcesoScalarFieldEnum | ProcesoScalarFieldEnum[]
  }

  /**
   * Proceso findFirstOrThrow
   */
  export type ProcesoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * Filter, which Proceso to fetch.
     */
    where?: ProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procesos to fetch.
     */
    orderBy?: ProcesoOrderByWithRelationInput | ProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procesos.
     */
    cursor?: ProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procesos.
     */
    distinct?: ProcesoScalarFieldEnum | ProcesoScalarFieldEnum[]
  }

  /**
   * Proceso findMany
   */
  export type ProcesoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * Filter, which Procesos to fetch.
     */
    where?: ProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procesos to fetch.
     */
    orderBy?: ProcesoOrderByWithRelationInput | ProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Procesos.
     */
    cursor?: ProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procesos.
     */
    skip?: number
    distinct?: ProcesoScalarFieldEnum | ProcesoScalarFieldEnum[]
  }

  /**
   * Proceso create
   */
  export type ProcesoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * The data needed to create a Proceso.
     */
    data: XOR<ProcesoCreateInput, ProcesoUncheckedCreateInput>
  }

  /**
   * Proceso createMany
   */
  export type ProcesoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Procesos.
     */
    data: ProcesoCreateManyInput | ProcesoCreateManyInput[]
  }

  /**
   * Proceso createManyAndReturn
   */
  export type ProcesoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Procesos.
     */
    data: ProcesoCreateManyInput | ProcesoCreateManyInput[]
  }

  /**
   * Proceso update
   */
  export type ProcesoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * The data needed to update a Proceso.
     */
    data: XOR<ProcesoUpdateInput, ProcesoUncheckedUpdateInput>
    /**
     * Choose, which Proceso to update.
     */
    where: ProcesoWhereUniqueInput
  }

  /**
   * Proceso updateMany
   */
  export type ProcesoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Procesos.
     */
    data: XOR<ProcesoUpdateManyMutationInput, ProcesoUncheckedUpdateManyInput>
    /**
     * Filter which Procesos to update
     */
    where?: ProcesoWhereInput
  }

  /**
   * Proceso upsert
   */
  export type ProcesoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * The filter to search for the Proceso to update in case it exists.
     */
    where: ProcesoWhereUniqueInput
    /**
     * In case the Proceso found by the `where` argument doesn't exist, create a new Proceso with this data.
     */
    create: XOR<ProcesoCreateInput, ProcesoUncheckedCreateInput>
    /**
     * In case the Proceso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcesoUpdateInput, ProcesoUncheckedUpdateInput>
  }

  /**
   * Proceso delete
   */
  export type ProcesoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * Filter which Proceso to delete.
     */
    where: ProcesoWhereUniqueInput
  }

  /**
   * Proceso deleteMany
   */
  export type ProcesoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procesos to delete
     */
    where?: ProcesoWhereInput
  }

  /**
   * Proceso.nodos
   */
  export type Proceso$nodosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessNode
     */
    select?: ProcessNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessNodeInclude<ExtArgs> | null
    where?: ProcessNodeWhereInput
    orderBy?: ProcessNodeOrderByWithRelationInput | ProcessNodeOrderByWithRelationInput[]
    cursor?: ProcessNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessNodeScalarFieldEnum | ProcessNodeScalarFieldEnum[]
  }

  /**
   * Proceso.edges
   */
  export type Proceso$edgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessEdge
     */
    select?: ProcessEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessEdgeInclude<ExtArgs> | null
    where?: ProcessEdgeWhereInput
    orderBy?: ProcessEdgeOrderByWithRelationInput | ProcessEdgeOrderByWithRelationInput[]
    cursor?: ProcessEdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessEdgeScalarFieldEnum | ProcessEdgeScalarFieldEnum[]
  }

  /**
   * Proceso.objetivos
   */
  export type Proceso$objetivosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjetivoProceso
     */
    select?: ObjetivoProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjetivoProcesoInclude<ExtArgs> | null
    where?: ObjetivoProcesoWhereInput
    orderBy?: ObjetivoProcesoOrderByWithRelationInput | ObjetivoProcesoOrderByWithRelationInput[]
    cursor?: ObjetivoProcesoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjetivoProcesoScalarFieldEnum | ObjetivoProcesoScalarFieldEnum[]
  }

  /**
   * Proceso.kpis
   */
  export type Proceso$kpisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiProceso
     */
    select?: KpiProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiProcesoInclude<ExtArgs> | null
    where?: KpiProcesoWhereInput
    orderBy?: KpiProcesoOrderByWithRelationInput | KpiProcesoOrderByWithRelationInput[]
    cursor?: KpiProcesoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiProcesoScalarFieldEnum | KpiProcesoScalarFieldEnum[]
  }

  /**
   * Proceso without action
   */
  export type ProcesoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
  }


  /**
   * Model ProcessNode
   */

  export type AggregateProcessNode = {
    _count: ProcessNodeCountAggregateOutputType | null
    _avg: ProcessNodeAvgAggregateOutputType | null
    _sum: ProcessNodeSumAggregateOutputType | null
    _min: ProcessNodeMinAggregateOutputType | null
    _max: ProcessNodeMaxAggregateOutputType | null
  }

  export type ProcessNodeAvgAggregateOutputType = {
    positionX: number | null
    positionY: number | null
  }

  export type ProcessNodeSumAggregateOutputType = {
    positionX: number | null
    positionY: number | null
  }

  export type ProcessNodeMinAggregateOutputType = {
    id: string | null
    procesoId: string | null
    type: string | null
    label: string | null
    descripcion: string | null
    config: string | null
    positionX: number | null
    positionY: number | null
  }

  export type ProcessNodeMaxAggregateOutputType = {
    id: string | null
    procesoId: string | null
    type: string | null
    label: string | null
    descripcion: string | null
    config: string | null
    positionX: number | null
    positionY: number | null
  }

  export type ProcessNodeCountAggregateOutputType = {
    id: number
    procesoId: number
    type: number
    label: number
    descripcion: number
    config: number
    positionX: number
    positionY: number
    _all: number
  }


  export type ProcessNodeAvgAggregateInputType = {
    positionX?: true
    positionY?: true
  }

  export type ProcessNodeSumAggregateInputType = {
    positionX?: true
    positionY?: true
  }

  export type ProcessNodeMinAggregateInputType = {
    id?: true
    procesoId?: true
    type?: true
    label?: true
    descripcion?: true
    config?: true
    positionX?: true
    positionY?: true
  }

  export type ProcessNodeMaxAggregateInputType = {
    id?: true
    procesoId?: true
    type?: true
    label?: true
    descripcion?: true
    config?: true
    positionX?: true
    positionY?: true
  }

  export type ProcessNodeCountAggregateInputType = {
    id?: true
    procesoId?: true
    type?: true
    label?: true
    descripcion?: true
    config?: true
    positionX?: true
    positionY?: true
    _all?: true
  }

  export type ProcessNodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessNode to aggregate.
     */
    where?: ProcessNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessNodes to fetch.
     */
    orderBy?: ProcessNodeOrderByWithRelationInput | ProcessNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessNodes
    **/
    _count?: true | ProcessNodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessNodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessNodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessNodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessNodeMaxAggregateInputType
  }

  export type GetProcessNodeAggregateType<T extends ProcessNodeAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessNode[P]>
      : GetScalarType<T[P], AggregateProcessNode[P]>
  }




  export type ProcessNodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessNodeWhereInput
    orderBy?: ProcessNodeOrderByWithAggregationInput | ProcessNodeOrderByWithAggregationInput[]
    by: ProcessNodeScalarFieldEnum[] | ProcessNodeScalarFieldEnum
    having?: ProcessNodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessNodeCountAggregateInputType | true
    _avg?: ProcessNodeAvgAggregateInputType
    _sum?: ProcessNodeSumAggregateInputType
    _min?: ProcessNodeMinAggregateInputType
    _max?: ProcessNodeMaxAggregateInputType
  }

  export type ProcessNodeGroupByOutputType = {
    id: string
    procesoId: string
    type: string
    label: string
    descripcion: string | null
    config: string
    positionX: number
    positionY: number
    _count: ProcessNodeCountAggregateOutputType | null
    _avg: ProcessNodeAvgAggregateOutputType | null
    _sum: ProcessNodeSumAggregateOutputType | null
    _min: ProcessNodeMinAggregateOutputType | null
    _max: ProcessNodeMaxAggregateOutputType | null
  }

  type GetProcessNodeGroupByPayload<T extends ProcessNodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessNodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessNodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessNodeGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessNodeGroupByOutputType[P]>
        }
      >
    >


  export type ProcessNodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procesoId?: boolean
    type?: boolean
    label?: boolean
    descripcion?: boolean
    config?: boolean
    positionX?: boolean
    positionY?: boolean
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    edgesFrom?: boolean | ProcessNode$edgesFromArgs<ExtArgs>
    edgesTo?: boolean | ProcessNode$edgesToArgs<ExtArgs>
    kpiHistorico?: boolean | ProcessNode$kpiHistoricoArgs<ExtArgs>
    _count?: boolean | ProcessNodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processNode"]>

  export type ProcessNodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procesoId?: boolean
    type?: boolean
    label?: boolean
    descripcion?: boolean
    config?: boolean
    positionX?: boolean
    positionY?: boolean
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processNode"]>

  export type ProcessNodeSelectScalar = {
    id?: boolean
    procesoId?: boolean
    type?: boolean
    label?: boolean
    descripcion?: boolean
    config?: boolean
    positionX?: boolean
    positionY?: boolean
  }

  export type ProcessNodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    edgesFrom?: boolean | ProcessNode$edgesFromArgs<ExtArgs>
    edgesTo?: boolean | ProcessNode$edgesToArgs<ExtArgs>
    kpiHistorico?: boolean | ProcessNode$kpiHistoricoArgs<ExtArgs>
    _count?: boolean | ProcessNodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProcessNodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
  }

  export type $ProcessNodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessNode"
    objects: {
      proceso: Prisma.$ProcesoPayload<ExtArgs>
      edgesFrom: Prisma.$ProcessEdgePayload<ExtArgs>[]
      edgesTo: Prisma.$ProcessEdgePayload<ExtArgs>[]
      kpiHistorico: Prisma.$KpiHistoricoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      procesoId: string
      type: string
      label: string
      descripcion: string | null
      config: string
      positionX: number
      positionY: number
    }, ExtArgs["result"]["processNode"]>
    composites: {}
  }

  type ProcessNodeGetPayload<S extends boolean | null | undefined | ProcessNodeDefaultArgs> = $Result.GetResult<Prisma.$ProcessNodePayload, S>

  type ProcessNodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcessNodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcessNodeCountAggregateInputType | true
    }

  export interface ProcessNodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessNode'], meta: { name: 'ProcessNode' } }
    /**
     * Find zero or one ProcessNode that matches the filter.
     * @param {ProcessNodeFindUniqueArgs} args - Arguments to find a ProcessNode
     * @example
     * // Get one ProcessNode
     * const processNode = await prisma.processNode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessNodeFindUniqueArgs>(args: SelectSubset<T, ProcessNodeFindUniqueArgs<ExtArgs>>): Prisma__ProcessNodeClient<$Result.GetResult<Prisma.$ProcessNodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProcessNode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcessNodeFindUniqueOrThrowArgs} args - Arguments to find a ProcessNode
     * @example
     * // Get one ProcessNode
     * const processNode = await prisma.processNode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessNodeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessNodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessNodeClient<$Result.GetResult<Prisma.$ProcessNodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProcessNode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessNodeFindFirstArgs} args - Arguments to find a ProcessNode
     * @example
     * // Get one ProcessNode
     * const processNode = await prisma.processNode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessNodeFindFirstArgs>(args?: SelectSubset<T, ProcessNodeFindFirstArgs<ExtArgs>>): Prisma__ProcessNodeClient<$Result.GetResult<Prisma.$ProcessNodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProcessNode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessNodeFindFirstOrThrowArgs} args - Arguments to find a ProcessNode
     * @example
     * // Get one ProcessNode
     * const processNode = await prisma.processNode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessNodeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessNodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessNodeClient<$Result.GetResult<Prisma.$ProcessNodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProcessNodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessNodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessNodes
     * const processNodes = await prisma.processNode.findMany()
     * 
     * // Get first 10 ProcessNodes
     * const processNodes = await prisma.processNode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processNodeWithIdOnly = await prisma.processNode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessNodeFindManyArgs>(args?: SelectSubset<T, ProcessNodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessNodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProcessNode.
     * @param {ProcessNodeCreateArgs} args - Arguments to create a ProcessNode.
     * @example
     * // Create one ProcessNode
     * const ProcessNode = await prisma.processNode.create({
     *   data: {
     *     // ... data to create a ProcessNode
     *   }
     * })
     * 
     */
    create<T extends ProcessNodeCreateArgs>(args: SelectSubset<T, ProcessNodeCreateArgs<ExtArgs>>): Prisma__ProcessNodeClient<$Result.GetResult<Prisma.$ProcessNodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProcessNodes.
     * @param {ProcessNodeCreateManyArgs} args - Arguments to create many ProcessNodes.
     * @example
     * // Create many ProcessNodes
     * const processNode = await prisma.processNode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessNodeCreateManyArgs>(args?: SelectSubset<T, ProcessNodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcessNodes and returns the data saved in the database.
     * @param {ProcessNodeCreateManyAndReturnArgs} args - Arguments to create many ProcessNodes.
     * @example
     * // Create many ProcessNodes
     * const processNode = await prisma.processNode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcessNodes and only return the `id`
     * const processNodeWithIdOnly = await prisma.processNode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessNodeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessNodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessNodePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProcessNode.
     * @param {ProcessNodeDeleteArgs} args - Arguments to delete one ProcessNode.
     * @example
     * // Delete one ProcessNode
     * const ProcessNode = await prisma.processNode.delete({
     *   where: {
     *     // ... filter to delete one ProcessNode
     *   }
     * })
     * 
     */
    delete<T extends ProcessNodeDeleteArgs>(args: SelectSubset<T, ProcessNodeDeleteArgs<ExtArgs>>): Prisma__ProcessNodeClient<$Result.GetResult<Prisma.$ProcessNodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProcessNode.
     * @param {ProcessNodeUpdateArgs} args - Arguments to update one ProcessNode.
     * @example
     * // Update one ProcessNode
     * const processNode = await prisma.processNode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessNodeUpdateArgs>(args: SelectSubset<T, ProcessNodeUpdateArgs<ExtArgs>>): Prisma__ProcessNodeClient<$Result.GetResult<Prisma.$ProcessNodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProcessNodes.
     * @param {ProcessNodeDeleteManyArgs} args - Arguments to filter ProcessNodes to delete.
     * @example
     * // Delete a few ProcessNodes
     * const { count } = await prisma.processNode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessNodeDeleteManyArgs>(args?: SelectSubset<T, ProcessNodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessNodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessNodes
     * const processNode = await prisma.processNode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessNodeUpdateManyArgs>(args: SelectSubset<T, ProcessNodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProcessNode.
     * @param {ProcessNodeUpsertArgs} args - Arguments to update or create a ProcessNode.
     * @example
     * // Update or create a ProcessNode
     * const processNode = await prisma.processNode.upsert({
     *   create: {
     *     // ... data to create a ProcessNode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessNode we want to update
     *   }
     * })
     */
    upsert<T extends ProcessNodeUpsertArgs>(args: SelectSubset<T, ProcessNodeUpsertArgs<ExtArgs>>): Prisma__ProcessNodeClient<$Result.GetResult<Prisma.$ProcessNodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProcessNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessNodeCountArgs} args - Arguments to filter ProcessNodes to count.
     * @example
     * // Count the number of ProcessNodes
     * const count = await prisma.processNode.count({
     *   where: {
     *     // ... the filter for the ProcessNodes we want to count
     *   }
     * })
    **/
    count<T extends ProcessNodeCountArgs>(
      args?: Subset<T, ProcessNodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessNodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessNodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessNodeAggregateArgs>(args: Subset<T, ProcessNodeAggregateArgs>): Prisma.PrismaPromise<GetProcessNodeAggregateType<T>>

    /**
     * Group by ProcessNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessNodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessNodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessNodeGroupByArgs['orderBy'] }
        : { orderBy?: ProcessNodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessNodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessNode model
   */
  readonly fields: ProcessNodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessNode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessNodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proceso<T extends ProcesoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcesoDefaultArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    edgesFrom<T extends ProcessNode$edgesFromArgs<ExtArgs> = {}>(args?: Subset<T, ProcessNode$edgesFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessEdgePayload<ExtArgs>, T, "findMany"> | Null>
    edgesTo<T extends ProcessNode$edgesToArgs<ExtArgs> = {}>(args?: Subset<T, ProcessNode$edgesToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessEdgePayload<ExtArgs>, T, "findMany"> | Null>
    kpiHistorico<T extends ProcessNode$kpiHistoricoArgs<ExtArgs> = {}>(args?: Subset<T, ProcessNode$kpiHistoricoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiHistoricoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessNode model
   */ 
  interface ProcessNodeFieldRefs {
    readonly id: FieldRef<"ProcessNode", 'String'>
    readonly procesoId: FieldRef<"ProcessNode", 'String'>
    readonly type: FieldRef<"ProcessNode", 'String'>
    readonly label: FieldRef<"ProcessNode", 'String'>
    readonly descripcion: FieldRef<"ProcessNode", 'String'>
    readonly config: FieldRef<"ProcessNode", 'String'>
    readonly positionX: FieldRef<"ProcessNode", 'Float'>
    readonly positionY: FieldRef<"ProcessNode", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ProcessNode findUnique
   */
  export type ProcessNodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessNode
     */
    select?: ProcessNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProcessNode to fetch.
     */
    where: ProcessNodeWhereUniqueInput
  }

  /**
   * ProcessNode findUniqueOrThrow
   */
  export type ProcessNodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessNode
     */
    select?: ProcessNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProcessNode to fetch.
     */
    where: ProcessNodeWhereUniqueInput
  }

  /**
   * ProcessNode findFirst
   */
  export type ProcessNodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessNode
     */
    select?: ProcessNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProcessNode to fetch.
     */
    where?: ProcessNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessNodes to fetch.
     */
    orderBy?: ProcessNodeOrderByWithRelationInput | ProcessNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessNodes.
     */
    cursor?: ProcessNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessNodes.
     */
    distinct?: ProcessNodeScalarFieldEnum | ProcessNodeScalarFieldEnum[]
  }

  /**
   * ProcessNode findFirstOrThrow
   */
  export type ProcessNodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessNode
     */
    select?: ProcessNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProcessNode to fetch.
     */
    where?: ProcessNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessNodes to fetch.
     */
    orderBy?: ProcessNodeOrderByWithRelationInput | ProcessNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessNodes.
     */
    cursor?: ProcessNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessNodes.
     */
    distinct?: ProcessNodeScalarFieldEnum | ProcessNodeScalarFieldEnum[]
  }

  /**
   * ProcessNode findMany
   */
  export type ProcessNodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessNode
     */
    select?: ProcessNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProcessNodes to fetch.
     */
    where?: ProcessNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessNodes to fetch.
     */
    orderBy?: ProcessNodeOrderByWithRelationInput | ProcessNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessNodes.
     */
    cursor?: ProcessNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessNodes.
     */
    skip?: number
    distinct?: ProcessNodeScalarFieldEnum | ProcessNodeScalarFieldEnum[]
  }

  /**
   * ProcessNode create
   */
  export type ProcessNodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessNode
     */
    select?: ProcessNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessNodeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessNode.
     */
    data: XOR<ProcessNodeCreateInput, ProcessNodeUncheckedCreateInput>
  }

  /**
   * ProcessNode createMany
   */
  export type ProcessNodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessNodes.
     */
    data: ProcessNodeCreateManyInput | ProcessNodeCreateManyInput[]
  }

  /**
   * ProcessNode createManyAndReturn
   */
  export type ProcessNodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessNode
     */
    select?: ProcessNodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProcessNodes.
     */
    data: ProcessNodeCreateManyInput | ProcessNodeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessNodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessNode update
   */
  export type ProcessNodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessNode
     */
    select?: ProcessNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessNodeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessNode.
     */
    data: XOR<ProcessNodeUpdateInput, ProcessNodeUncheckedUpdateInput>
    /**
     * Choose, which ProcessNode to update.
     */
    where: ProcessNodeWhereUniqueInput
  }

  /**
   * ProcessNode updateMany
   */
  export type ProcessNodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessNodes.
     */
    data: XOR<ProcessNodeUpdateManyMutationInput, ProcessNodeUncheckedUpdateManyInput>
    /**
     * Filter which ProcessNodes to update
     */
    where?: ProcessNodeWhereInput
  }

  /**
   * ProcessNode upsert
   */
  export type ProcessNodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessNode
     */
    select?: ProcessNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessNodeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessNode to update in case it exists.
     */
    where: ProcessNodeWhereUniqueInput
    /**
     * In case the ProcessNode found by the `where` argument doesn't exist, create a new ProcessNode with this data.
     */
    create: XOR<ProcessNodeCreateInput, ProcessNodeUncheckedCreateInput>
    /**
     * In case the ProcessNode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessNodeUpdateInput, ProcessNodeUncheckedUpdateInput>
  }

  /**
   * ProcessNode delete
   */
  export type ProcessNodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessNode
     */
    select?: ProcessNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessNodeInclude<ExtArgs> | null
    /**
     * Filter which ProcessNode to delete.
     */
    where: ProcessNodeWhereUniqueInput
  }

  /**
   * ProcessNode deleteMany
   */
  export type ProcessNodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessNodes to delete
     */
    where?: ProcessNodeWhereInput
  }

  /**
   * ProcessNode.edgesFrom
   */
  export type ProcessNode$edgesFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessEdge
     */
    select?: ProcessEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessEdgeInclude<ExtArgs> | null
    where?: ProcessEdgeWhereInput
    orderBy?: ProcessEdgeOrderByWithRelationInput | ProcessEdgeOrderByWithRelationInput[]
    cursor?: ProcessEdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessEdgeScalarFieldEnum | ProcessEdgeScalarFieldEnum[]
  }

  /**
   * ProcessNode.edgesTo
   */
  export type ProcessNode$edgesToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessEdge
     */
    select?: ProcessEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessEdgeInclude<ExtArgs> | null
    where?: ProcessEdgeWhereInput
    orderBy?: ProcessEdgeOrderByWithRelationInput | ProcessEdgeOrderByWithRelationInput[]
    cursor?: ProcessEdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessEdgeScalarFieldEnum | ProcessEdgeScalarFieldEnum[]
  }

  /**
   * ProcessNode.kpiHistorico
   */
  export type ProcessNode$kpiHistoricoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiHistorico
     */
    select?: KpiHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiHistoricoInclude<ExtArgs> | null
    where?: KpiHistoricoWhereInput
    orderBy?: KpiHistoricoOrderByWithRelationInput | KpiHistoricoOrderByWithRelationInput[]
    cursor?: KpiHistoricoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiHistoricoScalarFieldEnum | KpiHistoricoScalarFieldEnum[]
  }

  /**
   * ProcessNode without action
   */
  export type ProcessNodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessNode
     */
    select?: ProcessNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessNodeInclude<ExtArgs> | null
  }


  /**
   * Model ProcessEdge
   */

  export type AggregateProcessEdge = {
    _count: ProcessEdgeCountAggregateOutputType | null
    _min: ProcessEdgeMinAggregateOutputType | null
    _max: ProcessEdgeMaxAggregateOutputType | null
  }

  export type ProcessEdgeMinAggregateOutputType = {
    id: string | null
    procesoId: string | null
    sourceNodeId: string | null
    targetNodeId: string | null
    sourceHandle: string | null
    targetHandle: string | null
    label: string | null
  }

  export type ProcessEdgeMaxAggregateOutputType = {
    id: string | null
    procesoId: string | null
    sourceNodeId: string | null
    targetNodeId: string | null
    sourceHandle: string | null
    targetHandle: string | null
    label: string | null
  }

  export type ProcessEdgeCountAggregateOutputType = {
    id: number
    procesoId: number
    sourceNodeId: number
    targetNodeId: number
    sourceHandle: number
    targetHandle: number
    label: number
    _all: number
  }


  export type ProcessEdgeMinAggregateInputType = {
    id?: true
    procesoId?: true
    sourceNodeId?: true
    targetNodeId?: true
    sourceHandle?: true
    targetHandle?: true
    label?: true
  }

  export type ProcessEdgeMaxAggregateInputType = {
    id?: true
    procesoId?: true
    sourceNodeId?: true
    targetNodeId?: true
    sourceHandle?: true
    targetHandle?: true
    label?: true
  }

  export type ProcessEdgeCountAggregateInputType = {
    id?: true
    procesoId?: true
    sourceNodeId?: true
    targetNodeId?: true
    sourceHandle?: true
    targetHandle?: true
    label?: true
    _all?: true
  }

  export type ProcessEdgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessEdge to aggregate.
     */
    where?: ProcessEdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessEdges to fetch.
     */
    orderBy?: ProcessEdgeOrderByWithRelationInput | ProcessEdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessEdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessEdges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessEdges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessEdges
    **/
    _count?: true | ProcessEdgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessEdgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessEdgeMaxAggregateInputType
  }

  export type GetProcessEdgeAggregateType<T extends ProcessEdgeAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessEdge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessEdge[P]>
      : GetScalarType<T[P], AggregateProcessEdge[P]>
  }




  export type ProcessEdgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessEdgeWhereInput
    orderBy?: ProcessEdgeOrderByWithAggregationInput | ProcessEdgeOrderByWithAggregationInput[]
    by: ProcessEdgeScalarFieldEnum[] | ProcessEdgeScalarFieldEnum
    having?: ProcessEdgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessEdgeCountAggregateInputType | true
    _min?: ProcessEdgeMinAggregateInputType
    _max?: ProcessEdgeMaxAggregateInputType
  }

  export type ProcessEdgeGroupByOutputType = {
    id: string
    procesoId: string
    sourceNodeId: string
    targetNodeId: string
    sourceHandle: string | null
    targetHandle: string | null
    label: string | null
    _count: ProcessEdgeCountAggregateOutputType | null
    _min: ProcessEdgeMinAggregateOutputType | null
    _max: ProcessEdgeMaxAggregateOutputType | null
  }

  type GetProcessEdgeGroupByPayload<T extends ProcessEdgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessEdgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessEdgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessEdgeGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessEdgeGroupByOutputType[P]>
        }
      >
    >


  export type ProcessEdgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procesoId?: boolean
    sourceNodeId?: boolean
    targetNodeId?: boolean
    sourceHandle?: boolean
    targetHandle?: boolean
    label?: boolean
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    sourceNode?: boolean | ProcessNodeDefaultArgs<ExtArgs>
    targetNode?: boolean | ProcessNodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processEdge"]>

  export type ProcessEdgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procesoId?: boolean
    sourceNodeId?: boolean
    targetNodeId?: boolean
    sourceHandle?: boolean
    targetHandle?: boolean
    label?: boolean
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    sourceNode?: boolean | ProcessNodeDefaultArgs<ExtArgs>
    targetNode?: boolean | ProcessNodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processEdge"]>

  export type ProcessEdgeSelectScalar = {
    id?: boolean
    procesoId?: boolean
    sourceNodeId?: boolean
    targetNodeId?: boolean
    sourceHandle?: boolean
    targetHandle?: boolean
    label?: boolean
  }

  export type ProcessEdgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    sourceNode?: boolean | ProcessNodeDefaultArgs<ExtArgs>
    targetNode?: boolean | ProcessNodeDefaultArgs<ExtArgs>
  }
  export type ProcessEdgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    sourceNode?: boolean | ProcessNodeDefaultArgs<ExtArgs>
    targetNode?: boolean | ProcessNodeDefaultArgs<ExtArgs>
  }

  export type $ProcessEdgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessEdge"
    objects: {
      proceso: Prisma.$ProcesoPayload<ExtArgs>
      sourceNode: Prisma.$ProcessNodePayload<ExtArgs>
      targetNode: Prisma.$ProcessNodePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      procesoId: string
      sourceNodeId: string
      targetNodeId: string
      sourceHandle: string | null
      targetHandle: string | null
      label: string | null
    }, ExtArgs["result"]["processEdge"]>
    composites: {}
  }

  type ProcessEdgeGetPayload<S extends boolean | null | undefined | ProcessEdgeDefaultArgs> = $Result.GetResult<Prisma.$ProcessEdgePayload, S>

  type ProcessEdgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcessEdgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcessEdgeCountAggregateInputType | true
    }

  export interface ProcessEdgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessEdge'], meta: { name: 'ProcessEdge' } }
    /**
     * Find zero or one ProcessEdge that matches the filter.
     * @param {ProcessEdgeFindUniqueArgs} args - Arguments to find a ProcessEdge
     * @example
     * // Get one ProcessEdge
     * const processEdge = await prisma.processEdge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessEdgeFindUniqueArgs>(args: SelectSubset<T, ProcessEdgeFindUniqueArgs<ExtArgs>>): Prisma__ProcessEdgeClient<$Result.GetResult<Prisma.$ProcessEdgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProcessEdge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcessEdgeFindUniqueOrThrowArgs} args - Arguments to find a ProcessEdge
     * @example
     * // Get one ProcessEdge
     * const processEdge = await prisma.processEdge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessEdgeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessEdgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessEdgeClient<$Result.GetResult<Prisma.$ProcessEdgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProcessEdge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessEdgeFindFirstArgs} args - Arguments to find a ProcessEdge
     * @example
     * // Get one ProcessEdge
     * const processEdge = await prisma.processEdge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessEdgeFindFirstArgs>(args?: SelectSubset<T, ProcessEdgeFindFirstArgs<ExtArgs>>): Prisma__ProcessEdgeClient<$Result.GetResult<Prisma.$ProcessEdgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProcessEdge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessEdgeFindFirstOrThrowArgs} args - Arguments to find a ProcessEdge
     * @example
     * // Get one ProcessEdge
     * const processEdge = await prisma.processEdge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessEdgeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessEdgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessEdgeClient<$Result.GetResult<Prisma.$ProcessEdgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProcessEdges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessEdgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessEdges
     * const processEdges = await prisma.processEdge.findMany()
     * 
     * // Get first 10 ProcessEdges
     * const processEdges = await prisma.processEdge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processEdgeWithIdOnly = await prisma.processEdge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessEdgeFindManyArgs>(args?: SelectSubset<T, ProcessEdgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessEdgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProcessEdge.
     * @param {ProcessEdgeCreateArgs} args - Arguments to create a ProcessEdge.
     * @example
     * // Create one ProcessEdge
     * const ProcessEdge = await prisma.processEdge.create({
     *   data: {
     *     // ... data to create a ProcessEdge
     *   }
     * })
     * 
     */
    create<T extends ProcessEdgeCreateArgs>(args: SelectSubset<T, ProcessEdgeCreateArgs<ExtArgs>>): Prisma__ProcessEdgeClient<$Result.GetResult<Prisma.$ProcessEdgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProcessEdges.
     * @param {ProcessEdgeCreateManyArgs} args - Arguments to create many ProcessEdges.
     * @example
     * // Create many ProcessEdges
     * const processEdge = await prisma.processEdge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessEdgeCreateManyArgs>(args?: SelectSubset<T, ProcessEdgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcessEdges and returns the data saved in the database.
     * @param {ProcessEdgeCreateManyAndReturnArgs} args - Arguments to create many ProcessEdges.
     * @example
     * // Create many ProcessEdges
     * const processEdge = await prisma.processEdge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcessEdges and only return the `id`
     * const processEdgeWithIdOnly = await prisma.processEdge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessEdgeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessEdgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessEdgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProcessEdge.
     * @param {ProcessEdgeDeleteArgs} args - Arguments to delete one ProcessEdge.
     * @example
     * // Delete one ProcessEdge
     * const ProcessEdge = await prisma.processEdge.delete({
     *   where: {
     *     // ... filter to delete one ProcessEdge
     *   }
     * })
     * 
     */
    delete<T extends ProcessEdgeDeleteArgs>(args: SelectSubset<T, ProcessEdgeDeleteArgs<ExtArgs>>): Prisma__ProcessEdgeClient<$Result.GetResult<Prisma.$ProcessEdgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProcessEdge.
     * @param {ProcessEdgeUpdateArgs} args - Arguments to update one ProcessEdge.
     * @example
     * // Update one ProcessEdge
     * const processEdge = await prisma.processEdge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessEdgeUpdateArgs>(args: SelectSubset<T, ProcessEdgeUpdateArgs<ExtArgs>>): Prisma__ProcessEdgeClient<$Result.GetResult<Prisma.$ProcessEdgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProcessEdges.
     * @param {ProcessEdgeDeleteManyArgs} args - Arguments to filter ProcessEdges to delete.
     * @example
     * // Delete a few ProcessEdges
     * const { count } = await prisma.processEdge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessEdgeDeleteManyArgs>(args?: SelectSubset<T, ProcessEdgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessEdges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessEdgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessEdges
     * const processEdge = await prisma.processEdge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessEdgeUpdateManyArgs>(args: SelectSubset<T, ProcessEdgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProcessEdge.
     * @param {ProcessEdgeUpsertArgs} args - Arguments to update or create a ProcessEdge.
     * @example
     * // Update or create a ProcessEdge
     * const processEdge = await prisma.processEdge.upsert({
     *   create: {
     *     // ... data to create a ProcessEdge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessEdge we want to update
     *   }
     * })
     */
    upsert<T extends ProcessEdgeUpsertArgs>(args: SelectSubset<T, ProcessEdgeUpsertArgs<ExtArgs>>): Prisma__ProcessEdgeClient<$Result.GetResult<Prisma.$ProcessEdgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProcessEdges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessEdgeCountArgs} args - Arguments to filter ProcessEdges to count.
     * @example
     * // Count the number of ProcessEdges
     * const count = await prisma.processEdge.count({
     *   where: {
     *     // ... the filter for the ProcessEdges we want to count
     *   }
     * })
    **/
    count<T extends ProcessEdgeCountArgs>(
      args?: Subset<T, ProcessEdgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessEdgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessEdge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessEdgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessEdgeAggregateArgs>(args: Subset<T, ProcessEdgeAggregateArgs>): Prisma.PrismaPromise<GetProcessEdgeAggregateType<T>>

    /**
     * Group by ProcessEdge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessEdgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessEdgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessEdgeGroupByArgs['orderBy'] }
        : { orderBy?: ProcessEdgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessEdgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessEdgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessEdge model
   */
  readonly fields: ProcessEdgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessEdge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessEdgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proceso<T extends ProcesoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcesoDefaultArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sourceNode<T extends ProcessNodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessNodeDefaultArgs<ExtArgs>>): Prisma__ProcessNodeClient<$Result.GetResult<Prisma.$ProcessNodePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    targetNode<T extends ProcessNodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessNodeDefaultArgs<ExtArgs>>): Prisma__ProcessNodeClient<$Result.GetResult<Prisma.$ProcessNodePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessEdge model
   */ 
  interface ProcessEdgeFieldRefs {
    readonly id: FieldRef<"ProcessEdge", 'String'>
    readonly procesoId: FieldRef<"ProcessEdge", 'String'>
    readonly sourceNodeId: FieldRef<"ProcessEdge", 'String'>
    readonly targetNodeId: FieldRef<"ProcessEdge", 'String'>
    readonly sourceHandle: FieldRef<"ProcessEdge", 'String'>
    readonly targetHandle: FieldRef<"ProcessEdge", 'String'>
    readonly label: FieldRef<"ProcessEdge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProcessEdge findUnique
   */
  export type ProcessEdgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessEdge
     */
    select?: ProcessEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessEdgeInclude<ExtArgs> | null
    /**
     * Filter, which ProcessEdge to fetch.
     */
    where: ProcessEdgeWhereUniqueInput
  }

  /**
   * ProcessEdge findUniqueOrThrow
   */
  export type ProcessEdgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessEdge
     */
    select?: ProcessEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessEdgeInclude<ExtArgs> | null
    /**
     * Filter, which ProcessEdge to fetch.
     */
    where: ProcessEdgeWhereUniqueInput
  }

  /**
   * ProcessEdge findFirst
   */
  export type ProcessEdgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessEdge
     */
    select?: ProcessEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessEdgeInclude<ExtArgs> | null
    /**
     * Filter, which ProcessEdge to fetch.
     */
    where?: ProcessEdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessEdges to fetch.
     */
    orderBy?: ProcessEdgeOrderByWithRelationInput | ProcessEdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessEdges.
     */
    cursor?: ProcessEdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessEdges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessEdges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessEdges.
     */
    distinct?: ProcessEdgeScalarFieldEnum | ProcessEdgeScalarFieldEnum[]
  }

  /**
   * ProcessEdge findFirstOrThrow
   */
  export type ProcessEdgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessEdge
     */
    select?: ProcessEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessEdgeInclude<ExtArgs> | null
    /**
     * Filter, which ProcessEdge to fetch.
     */
    where?: ProcessEdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessEdges to fetch.
     */
    orderBy?: ProcessEdgeOrderByWithRelationInput | ProcessEdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessEdges.
     */
    cursor?: ProcessEdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessEdges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessEdges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessEdges.
     */
    distinct?: ProcessEdgeScalarFieldEnum | ProcessEdgeScalarFieldEnum[]
  }

  /**
   * ProcessEdge findMany
   */
  export type ProcessEdgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessEdge
     */
    select?: ProcessEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessEdgeInclude<ExtArgs> | null
    /**
     * Filter, which ProcessEdges to fetch.
     */
    where?: ProcessEdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessEdges to fetch.
     */
    orderBy?: ProcessEdgeOrderByWithRelationInput | ProcessEdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessEdges.
     */
    cursor?: ProcessEdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessEdges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessEdges.
     */
    skip?: number
    distinct?: ProcessEdgeScalarFieldEnum | ProcessEdgeScalarFieldEnum[]
  }

  /**
   * ProcessEdge create
   */
  export type ProcessEdgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessEdge
     */
    select?: ProcessEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessEdgeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessEdge.
     */
    data: XOR<ProcessEdgeCreateInput, ProcessEdgeUncheckedCreateInput>
  }

  /**
   * ProcessEdge createMany
   */
  export type ProcessEdgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessEdges.
     */
    data: ProcessEdgeCreateManyInput | ProcessEdgeCreateManyInput[]
  }

  /**
   * ProcessEdge createManyAndReturn
   */
  export type ProcessEdgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessEdge
     */
    select?: ProcessEdgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProcessEdges.
     */
    data: ProcessEdgeCreateManyInput | ProcessEdgeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessEdgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessEdge update
   */
  export type ProcessEdgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessEdge
     */
    select?: ProcessEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessEdgeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessEdge.
     */
    data: XOR<ProcessEdgeUpdateInput, ProcessEdgeUncheckedUpdateInput>
    /**
     * Choose, which ProcessEdge to update.
     */
    where: ProcessEdgeWhereUniqueInput
  }

  /**
   * ProcessEdge updateMany
   */
  export type ProcessEdgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessEdges.
     */
    data: XOR<ProcessEdgeUpdateManyMutationInput, ProcessEdgeUncheckedUpdateManyInput>
    /**
     * Filter which ProcessEdges to update
     */
    where?: ProcessEdgeWhereInput
  }

  /**
   * ProcessEdge upsert
   */
  export type ProcessEdgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessEdge
     */
    select?: ProcessEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessEdgeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessEdge to update in case it exists.
     */
    where: ProcessEdgeWhereUniqueInput
    /**
     * In case the ProcessEdge found by the `where` argument doesn't exist, create a new ProcessEdge with this data.
     */
    create: XOR<ProcessEdgeCreateInput, ProcessEdgeUncheckedCreateInput>
    /**
     * In case the ProcessEdge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessEdgeUpdateInput, ProcessEdgeUncheckedUpdateInput>
  }

  /**
   * ProcessEdge delete
   */
  export type ProcessEdgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessEdge
     */
    select?: ProcessEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessEdgeInclude<ExtArgs> | null
    /**
     * Filter which ProcessEdge to delete.
     */
    where: ProcessEdgeWhereUniqueInput
  }

  /**
   * ProcessEdge deleteMany
   */
  export type ProcessEdgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessEdges to delete
     */
    where?: ProcessEdgeWhereInput
  }

  /**
   * ProcessEdge without action
   */
  export type ProcessEdgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessEdge
     */
    select?: ProcessEdgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessEdgeInclude<ExtArgs> | null
  }


  /**
   * Model ObjetivoProceso
   */

  export type AggregateObjetivoProceso = {
    _count: ObjetivoProcesoCountAggregateOutputType | null
    _avg: ObjetivoProcesoAvgAggregateOutputType | null
    _sum: ObjetivoProcesoSumAggregateOutputType | null
    _min: ObjetivoProcesoMinAggregateOutputType | null
    _max: ObjetivoProcesoMaxAggregateOutputType | null
  }

  export type ObjetivoProcesoAvgAggregateOutputType = {
    progreso: number | null
  }

  export type ObjetivoProcesoSumAggregateOutputType = {
    progreso: number | null
  }

  export type ObjetivoProcesoMinAggregateOutputType = {
    id: string | null
    procesoId: string | null
    nombre: string | null
    descripcion: string | null
    tipo: string | null
    progreso: number | null
  }

  export type ObjetivoProcesoMaxAggregateOutputType = {
    id: string | null
    procesoId: string | null
    nombre: string | null
    descripcion: string | null
    tipo: string | null
    progreso: number | null
  }

  export type ObjetivoProcesoCountAggregateOutputType = {
    id: number
    procesoId: number
    nombre: number
    descripcion: number
    tipo: number
    progreso: number
    _all: number
  }


  export type ObjetivoProcesoAvgAggregateInputType = {
    progreso?: true
  }

  export type ObjetivoProcesoSumAggregateInputType = {
    progreso?: true
  }

  export type ObjetivoProcesoMinAggregateInputType = {
    id?: true
    procesoId?: true
    nombre?: true
    descripcion?: true
    tipo?: true
    progreso?: true
  }

  export type ObjetivoProcesoMaxAggregateInputType = {
    id?: true
    procesoId?: true
    nombre?: true
    descripcion?: true
    tipo?: true
    progreso?: true
  }

  export type ObjetivoProcesoCountAggregateInputType = {
    id?: true
    procesoId?: true
    nombre?: true
    descripcion?: true
    tipo?: true
    progreso?: true
    _all?: true
  }

  export type ObjetivoProcesoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjetivoProceso to aggregate.
     */
    where?: ObjetivoProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjetivoProcesos to fetch.
     */
    orderBy?: ObjetivoProcesoOrderByWithRelationInput | ObjetivoProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObjetivoProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjetivoProcesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjetivoProcesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ObjetivoProcesos
    **/
    _count?: true | ObjetivoProcesoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjetivoProcesoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjetivoProcesoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjetivoProcesoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjetivoProcesoMaxAggregateInputType
  }

  export type GetObjetivoProcesoAggregateType<T extends ObjetivoProcesoAggregateArgs> = {
        [P in keyof T & keyof AggregateObjetivoProceso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjetivoProceso[P]>
      : GetScalarType<T[P], AggregateObjetivoProceso[P]>
  }




  export type ObjetivoProcesoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjetivoProcesoWhereInput
    orderBy?: ObjetivoProcesoOrderByWithAggregationInput | ObjetivoProcesoOrderByWithAggregationInput[]
    by: ObjetivoProcesoScalarFieldEnum[] | ObjetivoProcesoScalarFieldEnum
    having?: ObjetivoProcesoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjetivoProcesoCountAggregateInputType | true
    _avg?: ObjetivoProcesoAvgAggregateInputType
    _sum?: ObjetivoProcesoSumAggregateInputType
    _min?: ObjetivoProcesoMinAggregateInputType
    _max?: ObjetivoProcesoMaxAggregateInputType
  }

  export type ObjetivoProcesoGroupByOutputType = {
    id: string
    procesoId: string
    nombre: string
    descripcion: string
    tipo: string
    progreso: number
    _count: ObjetivoProcesoCountAggregateOutputType | null
    _avg: ObjetivoProcesoAvgAggregateOutputType | null
    _sum: ObjetivoProcesoSumAggregateOutputType | null
    _min: ObjetivoProcesoMinAggregateOutputType | null
    _max: ObjetivoProcesoMaxAggregateOutputType | null
  }

  type GetObjetivoProcesoGroupByPayload<T extends ObjetivoProcesoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjetivoProcesoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjetivoProcesoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjetivoProcesoGroupByOutputType[P]>
            : GetScalarType<T[P], ObjetivoProcesoGroupByOutputType[P]>
        }
      >
    >


  export type ObjetivoProcesoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procesoId?: boolean
    nombre?: boolean
    descripcion?: boolean
    tipo?: boolean
    progreso?: boolean
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    kpis?: boolean | ObjetivoProceso$kpisArgs<ExtArgs>
    _count?: boolean | ObjetivoProcesoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objetivoProceso"]>

  export type ObjetivoProcesoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procesoId?: boolean
    nombre?: boolean
    descripcion?: boolean
    tipo?: boolean
    progreso?: boolean
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objetivoProceso"]>

  export type ObjetivoProcesoSelectScalar = {
    id?: boolean
    procesoId?: boolean
    nombre?: boolean
    descripcion?: boolean
    tipo?: boolean
    progreso?: boolean
  }

  export type ObjetivoProcesoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    kpis?: boolean | ObjetivoProceso$kpisArgs<ExtArgs>
    _count?: boolean | ObjetivoProcesoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ObjetivoProcesoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
  }

  export type $ObjetivoProcesoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ObjetivoProceso"
    objects: {
      proceso: Prisma.$ProcesoPayload<ExtArgs>
      kpis: Prisma.$KpiProcesoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      procesoId: string
      nombre: string
      descripcion: string
      tipo: string
      progreso: number
    }, ExtArgs["result"]["objetivoProceso"]>
    composites: {}
  }

  type ObjetivoProcesoGetPayload<S extends boolean | null | undefined | ObjetivoProcesoDefaultArgs> = $Result.GetResult<Prisma.$ObjetivoProcesoPayload, S>

  type ObjetivoProcesoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObjetivoProcesoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ObjetivoProcesoCountAggregateInputType | true
    }

  export interface ObjetivoProcesoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ObjetivoProceso'], meta: { name: 'ObjetivoProceso' } }
    /**
     * Find zero or one ObjetivoProceso that matches the filter.
     * @param {ObjetivoProcesoFindUniqueArgs} args - Arguments to find a ObjetivoProceso
     * @example
     * // Get one ObjetivoProceso
     * const objetivoProceso = await prisma.objetivoProceso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ObjetivoProcesoFindUniqueArgs>(args: SelectSubset<T, ObjetivoProcesoFindUniqueArgs<ExtArgs>>): Prisma__ObjetivoProcesoClient<$Result.GetResult<Prisma.$ObjetivoProcesoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ObjetivoProceso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ObjetivoProcesoFindUniqueOrThrowArgs} args - Arguments to find a ObjetivoProceso
     * @example
     * // Get one ObjetivoProceso
     * const objetivoProceso = await prisma.objetivoProceso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ObjetivoProcesoFindUniqueOrThrowArgs>(args: SelectSubset<T, ObjetivoProcesoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ObjetivoProcesoClient<$Result.GetResult<Prisma.$ObjetivoProcesoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ObjetivoProceso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjetivoProcesoFindFirstArgs} args - Arguments to find a ObjetivoProceso
     * @example
     * // Get one ObjetivoProceso
     * const objetivoProceso = await prisma.objetivoProceso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ObjetivoProcesoFindFirstArgs>(args?: SelectSubset<T, ObjetivoProcesoFindFirstArgs<ExtArgs>>): Prisma__ObjetivoProcesoClient<$Result.GetResult<Prisma.$ObjetivoProcesoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ObjetivoProceso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjetivoProcesoFindFirstOrThrowArgs} args - Arguments to find a ObjetivoProceso
     * @example
     * // Get one ObjetivoProceso
     * const objetivoProceso = await prisma.objetivoProceso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ObjetivoProcesoFindFirstOrThrowArgs>(args?: SelectSubset<T, ObjetivoProcesoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ObjetivoProcesoClient<$Result.GetResult<Prisma.$ObjetivoProcesoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ObjetivoProcesos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjetivoProcesoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ObjetivoProcesos
     * const objetivoProcesos = await prisma.objetivoProceso.findMany()
     * 
     * // Get first 10 ObjetivoProcesos
     * const objetivoProcesos = await prisma.objetivoProceso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objetivoProcesoWithIdOnly = await prisma.objetivoProceso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ObjetivoProcesoFindManyArgs>(args?: SelectSubset<T, ObjetivoProcesoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjetivoProcesoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ObjetivoProceso.
     * @param {ObjetivoProcesoCreateArgs} args - Arguments to create a ObjetivoProceso.
     * @example
     * // Create one ObjetivoProceso
     * const ObjetivoProceso = await prisma.objetivoProceso.create({
     *   data: {
     *     // ... data to create a ObjetivoProceso
     *   }
     * })
     * 
     */
    create<T extends ObjetivoProcesoCreateArgs>(args: SelectSubset<T, ObjetivoProcesoCreateArgs<ExtArgs>>): Prisma__ObjetivoProcesoClient<$Result.GetResult<Prisma.$ObjetivoProcesoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ObjetivoProcesos.
     * @param {ObjetivoProcesoCreateManyArgs} args - Arguments to create many ObjetivoProcesos.
     * @example
     * // Create many ObjetivoProcesos
     * const objetivoProceso = await prisma.objetivoProceso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ObjetivoProcesoCreateManyArgs>(args?: SelectSubset<T, ObjetivoProcesoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ObjetivoProcesos and returns the data saved in the database.
     * @param {ObjetivoProcesoCreateManyAndReturnArgs} args - Arguments to create many ObjetivoProcesos.
     * @example
     * // Create many ObjetivoProcesos
     * const objetivoProceso = await prisma.objetivoProceso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ObjetivoProcesos and only return the `id`
     * const objetivoProcesoWithIdOnly = await prisma.objetivoProceso.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ObjetivoProcesoCreateManyAndReturnArgs>(args?: SelectSubset<T, ObjetivoProcesoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjetivoProcesoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ObjetivoProceso.
     * @param {ObjetivoProcesoDeleteArgs} args - Arguments to delete one ObjetivoProceso.
     * @example
     * // Delete one ObjetivoProceso
     * const ObjetivoProceso = await prisma.objetivoProceso.delete({
     *   where: {
     *     // ... filter to delete one ObjetivoProceso
     *   }
     * })
     * 
     */
    delete<T extends ObjetivoProcesoDeleteArgs>(args: SelectSubset<T, ObjetivoProcesoDeleteArgs<ExtArgs>>): Prisma__ObjetivoProcesoClient<$Result.GetResult<Prisma.$ObjetivoProcesoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ObjetivoProceso.
     * @param {ObjetivoProcesoUpdateArgs} args - Arguments to update one ObjetivoProceso.
     * @example
     * // Update one ObjetivoProceso
     * const objetivoProceso = await prisma.objetivoProceso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ObjetivoProcesoUpdateArgs>(args: SelectSubset<T, ObjetivoProcesoUpdateArgs<ExtArgs>>): Prisma__ObjetivoProcesoClient<$Result.GetResult<Prisma.$ObjetivoProcesoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ObjetivoProcesos.
     * @param {ObjetivoProcesoDeleteManyArgs} args - Arguments to filter ObjetivoProcesos to delete.
     * @example
     * // Delete a few ObjetivoProcesos
     * const { count } = await prisma.objetivoProceso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ObjetivoProcesoDeleteManyArgs>(args?: SelectSubset<T, ObjetivoProcesoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObjetivoProcesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjetivoProcesoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ObjetivoProcesos
     * const objetivoProceso = await prisma.objetivoProceso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ObjetivoProcesoUpdateManyArgs>(args: SelectSubset<T, ObjetivoProcesoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ObjetivoProceso.
     * @param {ObjetivoProcesoUpsertArgs} args - Arguments to update or create a ObjetivoProceso.
     * @example
     * // Update or create a ObjetivoProceso
     * const objetivoProceso = await prisma.objetivoProceso.upsert({
     *   create: {
     *     // ... data to create a ObjetivoProceso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ObjetivoProceso we want to update
     *   }
     * })
     */
    upsert<T extends ObjetivoProcesoUpsertArgs>(args: SelectSubset<T, ObjetivoProcesoUpsertArgs<ExtArgs>>): Prisma__ObjetivoProcesoClient<$Result.GetResult<Prisma.$ObjetivoProcesoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ObjetivoProcesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjetivoProcesoCountArgs} args - Arguments to filter ObjetivoProcesos to count.
     * @example
     * // Count the number of ObjetivoProcesos
     * const count = await prisma.objetivoProceso.count({
     *   where: {
     *     // ... the filter for the ObjetivoProcesos we want to count
     *   }
     * })
    **/
    count<T extends ObjetivoProcesoCountArgs>(
      args?: Subset<T, ObjetivoProcesoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjetivoProcesoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ObjetivoProceso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjetivoProcesoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjetivoProcesoAggregateArgs>(args: Subset<T, ObjetivoProcesoAggregateArgs>): Prisma.PrismaPromise<GetObjetivoProcesoAggregateType<T>>

    /**
     * Group by ObjetivoProceso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjetivoProcesoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjetivoProcesoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjetivoProcesoGroupByArgs['orderBy'] }
        : { orderBy?: ObjetivoProcesoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjetivoProcesoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjetivoProcesoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ObjetivoProceso model
   */
  readonly fields: ObjetivoProcesoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ObjetivoProceso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObjetivoProcesoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proceso<T extends ProcesoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcesoDefaultArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    kpis<T extends ObjetivoProceso$kpisArgs<ExtArgs> = {}>(args?: Subset<T, ObjetivoProceso$kpisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiProcesoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ObjetivoProceso model
   */ 
  interface ObjetivoProcesoFieldRefs {
    readonly id: FieldRef<"ObjetivoProceso", 'String'>
    readonly procesoId: FieldRef<"ObjetivoProceso", 'String'>
    readonly nombre: FieldRef<"ObjetivoProceso", 'String'>
    readonly descripcion: FieldRef<"ObjetivoProceso", 'String'>
    readonly tipo: FieldRef<"ObjetivoProceso", 'String'>
    readonly progreso: FieldRef<"ObjetivoProceso", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ObjetivoProceso findUnique
   */
  export type ObjetivoProcesoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjetivoProceso
     */
    select?: ObjetivoProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjetivoProcesoInclude<ExtArgs> | null
    /**
     * Filter, which ObjetivoProceso to fetch.
     */
    where: ObjetivoProcesoWhereUniqueInput
  }

  /**
   * ObjetivoProceso findUniqueOrThrow
   */
  export type ObjetivoProcesoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjetivoProceso
     */
    select?: ObjetivoProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjetivoProcesoInclude<ExtArgs> | null
    /**
     * Filter, which ObjetivoProceso to fetch.
     */
    where: ObjetivoProcesoWhereUniqueInput
  }

  /**
   * ObjetivoProceso findFirst
   */
  export type ObjetivoProcesoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjetivoProceso
     */
    select?: ObjetivoProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjetivoProcesoInclude<ExtArgs> | null
    /**
     * Filter, which ObjetivoProceso to fetch.
     */
    where?: ObjetivoProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjetivoProcesos to fetch.
     */
    orderBy?: ObjetivoProcesoOrderByWithRelationInput | ObjetivoProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjetivoProcesos.
     */
    cursor?: ObjetivoProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjetivoProcesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjetivoProcesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjetivoProcesos.
     */
    distinct?: ObjetivoProcesoScalarFieldEnum | ObjetivoProcesoScalarFieldEnum[]
  }

  /**
   * ObjetivoProceso findFirstOrThrow
   */
  export type ObjetivoProcesoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjetivoProceso
     */
    select?: ObjetivoProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjetivoProcesoInclude<ExtArgs> | null
    /**
     * Filter, which ObjetivoProceso to fetch.
     */
    where?: ObjetivoProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjetivoProcesos to fetch.
     */
    orderBy?: ObjetivoProcesoOrderByWithRelationInput | ObjetivoProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjetivoProcesos.
     */
    cursor?: ObjetivoProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjetivoProcesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjetivoProcesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjetivoProcesos.
     */
    distinct?: ObjetivoProcesoScalarFieldEnum | ObjetivoProcesoScalarFieldEnum[]
  }

  /**
   * ObjetivoProceso findMany
   */
  export type ObjetivoProcesoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjetivoProceso
     */
    select?: ObjetivoProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjetivoProcesoInclude<ExtArgs> | null
    /**
     * Filter, which ObjetivoProcesos to fetch.
     */
    where?: ObjetivoProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjetivoProcesos to fetch.
     */
    orderBy?: ObjetivoProcesoOrderByWithRelationInput | ObjetivoProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ObjetivoProcesos.
     */
    cursor?: ObjetivoProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjetivoProcesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjetivoProcesos.
     */
    skip?: number
    distinct?: ObjetivoProcesoScalarFieldEnum | ObjetivoProcesoScalarFieldEnum[]
  }

  /**
   * ObjetivoProceso create
   */
  export type ObjetivoProcesoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjetivoProceso
     */
    select?: ObjetivoProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjetivoProcesoInclude<ExtArgs> | null
    /**
     * The data needed to create a ObjetivoProceso.
     */
    data: XOR<ObjetivoProcesoCreateInput, ObjetivoProcesoUncheckedCreateInput>
  }

  /**
   * ObjetivoProceso createMany
   */
  export type ObjetivoProcesoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ObjetivoProcesos.
     */
    data: ObjetivoProcesoCreateManyInput | ObjetivoProcesoCreateManyInput[]
  }

  /**
   * ObjetivoProceso createManyAndReturn
   */
  export type ObjetivoProcesoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjetivoProceso
     */
    select?: ObjetivoProcesoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ObjetivoProcesos.
     */
    data: ObjetivoProcesoCreateManyInput | ObjetivoProcesoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjetivoProcesoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ObjetivoProceso update
   */
  export type ObjetivoProcesoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjetivoProceso
     */
    select?: ObjetivoProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjetivoProcesoInclude<ExtArgs> | null
    /**
     * The data needed to update a ObjetivoProceso.
     */
    data: XOR<ObjetivoProcesoUpdateInput, ObjetivoProcesoUncheckedUpdateInput>
    /**
     * Choose, which ObjetivoProceso to update.
     */
    where: ObjetivoProcesoWhereUniqueInput
  }

  /**
   * ObjetivoProceso updateMany
   */
  export type ObjetivoProcesoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ObjetivoProcesos.
     */
    data: XOR<ObjetivoProcesoUpdateManyMutationInput, ObjetivoProcesoUncheckedUpdateManyInput>
    /**
     * Filter which ObjetivoProcesos to update
     */
    where?: ObjetivoProcesoWhereInput
  }

  /**
   * ObjetivoProceso upsert
   */
  export type ObjetivoProcesoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjetivoProceso
     */
    select?: ObjetivoProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjetivoProcesoInclude<ExtArgs> | null
    /**
     * The filter to search for the ObjetivoProceso to update in case it exists.
     */
    where: ObjetivoProcesoWhereUniqueInput
    /**
     * In case the ObjetivoProceso found by the `where` argument doesn't exist, create a new ObjetivoProceso with this data.
     */
    create: XOR<ObjetivoProcesoCreateInput, ObjetivoProcesoUncheckedCreateInput>
    /**
     * In case the ObjetivoProceso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObjetivoProcesoUpdateInput, ObjetivoProcesoUncheckedUpdateInput>
  }

  /**
   * ObjetivoProceso delete
   */
  export type ObjetivoProcesoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjetivoProceso
     */
    select?: ObjetivoProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjetivoProcesoInclude<ExtArgs> | null
    /**
     * Filter which ObjetivoProceso to delete.
     */
    where: ObjetivoProcesoWhereUniqueInput
  }

  /**
   * ObjetivoProceso deleteMany
   */
  export type ObjetivoProcesoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjetivoProcesos to delete
     */
    where?: ObjetivoProcesoWhereInput
  }

  /**
   * ObjetivoProceso.kpis
   */
  export type ObjetivoProceso$kpisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiProceso
     */
    select?: KpiProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiProcesoInclude<ExtArgs> | null
    where?: KpiProcesoWhereInput
    orderBy?: KpiProcesoOrderByWithRelationInput | KpiProcesoOrderByWithRelationInput[]
    cursor?: KpiProcesoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiProcesoScalarFieldEnum | KpiProcesoScalarFieldEnum[]
  }

  /**
   * ObjetivoProceso without action
   */
  export type ObjetivoProcesoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjetivoProceso
     */
    select?: ObjetivoProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjetivoProcesoInclude<ExtArgs> | null
  }


  /**
   * Model KpiProceso
   */

  export type AggregateKpiProceso = {
    _count: KpiProcesoCountAggregateOutputType | null
    _avg: KpiProcesoAvgAggregateOutputType | null
    _sum: KpiProcesoSumAggregateOutputType | null
    _min: KpiProcesoMinAggregateOutputType | null
    _max: KpiProcesoMaxAggregateOutputType | null
  }

  export type KpiProcesoAvgAggregateOutputType = {
    meta: number | null
    valorActual: number | null
    alertaAdvertencia: number | null
    alertaCritico: number | null
  }

  export type KpiProcesoSumAggregateOutputType = {
    meta: number | null
    valorActual: number | null
    alertaAdvertencia: number | null
    alertaCritico: number | null
  }

  export type KpiProcesoMinAggregateOutputType = {
    id: string | null
    procesoId: string | null
    objetivoId: string | null
    nombre: string | null
    descripcion: string | null
    unidad: string | null
    meta: number | null
    valorActual: number | null
    fechaUltimaActualizacion: Date | null
    alertaAdvertencia: number | null
    alertaCritico: number | null
    alertaDireccion: string | null
  }

  export type KpiProcesoMaxAggregateOutputType = {
    id: string | null
    procesoId: string | null
    objetivoId: string | null
    nombre: string | null
    descripcion: string | null
    unidad: string | null
    meta: number | null
    valorActual: number | null
    fechaUltimaActualizacion: Date | null
    alertaAdvertencia: number | null
    alertaCritico: number | null
    alertaDireccion: string | null
  }

  export type KpiProcesoCountAggregateOutputType = {
    id: number
    procesoId: number
    objetivoId: number
    nombre: number
    descripcion: number
    unidad: number
    meta: number
    valorActual: number
    fechaUltimaActualizacion: number
    alertaAdvertencia: number
    alertaCritico: number
    alertaDireccion: number
    _all: number
  }


  export type KpiProcesoAvgAggregateInputType = {
    meta?: true
    valorActual?: true
    alertaAdvertencia?: true
    alertaCritico?: true
  }

  export type KpiProcesoSumAggregateInputType = {
    meta?: true
    valorActual?: true
    alertaAdvertencia?: true
    alertaCritico?: true
  }

  export type KpiProcesoMinAggregateInputType = {
    id?: true
    procesoId?: true
    objetivoId?: true
    nombre?: true
    descripcion?: true
    unidad?: true
    meta?: true
    valorActual?: true
    fechaUltimaActualizacion?: true
    alertaAdvertencia?: true
    alertaCritico?: true
    alertaDireccion?: true
  }

  export type KpiProcesoMaxAggregateInputType = {
    id?: true
    procesoId?: true
    objetivoId?: true
    nombre?: true
    descripcion?: true
    unidad?: true
    meta?: true
    valorActual?: true
    fechaUltimaActualizacion?: true
    alertaAdvertencia?: true
    alertaCritico?: true
    alertaDireccion?: true
  }

  export type KpiProcesoCountAggregateInputType = {
    id?: true
    procesoId?: true
    objetivoId?: true
    nombre?: true
    descripcion?: true
    unidad?: true
    meta?: true
    valorActual?: true
    fechaUltimaActualizacion?: true
    alertaAdvertencia?: true
    alertaCritico?: true
    alertaDireccion?: true
    _all?: true
  }

  export type KpiProcesoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KpiProceso to aggregate.
     */
    where?: KpiProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiProcesos to fetch.
     */
    orderBy?: KpiProcesoOrderByWithRelationInput | KpiProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KpiProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiProcesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiProcesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KpiProcesos
    **/
    _count?: true | KpiProcesoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KpiProcesoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KpiProcesoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KpiProcesoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KpiProcesoMaxAggregateInputType
  }

  export type GetKpiProcesoAggregateType<T extends KpiProcesoAggregateArgs> = {
        [P in keyof T & keyof AggregateKpiProceso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKpiProceso[P]>
      : GetScalarType<T[P], AggregateKpiProceso[P]>
  }




  export type KpiProcesoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiProcesoWhereInput
    orderBy?: KpiProcesoOrderByWithAggregationInput | KpiProcesoOrderByWithAggregationInput[]
    by: KpiProcesoScalarFieldEnum[] | KpiProcesoScalarFieldEnum
    having?: KpiProcesoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KpiProcesoCountAggregateInputType | true
    _avg?: KpiProcesoAvgAggregateInputType
    _sum?: KpiProcesoSumAggregateInputType
    _min?: KpiProcesoMinAggregateInputType
    _max?: KpiProcesoMaxAggregateInputType
  }

  export type KpiProcesoGroupByOutputType = {
    id: string
    procesoId: string
    objetivoId: string | null
    nombre: string
    descripcion: string | null
    unidad: string
    meta: number
    valorActual: number
    fechaUltimaActualizacion: Date | null
    alertaAdvertencia: number | null
    alertaCritico: number | null
    alertaDireccion: string
    _count: KpiProcesoCountAggregateOutputType | null
    _avg: KpiProcesoAvgAggregateOutputType | null
    _sum: KpiProcesoSumAggregateOutputType | null
    _min: KpiProcesoMinAggregateOutputType | null
    _max: KpiProcesoMaxAggregateOutputType | null
  }

  type GetKpiProcesoGroupByPayload<T extends KpiProcesoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KpiProcesoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KpiProcesoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KpiProcesoGroupByOutputType[P]>
            : GetScalarType<T[P], KpiProcesoGroupByOutputType[P]>
        }
      >
    >


  export type KpiProcesoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procesoId?: boolean
    objetivoId?: boolean
    nombre?: boolean
    descripcion?: boolean
    unidad?: boolean
    meta?: boolean
    valorActual?: boolean
    fechaUltimaActualizacion?: boolean
    alertaAdvertencia?: boolean
    alertaCritico?: boolean
    alertaDireccion?: boolean
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    objetivo?: boolean | KpiProceso$objetivoArgs<ExtArgs>
    historico?: boolean | KpiProceso$historicoArgs<ExtArgs>
    _count?: boolean | KpiProcesoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kpiProceso"]>

  export type KpiProcesoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procesoId?: boolean
    objetivoId?: boolean
    nombre?: boolean
    descripcion?: boolean
    unidad?: boolean
    meta?: boolean
    valorActual?: boolean
    fechaUltimaActualizacion?: boolean
    alertaAdvertencia?: boolean
    alertaCritico?: boolean
    alertaDireccion?: boolean
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    objetivo?: boolean | KpiProceso$objetivoArgs<ExtArgs>
  }, ExtArgs["result"]["kpiProceso"]>

  export type KpiProcesoSelectScalar = {
    id?: boolean
    procesoId?: boolean
    objetivoId?: boolean
    nombre?: boolean
    descripcion?: boolean
    unidad?: boolean
    meta?: boolean
    valorActual?: boolean
    fechaUltimaActualizacion?: boolean
    alertaAdvertencia?: boolean
    alertaCritico?: boolean
    alertaDireccion?: boolean
  }

  export type KpiProcesoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    objetivo?: boolean | KpiProceso$objetivoArgs<ExtArgs>
    historico?: boolean | KpiProceso$historicoArgs<ExtArgs>
    _count?: boolean | KpiProcesoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KpiProcesoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    objetivo?: boolean | KpiProceso$objetivoArgs<ExtArgs>
  }

  export type $KpiProcesoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KpiProceso"
    objects: {
      proceso: Prisma.$ProcesoPayload<ExtArgs>
      objetivo: Prisma.$ObjetivoProcesoPayload<ExtArgs> | null
      historico: Prisma.$KpiHistoricoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      procesoId: string
      objetivoId: string | null
      nombre: string
      descripcion: string | null
      unidad: string
      meta: number
      valorActual: number
      fechaUltimaActualizacion: Date | null
      alertaAdvertencia: number | null
      alertaCritico: number | null
      alertaDireccion: string
    }, ExtArgs["result"]["kpiProceso"]>
    composites: {}
  }

  type KpiProcesoGetPayload<S extends boolean | null | undefined | KpiProcesoDefaultArgs> = $Result.GetResult<Prisma.$KpiProcesoPayload, S>

  type KpiProcesoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KpiProcesoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KpiProcesoCountAggregateInputType | true
    }

  export interface KpiProcesoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KpiProceso'], meta: { name: 'KpiProceso' } }
    /**
     * Find zero or one KpiProceso that matches the filter.
     * @param {KpiProcesoFindUniqueArgs} args - Arguments to find a KpiProceso
     * @example
     * // Get one KpiProceso
     * const kpiProceso = await prisma.kpiProceso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KpiProcesoFindUniqueArgs>(args: SelectSubset<T, KpiProcesoFindUniqueArgs<ExtArgs>>): Prisma__KpiProcesoClient<$Result.GetResult<Prisma.$KpiProcesoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KpiProceso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KpiProcesoFindUniqueOrThrowArgs} args - Arguments to find a KpiProceso
     * @example
     * // Get one KpiProceso
     * const kpiProceso = await prisma.kpiProceso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KpiProcesoFindUniqueOrThrowArgs>(args: SelectSubset<T, KpiProcesoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KpiProcesoClient<$Result.GetResult<Prisma.$KpiProcesoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KpiProceso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiProcesoFindFirstArgs} args - Arguments to find a KpiProceso
     * @example
     * // Get one KpiProceso
     * const kpiProceso = await prisma.kpiProceso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KpiProcesoFindFirstArgs>(args?: SelectSubset<T, KpiProcesoFindFirstArgs<ExtArgs>>): Prisma__KpiProcesoClient<$Result.GetResult<Prisma.$KpiProcesoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KpiProceso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiProcesoFindFirstOrThrowArgs} args - Arguments to find a KpiProceso
     * @example
     * // Get one KpiProceso
     * const kpiProceso = await prisma.kpiProceso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KpiProcesoFindFirstOrThrowArgs>(args?: SelectSubset<T, KpiProcesoFindFirstOrThrowArgs<ExtArgs>>): Prisma__KpiProcesoClient<$Result.GetResult<Prisma.$KpiProcesoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KpiProcesos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiProcesoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KpiProcesos
     * const kpiProcesos = await prisma.kpiProceso.findMany()
     * 
     * // Get first 10 KpiProcesos
     * const kpiProcesos = await prisma.kpiProceso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kpiProcesoWithIdOnly = await prisma.kpiProceso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KpiProcesoFindManyArgs>(args?: SelectSubset<T, KpiProcesoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiProcesoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KpiProceso.
     * @param {KpiProcesoCreateArgs} args - Arguments to create a KpiProceso.
     * @example
     * // Create one KpiProceso
     * const KpiProceso = await prisma.kpiProceso.create({
     *   data: {
     *     // ... data to create a KpiProceso
     *   }
     * })
     * 
     */
    create<T extends KpiProcesoCreateArgs>(args: SelectSubset<T, KpiProcesoCreateArgs<ExtArgs>>): Prisma__KpiProcesoClient<$Result.GetResult<Prisma.$KpiProcesoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KpiProcesos.
     * @param {KpiProcesoCreateManyArgs} args - Arguments to create many KpiProcesos.
     * @example
     * // Create many KpiProcesos
     * const kpiProceso = await prisma.kpiProceso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KpiProcesoCreateManyArgs>(args?: SelectSubset<T, KpiProcesoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KpiProcesos and returns the data saved in the database.
     * @param {KpiProcesoCreateManyAndReturnArgs} args - Arguments to create many KpiProcesos.
     * @example
     * // Create many KpiProcesos
     * const kpiProceso = await prisma.kpiProceso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KpiProcesos and only return the `id`
     * const kpiProcesoWithIdOnly = await prisma.kpiProceso.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KpiProcesoCreateManyAndReturnArgs>(args?: SelectSubset<T, KpiProcesoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiProcesoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KpiProceso.
     * @param {KpiProcesoDeleteArgs} args - Arguments to delete one KpiProceso.
     * @example
     * // Delete one KpiProceso
     * const KpiProceso = await prisma.kpiProceso.delete({
     *   where: {
     *     // ... filter to delete one KpiProceso
     *   }
     * })
     * 
     */
    delete<T extends KpiProcesoDeleteArgs>(args: SelectSubset<T, KpiProcesoDeleteArgs<ExtArgs>>): Prisma__KpiProcesoClient<$Result.GetResult<Prisma.$KpiProcesoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KpiProceso.
     * @param {KpiProcesoUpdateArgs} args - Arguments to update one KpiProceso.
     * @example
     * // Update one KpiProceso
     * const kpiProceso = await prisma.kpiProceso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KpiProcesoUpdateArgs>(args: SelectSubset<T, KpiProcesoUpdateArgs<ExtArgs>>): Prisma__KpiProcesoClient<$Result.GetResult<Prisma.$KpiProcesoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KpiProcesos.
     * @param {KpiProcesoDeleteManyArgs} args - Arguments to filter KpiProcesos to delete.
     * @example
     * // Delete a few KpiProcesos
     * const { count } = await prisma.kpiProceso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KpiProcesoDeleteManyArgs>(args?: SelectSubset<T, KpiProcesoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KpiProcesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiProcesoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KpiProcesos
     * const kpiProceso = await prisma.kpiProceso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KpiProcesoUpdateManyArgs>(args: SelectSubset<T, KpiProcesoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KpiProceso.
     * @param {KpiProcesoUpsertArgs} args - Arguments to update or create a KpiProceso.
     * @example
     * // Update or create a KpiProceso
     * const kpiProceso = await prisma.kpiProceso.upsert({
     *   create: {
     *     // ... data to create a KpiProceso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KpiProceso we want to update
     *   }
     * })
     */
    upsert<T extends KpiProcesoUpsertArgs>(args: SelectSubset<T, KpiProcesoUpsertArgs<ExtArgs>>): Prisma__KpiProcesoClient<$Result.GetResult<Prisma.$KpiProcesoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KpiProcesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiProcesoCountArgs} args - Arguments to filter KpiProcesos to count.
     * @example
     * // Count the number of KpiProcesos
     * const count = await prisma.kpiProceso.count({
     *   where: {
     *     // ... the filter for the KpiProcesos we want to count
     *   }
     * })
    **/
    count<T extends KpiProcesoCountArgs>(
      args?: Subset<T, KpiProcesoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KpiProcesoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KpiProceso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiProcesoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KpiProcesoAggregateArgs>(args: Subset<T, KpiProcesoAggregateArgs>): Prisma.PrismaPromise<GetKpiProcesoAggregateType<T>>

    /**
     * Group by KpiProceso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiProcesoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KpiProcesoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KpiProcesoGroupByArgs['orderBy'] }
        : { orderBy?: KpiProcesoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KpiProcesoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKpiProcesoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KpiProceso model
   */
  readonly fields: KpiProcesoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KpiProceso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KpiProcesoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proceso<T extends ProcesoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcesoDefaultArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    objetivo<T extends KpiProceso$objetivoArgs<ExtArgs> = {}>(args?: Subset<T, KpiProceso$objetivoArgs<ExtArgs>>): Prisma__ObjetivoProcesoClient<$Result.GetResult<Prisma.$ObjetivoProcesoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    historico<T extends KpiProceso$historicoArgs<ExtArgs> = {}>(args?: Subset<T, KpiProceso$historicoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiHistoricoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KpiProceso model
   */ 
  interface KpiProcesoFieldRefs {
    readonly id: FieldRef<"KpiProceso", 'String'>
    readonly procesoId: FieldRef<"KpiProceso", 'String'>
    readonly objetivoId: FieldRef<"KpiProceso", 'String'>
    readonly nombre: FieldRef<"KpiProceso", 'String'>
    readonly descripcion: FieldRef<"KpiProceso", 'String'>
    readonly unidad: FieldRef<"KpiProceso", 'String'>
    readonly meta: FieldRef<"KpiProceso", 'Float'>
    readonly valorActual: FieldRef<"KpiProceso", 'Float'>
    readonly fechaUltimaActualizacion: FieldRef<"KpiProceso", 'DateTime'>
    readonly alertaAdvertencia: FieldRef<"KpiProceso", 'Float'>
    readonly alertaCritico: FieldRef<"KpiProceso", 'Float'>
    readonly alertaDireccion: FieldRef<"KpiProceso", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KpiProceso findUnique
   */
  export type KpiProcesoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiProceso
     */
    select?: KpiProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiProcesoInclude<ExtArgs> | null
    /**
     * Filter, which KpiProceso to fetch.
     */
    where: KpiProcesoWhereUniqueInput
  }

  /**
   * KpiProceso findUniqueOrThrow
   */
  export type KpiProcesoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiProceso
     */
    select?: KpiProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiProcesoInclude<ExtArgs> | null
    /**
     * Filter, which KpiProceso to fetch.
     */
    where: KpiProcesoWhereUniqueInput
  }

  /**
   * KpiProceso findFirst
   */
  export type KpiProcesoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiProceso
     */
    select?: KpiProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiProcesoInclude<ExtArgs> | null
    /**
     * Filter, which KpiProceso to fetch.
     */
    where?: KpiProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiProcesos to fetch.
     */
    orderBy?: KpiProcesoOrderByWithRelationInput | KpiProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KpiProcesos.
     */
    cursor?: KpiProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiProcesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiProcesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KpiProcesos.
     */
    distinct?: KpiProcesoScalarFieldEnum | KpiProcesoScalarFieldEnum[]
  }

  /**
   * KpiProceso findFirstOrThrow
   */
  export type KpiProcesoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiProceso
     */
    select?: KpiProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiProcesoInclude<ExtArgs> | null
    /**
     * Filter, which KpiProceso to fetch.
     */
    where?: KpiProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiProcesos to fetch.
     */
    orderBy?: KpiProcesoOrderByWithRelationInput | KpiProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KpiProcesos.
     */
    cursor?: KpiProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiProcesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiProcesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KpiProcesos.
     */
    distinct?: KpiProcesoScalarFieldEnum | KpiProcesoScalarFieldEnum[]
  }

  /**
   * KpiProceso findMany
   */
  export type KpiProcesoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiProceso
     */
    select?: KpiProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiProcesoInclude<ExtArgs> | null
    /**
     * Filter, which KpiProcesos to fetch.
     */
    where?: KpiProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiProcesos to fetch.
     */
    orderBy?: KpiProcesoOrderByWithRelationInput | KpiProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KpiProcesos.
     */
    cursor?: KpiProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiProcesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiProcesos.
     */
    skip?: number
    distinct?: KpiProcesoScalarFieldEnum | KpiProcesoScalarFieldEnum[]
  }

  /**
   * KpiProceso create
   */
  export type KpiProcesoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiProceso
     */
    select?: KpiProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiProcesoInclude<ExtArgs> | null
    /**
     * The data needed to create a KpiProceso.
     */
    data: XOR<KpiProcesoCreateInput, KpiProcesoUncheckedCreateInput>
  }

  /**
   * KpiProceso createMany
   */
  export type KpiProcesoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KpiProcesos.
     */
    data: KpiProcesoCreateManyInput | KpiProcesoCreateManyInput[]
  }

  /**
   * KpiProceso createManyAndReturn
   */
  export type KpiProcesoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiProceso
     */
    select?: KpiProcesoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KpiProcesos.
     */
    data: KpiProcesoCreateManyInput | KpiProcesoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiProcesoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KpiProceso update
   */
  export type KpiProcesoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiProceso
     */
    select?: KpiProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiProcesoInclude<ExtArgs> | null
    /**
     * The data needed to update a KpiProceso.
     */
    data: XOR<KpiProcesoUpdateInput, KpiProcesoUncheckedUpdateInput>
    /**
     * Choose, which KpiProceso to update.
     */
    where: KpiProcesoWhereUniqueInput
  }

  /**
   * KpiProceso updateMany
   */
  export type KpiProcesoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KpiProcesos.
     */
    data: XOR<KpiProcesoUpdateManyMutationInput, KpiProcesoUncheckedUpdateManyInput>
    /**
     * Filter which KpiProcesos to update
     */
    where?: KpiProcesoWhereInput
  }

  /**
   * KpiProceso upsert
   */
  export type KpiProcesoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiProceso
     */
    select?: KpiProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiProcesoInclude<ExtArgs> | null
    /**
     * The filter to search for the KpiProceso to update in case it exists.
     */
    where: KpiProcesoWhereUniqueInput
    /**
     * In case the KpiProceso found by the `where` argument doesn't exist, create a new KpiProceso with this data.
     */
    create: XOR<KpiProcesoCreateInput, KpiProcesoUncheckedCreateInput>
    /**
     * In case the KpiProceso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KpiProcesoUpdateInput, KpiProcesoUncheckedUpdateInput>
  }

  /**
   * KpiProceso delete
   */
  export type KpiProcesoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiProceso
     */
    select?: KpiProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiProcesoInclude<ExtArgs> | null
    /**
     * Filter which KpiProceso to delete.
     */
    where: KpiProcesoWhereUniqueInput
  }

  /**
   * KpiProceso deleteMany
   */
  export type KpiProcesoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KpiProcesos to delete
     */
    where?: KpiProcesoWhereInput
  }

  /**
   * KpiProceso.objetivo
   */
  export type KpiProceso$objetivoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjetivoProceso
     */
    select?: ObjetivoProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjetivoProcesoInclude<ExtArgs> | null
    where?: ObjetivoProcesoWhereInput
  }

  /**
   * KpiProceso.historico
   */
  export type KpiProceso$historicoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiHistorico
     */
    select?: KpiHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiHistoricoInclude<ExtArgs> | null
    where?: KpiHistoricoWhereInput
    orderBy?: KpiHistoricoOrderByWithRelationInput | KpiHistoricoOrderByWithRelationInput[]
    cursor?: KpiHistoricoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiHistoricoScalarFieldEnum | KpiHistoricoScalarFieldEnum[]
  }

  /**
   * KpiProceso without action
   */
  export type KpiProcesoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiProceso
     */
    select?: KpiProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiProcesoInclude<ExtArgs> | null
  }


  /**
   * Model KpiHistorico
   */

  export type AggregateKpiHistorico = {
    _count: KpiHistoricoCountAggregateOutputType | null
    _avg: KpiHistoricoAvgAggregateOutputType | null
    _sum: KpiHistoricoSumAggregateOutputType | null
    _min: KpiHistoricoMinAggregateOutputType | null
    _max: KpiHistoricoMaxAggregateOutputType | null
  }

  export type KpiHistoricoAvgAggregateOutputType = {
    valor: number | null
  }

  export type KpiHistoricoSumAggregateOutputType = {
    valor: number | null
  }

  export type KpiHistoricoMinAggregateOutputType = {
    id: string | null
    kpiId: string | null
    valor: number | null
    timestamp: Date | null
    procesoId: string | null
    nodoId: string | null
    metadatos: string | null
  }

  export type KpiHistoricoMaxAggregateOutputType = {
    id: string | null
    kpiId: string | null
    valor: number | null
    timestamp: Date | null
    procesoId: string | null
    nodoId: string | null
    metadatos: string | null
  }

  export type KpiHistoricoCountAggregateOutputType = {
    id: number
    kpiId: number
    valor: number
    timestamp: number
    procesoId: number
    nodoId: number
    metadatos: number
    _all: number
  }


  export type KpiHistoricoAvgAggregateInputType = {
    valor?: true
  }

  export type KpiHistoricoSumAggregateInputType = {
    valor?: true
  }

  export type KpiHistoricoMinAggregateInputType = {
    id?: true
    kpiId?: true
    valor?: true
    timestamp?: true
    procesoId?: true
    nodoId?: true
    metadatos?: true
  }

  export type KpiHistoricoMaxAggregateInputType = {
    id?: true
    kpiId?: true
    valor?: true
    timestamp?: true
    procesoId?: true
    nodoId?: true
    metadatos?: true
  }

  export type KpiHistoricoCountAggregateInputType = {
    id?: true
    kpiId?: true
    valor?: true
    timestamp?: true
    procesoId?: true
    nodoId?: true
    metadatos?: true
    _all?: true
  }

  export type KpiHistoricoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KpiHistorico to aggregate.
     */
    where?: KpiHistoricoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiHistoricos to fetch.
     */
    orderBy?: KpiHistoricoOrderByWithRelationInput | KpiHistoricoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KpiHistoricoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiHistoricos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiHistoricos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KpiHistoricos
    **/
    _count?: true | KpiHistoricoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KpiHistoricoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KpiHistoricoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KpiHistoricoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KpiHistoricoMaxAggregateInputType
  }

  export type GetKpiHistoricoAggregateType<T extends KpiHistoricoAggregateArgs> = {
        [P in keyof T & keyof AggregateKpiHistorico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKpiHistorico[P]>
      : GetScalarType<T[P], AggregateKpiHistorico[P]>
  }




  export type KpiHistoricoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiHistoricoWhereInput
    orderBy?: KpiHistoricoOrderByWithAggregationInput | KpiHistoricoOrderByWithAggregationInput[]
    by: KpiHistoricoScalarFieldEnum[] | KpiHistoricoScalarFieldEnum
    having?: KpiHistoricoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KpiHistoricoCountAggregateInputType | true
    _avg?: KpiHistoricoAvgAggregateInputType
    _sum?: KpiHistoricoSumAggregateInputType
    _min?: KpiHistoricoMinAggregateInputType
    _max?: KpiHistoricoMaxAggregateInputType
  }

  export type KpiHistoricoGroupByOutputType = {
    id: string
    kpiId: string
    valor: number
    timestamp: Date
    procesoId: string
    nodoId: string | null
    metadatos: string | null
    _count: KpiHistoricoCountAggregateOutputType | null
    _avg: KpiHistoricoAvgAggregateOutputType | null
    _sum: KpiHistoricoSumAggregateOutputType | null
    _min: KpiHistoricoMinAggregateOutputType | null
    _max: KpiHistoricoMaxAggregateOutputType | null
  }

  type GetKpiHistoricoGroupByPayload<T extends KpiHistoricoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KpiHistoricoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KpiHistoricoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KpiHistoricoGroupByOutputType[P]>
            : GetScalarType<T[P], KpiHistoricoGroupByOutputType[P]>
        }
      >
    >


  export type KpiHistoricoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kpiId?: boolean
    valor?: boolean
    timestamp?: boolean
    procesoId?: boolean
    nodoId?: boolean
    metadatos?: boolean
    kpi?: boolean | KpiProcesoDefaultArgs<ExtArgs>
    nodo?: boolean | KpiHistorico$nodoArgs<ExtArgs>
  }, ExtArgs["result"]["kpiHistorico"]>

  export type KpiHistoricoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kpiId?: boolean
    valor?: boolean
    timestamp?: boolean
    procesoId?: boolean
    nodoId?: boolean
    metadatos?: boolean
    kpi?: boolean | KpiProcesoDefaultArgs<ExtArgs>
    nodo?: boolean | KpiHistorico$nodoArgs<ExtArgs>
  }, ExtArgs["result"]["kpiHistorico"]>

  export type KpiHistoricoSelectScalar = {
    id?: boolean
    kpiId?: boolean
    valor?: boolean
    timestamp?: boolean
    procesoId?: boolean
    nodoId?: boolean
    metadatos?: boolean
  }

  export type KpiHistoricoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kpi?: boolean | KpiProcesoDefaultArgs<ExtArgs>
    nodo?: boolean | KpiHistorico$nodoArgs<ExtArgs>
  }
  export type KpiHistoricoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kpi?: boolean | KpiProcesoDefaultArgs<ExtArgs>
    nodo?: boolean | KpiHistorico$nodoArgs<ExtArgs>
  }

  export type $KpiHistoricoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KpiHistorico"
    objects: {
      kpi: Prisma.$KpiProcesoPayload<ExtArgs>
      nodo: Prisma.$ProcessNodePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kpiId: string
      valor: number
      timestamp: Date
      procesoId: string
      nodoId: string | null
      metadatos: string | null
    }, ExtArgs["result"]["kpiHistorico"]>
    composites: {}
  }

  type KpiHistoricoGetPayload<S extends boolean | null | undefined | KpiHistoricoDefaultArgs> = $Result.GetResult<Prisma.$KpiHistoricoPayload, S>

  type KpiHistoricoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KpiHistoricoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KpiHistoricoCountAggregateInputType | true
    }

  export interface KpiHistoricoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KpiHistorico'], meta: { name: 'KpiHistorico' } }
    /**
     * Find zero or one KpiHistorico that matches the filter.
     * @param {KpiHistoricoFindUniqueArgs} args - Arguments to find a KpiHistorico
     * @example
     * // Get one KpiHistorico
     * const kpiHistorico = await prisma.kpiHistorico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KpiHistoricoFindUniqueArgs>(args: SelectSubset<T, KpiHistoricoFindUniqueArgs<ExtArgs>>): Prisma__KpiHistoricoClient<$Result.GetResult<Prisma.$KpiHistoricoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KpiHistorico that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KpiHistoricoFindUniqueOrThrowArgs} args - Arguments to find a KpiHistorico
     * @example
     * // Get one KpiHistorico
     * const kpiHistorico = await prisma.kpiHistorico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KpiHistoricoFindUniqueOrThrowArgs>(args: SelectSubset<T, KpiHistoricoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KpiHistoricoClient<$Result.GetResult<Prisma.$KpiHistoricoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KpiHistorico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiHistoricoFindFirstArgs} args - Arguments to find a KpiHistorico
     * @example
     * // Get one KpiHistorico
     * const kpiHistorico = await prisma.kpiHistorico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KpiHistoricoFindFirstArgs>(args?: SelectSubset<T, KpiHistoricoFindFirstArgs<ExtArgs>>): Prisma__KpiHistoricoClient<$Result.GetResult<Prisma.$KpiHistoricoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KpiHistorico that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiHistoricoFindFirstOrThrowArgs} args - Arguments to find a KpiHistorico
     * @example
     * // Get one KpiHistorico
     * const kpiHistorico = await prisma.kpiHistorico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KpiHistoricoFindFirstOrThrowArgs>(args?: SelectSubset<T, KpiHistoricoFindFirstOrThrowArgs<ExtArgs>>): Prisma__KpiHistoricoClient<$Result.GetResult<Prisma.$KpiHistoricoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KpiHistoricos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiHistoricoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KpiHistoricos
     * const kpiHistoricos = await prisma.kpiHistorico.findMany()
     * 
     * // Get first 10 KpiHistoricos
     * const kpiHistoricos = await prisma.kpiHistorico.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kpiHistoricoWithIdOnly = await prisma.kpiHistorico.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KpiHistoricoFindManyArgs>(args?: SelectSubset<T, KpiHistoricoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiHistoricoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KpiHistorico.
     * @param {KpiHistoricoCreateArgs} args - Arguments to create a KpiHistorico.
     * @example
     * // Create one KpiHistorico
     * const KpiHistorico = await prisma.kpiHistorico.create({
     *   data: {
     *     // ... data to create a KpiHistorico
     *   }
     * })
     * 
     */
    create<T extends KpiHistoricoCreateArgs>(args: SelectSubset<T, KpiHistoricoCreateArgs<ExtArgs>>): Prisma__KpiHistoricoClient<$Result.GetResult<Prisma.$KpiHistoricoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KpiHistoricos.
     * @param {KpiHistoricoCreateManyArgs} args - Arguments to create many KpiHistoricos.
     * @example
     * // Create many KpiHistoricos
     * const kpiHistorico = await prisma.kpiHistorico.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KpiHistoricoCreateManyArgs>(args?: SelectSubset<T, KpiHistoricoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KpiHistoricos and returns the data saved in the database.
     * @param {KpiHistoricoCreateManyAndReturnArgs} args - Arguments to create many KpiHistoricos.
     * @example
     * // Create many KpiHistoricos
     * const kpiHistorico = await prisma.kpiHistorico.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KpiHistoricos and only return the `id`
     * const kpiHistoricoWithIdOnly = await prisma.kpiHistorico.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KpiHistoricoCreateManyAndReturnArgs>(args?: SelectSubset<T, KpiHistoricoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiHistoricoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KpiHistorico.
     * @param {KpiHistoricoDeleteArgs} args - Arguments to delete one KpiHistorico.
     * @example
     * // Delete one KpiHistorico
     * const KpiHistorico = await prisma.kpiHistorico.delete({
     *   where: {
     *     // ... filter to delete one KpiHistorico
     *   }
     * })
     * 
     */
    delete<T extends KpiHistoricoDeleteArgs>(args: SelectSubset<T, KpiHistoricoDeleteArgs<ExtArgs>>): Prisma__KpiHistoricoClient<$Result.GetResult<Prisma.$KpiHistoricoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KpiHistorico.
     * @param {KpiHistoricoUpdateArgs} args - Arguments to update one KpiHistorico.
     * @example
     * // Update one KpiHistorico
     * const kpiHistorico = await prisma.kpiHistorico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KpiHistoricoUpdateArgs>(args: SelectSubset<T, KpiHistoricoUpdateArgs<ExtArgs>>): Prisma__KpiHistoricoClient<$Result.GetResult<Prisma.$KpiHistoricoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KpiHistoricos.
     * @param {KpiHistoricoDeleteManyArgs} args - Arguments to filter KpiHistoricos to delete.
     * @example
     * // Delete a few KpiHistoricos
     * const { count } = await prisma.kpiHistorico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KpiHistoricoDeleteManyArgs>(args?: SelectSubset<T, KpiHistoricoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KpiHistoricos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiHistoricoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KpiHistoricos
     * const kpiHistorico = await prisma.kpiHistorico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KpiHistoricoUpdateManyArgs>(args: SelectSubset<T, KpiHistoricoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KpiHistorico.
     * @param {KpiHistoricoUpsertArgs} args - Arguments to update or create a KpiHistorico.
     * @example
     * // Update or create a KpiHistorico
     * const kpiHistorico = await prisma.kpiHistorico.upsert({
     *   create: {
     *     // ... data to create a KpiHistorico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KpiHistorico we want to update
     *   }
     * })
     */
    upsert<T extends KpiHistoricoUpsertArgs>(args: SelectSubset<T, KpiHistoricoUpsertArgs<ExtArgs>>): Prisma__KpiHistoricoClient<$Result.GetResult<Prisma.$KpiHistoricoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KpiHistoricos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiHistoricoCountArgs} args - Arguments to filter KpiHistoricos to count.
     * @example
     * // Count the number of KpiHistoricos
     * const count = await prisma.kpiHistorico.count({
     *   where: {
     *     // ... the filter for the KpiHistoricos we want to count
     *   }
     * })
    **/
    count<T extends KpiHistoricoCountArgs>(
      args?: Subset<T, KpiHistoricoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KpiHistoricoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KpiHistorico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiHistoricoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KpiHistoricoAggregateArgs>(args: Subset<T, KpiHistoricoAggregateArgs>): Prisma.PrismaPromise<GetKpiHistoricoAggregateType<T>>

    /**
     * Group by KpiHistorico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiHistoricoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KpiHistoricoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KpiHistoricoGroupByArgs['orderBy'] }
        : { orderBy?: KpiHistoricoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KpiHistoricoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKpiHistoricoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KpiHistorico model
   */
  readonly fields: KpiHistoricoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KpiHistorico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KpiHistoricoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kpi<T extends KpiProcesoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KpiProcesoDefaultArgs<ExtArgs>>): Prisma__KpiProcesoClient<$Result.GetResult<Prisma.$KpiProcesoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    nodo<T extends KpiHistorico$nodoArgs<ExtArgs> = {}>(args?: Subset<T, KpiHistorico$nodoArgs<ExtArgs>>): Prisma__ProcessNodeClient<$Result.GetResult<Prisma.$ProcessNodePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KpiHistorico model
   */ 
  interface KpiHistoricoFieldRefs {
    readonly id: FieldRef<"KpiHistorico", 'String'>
    readonly kpiId: FieldRef<"KpiHistorico", 'String'>
    readonly valor: FieldRef<"KpiHistorico", 'Float'>
    readonly timestamp: FieldRef<"KpiHistorico", 'DateTime'>
    readonly procesoId: FieldRef<"KpiHistorico", 'String'>
    readonly nodoId: FieldRef<"KpiHistorico", 'String'>
    readonly metadatos: FieldRef<"KpiHistorico", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KpiHistorico findUnique
   */
  export type KpiHistoricoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiHistorico
     */
    select?: KpiHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiHistoricoInclude<ExtArgs> | null
    /**
     * Filter, which KpiHistorico to fetch.
     */
    where: KpiHistoricoWhereUniqueInput
  }

  /**
   * KpiHistorico findUniqueOrThrow
   */
  export type KpiHistoricoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiHistorico
     */
    select?: KpiHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiHistoricoInclude<ExtArgs> | null
    /**
     * Filter, which KpiHistorico to fetch.
     */
    where: KpiHistoricoWhereUniqueInput
  }

  /**
   * KpiHistorico findFirst
   */
  export type KpiHistoricoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiHistorico
     */
    select?: KpiHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiHistoricoInclude<ExtArgs> | null
    /**
     * Filter, which KpiHistorico to fetch.
     */
    where?: KpiHistoricoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiHistoricos to fetch.
     */
    orderBy?: KpiHistoricoOrderByWithRelationInput | KpiHistoricoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KpiHistoricos.
     */
    cursor?: KpiHistoricoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiHistoricos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiHistoricos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KpiHistoricos.
     */
    distinct?: KpiHistoricoScalarFieldEnum | KpiHistoricoScalarFieldEnum[]
  }

  /**
   * KpiHistorico findFirstOrThrow
   */
  export type KpiHistoricoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiHistorico
     */
    select?: KpiHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiHistoricoInclude<ExtArgs> | null
    /**
     * Filter, which KpiHistorico to fetch.
     */
    where?: KpiHistoricoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiHistoricos to fetch.
     */
    orderBy?: KpiHistoricoOrderByWithRelationInput | KpiHistoricoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KpiHistoricos.
     */
    cursor?: KpiHistoricoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiHistoricos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiHistoricos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KpiHistoricos.
     */
    distinct?: KpiHistoricoScalarFieldEnum | KpiHistoricoScalarFieldEnum[]
  }

  /**
   * KpiHistorico findMany
   */
  export type KpiHistoricoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiHistorico
     */
    select?: KpiHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiHistoricoInclude<ExtArgs> | null
    /**
     * Filter, which KpiHistoricos to fetch.
     */
    where?: KpiHistoricoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiHistoricos to fetch.
     */
    orderBy?: KpiHistoricoOrderByWithRelationInput | KpiHistoricoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KpiHistoricos.
     */
    cursor?: KpiHistoricoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiHistoricos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiHistoricos.
     */
    skip?: number
    distinct?: KpiHistoricoScalarFieldEnum | KpiHistoricoScalarFieldEnum[]
  }

  /**
   * KpiHistorico create
   */
  export type KpiHistoricoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiHistorico
     */
    select?: KpiHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiHistoricoInclude<ExtArgs> | null
    /**
     * The data needed to create a KpiHistorico.
     */
    data: XOR<KpiHistoricoCreateInput, KpiHistoricoUncheckedCreateInput>
  }

  /**
   * KpiHistorico createMany
   */
  export type KpiHistoricoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KpiHistoricos.
     */
    data: KpiHistoricoCreateManyInput | KpiHistoricoCreateManyInput[]
  }

  /**
   * KpiHistorico createManyAndReturn
   */
  export type KpiHistoricoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiHistorico
     */
    select?: KpiHistoricoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KpiHistoricos.
     */
    data: KpiHistoricoCreateManyInput | KpiHistoricoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiHistoricoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KpiHistorico update
   */
  export type KpiHistoricoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiHistorico
     */
    select?: KpiHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiHistoricoInclude<ExtArgs> | null
    /**
     * The data needed to update a KpiHistorico.
     */
    data: XOR<KpiHistoricoUpdateInput, KpiHistoricoUncheckedUpdateInput>
    /**
     * Choose, which KpiHistorico to update.
     */
    where: KpiHistoricoWhereUniqueInput
  }

  /**
   * KpiHistorico updateMany
   */
  export type KpiHistoricoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KpiHistoricos.
     */
    data: XOR<KpiHistoricoUpdateManyMutationInput, KpiHistoricoUncheckedUpdateManyInput>
    /**
     * Filter which KpiHistoricos to update
     */
    where?: KpiHistoricoWhereInput
  }

  /**
   * KpiHistorico upsert
   */
  export type KpiHistoricoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiHistorico
     */
    select?: KpiHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiHistoricoInclude<ExtArgs> | null
    /**
     * The filter to search for the KpiHistorico to update in case it exists.
     */
    where: KpiHistoricoWhereUniqueInput
    /**
     * In case the KpiHistorico found by the `where` argument doesn't exist, create a new KpiHistorico with this data.
     */
    create: XOR<KpiHistoricoCreateInput, KpiHistoricoUncheckedCreateInput>
    /**
     * In case the KpiHistorico was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KpiHistoricoUpdateInput, KpiHistoricoUncheckedUpdateInput>
  }

  /**
   * KpiHistorico delete
   */
  export type KpiHistoricoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiHistorico
     */
    select?: KpiHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiHistoricoInclude<ExtArgs> | null
    /**
     * Filter which KpiHistorico to delete.
     */
    where: KpiHistoricoWhereUniqueInput
  }

  /**
   * KpiHistorico deleteMany
   */
  export type KpiHistoricoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KpiHistoricos to delete
     */
    where?: KpiHistoricoWhereInput
  }

  /**
   * KpiHistorico.nodo
   */
  export type KpiHistorico$nodoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessNode
     */
    select?: ProcessNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessNodeInclude<ExtArgs> | null
    where?: ProcessNodeWhereInput
  }

  /**
   * KpiHistorico without action
   */
  export type KpiHistoricoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiHistorico
     */
    select?: KpiHistoricoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiHistoricoInclude<ExtArgs> | null
  }


  /**
   * Model DashboardConfig
   */

  export type AggregateDashboardConfig = {
    _count: DashboardConfigCountAggregateOutputType | null
    _avg: DashboardConfigAvgAggregateOutputType | null
    _sum: DashboardConfigSumAggregateOutputType | null
    _min: DashboardConfigMinAggregateOutputType | null
    _max: DashboardConfigMaxAggregateOutputType | null
  }

  export type DashboardConfigAvgAggregateOutputType = {
    columns: number | null
    rowHeight: number | null
    gap: number | null
  }

  export type DashboardConfigSumAggregateOutputType = {
    columns: number | null
    rowHeight: number | null
    gap: number | null
  }

  export type DashboardConfigMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    isDefault: boolean | null
    isLocked: boolean | null
    columns: number | null
    rowHeight: number | null
    gap: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type DashboardConfigMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    isDefault: boolean | null
    isLocked: boolean | null
    columns: number | null
    rowHeight: number | null
    gap: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type DashboardConfigCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    isDefault: number
    isLocked: number
    columns: number
    rowHeight: number
    gap: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type DashboardConfigAvgAggregateInputType = {
    columns?: true
    rowHeight?: true
    gap?: true
  }

  export type DashboardConfigSumAggregateInputType = {
    columns?: true
    rowHeight?: true
    gap?: true
  }

  export type DashboardConfigMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    isDefault?: true
    isLocked?: true
    columns?: true
    rowHeight?: true
    gap?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type DashboardConfigMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    isDefault?: true
    isLocked?: true
    columns?: true
    rowHeight?: true
    gap?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type DashboardConfigCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    isDefault?: true
    isLocked?: true
    columns?: true
    rowHeight?: true
    gap?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type DashboardConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardConfig to aggregate.
     */
    where?: DashboardConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardConfigs to fetch.
     */
    orderBy?: DashboardConfigOrderByWithRelationInput | DashboardConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DashboardConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardConfigs
    **/
    _count?: true | DashboardConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DashboardConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DashboardConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardConfigMaxAggregateInputType
  }

  export type GetDashboardConfigAggregateType<T extends DashboardConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardConfig[P]>
      : GetScalarType<T[P], AggregateDashboardConfig[P]>
  }




  export type DashboardConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardConfigWhereInput
    orderBy?: DashboardConfigOrderByWithAggregationInput | DashboardConfigOrderByWithAggregationInput[]
    by: DashboardConfigScalarFieldEnum[] | DashboardConfigScalarFieldEnum
    having?: DashboardConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardConfigCountAggregateInputType | true
    _avg?: DashboardConfigAvgAggregateInputType
    _sum?: DashboardConfigSumAggregateInputType
    _min?: DashboardConfigMinAggregateInputType
    _max?: DashboardConfigMaxAggregateInputType
  }

  export type DashboardConfigGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string | null
    isDefault: boolean
    isLocked: boolean
    columns: number
    rowHeight: number
    gap: number
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    _count: DashboardConfigCountAggregateOutputType | null
    _avg: DashboardConfigAvgAggregateOutputType | null
    _sum: DashboardConfigSumAggregateOutputType | null
    _min: DashboardConfigMinAggregateOutputType | null
    _max: DashboardConfigMaxAggregateOutputType | null
  }

  type GetDashboardConfigGroupByPayload<T extends DashboardConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DashboardConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardConfigGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardConfigGroupByOutputType[P]>
        }
      >
    >


  export type DashboardConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    isDefault?: boolean
    isLocked?: boolean
    columns?: boolean
    rowHeight?: boolean
    gap?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    widgets?: boolean | DashboardConfig$widgetsArgs<ExtArgs>
    _count?: boolean | DashboardConfigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardConfig"]>

  export type DashboardConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    isDefault?: boolean
    isLocked?: boolean
    columns?: boolean
    rowHeight?: boolean
    gap?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["dashboardConfig"]>

  export type DashboardConfigSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    isDefault?: boolean
    isLocked?: boolean
    columns?: boolean
    rowHeight?: boolean
    gap?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type DashboardConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    widgets?: boolean | DashboardConfig$widgetsArgs<ExtArgs>
    _count?: boolean | DashboardConfigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DashboardConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DashboardConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DashboardConfig"
    objects: {
      widgets: Prisma.$DashboardWidgetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      descripcion: string | null
      isDefault: boolean
      isLocked: boolean
      columns: number
      rowHeight: number
      gap: number
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["dashboardConfig"]>
    composites: {}
  }

  type DashboardConfigGetPayload<S extends boolean | null | undefined | DashboardConfigDefaultArgs> = $Result.GetResult<Prisma.$DashboardConfigPayload, S>

  type DashboardConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DashboardConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DashboardConfigCountAggregateInputType | true
    }

  export interface DashboardConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DashboardConfig'], meta: { name: 'DashboardConfig' } }
    /**
     * Find zero or one DashboardConfig that matches the filter.
     * @param {DashboardConfigFindUniqueArgs} args - Arguments to find a DashboardConfig
     * @example
     * // Get one DashboardConfig
     * const dashboardConfig = await prisma.dashboardConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DashboardConfigFindUniqueArgs>(args: SelectSubset<T, DashboardConfigFindUniqueArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DashboardConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DashboardConfigFindUniqueOrThrowArgs} args - Arguments to find a DashboardConfig
     * @example
     * // Get one DashboardConfig
     * const dashboardConfig = await prisma.dashboardConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DashboardConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, DashboardConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DashboardConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardConfigFindFirstArgs} args - Arguments to find a DashboardConfig
     * @example
     * // Get one DashboardConfig
     * const dashboardConfig = await prisma.dashboardConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DashboardConfigFindFirstArgs>(args?: SelectSubset<T, DashboardConfigFindFirstArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DashboardConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardConfigFindFirstOrThrowArgs} args - Arguments to find a DashboardConfig
     * @example
     * // Get one DashboardConfig
     * const dashboardConfig = await prisma.dashboardConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DashboardConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, DashboardConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DashboardConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardConfigs
     * const dashboardConfigs = await prisma.dashboardConfig.findMany()
     * 
     * // Get first 10 DashboardConfigs
     * const dashboardConfigs = await prisma.dashboardConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dashboardConfigWithIdOnly = await prisma.dashboardConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DashboardConfigFindManyArgs>(args?: SelectSubset<T, DashboardConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DashboardConfig.
     * @param {DashboardConfigCreateArgs} args - Arguments to create a DashboardConfig.
     * @example
     * // Create one DashboardConfig
     * const DashboardConfig = await prisma.dashboardConfig.create({
     *   data: {
     *     // ... data to create a DashboardConfig
     *   }
     * })
     * 
     */
    create<T extends DashboardConfigCreateArgs>(args: SelectSubset<T, DashboardConfigCreateArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DashboardConfigs.
     * @param {DashboardConfigCreateManyArgs} args - Arguments to create many DashboardConfigs.
     * @example
     * // Create many DashboardConfigs
     * const dashboardConfig = await prisma.dashboardConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DashboardConfigCreateManyArgs>(args?: SelectSubset<T, DashboardConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DashboardConfigs and returns the data saved in the database.
     * @param {DashboardConfigCreateManyAndReturnArgs} args - Arguments to create many DashboardConfigs.
     * @example
     * // Create many DashboardConfigs
     * const dashboardConfig = await prisma.dashboardConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DashboardConfigs and only return the `id`
     * const dashboardConfigWithIdOnly = await prisma.dashboardConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DashboardConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, DashboardConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DashboardConfig.
     * @param {DashboardConfigDeleteArgs} args - Arguments to delete one DashboardConfig.
     * @example
     * // Delete one DashboardConfig
     * const DashboardConfig = await prisma.dashboardConfig.delete({
     *   where: {
     *     // ... filter to delete one DashboardConfig
     *   }
     * })
     * 
     */
    delete<T extends DashboardConfigDeleteArgs>(args: SelectSubset<T, DashboardConfigDeleteArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DashboardConfig.
     * @param {DashboardConfigUpdateArgs} args - Arguments to update one DashboardConfig.
     * @example
     * // Update one DashboardConfig
     * const dashboardConfig = await prisma.dashboardConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DashboardConfigUpdateArgs>(args: SelectSubset<T, DashboardConfigUpdateArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DashboardConfigs.
     * @param {DashboardConfigDeleteManyArgs} args - Arguments to filter DashboardConfigs to delete.
     * @example
     * // Delete a few DashboardConfigs
     * const { count } = await prisma.dashboardConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DashboardConfigDeleteManyArgs>(args?: SelectSubset<T, DashboardConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardConfigs
     * const dashboardConfig = await prisma.dashboardConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DashboardConfigUpdateManyArgs>(args: SelectSubset<T, DashboardConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DashboardConfig.
     * @param {DashboardConfigUpsertArgs} args - Arguments to update or create a DashboardConfig.
     * @example
     * // Update or create a DashboardConfig
     * const dashboardConfig = await prisma.dashboardConfig.upsert({
     *   create: {
     *     // ... data to create a DashboardConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardConfig we want to update
     *   }
     * })
     */
    upsert<T extends DashboardConfigUpsertArgs>(args: SelectSubset<T, DashboardConfigUpsertArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DashboardConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardConfigCountArgs} args - Arguments to filter DashboardConfigs to count.
     * @example
     * // Count the number of DashboardConfigs
     * const count = await prisma.dashboardConfig.count({
     *   where: {
     *     // ... the filter for the DashboardConfigs we want to count
     *   }
     * })
    **/
    count<T extends DashboardConfigCountArgs>(
      args?: Subset<T, DashboardConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardConfigAggregateArgs>(args: Subset<T, DashboardConfigAggregateArgs>): Prisma.PrismaPromise<GetDashboardConfigAggregateType<T>>

    /**
     * Group by DashboardConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardConfigGroupByArgs['orderBy'] }
        : { orderBy?: DashboardConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DashboardConfig model
   */
  readonly fields: DashboardConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DashboardConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    widgets<T extends DashboardConfig$widgetsArgs<ExtArgs> = {}>(args?: Subset<T, DashboardConfig$widgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardWidgetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DashboardConfig model
   */ 
  interface DashboardConfigFieldRefs {
    readonly id: FieldRef<"DashboardConfig", 'String'>
    readonly nombre: FieldRef<"DashboardConfig", 'String'>
    readonly descripcion: FieldRef<"DashboardConfig", 'String'>
    readonly isDefault: FieldRef<"DashboardConfig", 'Boolean'>
    readonly isLocked: FieldRef<"DashboardConfig", 'Boolean'>
    readonly columns: FieldRef<"DashboardConfig", 'Int'>
    readonly rowHeight: FieldRef<"DashboardConfig", 'Int'>
    readonly gap: FieldRef<"DashboardConfig", 'Int'>
    readonly createdAt: FieldRef<"DashboardConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"DashboardConfig", 'DateTime'>
    readonly createdBy: FieldRef<"DashboardConfig", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DashboardConfig findUnique
   */
  export type DashboardConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * Filter, which DashboardConfig to fetch.
     */
    where: DashboardConfigWhereUniqueInput
  }

  /**
   * DashboardConfig findUniqueOrThrow
   */
  export type DashboardConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * Filter, which DashboardConfig to fetch.
     */
    where: DashboardConfigWhereUniqueInput
  }

  /**
   * DashboardConfig findFirst
   */
  export type DashboardConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * Filter, which DashboardConfig to fetch.
     */
    where?: DashboardConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardConfigs to fetch.
     */
    orderBy?: DashboardConfigOrderByWithRelationInput | DashboardConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardConfigs.
     */
    cursor?: DashboardConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardConfigs.
     */
    distinct?: DashboardConfigScalarFieldEnum | DashboardConfigScalarFieldEnum[]
  }

  /**
   * DashboardConfig findFirstOrThrow
   */
  export type DashboardConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * Filter, which DashboardConfig to fetch.
     */
    where?: DashboardConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardConfigs to fetch.
     */
    orderBy?: DashboardConfigOrderByWithRelationInput | DashboardConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardConfigs.
     */
    cursor?: DashboardConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardConfigs.
     */
    distinct?: DashboardConfigScalarFieldEnum | DashboardConfigScalarFieldEnum[]
  }

  /**
   * DashboardConfig findMany
   */
  export type DashboardConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * Filter, which DashboardConfigs to fetch.
     */
    where?: DashboardConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardConfigs to fetch.
     */
    orderBy?: DashboardConfigOrderByWithRelationInput | DashboardConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardConfigs.
     */
    cursor?: DashboardConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardConfigs.
     */
    skip?: number
    distinct?: DashboardConfigScalarFieldEnum | DashboardConfigScalarFieldEnum[]
  }

  /**
   * DashboardConfig create
   */
  export type DashboardConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a DashboardConfig.
     */
    data: XOR<DashboardConfigCreateInput, DashboardConfigUncheckedCreateInput>
  }

  /**
   * DashboardConfig createMany
   */
  export type DashboardConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DashboardConfigs.
     */
    data: DashboardConfigCreateManyInput | DashboardConfigCreateManyInput[]
  }

  /**
   * DashboardConfig createManyAndReturn
   */
  export type DashboardConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DashboardConfigs.
     */
    data: DashboardConfigCreateManyInput | DashboardConfigCreateManyInput[]
  }

  /**
   * DashboardConfig update
   */
  export type DashboardConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a DashboardConfig.
     */
    data: XOR<DashboardConfigUpdateInput, DashboardConfigUncheckedUpdateInput>
    /**
     * Choose, which DashboardConfig to update.
     */
    where: DashboardConfigWhereUniqueInput
  }

  /**
   * DashboardConfig updateMany
   */
  export type DashboardConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DashboardConfigs.
     */
    data: XOR<DashboardConfigUpdateManyMutationInput, DashboardConfigUncheckedUpdateManyInput>
    /**
     * Filter which DashboardConfigs to update
     */
    where?: DashboardConfigWhereInput
  }

  /**
   * DashboardConfig upsert
   */
  export type DashboardConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the DashboardConfig to update in case it exists.
     */
    where: DashboardConfigWhereUniqueInput
    /**
     * In case the DashboardConfig found by the `where` argument doesn't exist, create a new DashboardConfig with this data.
     */
    create: XOR<DashboardConfigCreateInput, DashboardConfigUncheckedCreateInput>
    /**
     * In case the DashboardConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DashboardConfigUpdateInput, DashboardConfigUncheckedUpdateInput>
  }

  /**
   * DashboardConfig delete
   */
  export type DashboardConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
    /**
     * Filter which DashboardConfig to delete.
     */
    where: DashboardConfigWhereUniqueInput
  }

  /**
   * DashboardConfig deleteMany
   */
  export type DashboardConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardConfigs to delete
     */
    where?: DashboardConfigWhereInput
  }

  /**
   * DashboardConfig.widgets
   */
  export type DashboardConfig$widgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardWidget
     */
    select?: DashboardWidgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardWidgetInclude<ExtArgs> | null
    where?: DashboardWidgetWhereInput
    orderBy?: DashboardWidgetOrderByWithRelationInput | DashboardWidgetOrderByWithRelationInput[]
    cursor?: DashboardWidgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DashboardWidgetScalarFieldEnum | DashboardWidgetScalarFieldEnum[]
  }

  /**
   * DashboardConfig without action
   */
  export type DashboardConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardConfig
     */
    select?: DashboardConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardConfigInclude<ExtArgs> | null
  }


  /**
   * Model DashboardWidget
   */

  export type AggregateDashboardWidget = {
    _count: DashboardWidgetCountAggregateOutputType | null
    _avg: DashboardWidgetAvgAggregateOutputType | null
    _sum: DashboardWidgetSumAggregateOutputType | null
    _min: DashboardWidgetMinAggregateOutputType | null
    _max: DashboardWidgetMaxAggregateOutputType | null
  }

  export type DashboardWidgetAvgAggregateOutputType = {
    x: number | null
    y: number | null
    cols: number | null
    rows: number | null
  }

  export type DashboardWidgetSumAggregateOutputType = {
    x: number | null
    y: number | null
    cols: number | null
    rows: number | null
  }

  export type DashboardWidgetMinAggregateOutputType = {
    id: string | null
    dashboardId: string | null
    tipo: string | null
    titulo: string | null
    subtitulo: string | null
    icono: string | null
    config: string | null
    x: number | null
    y: number | null
    cols: number | null
    rows: number | null
    canResize: boolean | null
    canDrag: boolean | null
    canRemove: boolean | null
    canEdit: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DashboardWidgetMaxAggregateOutputType = {
    id: string | null
    dashboardId: string | null
    tipo: string | null
    titulo: string | null
    subtitulo: string | null
    icono: string | null
    config: string | null
    x: number | null
    y: number | null
    cols: number | null
    rows: number | null
    canResize: boolean | null
    canDrag: boolean | null
    canRemove: boolean | null
    canEdit: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DashboardWidgetCountAggregateOutputType = {
    id: number
    dashboardId: number
    tipo: number
    titulo: number
    subtitulo: number
    icono: number
    config: number
    x: number
    y: number
    cols: number
    rows: number
    canResize: number
    canDrag: number
    canRemove: number
    canEdit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DashboardWidgetAvgAggregateInputType = {
    x?: true
    y?: true
    cols?: true
    rows?: true
  }

  export type DashboardWidgetSumAggregateInputType = {
    x?: true
    y?: true
    cols?: true
    rows?: true
  }

  export type DashboardWidgetMinAggregateInputType = {
    id?: true
    dashboardId?: true
    tipo?: true
    titulo?: true
    subtitulo?: true
    icono?: true
    config?: true
    x?: true
    y?: true
    cols?: true
    rows?: true
    canResize?: true
    canDrag?: true
    canRemove?: true
    canEdit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DashboardWidgetMaxAggregateInputType = {
    id?: true
    dashboardId?: true
    tipo?: true
    titulo?: true
    subtitulo?: true
    icono?: true
    config?: true
    x?: true
    y?: true
    cols?: true
    rows?: true
    canResize?: true
    canDrag?: true
    canRemove?: true
    canEdit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DashboardWidgetCountAggregateInputType = {
    id?: true
    dashboardId?: true
    tipo?: true
    titulo?: true
    subtitulo?: true
    icono?: true
    config?: true
    x?: true
    y?: true
    cols?: true
    rows?: true
    canResize?: true
    canDrag?: true
    canRemove?: true
    canEdit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DashboardWidgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardWidget to aggregate.
     */
    where?: DashboardWidgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardWidgets to fetch.
     */
    orderBy?: DashboardWidgetOrderByWithRelationInput | DashboardWidgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DashboardWidgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardWidgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardWidgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardWidgets
    **/
    _count?: true | DashboardWidgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DashboardWidgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DashboardWidgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardWidgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardWidgetMaxAggregateInputType
  }

  export type GetDashboardWidgetAggregateType<T extends DashboardWidgetAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardWidget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardWidget[P]>
      : GetScalarType<T[P], AggregateDashboardWidget[P]>
  }




  export type DashboardWidgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardWidgetWhereInput
    orderBy?: DashboardWidgetOrderByWithAggregationInput | DashboardWidgetOrderByWithAggregationInput[]
    by: DashboardWidgetScalarFieldEnum[] | DashboardWidgetScalarFieldEnum
    having?: DashboardWidgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardWidgetCountAggregateInputType | true
    _avg?: DashboardWidgetAvgAggregateInputType
    _sum?: DashboardWidgetSumAggregateInputType
    _min?: DashboardWidgetMinAggregateInputType
    _max?: DashboardWidgetMaxAggregateInputType
  }

  export type DashboardWidgetGroupByOutputType = {
    id: string
    dashboardId: string
    tipo: string
    titulo: string
    subtitulo: string | null
    icono: string | null
    config: string
    x: number
    y: number
    cols: number
    rows: number
    canResize: boolean
    canDrag: boolean
    canRemove: boolean
    canEdit: boolean
    createdAt: Date
    updatedAt: Date
    _count: DashboardWidgetCountAggregateOutputType | null
    _avg: DashboardWidgetAvgAggregateOutputType | null
    _sum: DashboardWidgetSumAggregateOutputType | null
    _min: DashboardWidgetMinAggregateOutputType | null
    _max: DashboardWidgetMaxAggregateOutputType | null
  }

  type GetDashboardWidgetGroupByPayload<T extends DashboardWidgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DashboardWidgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardWidgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardWidgetGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardWidgetGroupByOutputType[P]>
        }
      >
    >


  export type DashboardWidgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dashboardId?: boolean
    tipo?: boolean
    titulo?: boolean
    subtitulo?: boolean
    icono?: boolean
    config?: boolean
    x?: boolean
    y?: boolean
    cols?: boolean
    rows?: boolean
    canResize?: boolean
    canDrag?: boolean
    canRemove?: boolean
    canEdit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dashboard?: boolean | DashboardConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardWidget"]>

  export type DashboardWidgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dashboardId?: boolean
    tipo?: boolean
    titulo?: boolean
    subtitulo?: boolean
    icono?: boolean
    config?: boolean
    x?: boolean
    y?: boolean
    cols?: boolean
    rows?: boolean
    canResize?: boolean
    canDrag?: boolean
    canRemove?: boolean
    canEdit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dashboard?: boolean | DashboardConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardWidget"]>

  export type DashboardWidgetSelectScalar = {
    id?: boolean
    dashboardId?: boolean
    tipo?: boolean
    titulo?: boolean
    subtitulo?: boolean
    icono?: boolean
    config?: boolean
    x?: boolean
    y?: boolean
    cols?: boolean
    rows?: boolean
    canResize?: boolean
    canDrag?: boolean
    canRemove?: boolean
    canEdit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DashboardWidgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardConfigDefaultArgs<ExtArgs>
  }
  export type DashboardWidgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardConfigDefaultArgs<ExtArgs>
  }

  export type $DashboardWidgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DashboardWidget"
    objects: {
      dashboard: Prisma.$DashboardConfigPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dashboardId: string
      tipo: string
      titulo: string
      subtitulo: string | null
      icono: string | null
      config: string
      x: number
      y: number
      cols: number
      rows: number
      canResize: boolean
      canDrag: boolean
      canRemove: boolean
      canEdit: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dashboardWidget"]>
    composites: {}
  }

  type DashboardWidgetGetPayload<S extends boolean | null | undefined | DashboardWidgetDefaultArgs> = $Result.GetResult<Prisma.$DashboardWidgetPayload, S>

  type DashboardWidgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DashboardWidgetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DashboardWidgetCountAggregateInputType | true
    }

  export interface DashboardWidgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DashboardWidget'], meta: { name: 'DashboardWidget' } }
    /**
     * Find zero or one DashboardWidget that matches the filter.
     * @param {DashboardWidgetFindUniqueArgs} args - Arguments to find a DashboardWidget
     * @example
     * // Get one DashboardWidget
     * const dashboardWidget = await prisma.dashboardWidget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DashboardWidgetFindUniqueArgs>(args: SelectSubset<T, DashboardWidgetFindUniqueArgs<ExtArgs>>): Prisma__DashboardWidgetClient<$Result.GetResult<Prisma.$DashboardWidgetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DashboardWidget that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DashboardWidgetFindUniqueOrThrowArgs} args - Arguments to find a DashboardWidget
     * @example
     * // Get one DashboardWidget
     * const dashboardWidget = await prisma.dashboardWidget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DashboardWidgetFindUniqueOrThrowArgs>(args: SelectSubset<T, DashboardWidgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DashboardWidgetClient<$Result.GetResult<Prisma.$DashboardWidgetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DashboardWidget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetFindFirstArgs} args - Arguments to find a DashboardWidget
     * @example
     * // Get one DashboardWidget
     * const dashboardWidget = await prisma.dashboardWidget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DashboardWidgetFindFirstArgs>(args?: SelectSubset<T, DashboardWidgetFindFirstArgs<ExtArgs>>): Prisma__DashboardWidgetClient<$Result.GetResult<Prisma.$DashboardWidgetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DashboardWidget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetFindFirstOrThrowArgs} args - Arguments to find a DashboardWidget
     * @example
     * // Get one DashboardWidget
     * const dashboardWidget = await prisma.dashboardWidget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DashboardWidgetFindFirstOrThrowArgs>(args?: SelectSubset<T, DashboardWidgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__DashboardWidgetClient<$Result.GetResult<Prisma.$DashboardWidgetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DashboardWidgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardWidgets
     * const dashboardWidgets = await prisma.dashboardWidget.findMany()
     * 
     * // Get first 10 DashboardWidgets
     * const dashboardWidgets = await prisma.dashboardWidget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dashboardWidgetWithIdOnly = await prisma.dashboardWidget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DashboardWidgetFindManyArgs>(args?: SelectSubset<T, DashboardWidgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardWidgetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DashboardWidget.
     * @param {DashboardWidgetCreateArgs} args - Arguments to create a DashboardWidget.
     * @example
     * // Create one DashboardWidget
     * const DashboardWidget = await prisma.dashboardWidget.create({
     *   data: {
     *     // ... data to create a DashboardWidget
     *   }
     * })
     * 
     */
    create<T extends DashboardWidgetCreateArgs>(args: SelectSubset<T, DashboardWidgetCreateArgs<ExtArgs>>): Prisma__DashboardWidgetClient<$Result.GetResult<Prisma.$DashboardWidgetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DashboardWidgets.
     * @param {DashboardWidgetCreateManyArgs} args - Arguments to create many DashboardWidgets.
     * @example
     * // Create many DashboardWidgets
     * const dashboardWidget = await prisma.dashboardWidget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DashboardWidgetCreateManyArgs>(args?: SelectSubset<T, DashboardWidgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DashboardWidgets and returns the data saved in the database.
     * @param {DashboardWidgetCreateManyAndReturnArgs} args - Arguments to create many DashboardWidgets.
     * @example
     * // Create many DashboardWidgets
     * const dashboardWidget = await prisma.dashboardWidget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DashboardWidgets and only return the `id`
     * const dashboardWidgetWithIdOnly = await prisma.dashboardWidget.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DashboardWidgetCreateManyAndReturnArgs>(args?: SelectSubset<T, DashboardWidgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardWidgetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DashboardWidget.
     * @param {DashboardWidgetDeleteArgs} args - Arguments to delete one DashboardWidget.
     * @example
     * // Delete one DashboardWidget
     * const DashboardWidget = await prisma.dashboardWidget.delete({
     *   where: {
     *     // ... filter to delete one DashboardWidget
     *   }
     * })
     * 
     */
    delete<T extends DashboardWidgetDeleteArgs>(args: SelectSubset<T, DashboardWidgetDeleteArgs<ExtArgs>>): Prisma__DashboardWidgetClient<$Result.GetResult<Prisma.$DashboardWidgetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DashboardWidget.
     * @param {DashboardWidgetUpdateArgs} args - Arguments to update one DashboardWidget.
     * @example
     * // Update one DashboardWidget
     * const dashboardWidget = await prisma.dashboardWidget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DashboardWidgetUpdateArgs>(args: SelectSubset<T, DashboardWidgetUpdateArgs<ExtArgs>>): Prisma__DashboardWidgetClient<$Result.GetResult<Prisma.$DashboardWidgetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DashboardWidgets.
     * @param {DashboardWidgetDeleteManyArgs} args - Arguments to filter DashboardWidgets to delete.
     * @example
     * // Delete a few DashboardWidgets
     * const { count } = await prisma.dashboardWidget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DashboardWidgetDeleteManyArgs>(args?: SelectSubset<T, DashboardWidgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardWidgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardWidgets
     * const dashboardWidget = await prisma.dashboardWidget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DashboardWidgetUpdateManyArgs>(args: SelectSubset<T, DashboardWidgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DashboardWidget.
     * @param {DashboardWidgetUpsertArgs} args - Arguments to update or create a DashboardWidget.
     * @example
     * // Update or create a DashboardWidget
     * const dashboardWidget = await prisma.dashboardWidget.upsert({
     *   create: {
     *     // ... data to create a DashboardWidget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardWidget we want to update
     *   }
     * })
     */
    upsert<T extends DashboardWidgetUpsertArgs>(args: SelectSubset<T, DashboardWidgetUpsertArgs<ExtArgs>>): Prisma__DashboardWidgetClient<$Result.GetResult<Prisma.$DashboardWidgetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DashboardWidgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetCountArgs} args - Arguments to filter DashboardWidgets to count.
     * @example
     * // Count the number of DashboardWidgets
     * const count = await prisma.dashboardWidget.count({
     *   where: {
     *     // ... the filter for the DashboardWidgets we want to count
     *   }
     * })
    **/
    count<T extends DashboardWidgetCountArgs>(
      args?: Subset<T, DashboardWidgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardWidgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardWidget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardWidgetAggregateArgs>(args: Subset<T, DashboardWidgetAggregateArgs>): Prisma.PrismaPromise<GetDashboardWidgetAggregateType<T>>

    /**
     * Group by DashboardWidget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardWidgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardWidgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardWidgetGroupByArgs['orderBy'] }
        : { orderBy?: DashboardWidgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardWidgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardWidgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DashboardWidget model
   */
  readonly fields: DashboardWidgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardWidget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DashboardWidgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dashboard<T extends DashboardConfigDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DashboardConfigDefaultArgs<ExtArgs>>): Prisma__DashboardConfigClient<$Result.GetResult<Prisma.$DashboardConfigPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DashboardWidget model
   */ 
  interface DashboardWidgetFieldRefs {
    readonly id: FieldRef<"DashboardWidget", 'String'>
    readonly dashboardId: FieldRef<"DashboardWidget", 'String'>
    readonly tipo: FieldRef<"DashboardWidget", 'String'>
    readonly titulo: FieldRef<"DashboardWidget", 'String'>
    readonly subtitulo: FieldRef<"DashboardWidget", 'String'>
    readonly icono: FieldRef<"DashboardWidget", 'String'>
    readonly config: FieldRef<"DashboardWidget", 'String'>
    readonly x: FieldRef<"DashboardWidget", 'Int'>
    readonly y: FieldRef<"DashboardWidget", 'Int'>
    readonly cols: FieldRef<"DashboardWidget", 'Int'>
    readonly rows: FieldRef<"DashboardWidget", 'Int'>
    readonly canResize: FieldRef<"DashboardWidget", 'Boolean'>
    readonly canDrag: FieldRef<"DashboardWidget", 'Boolean'>
    readonly canRemove: FieldRef<"DashboardWidget", 'Boolean'>
    readonly canEdit: FieldRef<"DashboardWidget", 'Boolean'>
    readonly createdAt: FieldRef<"DashboardWidget", 'DateTime'>
    readonly updatedAt: FieldRef<"DashboardWidget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DashboardWidget findUnique
   */
  export type DashboardWidgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardWidget
     */
    select?: DashboardWidgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardWidgetInclude<ExtArgs> | null
    /**
     * Filter, which DashboardWidget to fetch.
     */
    where: DashboardWidgetWhereUniqueInput
  }

  /**
   * DashboardWidget findUniqueOrThrow
   */
  export type DashboardWidgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardWidget
     */
    select?: DashboardWidgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardWidgetInclude<ExtArgs> | null
    /**
     * Filter, which DashboardWidget to fetch.
     */
    where: DashboardWidgetWhereUniqueInput
  }

  /**
   * DashboardWidget findFirst
   */
  export type DashboardWidgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardWidget
     */
    select?: DashboardWidgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardWidgetInclude<ExtArgs> | null
    /**
     * Filter, which DashboardWidget to fetch.
     */
    where?: DashboardWidgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardWidgets to fetch.
     */
    orderBy?: DashboardWidgetOrderByWithRelationInput | DashboardWidgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardWidgets.
     */
    cursor?: DashboardWidgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardWidgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardWidgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardWidgets.
     */
    distinct?: DashboardWidgetScalarFieldEnum | DashboardWidgetScalarFieldEnum[]
  }

  /**
   * DashboardWidget findFirstOrThrow
   */
  export type DashboardWidgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardWidget
     */
    select?: DashboardWidgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardWidgetInclude<ExtArgs> | null
    /**
     * Filter, which DashboardWidget to fetch.
     */
    where?: DashboardWidgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardWidgets to fetch.
     */
    orderBy?: DashboardWidgetOrderByWithRelationInput | DashboardWidgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardWidgets.
     */
    cursor?: DashboardWidgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardWidgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardWidgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardWidgets.
     */
    distinct?: DashboardWidgetScalarFieldEnum | DashboardWidgetScalarFieldEnum[]
  }

  /**
   * DashboardWidget findMany
   */
  export type DashboardWidgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardWidget
     */
    select?: DashboardWidgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardWidgetInclude<ExtArgs> | null
    /**
     * Filter, which DashboardWidgets to fetch.
     */
    where?: DashboardWidgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardWidgets to fetch.
     */
    orderBy?: DashboardWidgetOrderByWithRelationInput | DashboardWidgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardWidgets.
     */
    cursor?: DashboardWidgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardWidgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardWidgets.
     */
    skip?: number
    distinct?: DashboardWidgetScalarFieldEnum | DashboardWidgetScalarFieldEnum[]
  }

  /**
   * DashboardWidget create
   */
  export type DashboardWidgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardWidget
     */
    select?: DashboardWidgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardWidgetInclude<ExtArgs> | null
    /**
     * The data needed to create a DashboardWidget.
     */
    data: XOR<DashboardWidgetCreateInput, DashboardWidgetUncheckedCreateInput>
  }

  /**
   * DashboardWidget createMany
   */
  export type DashboardWidgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DashboardWidgets.
     */
    data: DashboardWidgetCreateManyInput | DashboardWidgetCreateManyInput[]
  }

  /**
   * DashboardWidget createManyAndReturn
   */
  export type DashboardWidgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardWidget
     */
    select?: DashboardWidgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DashboardWidgets.
     */
    data: DashboardWidgetCreateManyInput | DashboardWidgetCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardWidgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DashboardWidget update
   */
  export type DashboardWidgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardWidget
     */
    select?: DashboardWidgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardWidgetInclude<ExtArgs> | null
    /**
     * The data needed to update a DashboardWidget.
     */
    data: XOR<DashboardWidgetUpdateInput, DashboardWidgetUncheckedUpdateInput>
    /**
     * Choose, which DashboardWidget to update.
     */
    where: DashboardWidgetWhereUniqueInput
  }

  /**
   * DashboardWidget updateMany
   */
  export type DashboardWidgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DashboardWidgets.
     */
    data: XOR<DashboardWidgetUpdateManyMutationInput, DashboardWidgetUncheckedUpdateManyInput>
    /**
     * Filter which DashboardWidgets to update
     */
    where?: DashboardWidgetWhereInput
  }

  /**
   * DashboardWidget upsert
   */
  export type DashboardWidgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardWidget
     */
    select?: DashboardWidgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardWidgetInclude<ExtArgs> | null
    /**
     * The filter to search for the DashboardWidget to update in case it exists.
     */
    where: DashboardWidgetWhereUniqueInput
    /**
     * In case the DashboardWidget found by the `where` argument doesn't exist, create a new DashboardWidget with this data.
     */
    create: XOR<DashboardWidgetCreateInput, DashboardWidgetUncheckedCreateInput>
    /**
     * In case the DashboardWidget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DashboardWidgetUpdateInput, DashboardWidgetUncheckedUpdateInput>
  }

  /**
   * DashboardWidget delete
   */
  export type DashboardWidgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardWidget
     */
    select?: DashboardWidgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardWidgetInclude<ExtArgs> | null
    /**
     * Filter which DashboardWidget to delete.
     */
    where: DashboardWidgetWhereUniqueInput
  }

  /**
   * DashboardWidget deleteMany
   */
  export type DashboardWidgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardWidgets to delete
     */
    where?: DashboardWidgetWhereInput
  }

  /**
   * DashboardWidget without action
   */
  export type DashboardWidgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardWidget
     */
    select?: DashboardWidgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardWidgetInclude<ExtArgs> | null
  }


  /**
   * Model Catalogo
   */

  export type AggregateCatalogo = {
    _count: CatalogoCountAggregateOutputType | null
    _avg: CatalogoAvgAggregateOutputType | null
    _sum: CatalogoSumAggregateOutputType | null
    _min: CatalogoMinAggregateOutputType | null
    _max: CatalogoMaxAggregateOutputType | null
  }

  export type CatalogoAvgAggregateOutputType = {
    orden: number | null
  }

  export type CatalogoSumAggregateOutputType = {
    orden: number | null
  }

  export type CatalogoMinAggregateOutputType = {
    id: string | null
    tipo: string | null
    codigo: string | null
    nombre: string | null
    descripcion: string | null
    orden: number | null
    activo: boolean | null
    color: string | null
    icono: string | null
    metadata: string | null
  }

  export type CatalogoMaxAggregateOutputType = {
    id: string | null
    tipo: string | null
    codigo: string | null
    nombre: string | null
    descripcion: string | null
    orden: number | null
    activo: boolean | null
    color: string | null
    icono: string | null
    metadata: string | null
  }

  export type CatalogoCountAggregateOutputType = {
    id: number
    tipo: number
    codigo: number
    nombre: number
    descripcion: number
    orden: number
    activo: number
    color: number
    icono: number
    metadata: number
    _all: number
  }


  export type CatalogoAvgAggregateInputType = {
    orden?: true
  }

  export type CatalogoSumAggregateInputType = {
    orden?: true
  }

  export type CatalogoMinAggregateInputType = {
    id?: true
    tipo?: true
    codigo?: true
    nombre?: true
    descripcion?: true
    orden?: true
    activo?: true
    color?: true
    icono?: true
    metadata?: true
  }

  export type CatalogoMaxAggregateInputType = {
    id?: true
    tipo?: true
    codigo?: true
    nombre?: true
    descripcion?: true
    orden?: true
    activo?: true
    color?: true
    icono?: true
    metadata?: true
  }

  export type CatalogoCountAggregateInputType = {
    id?: true
    tipo?: true
    codigo?: true
    nombre?: true
    descripcion?: true
    orden?: true
    activo?: true
    color?: true
    icono?: true
    metadata?: true
    _all?: true
  }

  export type CatalogoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Catalogo to aggregate.
     */
    where?: CatalogoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Catalogos to fetch.
     */
    orderBy?: CatalogoOrderByWithRelationInput | CatalogoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Catalogos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Catalogos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Catalogos
    **/
    _count?: true | CatalogoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogoMaxAggregateInputType
  }

  export type GetCatalogoAggregateType<T extends CatalogoAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogo[P]>
      : GetScalarType<T[P], AggregateCatalogo[P]>
  }




  export type CatalogoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogoWhereInput
    orderBy?: CatalogoOrderByWithAggregationInput | CatalogoOrderByWithAggregationInput[]
    by: CatalogoScalarFieldEnum[] | CatalogoScalarFieldEnum
    having?: CatalogoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogoCountAggregateInputType | true
    _avg?: CatalogoAvgAggregateInputType
    _sum?: CatalogoSumAggregateInputType
    _min?: CatalogoMinAggregateInputType
    _max?: CatalogoMaxAggregateInputType
  }

  export type CatalogoGroupByOutputType = {
    id: string
    tipo: string
    codigo: string
    nombre: string
    descripcion: string | null
    orden: number
    activo: boolean
    color: string | null
    icono: string | null
    metadata: string | null
    _count: CatalogoCountAggregateOutputType | null
    _avg: CatalogoAvgAggregateOutputType | null
    _sum: CatalogoSumAggregateOutputType | null
    _min: CatalogoMinAggregateOutputType | null
    _max: CatalogoMaxAggregateOutputType | null
  }

  type GetCatalogoGroupByPayload<T extends CatalogoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogoGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogoGroupByOutputType[P]>
        }
      >
    >


  export type CatalogoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    orden?: boolean
    activo?: boolean
    color?: boolean
    icono?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["catalogo"]>

  export type CatalogoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    orden?: boolean
    activo?: boolean
    color?: boolean
    icono?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["catalogo"]>

  export type CatalogoSelectScalar = {
    id?: boolean
    tipo?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    orden?: boolean
    activo?: boolean
    color?: boolean
    icono?: boolean
    metadata?: boolean
  }


  export type $CatalogoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Catalogo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tipo: string
      codigo: string
      nombre: string
      descripcion: string | null
      orden: number
      activo: boolean
      color: string | null
      icono: string | null
      metadata: string | null
    }, ExtArgs["result"]["catalogo"]>
    composites: {}
  }

  type CatalogoGetPayload<S extends boolean | null | undefined | CatalogoDefaultArgs> = $Result.GetResult<Prisma.$CatalogoPayload, S>

  type CatalogoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogoCountAggregateInputType | true
    }

  export interface CatalogoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Catalogo'], meta: { name: 'Catalogo' } }
    /**
     * Find zero or one Catalogo that matches the filter.
     * @param {CatalogoFindUniqueArgs} args - Arguments to find a Catalogo
     * @example
     * // Get one Catalogo
     * const catalogo = await prisma.catalogo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatalogoFindUniqueArgs>(args: SelectSubset<T, CatalogoFindUniqueArgs<ExtArgs>>): Prisma__CatalogoClient<$Result.GetResult<Prisma.$CatalogoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Catalogo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogoFindUniqueOrThrowArgs} args - Arguments to find a Catalogo
     * @example
     * // Get one Catalogo
     * const catalogo = await prisma.catalogo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatalogoFindUniqueOrThrowArgs>(args: SelectSubset<T, CatalogoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatalogoClient<$Result.GetResult<Prisma.$CatalogoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Catalogo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoFindFirstArgs} args - Arguments to find a Catalogo
     * @example
     * // Get one Catalogo
     * const catalogo = await prisma.catalogo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatalogoFindFirstArgs>(args?: SelectSubset<T, CatalogoFindFirstArgs<ExtArgs>>): Prisma__CatalogoClient<$Result.GetResult<Prisma.$CatalogoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Catalogo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoFindFirstOrThrowArgs} args - Arguments to find a Catalogo
     * @example
     * // Get one Catalogo
     * const catalogo = await prisma.catalogo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatalogoFindFirstOrThrowArgs>(args?: SelectSubset<T, CatalogoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatalogoClient<$Result.GetResult<Prisma.$CatalogoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Catalogos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Catalogos
     * const catalogos = await prisma.catalogo.findMany()
     * 
     * // Get first 10 Catalogos
     * const catalogos = await prisma.catalogo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogoWithIdOnly = await prisma.catalogo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatalogoFindManyArgs>(args?: SelectSubset<T, CatalogoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Catalogo.
     * @param {CatalogoCreateArgs} args - Arguments to create a Catalogo.
     * @example
     * // Create one Catalogo
     * const Catalogo = await prisma.catalogo.create({
     *   data: {
     *     // ... data to create a Catalogo
     *   }
     * })
     * 
     */
    create<T extends CatalogoCreateArgs>(args: SelectSubset<T, CatalogoCreateArgs<ExtArgs>>): Prisma__CatalogoClient<$Result.GetResult<Prisma.$CatalogoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Catalogos.
     * @param {CatalogoCreateManyArgs} args - Arguments to create many Catalogos.
     * @example
     * // Create many Catalogos
     * const catalogo = await prisma.catalogo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatalogoCreateManyArgs>(args?: SelectSubset<T, CatalogoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Catalogos and returns the data saved in the database.
     * @param {CatalogoCreateManyAndReturnArgs} args - Arguments to create many Catalogos.
     * @example
     * // Create many Catalogos
     * const catalogo = await prisma.catalogo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Catalogos and only return the `id`
     * const catalogoWithIdOnly = await prisma.catalogo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatalogoCreateManyAndReturnArgs>(args?: SelectSubset<T, CatalogoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Catalogo.
     * @param {CatalogoDeleteArgs} args - Arguments to delete one Catalogo.
     * @example
     * // Delete one Catalogo
     * const Catalogo = await prisma.catalogo.delete({
     *   where: {
     *     // ... filter to delete one Catalogo
     *   }
     * })
     * 
     */
    delete<T extends CatalogoDeleteArgs>(args: SelectSubset<T, CatalogoDeleteArgs<ExtArgs>>): Prisma__CatalogoClient<$Result.GetResult<Prisma.$CatalogoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Catalogo.
     * @param {CatalogoUpdateArgs} args - Arguments to update one Catalogo.
     * @example
     * // Update one Catalogo
     * const catalogo = await prisma.catalogo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatalogoUpdateArgs>(args: SelectSubset<T, CatalogoUpdateArgs<ExtArgs>>): Prisma__CatalogoClient<$Result.GetResult<Prisma.$CatalogoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Catalogos.
     * @param {CatalogoDeleteManyArgs} args - Arguments to filter Catalogos to delete.
     * @example
     * // Delete a few Catalogos
     * const { count } = await prisma.catalogo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatalogoDeleteManyArgs>(args?: SelectSubset<T, CatalogoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Catalogos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Catalogos
     * const catalogo = await prisma.catalogo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatalogoUpdateManyArgs>(args: SelectSubset<T, CatalogoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Catalogo.
     * @param {CatalogoUpsertArgs} args - Arguments to update or create a Catalogo.
     * @example
     * // Update or create a Catalogo
     * const catalogo = await prisma.catalogo.upsert({
     *   create: {
     *     // ... data to create a Catalogo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Catalogo we want to update
     *   }
     * })
     */
    upsert<T extends CatalogoUpsertArgs>(args: SelectSubset<T, CatalogoUpsertArgs<ExtArgs>>): Prisma__CatalogoClient<$Result.GetResult<Prisma.$CatalogoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Catalogos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoCountArgs} args - Arguments to filter Catalogos to count.
     * @example
     * // Count the number of Catalogos
     * const count = await prisma.catalogo.count({
     *   where: {
     *     // ... the filter for the Catalogos we want to count
     *   }
     * })
    **/
    count<T extends CatalogoCountArgs>(
      args?: Subset<T, CatalogoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Catalogo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogoAggregateArgs>(args: Subset<T, CatalogoAggregateArgs>): Prisma.PrismaPromise<GetCatalogoAggregateType<T>>

    /**
     * Group by Catalogo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogoGroupByArgs['orderBy'] }
        : { orderBy?: CatalogoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Catalogo model
   */
  readonly fields: CatalogoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Catalogo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Catalogo model
   */ 
  interface CatalogoFieldRefs {
    readonly id: FieldRef<"Catalogo", 'String'>
    readonly tipo: FieldRef<"Catalogo", 'String'>
    readonly codigo: FieldRef<"Catalogo", 'String'>
    readonly nombre: FieldRef<"Catalogo", 'String'>
    readonly descripcion: FieldRef<"Catalogo", 'String'>
    readonly orden: FieldRef<"Catalogo", 'Int'>
    readonly activo: FieldRef<"Catalogo", 'Boolean'>
    readonly color: FieldRef<"Catalogo", 'String'>
    readonly icono: FieldRef<"Catalogo", 'String'>
    readonly metadata: FieldRef<"Catalogo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Catalogo findUnique
   */
  export type CatalogoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalogo
     */
    select?: CatalogoSelect<ExtArgs> | null
    /**
     * Filter, which Catalogo to fetch.
     */
    where: CatalogoWhereUniqueInput
  }

  /**
   * Catalogo findUniqueOrThrow
   */
  export type CatalogoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalogo
     */
    select?: CatalogoSelect<ExtArgs> | null
    /**
     * Filter, which Catalogo to fetch.
     */
    where: CatalogoWhereUniqueInput
  }

  /**
   * Catalogo findFirst
   */
  export type CatalogoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalogo
     */
    select?: CatalogoSelect<ExtArgs> | null
    /**
     * Filter, which Catalogo to fetch.
     */
    where?: CatalogoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Catalogos to fetch.
     */
    orderBy?: CatalogoOrderByWithRelationInput | CatalogoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Catalogos.
     */
    cursor?: CatalogoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Catalogos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Catalogos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Catalogos.
     */
    distinct?: CatalogoScalarFieldEnum | CatalogoScalarFieldEnum[]
  }

  /**
   * Catalogo findFirstOrThrow
   */
  export type CatalogoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalogo
     */
    select?: CatalogoSelect<ExtArgs> | null
    /**
     * Filter, which Catalogo to fetch.
     */
    where?: CatalogoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Catalogos to fetch.
     */
    orderBy?: CatalogoOrderByWithRelationInput | CatalogoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Catalogos.
     */
    cursor?: CatalogoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Catalogos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Catalogos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Catalogos.
     */
    distinct?: CatalogoScalarFieldEnum | CatalogoScalarFieldEnum[]
  }

  /**
   * Catalogo findMany
   */
  export type CatalogoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalogo
     */
    select?: CatalogoSelect<ExtArgs> | null
    /**
     * Filter, which Catalogos to fetch.
     */
    where?: CatalogoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Catalogos to fetch.
     */
    orderBy?: CatalogoOrderByWithRelationInput | CatalogoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Catalogos.
     */
    cursor?: CatalogoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Catalogos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Catalogos.
     */
    skip?: number
    distinct?: CatalogoScalarFieldEnum | CatalogoScalarFieldEnum[]
  }

  /**
   * Catalogo create
   */
  export type CatalogoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalogo
     */
    select?: CatalogoSelect<ExtArgs> | null
    /**
     * The data needed to create a Catalogo.
     */
    data: XOR<CatalogoCreateInput, CatalogoUncheckedCreateInput>
  }

  /**
   * Catalogo createMany
   */
  export type CatalogoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Catalogos.
     */
    data: CatalogoCreateManyInput | CatalogoCreateManyInput[]
  }

  /**
   * Catalogo createManyAndReturn
   */
  export type CatalogoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalogo
     */
    select?: CatalogoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Catalogos.
     */
    data: CatalogoCreateManyInput | CatalogoCreateManyInput[]
  }

  /**
   * Catalogo update
   */
  export type CatalogoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalogo
     */
    select?: CatalogoSelect<ExtArgs> | null
    /**
     * The data needed to update a Catalogo.
     */
    data: XOR<CatalogoUpdateInput, CatalogoUncheckedUpdateInput>
    /**
     * Choose, which Catalogo to update.
     */
    where: CatalogoWhereUniqueInput
  }

  /**
   * Catalogo updateMany
   */
  export type CatalogoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Catalogos.
     */
    data: XOR<CatalogoUpdateManyMutationInput, CatalogoUncheckedUpdateManyInput>
    /**
     * Filter which Catalogos to update
     */
    where?: CatalogoWhereInput
  }

  /**
   * Catalogo upsert
   */
  export type CatalogoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalogo
     */
    select?: CatalogoSelect<ExtArgs> | null
    /**
     * The filter to search for the Catalogo to update in case it exists.
     */
    where: CatalogoWhereUniqueInput
    /**
     * In case the Catalogo found by the `where` argument doesn't exist, create a new Catalogo with this data.
     */
    create: XOR<CatalogoCreateInput, CatalogoUncheckedCreateInput>
    /**
     * In case the Catalogo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogoUpdateInput, CatalogoUncheckedUpdateInput>
  }

  /**
   * Catalogo delete
   */
  export type CatalogoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalogo
     */
    select?: CatalogoSelect<ExtArgs> | null
    /**
     * Filter which Catalogo to delete.
     */
    where: CatalogoWhereUniqueInput
  }

  /**
   * Catalogo deleteMany
   */
  export type CatalogoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Catalogos to delete
     */
    where?: CatalogoWhereInput
  }

  /**
   * Catalogo without action
   */
  export type CatalogoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalogo
     */
    select?: CatalogoSelect<ExtArgs> | null
  }


  /**
   * Model NotificationRule
   */

  export type AggregateNotificationRule = {
    _count: NotificationRuleCountAggregateOutputType | null
    _min: NotificationRuleMinAggregateOutputType | null
    _max: NotificationRuleMaxAggregateOutputType | null
  }

  export type NotificationRuleMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    entidadTipo: string | null
    eventoTipo: string | null
    activo: boolean | null
    notificarCreador: boolean | null
    notificarResponsable: boolean | null
    notificarAprobadores: boolean | null
    rolesDestino: string | null
    usuariosDestino: string | null
    enviarInApp: boolean | null
    enviarEmail: boolean | null
    plantillaMensaje: string | null
    severidad: string | null
    fechaCreacion: Date | null
    fechaModificacion: Date | null
  }

  export type NotificationRuleMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    entidadTipo: string | null
    eventoTipo: string | null
    activo: boolean | null
    notificarCreador: boolean | null
    notificarResponsable: boolean | null
    notificarAprobadores: boolean | null
    rolesDestino: string | null
    usuariosDestino: string | null
    enviarInApp: boolean | null
    enviarEmail: boolean | null
    plantillaMensaje: string | null
    severidad: string | null
    fechaCreacion: Date | null
    fechaModificacion: Date | null
  }

  export type NotificationRuleCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    entidadTipo: number
    eventoTipo: number
    activo: number
    notificarCreador: number
    notificarResponsable: number
    notificarAprobadores: number
    rolesDestino: number
    usuariosDestino: number
    enviarInApp: number
    enviarEmail: number
    plantillaMensaje: number
    severidad: number
    fechaCreacion: number
    fechaModificacion: number
    _all: number
  }


  export type NotificationRuleMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    entidadTipo?: true
    eventoTipo?: true
    activo?: true
    notificarCreador?: true
    notificarResponsable?: true
    notificarAprobadores?: true
    rolesDestino?: true
    usuariosDestino?: true
    enviarInApp?: true
    enviarEmail?: true
    plantillaMensaje?: true
    severidad?: true
    fechaCreacion?: true
    fechaModificacion?: true
  }

  export type NotificationRuleMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    entidadTipo?: true
    eventoTipo?: true
    activo?: true
    notificarCreador?: true
    notificarResponsable?: true
    notificarAprobadores?: true
    rolesDestino?: true
    usuariosDestino?: true
    enviarInApp?: true
    enviarEmail?: true
    plantillaMensaje?: true
    severidad?: true
    fechaCreacion?: true
    fechaModificacion?: true
  }

  export type NotificationRuleCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    entidadTipo?: true
    eventoTipo?: true
    activo?: true
    notificarCreador?: true
    notificarResponsable?: true
    notificarAprobadores?: true
    rolesDestino?: true
    usuariosDestino?: true
    enviarInApp?: true
    enviarEmail?: true
    plantillaMensaje?: true
    severidad?: true
    fechaCreacion?: true
    fechaModificacion?: true
    _all?: true
  }

  export type NotificationRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationRule to aggregate.
     */
    where?: NotificationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRules to fetch.
     */
    orderBy?: NotificationRuleOrderByWithRelationInput | NotificationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationRules
    **/
    _count?: true | NotificationRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationRuleMaxAggregateInputType
  }

  export type GetNotificationRuleAggregateType<T extends NotificationRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationRule[P]>
      : GetScalarType<T[P], AggregateNotificationRule[P]>
  }




  export type NotificationRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationRuleWhereInput
    orderBy?: NotificationRuleOrderByWithAggregationInput | NotificationRuleOrderByWithAggregationInput[]
    by: NotificationRuleScalarFieldEnum[] | NotificationRuleScalarFieldEnum
    having?: NotificationRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationRuleCountAggregateInputType | true
    _min?: NotificationRuleMinAggregateInputType
    _max?: NotificationRuleMaxAggregateInputType
  }

  export type NotificationRuleGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string | null
    entidadTipo: string
    eventoTipo: string
    activo: boolean
    notificarCreador: boolean
    notificarResponsable: boolean
    notificarAprobadores: boolean
    rolesDestino: string | null
    usuariosDestino: string | null
    enviarInApp: boolean
    enviarEmail: boolean
    plantillaMensaje: string | null
    severidad: string
    fechaCreacion: Date
    fechaModificacion: Date
    _count: NotificationRuleCountAggregateOutputType | null
    _min: NotificationRuleMinAggregateOutputType | null
    _max: NotificationRuleMaxAggregateOutputType | null
  }

  type GetNotificationRuleGroupByPayload<T extends NotificationRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationRuleGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationRuleGroupByOutputType[P]>
        }
      >
    >


  export type NotificationRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    entidadTipo?: boolean
    eventoTipo?: boolean
    activo?: boolean
    notificarCreador?: boolean
    notificarResponsable?: boolean
    notificarAprobadores?: boolean
    rolesDestino?: boolean
    usuariosDestino?: boolean
    enviarInApp?: boolean
    enviarEmail?: boolean
    plantillaMensaje?: boolean
    severidad?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
  }, ExtArgs["result"]["notificationRule"]>

  export type NotificationRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    entidadTipo?: boolean
    eventoTipo?: boolean
    activo?: boolean
    notificarCreador?: boolean
    notificarResponsable?: boolean
    notificarAprobadores?: boolean
    rolesDestino?: boolean
    usuariosDestino?: boolean
    enviarInApp?: boolean
    enviarEmail?: boolean
    plantillaMensaje?: boolean
    severidad?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
  }, ExtArgs["result"]["notificationRule"]>

  export type NotificationRuleSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    entidadTipo?: boolean
    eventoTipo?: boolean
    activo?: boolean
    notificarCreador?: boolean
    notificarResponsable?: boolean
    notificarAprobadores?: boolean
    rolesDestino?: boolean
    usuariosDestino?: boolean
    enviarInApp?: boolean
    enviarEmail?: boolean
    plantillaMensaje?: boolean
    severidad?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
  }


  export type $NotificationRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationRule"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      descripcion: string | null
      entidadTipo: string
      eventoTipo: string
      activo: boolean
      notificarCreador: boolean
      notificarResponsable: boolean
      notificarAprobadores: boolean
      rolesDestino: string | null
      usuariosDestino: string | null
      enviarInApp: boolean
      enviarEmail: boolean
      plantillaMensaje: string | null
      severidad: string
      fechaCreacion: Date
      fechaModificacion: Date
    }, ExtArgs["result"]["notificationRule"]>
    composites: {}
  }

  type NotificationRuleGetPayload<S extends boolean | null | undefined | NotificationRuleDefaultArgs> = $Result.GetResult<Prisma.$NotificationRulePayload, S>

  type NotificationRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationRuleCountAggregateInputType | true
    }

  export interface NotificationRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationRule'], meta: { name: 'NotificationRule' } }
    /**
     * Find zero or one NotificationRule that matches the filter.
     * @param {NotificationRuleFindUniqueArgs} args - Arguments to find a NotificationRule
     * @example
     * // Get one NotificationRule
     * const notificationRule = await prisma.notificationRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationRuleFindUniqueArgs>(args: SelectSubset<T, NotificationRuleFindUniqueArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationRuleFindUniqueOrThrowArgs} args - Arguments to find a NotificationRule
     * @example
     * // Get one NotificationRule
     * const notificationRule = await prisma.notificationRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleFindFirstArgs} args - Arguments to find a NotificationRule
     * @example
     * // Get one NotificationRule
     * const notificationRule = await prisma.notificationRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationRuleFindFirstArgs>(args?: SelectSubset<T, NotificationRuleFindFirstArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleFindFirstOrThrowArgs} args - Arguments to find a NotificationRule
     * @example
     * // Get one NotificationRule
     * const notificationRule = await prisma.notificationRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationRules
     * const notificationRules = await prisma.notificationRule.findMany()
     * 
     * // Get first 10 NotificationRules
     * const notificationRules = await prisma.notificationRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationRuleWithIdOnly = await prisma.notificationRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationRuleFindManyArgs>(args?: SelectSubset<T, NotificationRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationRule.
     * @param {NotificationRuleCreateArgs} args - Arguments to create a NotificationRule.
     * @example
     * // Create one NotificationRule
     * const NotificationRule = await prisma.notificationRule.create({
     *   data: {
     *     // ... data to create a NotificationRule
     *   }
     * })
     * 
     */
    create<T extends NotificationRuleCreateArgs>(args: SelectSubset<T, NotificationRuleCreateArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationRules.
     * @param {NotificationRuleCreateManyArgs} args - Arguments to create many NotificationRules.
     * @example
     * // Create many NotificationRules
     * const notificationRule = await prisma.notificationRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationRuleCreateManyArgs>(args?: SelectSubset<T, NotificationRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationRules and returns the data saved in the database.
     * @param {NotificationRuleCreateManyAndReturnArgs} args - Arguments to create many NotificationRules.
     * @example
     * // Create many NotificationRules
     * const notificationRule = await prisma.notificationRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationRules and only return the `id`
     * const notificationRuleWithIdOnly = await prisma.notificationRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationRule.
     * @param {NotificationRuleDeleteArgs} args - Arguments to delete one NotificationRule.
     * @example
     * // Delete one NotificationRule
     * const NotificationRule = await prisma.notificationRule.delete({
     *   where: {
     *     // ... filter to delete one NotificationRule
     *   }
     * })
     * 
     */
    delete<T extends NotificationRuleDeleteArgs>(args: SelectSubset<T, NotificationRuleDeleteArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationRule.
     * @param {NotificationRuleUpdateArgs} args - Arguments to update one NotificationRule.
     * @example
     * // Update one NotificationRule
     * const notificationRule = await prisma.notificationRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationRuleUpdateArgs>(args: SelectSubset<T, NotificationRuleUpdateArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationRules.
     * @param {NotificationRuleDeleteManyArgs} args - Arguments to filter NotificationRules to delete.
     * @example
     * // Delete a few NotificationRules
     * const { count } = await prisma.notificationRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationRuleDeleteManyArgs>(args?: SelectSubset<T, NotificationRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationRules
     * const notificationRule = await prisma.notificationRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationRuleUpdateManyArgs>(args: SelectSubset<T, NotificationRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationRule.
     * @param {NotificationRuleUpsertArgs} args - Arguments to update or create a NotificationRule.
     * @example
     * // Update or create a NotificationRule
     * const notificationRule = await prisma.notificationRule.upsert({
     *   create: {
     *     // ... data to create a NotificationRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationRule we want to update
     *   }
     * })
     */
    upsert<T extends NotificationRuleUpsertArgs>(args: SelectSubset<T, NotificationRuleUpsertArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleCountArgs} args - Arguments to filter NotificationRules to count.
     * @example
     * // Count the number of NotificationRules
     * const count = await prisma.notificationRule.count({
     *   where: {
     *     // ... the filter for the NotificationRules we want to count
     *   }
     * })
    **/
    count<T extends NotificationRuleCountArgs>(
      args?: Subset<T, NotificationRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationRuleAggregateArgs>(args: Subset<T, NotificationRuleAggregateArgs>): Prisma.PrismaPromise<GetNotificationRuleAggregateType<T>>

    /**
     * Group by NotificationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationRuleGroupByArgs['orderBy'] }
        : { orderBy?: NotificationRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationRule model
   */
  readonly fields: NotificationRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationRule model
   */ 
  interface NotificationRuleFieldRefs {
    readonly id: FieldRef<"NotificationRule", 'String'>
    readonly nombre: FieldRef<"NotificationRule", 'String'>
    readonly descripcion: FieldRef<"NotificationRule", 'String'>
    readonly entidadTipo: FieldRef<"NotificationRule", 'String'>
    readonly eventoTipo: FieldRef<"NotificationRule", 'String'>
    readonly activo: FieldRef<"NotificationRule", 'Boolean'>
    readonly notificarCreador: FieldRef<"NotificationRule", 'Boolean'>
    readonly notificarResponsable: FieldRef<"NotificationRule", 'Boolean'>
    readonly notificarAprobadores: FieldRef<"NotificationRule", 'Boolean'>
    readonly rolesDestino: FieldRef<"NotificationRule", 'String'>
    readonly usuariosDestino: FieldRef<"NotificationRule", 'String'>
    readonly enviarInApp: FieldRef<"NotificationRule", 'Boolean'>
    readonly enviarEmail: FieldRef<"NotificationRule", 'Boolean'>
    readonly plantillaMensaje: FieldRef<"NotificationRule", 'String'>
    readonly severidad: FieldRef<"NotificationRule", 'String'>
    readonly fechaCreacion: FieldRef<"NotificationRule", 'DateTime'>
    readonly fechaModificacion: FieldRef<"NotificationRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationRule findUnique
   */
  export type NotificationRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Filter, which NotificationRule to fetch.
     */
    where: NotificationRuleWhereUniqueInput
  }

  /**
   * NotificationRule findUniqueOrThrow
   */
  export type NotificationRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Filter, which NotificationRule to fetch.
     */
    where: NotificationRuleWhereUniqueInput
  }

  /**
   * NotificationRule findFirst
   */
  export type NotificationRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Filter, which NotificationRule to fetch.
     */
    where?: NotificationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRules to fetch.
     */
    orderBy?: NotificationRuleOrderByWithRelationInput | NotificationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationRules.
     */
    cursor?: NotificationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationRules.
     */
    distinct?: NotificationRuleScalarFieldEnum | NotificationRuleScalarFieldEnum[]
  }

  /**
   * NotificationRule findFirstOrThrow
   */
  export type NotificationRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Filter, which NotificationRule to fetch.
     */
    where?: NotificationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRules to fetch.
     */
    orderBy?: NotificationRuleOrderByWithRelationInput | NotificationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationRules.
     */
    cursor?: NotificationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationRules.
     */
    distinct?: NotificationRuleScalarFieldEnum | NotificationRuleScalarFieldEnum[]
  }

  /**
   * NotificationRule findMany
   */
  export type NotificationRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Filter, which NotificationRules to fetch.
     */
    where?: NotificationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRules to fetch.
     */
    orderBy?: NotificationRuleOrderByWithRelationInput | NotificationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationRules.
     */
    cursor?: NotificationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRules.
     */
    skip?: number
    distinct?: NotificationRuleScalarFieldEnum | NotificationRuleScalarFieldEnum[]
  }

  /**
   * NotificationRule create
   */
  export type NotificationRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * The data needed to create a NotificationRule.
     */
    data: XOR<NotificationRuleCreateInput, NotificationRuleUncheckedCreateInput>
  }

  /**
   * NotificationRule createMany
   */
  export type NotificationRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationRules.
     */
    data: NotificationRuleCreateManyInput | NotificationRuleCreateManyInput[]
  }

  /**
   * NotificationRule createManyAndReturn
   */
  export type NotificationRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationRules.
     */
    data: NotificationRuleCreateManyInput | NotificationRuleCreateManyInput[]
  }

  /**
   * NotificationRule update
   */
  export type NotificationRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * The data needed to update a NotificationRule.
     */
    data: XOR<NotificationRuleUpdateInput, NotificationRuleUncheckedUpdateInput>
    /**
     * Choose, which NotificationRule to update.
     */
    where: NotificationRuleWhereUniqueInput
  }

  /**
   * NotificationRule updateMany
   */
  export type NotificationRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationRules.
     */
    data: XOR<NotificationRuleUpdateManyMutationInput, NotificationRuleUncheckedUpdateManyInput>
    /**
     * Filter which NotificationRules to update
     */
    where?: NotificationRuleWhereInput
  }

  /**
   * NotificationRule upsert
   */
  export type NotificationRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * The filter to search for the NotificationRule to update in case it exists.
     */
    where: NotificationRuleWhereUniqueInput
    /**
     * In case the NotificationRule found by the `where` argument doesn't exist, create a new NotificationRule with this data.
     */
    create: XOR<NotificationRuleCreateInput, NotificationRuleUncheckedCreateInput>
    /**
     * In case the NotificationRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationRuleUpdateInput, NotificationRuleUncheckedUpdateInput>
  }

  /**
   * NotificationRule delete
   */
  export type NotificationRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Filter which NotificationRule to delete.
     */
    where: NotificationRuleWhereUniqueInput
  }

  /**
   * NotificationRule deleteMany
   */
  export type NotificationRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationRules to delete
     */
    where?: NotificationRuleWhereInput
  }

  /**
   * NotificationRule without action
   */
  export type NotificationRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
  }


  /**
   * Model AlertRule
   */

  export type AggregateAlertRule = {
    _count: AlertRuleCountAggregateOutputType | null
    _avg: AlertRuleAvgAggregateOutputType | null
    _sum: AlertRuleSumAggregateOutputType | null
    _min: AlertRuleMinAggregateOutputType | null
    _max: AlertRuleMaxAggregateOutputType | null
  }

  export type AlertRuleAvgAggregateOutputType = {
    valorUmbral: number | null
    cooldownMinutos: number | null
  }

  export type AlertRuleSumAggregateOutputType = {
    valorUmbral: number | null
    cooldownMinutos: number | null
  }

  export type AlertRuleMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    entidadTipo: string | null
    entidadId: string | null
    metricaNombre: string | null
    operador: string | null
    valorUmbral: number | null
    tipoAgregacion: string | null
    periodoEvaluacion: string | null
    activo: boolean | null
    rolesDestino: string | null
    usuariosDestino: string | null
    enviarInApp: boolean | null
    enviarEmail: boolean | null
    severidad: string | null
    cooldownMinutos: number | null
    ultimaEjecucion: Date | null
    fechaCreacion: Date | null
    fechaModificacion: Date | null
  }

  export type AlertRuleMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    entidadTipo: string | null
    entidadId: string | null
    metricaNombre: string | null
    operador: string | null
    valorUmbral: number | null
    tipoAgregacion: string | null
    periodoEvaluacion: string | null
    activo: boolean | null
    rolesDestino: string | null
    usuariosDestino: string | null
    enviarInApp: boolean | null
    enviarEmail: boolean | null
    severidad: string | null
    cooldownMinutos: number | null
    ultimaEjecucion: Date | null
    fechaCreacion: Date | null
    fechaModificacion: Date | null
  }

  export type AlertRuleCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    entidadTipo: number
    entidadId: number
    metricaNombre: number
    operador: number
    valorUmbral: number
    tipoAgregacion: number
    periodoEvaluacion: number
    activo: number
    rolesDestino: number
    usuariosDestino: number
    enviarInApp: number
    enviarEmail: number
    severidad: number
    cooldownMinutos: number
    ultimaEjecucion: number
    fechaCreacion: number
    fechaModificacion: number
    _all: number
  }


  export type AlertRuleAvgAggregateInputType = {
    valorUmbral?: true
    cooldownMinutos?: true
  }

  export type AlertRuleSumAggregateInputType = {
    valorUmbral?: true
    cooldownMinutos?: true
  }

  export type AlertRuleMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    entidadTipo?: true
    entidadId?: true
    metricaNombre?: true
    operador?: true
    valorUmbral?: true
    tipoAgregacion?: true
    periodoEvaluacion?: true
    activo?: true
    rolesDestino?: true
    usuariosDestino?: true
    enviarInApp?: true
    enviarEmail?: true
    severidad?: true
    cooldownMinutos?: true
    ultimaEjecucion?: true
    fechaCreacion?: true
    fechaModificacion?: true
  }

  export type AlertRuleMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    entidadTipo?: true
    entidadId?: true
    metricaNombre?: true
    operador?: true
    valorUmbral?: true
    tipoAgregacion?: true
    periodoEvaluacion?: true
    activo?: true
    rolesDestino?: true
    usuariosDestino?: true
    enviarInApp?: true
    enviarEmail?: true
    severidad?: true
    cooldownMinutos?: true
    ultimaEjecucion?: true
    fechaCreacion?: true
    fechaModificacion?: true
  }

  export type AlertRuleCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    entidadTipo?: true
    entidadId?: true
    metricaNombre?: true
    operador?: true
    valorUmbral?: true
    tipoAgregacion?: true
    periodoEvaluacion?: true
    activo?: true
    rolesDestino?: true
    usuariosDestino?: true
    enviarInApp?: true
    enviarEmail?: true
    severidad?: true
    cooldownMinutos?: true
    ultimaEjecucion?: true
    fechaCreacion?: true
    fechaModificacion?: true
    _all?: true
  }

  export type AlertRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertRule to aggregate.
     */
    where?: AlertRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertRules to fetch.
     */
    orderBy?: AlertRuleOrderByWithRelationInput | AlertRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlertRules
    **/
    _count?: true | AlertRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertRuleMaxAggregateInputType
  }

  export type GetAlertRuleAggregateType<T extends AlertRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateAlertRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlertRule[P]>
      : GetScalarType<T[P], AggregateAlertRule[P]>
  }




  export type AlertRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertRuleWhereInput
    orderBy?: AlertRuleOrderByWithAggregationInput | AlertRuleOrderByWithAggregationInput[]
    by: AlertRuleScalarFieldEnum[] | AlertRuleScalarFieldEnum
    having?: AlertRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertRuleCountAggregateInputType | true
    _avg?: AlertRuleAvgAggregateInputType
    _sum?: AlertRuleSumAggregateInputType
    _min?: AlertRuleMinAggregateInputType
    _max?: AlertRuleMaxAggregateInputType
  }

  export type AlertRuleGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string | null
    entidadTipo: string
    entidadId: string | null
    metricaNombre: string
    operador: string
    valorUmbral: number
    tipoAgregacion: string
    periodoEvaluacion: string | null
    activo: boolean
    rolesDestino: string | null
    usuariosDestino: string | null
    enviarInApp: boolean
    enviarEmail: boolean
    severidad: string
    cooldownMinutos: number
    ultimaEjecucion: Date | null
    fechaCreacion: Date
    fechaModificacion: Date
    _count: AlertRuleCountAggregateOutputType | null
    _avg: AlertRuleAvgAggregateOutputType | null
    _sum: AlertRuleSumAggregateOutputType | null
    _min: AlertRuleMinAggregateOutputType | null
    _max: AlertRuleMaxAggregateOutputType | null
  }

  type GetAlertRuleGroupByPayload<T extends AlertRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertRuleGroupByOutputType[P]>
            : GetScalarType<T[P], AlertRuleGroupByOutputType[P]>
        }
      >
    >


  export type AlertRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    entidadTipo?: boolean
    entidadId?: boolean
    metricaNombre?: boolean
    operador?: boolean
    valorUmbral?: boolean
    tipoAgregacion?: boolean
    periodoEvaluacion?: boolean
    activo?: boolean
    rolesDestino?: boolean
    usuariosDestino?: boolean
    enviarInApp?: boolean
    enviarEmail?: boolean
    severidad?: boolean
    cooldownMinutos?: boolean
    ultimaEjecucion?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
  }, ExtArgs["result"]["alertRule"]>

  export type AlertRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    entidadTipo?: boolean
    entidadId?: boolean
    metricaNombre?: boolean
    operador?: boolean
    valorUmbral?: boolean
    tipoAgregacion?: boolean
    periodoEvaluacion?: boolean
    activo?: boolean
    rolesDestino?: boolean
    usuariosDestino?: boolean
    enviarInApp?: boolean
    enviarEmail?: boolean
    severidad?: boolean
    cooldownMinutos?: boolean
    ultimaEjecucion?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
  }, ExtArgs["result"]["alertRule"]>

  export type AlertRuleSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    entidadTipo?: boolean
    entidadId?: boolean
    metricaNombre?: boolean
    operador?: boolean
    valorUmbral?: boolean
    tipoAgregacion?: boolean
    periodoEvaluacion?: boolean
    activo?: boolean
    rolesDestino?: boolean
    usuariosDestino?: boolean
    enviarInApp?: boolean
    enviarEmail?: boolean
    severidad?: boolean
    cooldownMinutos?: boolean
    ultimaEjecucion?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
  }


  export type $AlertRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlertRule"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      descripcion: string | null
      entidadTipo: string
      entidadId: string | null
      metricaNombre: string
      operador: string
      valorUmbral: number
      tipoAgregacion: string
      periodoEvaluacion: string | null
      activo: boolean
      rolesDestino: string | null
      usuariosDestino: string | null
      enviarInApp: boolean
      enviarEmail: boolean
      severidad: string
      cooldownMinutos: number
      ultimaEjecucion: Date | null
      fechaCreacion: Date
      fechaModificacion: Date
    }, ExtArgs["result"]["alertRule"]>
    composites: {}
  }

  type AlertRuleGetPayload<S extends boolean | null | undefined | AlertRuleDefaultArgs> = $Result.GetResult<Prisma.$AlertRulePayload, S>

  type AlertRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlertRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertRuleCountAggregateInputType | true
    }

  export interface AlertRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlertRule'], meta: { name: 'AlertRule' } }
    /**
     * Find zero or one AlertRule that matches the filter.
     * @param {AlertRuleFindUniqueArgs} args - Arguments to find a AlertRule
     * @example
     * // Get one AlertRule
     * const alertRule = await prisma.alertRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertRuleFindUniqueArgs>(args: SelectSubset<T, AlertRuleFindUniqueArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AlertRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlertRuleFindUniqueOrThrowArgs} args - Arguments to find a AlertRule
     * @example
     * // Get one AlertRule
     * const alertRule = await prisma.alertRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AlertRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleFindFirstArgs} args - Arguments to find a AlertRule
     * @example
     * // Get one AlertRule
     * const alertRule = await prisma.alertRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertRuleFindFirstArgs>(args?: SelectSubset<T, AlertRuleFindFirstArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AlertRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleFindFirstOrThrowArgs} args - Arguments to find a AlertRule
     * @example
     * // Get one AlertRule
     * const alertRule = await prisma.alertRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AlertRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlertRules
     * const alertRules = await prisma.alertRule.findMany()
     * 
     * // Get first 10 AlertRules
     * const alertRules = await prisma.alertRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertRuleWithIdOnly = await prisma.alertRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertRuleFindManyArgs>(args?: SelectSubset<T, AlertRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AlertRule.
     * @param {AlertRuleCreateArgs} args - Arguments to create a AlertRule.
     * @example
     * // Create one AlertRule
     * const AlertRule = await prisma.alertRule.create({
     *   data: {
     *     // ... data to create a AlertRule
     *   }
     * })
     * 
     */
    create<T extends AlertRuleCreateArgs>(args: SelectSubset<T, AlertRuleCreateArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AlertRules.
     * @param {AlertRuleCreateManyArgs} args - Arguments to create many AlertRules.
     * @example
     * // Create many AlertRules
     * const alertRule = await prisma.alertRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertRuleCreateManyArgs>(args?: SelectSubset<T, AlertRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlertRules and returns the data saved in the database.
     * @param {AlertRuleCreateManyAndReturnArgs} args - Arguments to create many AlertRules.
     * @example
     * // Create many AlertRules
     * const alertRule = await prisma.alertRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlertRules and only return the `id`
     * const alertRuleWithIdOnly = await prisma.alertRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AlertRule.
     * @param {AlertRuleDeleteArgs} args - Arguments to delete one AlertRule.
     * @example
     * // Delete one AlertRule
     * const AlertRule = await prisma.alertRule.delete({
     *   where: {
     *     // ... filter to delete one AlertRule
     *   }
     * })
     * 
     */
    delete<T extends AlertRuleDeleteArgs>(args: SelectSubset<T, AlertRuleDeleteArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AlertRule.
     * @param {AlertRuleUpdateArgs} args - Arguments to update one AlertRule.
     * @example
     * // Update one AlertRule
     * const alertRule = await prisma.alertRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertRuleUpdateArgs>(args: SelectSubset<T, AlertRuleUpdateArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AlertRules.
     * @param {AlertRuleDeleteManyArgs} args - Arguments to filter AlertRules to delete.
     * @example
     * // Delete a few AlertRules
     * const { count } = await prisma.alertRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertRuleDeleteManyArgs>(args?: SelectSubset<T, AlertRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlertRules
     * const alertRule = await prisma.alertRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertRuleUpdateManyArgs>(args: SelectSubset<T, AlertRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AlertRule.
     * @param {AlertRuleUpsertArgs} args - Arguments to update or create a AlertRule.
     * @example
     * // Update or create a AlertRule
     * const alertRule = await prisma.alertRule.upsert({
     *   create: {
     *     // ... data to create a AlertRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlertRule we want to update
     *   }
     * })
     */
    upsert<T extends AlertRuleUpsertArgs>(args: SelectSubset<T, AlertRuleUpsertArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AlertRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleCountArgs} args - Arguments to filter AlertRules to count.
     * @example
     * // Count the number of AlertRules
     * const count = await prisma.alertRule.count({
     *   where: {
     *     // ... the filter for the AlertRules we want to count
     *   }
     * })
    **/
    count<T extends AlertRuleCountArgs>(
      args?: Subset<T, AlertRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlertRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertRuleAggregateArgs>(args: Subset<T, AlertRuleAggregateArgs>): Prisma.PrismaPromise<GetAlertRuleAggregateType<T>>

    /**
     * Group by AlertRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertRuleGroupByArgs['orderBy'] }
        : { orderBy?: AlertRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlertRule model
   */
  readonly fields: AlertRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlertRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlertRule model
   */ 
  interface AlertRuleFieldRefs {
    readonly id: FieldRef<"AlertRule", 'String'>
    readonly nombre: FieldRef<"AlertRule", 'String'>
    readonly descripcion: FieldRef<"AlertRule", 'String'>
    readonly entidadTipo: FieldRef<"AlertRule", 'String'>
    readonly entidadId: FieldRef<"AlertRule", 'String'>
    readonly metricaNombre: FieldRef<"AlertRule", 'String'>
    readonly operador: FieldRef<"AlertRule", 'String'>
    readonly valorUmbral: FieldRef<"AlertRule", 'Float'>
    readonly tipoAgregacion: FieldRef<"AlertRule", 'String'>
    readonly periodoEvaluacion: FieldRef<"AlertRule", 'String'>
    readonly activo: FieldRef<"AlertRule", 'Boolean'>
    readonly rolesDestino: FieldRef<"AlertRule", 'String'>
    readonly usuariosDestino: FieldRef<"AlertRule", 'String'>
    readonly enviarInApp: FieldRef<"AlertRule", 'Boolean'>
    readonly enviarEmail: FieldRef<"AlertRule", 'Boolean'>
    readonly severidad: FieldRef<"AlertRule", 'String'>
    readonly cooldownMinutos: FieldRef<"AlertRule", 'Int'>
    readonly ultimaEjecucion: FieldRef<"AlertRule", 'DateTime'>
    readonly fechaCreacion: FieldRef<"AlertRule", 'DateTime'>
    readonly fechaModificacion: FieldRef<"AlertRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AlertRule findUnique
   */
  export type AlertRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Filter, which AlertRule to fetch.
     */
    where: AlertRuleWhereUniqueInput
  }

  /**
   * AlertRule findUniqueOrThrow
   */
  export type AlertRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Filter, which AlertRule to fetch.
     */
    where: AlertRuleWhereUniqueInput
  }

  /**
   * AlertRule findFirst
   */
  export type AlertRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Filter, which AlertRule to fetch.
     */
    where?: AlertRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertRules to fetch.
     */
    orderBy?: AlertRuleOrderByWithRelationInput | AlertRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertRules.
     */
    cursor?: AlertRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertRules.
     */
    distinct?: AlertRuleScalarFieldEnum | AlertRuleScalarFieldEnum[]
  }

  /**
   * AlertRule findFirstOrThrow
   */
  export type AlertRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Filter, which AlertRule to fetch.
     */
    where?: AlertRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertRules to fetch.
     */
    orderBy?: AlertRuleOrderByWithRelationInput | AlertRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertRules.
     */
    cursor?: AlertRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertRules.
     */
    distinct?: AlertRuleScalarFieldEnum | AlertRuleScalarFieldEnum[]
  }

  /**
   * AlertRule findMany
   */
  export type AlertRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Filter, which AlertRules to fetch.
     */
    where?: AlertRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertRules to fetch.
     */
    orderBy?: AlertRuleOrderByWithRelationInput | AlertRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlertRules.
     */
    cursor?: AlertRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertRules.
     */
    skip?: number
    distinct?: AlertRuleScalarFieldEnum | AlertRuleScalarFieldEnum[]
  }

  /**
   * AlertRule create
   */
  export type AlertRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * The data needed to create a AlertRule.
     */
    data: XOR<AlertRuleCreateInput, AlertRuleUncheckedCreateInput>
  }

  /**
   * AlertRule createMany
   */
  export type AlertRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlertRules.
     */
    data: AlertRuleCreateManyInput | AlertRuleCreateManyInput[]
  }

  /**
   * AlertRule createManyAndReturn
   */
  export type AlertRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AlertRules.
     */
    data: AlertRuleCreateManyInput | AlertRuleCreateManyInput[]
  }

  /**
   * AlertRule update
   */
  export type AlertRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * The data needed to update a AlertRule.
     */
    data: XOR<AlertRuleUpdateInput, AlertRuleUncheckedUpdateInput>
    /**
     * Choose, which AlertRule to update.
     */
    where: AlertRuleWhereUniqueInput
  }

  /**
   * AlertRule updateMany
   */
  export type AlertRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlertRules.
     */
    data: XOR<AlertRuleUpdateManyMutationInput, AlertRuleUncheckedUpdateManyInput>
    /**
     * Filter which AlertRules to update
     */
    where?: AlertRuleWhereInput
  }

  /**
   * AlertRule upsert
   */
  export type AlertRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * The filter to search for the AlertRule to update in case it exists.
     */
    where: AlertRuleWhereUniqueInput
    /**
     * In case the AlertRule found by the `where` argument doesn't exist, create a new AlertRule with this data.
     */
    create: XOR<AlertRuleCreateInput, AlertRuleUncheckedCreateInput>
    /**
     * In case the AlertRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertRuleUpdateInput, AlertRuleUncheckedUpdateInput>
  }

  /**
   * AlertRule delete
   */
  export type AlertRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Filter which AlertRule to delete.
     */
    where: AlertRuleWhereUniqueInput
  }

  /**
   * AlertRule deleteMany
   */
  export type AlertRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertRules to delete
     */
    where?: AlertRuleWhereInput
  }

  /**
   * AlertRule without action
   */
  export type AlertRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
  }


  /**
   * Model ExpirationRule
   */

  export type AggregateExpirationRule = {
    _count: ExpirationRuleCountAggregateOutputType | null
    _min: ExpirationRuleMinAggregateOutputType | null
    _max: ExpirationRuleMaxAggregateOutputType | null
  }

  export type ExpirationRuleMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    entidadTipo: string | null
    diasAnticipacion: string | null
    diasDespuesVencido: string | null
    activo: boolean | null
    notificarResponsable: boolean | null
    notificarSupervisor: boolean | null
    rolesDestino: string | null
    enviarInApp: boolean | null
    enviarEmail: boolean | null
    fechaCreacion: Date | null
    fechaModificacion: Date | null
  }

  export type ExpirationRuleMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    entidadTipo: string | null
    diasAnticipacion: string | null
    diasDespuesVencido: string | null
    activo: boolean | null
    notificarResponsable: boolean | null
    notificarSupervisor: boolean | null
    rolesDestino: string | null
    enviarInApp: boolean | null
    enviarEmail: boolean | null
    fechaCreacion: Date | null
    fechaModificacion: Date | null
  }

  export type ExpirationRuleCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    entidadTipo: number
    diasAnticipacion: number
    diasDespuesVencido: number
    activo: number
    notificarResponsable: number
    notificarSupervisor: number
    rolesDestino: number
    enviarInApp: number
    enviarEmail: number
    fechaCreacion: number
    fechaModificacion: number
    _all: number
  }


  export type ExpirationRuleMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    entidadTipo?: true
    diasAnticipacion?: true
    diasDespuesVencido?: true
    activo?: true
    notificarResponsable?: true
    notificarSupervisor?: true
    rolesDestino?: true
    enviarInApp?: true
    enviarEmail?: true
    fechaCreacion?: true
    fechaModificacion?: true
  }

  export type ExpirationRuleMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    entidadTipo?: true
    diasAnticipacion?: true
    diasDespuesVencido?: true
    activo?: true
    notificarResponsable?: true
    notificarSupervisor?: true
    rolesDestino?: true
    enviarInApp?: true
    enviarEmail?: true
    fechaCreacion?: true
    fechaModificacion?: true
  }

  export type ExpirationRuleCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    entidadTipo?: true
    diasAnticipacion?: true
    diasDespuesVencido?: true
    activo?: true
    notificarResponsable?: true
    notificarSupervisor?: true
    rolesDestino?: true
    enviarInApp?: true
    enviarEmail?: true
    fechaCreacion?: true
    fechaModificacion?: true
    _all?: true
  }

  export type ExpirationRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpirationRule to aggregate.
     */
    where?: ExpirationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpirationRules to fetch.
     */
    orderBy?: ExpirationRuleOrderByWithRelationInput | ExpirationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpirationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpirationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpirationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpirationRules
    **/
    _count?: true | ExpirationRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpirationRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpirationRuleMaxAggregateInputType
  }

  export type GetExpirationRuleAggregateType<T extends ExpirationRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateExpirationRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpirationRule[P]>
      : GetScalarType<T[P], AggregateExpirationRule[P]>
  }




  export type ExpirationRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpirationRuleWhereInput
    orderBy?: ExpirationRuleOrderByWithAggregationInput | ExpirationRuleOrderByWithAggregationInput[]
    by: ExpirationRuleScalarFieldEnum[] | ExpirationRuleScalarFieldEnum
    having?: ExpirationRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpirationRuleCountAggregateInputType | true
    _min?: ExpirationRuleMinAggregateInputType
    _max?: ExpirationRuleMaxAggregateInputType
  }

  export type ExpirationRuleGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string | null
    entidadTipo: string
    diasAnticipacion: string
    diasDespuesVencido: string | null
    activo: boolean
    notificarResponsable: boolean
    notificarSupervisor: boolean
    rolesDestino: string | null
    enviarInApp: boolean
    enviarEmail: boolean
    fechaCreacion: Date
    fechaModificacion: Date
    _count: ExpirationRuleCountAggregateOutputType | null
    _min: ExpirationRuleMinAggregateOutputType | null
    _max: ExpirationRuleMaxAggregateOutputType | null
  }

  type GetExpirationRuleGroupByPayload<T extends ExpirationRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpirationRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpirationRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpirationRuleGroupByOutputType[P]>
            : GetScalarType<T[P], ExpirationRuleGroupByOutputType[P]>
        }
      >
    >


  export type ExpirationRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    entidadTipo?: boolean
    diasAnticipacion?: boolean
    diasDespuesVencido?: boolean
    activo?: boolean
    notificarResponsable?: boolean
    notificarSupervisor?: boolean
    rolesDestino?: boolean
    enviarInApp?: boolean
    enviarEmail?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
  }, ExtArgs["result"]["expirationRule"]>

  export type ExpirationRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    entidadTipo?: boolean
    diasAnticipacion?: boolean
    diasDespuesVencido?: boolean
    activo?: boolean
    notificarResponsable?: boolean
    notificarSupervisor?: boolean
    rolesDestino?: boolean
    enviarInApp?: boolean
    enviarEmail?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
  }, ExtArgs["result"]["expirationRule"]>

  export type ExpirationRuleSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    entidadTipo?: boolean
    diasAnticipacion?: boolean
    diasDespuesVencido?: boolean
    activo?: boolean
    notificarResponsable?: boolean
    notificarSupervisor?: boolean
    rolesDestino?: boolean
    enviarInApp?: boolean
    enviarEmail?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
  }


  export type $ExpirationRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpirationRule"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      descripcion: string | null
      entidadTipo: string
      diasAnticipacion: string
      diasDespuesVencido: string | null
      activo: boolean
      notificarResponsable: boolean
      notificarSupervisor: boolean
      rolesDestino: string | null
      enviarInApp: boolean
      enviarEmail: boolean
      fechaCreacion: Date
      fechaModificacion: Date
    }, ExtArgs["result"]["expirationRule"]>
    composites: {}
  }

  type ExpirationRuleGetPayload<S extends boolean | null | undefined | ExpirationRuleDefaultArgs> = $Result.GetResult<Prisma.$ExpirationRulePayload, S>

  type ExpirationRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpirationRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpirationRuleCountAggregateInputType | true
    }

  export interface ExpirationRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpirationRule'], meta: { name: 'ExpirationRule' } }
    /**
     * Find zero or one ExpirationRule that matches the filter.
     * @param {ExpirationRuleFindUniqueArgs} args - Arguments to find a ExpirationRule
     * @example
     * // Get one ExpirationRule
     * const expirationRule = await prisma.expirationRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpirationRuleFindUniqueArgs>(args: SelectSubset<T, ExpirationRuleFindUniqueArgs<ExtArgs>>): Prisma__ExpirationRuleClient<$Result.GetResult<Prisma.$ExpirationRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExpirationRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpirationRuleFindUniqueOrThrowArgs} args - Arguments to find a ExpirationRule
     * @example
     * // Get one ExpirationRule
     * const expirationRule = await prisma.expirationRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpirationRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpirationRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpirationRuleClient<$Result.GetResult<Prisma.$ExpirationRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExpirationRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpirationRuleFindFirstArgs} args - Arguments to find a ExpirationRule
     * @example
     * // Get one ExpirationRule
     * const expirationRule = await prisma.expirationRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpirationRuleFindFirstArgs>(args?: SelectSubset<T, ExpirationRuleFindFirstArgs<ExtArgs>>): Prisma__ExpirationRuleClient<$Result.GetResult<Prisma.$ExpirationRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExpirationRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpirationRuleFindFirstOrThrowArgs} args - Arguments to find a ExpirationRule
     * @example
     * // Get one ExpirationRule
     * const expirationRule = await prisma.expirationRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpirationRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpirationRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpirationRuleClient<$Result.GetResult<Prisma.$ExpirationRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExpirationRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpirationRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpirationRules
     * const expirationRules = await prisma.expirationRule.findMany()
     * 
     * // Get first 10 ExpirationRules
     * const expirationRules = await prisma.expirationRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expirationRuleWithIdOnly = await prisma.expirationRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpirationRuleFindManyArgs>(args?: SelectSubset<T, ExpirationRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpirationRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExpirationRule.
     * @param {ExpirationRuleCreateArgs} args - Arguments to create a ExpirationRule.
     * @example
     * // Create one ExpirationRule
     * const ExpirationRule = await prisma.expirationRule.create({
     *   data: {
     *     // ... data to create a ExpirationRule
     *   }
     * })
     * 
     */
    create<T extends ExpirationRuleCreateArgs>(args: SelectSubset<T, ExpirationRuleCreateArgs<ExtArgs>>): Prisma__ExpirationRuleClient<$Result.GetResult<Prisma.$ExpirationRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExpirationRules.
     * @param {ExpirationRuleCreateManyArgs} args - Arguments to create many ExpirationRules.
     * @example
     * // Create many ExpirationRules
     * const expirationRule = await prisma.expirationRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpirationRuleCreateManyArgs>(args?: SelectSubset<T, ExpirationRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpirationRules and returns the data saved in the database.
     * @param {ExpirationRuleCreateManyAndReturnArgs} args - Arguments to create many ExpirationRules.
     * @example
     * // Create many ExpirationRules
     * const expirationRule = await prisma.expirationRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpirationRules and only return the `id`
     * const expirationRuleWithIdOnly = await prisma.expirationRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpirationRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpirationRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpirationRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExpirationRule.
     * @param {ExpirationRuleDeleteArgs} args - Arguments to delete one ExpirationRule.
     * @example
     * // Delete one ExpirationRule
     * const ExpirationRule = await prisma.expirationRule.delete({
     *   where: {
     *     // ... filter to delete one ExpirationRule
     *   }
     * })
     * 
     */
    delete<T extends ExpirationRuleDeleteArgs>(args: SelectSubset<T, ExpirationRuleDeleteArgs<ExtArgs>>): Prisma__ExpirationRuleClient<$Result.GetResult<Prisma.$ExpirationRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExpirationRule.
     * @param {ExpirationRuleUpdateArgs} args - Arguments to update one ExpirationRule.
     * @example
     * // Update one ExpirationRule
     * const expirationRule = await prisma.expirationRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpirationRuleUpdateArgs>(args: SelectSubset<T, ExpirationRuleUpdateArgs<ExtArgs>>): Prisma__ExpirationRuleClient<$Result.GetResult<Prisma.$ExpirationRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExpirationRules.
     * @param {ExpirationRuleDeleteManyArgs} args - Arguments to filter ExpirationRules to delete.
     * @example
     * // Delete a few ExpirationRules
     * const { count } = await prisma.expirationRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpirationRuleDeleteManyArgs>(args?: SelectSubset<T, ExpirationRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpirationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpirationRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpirationRules
     * const expirationRule = await prisma.expirationRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpirationRuleUpdateManyArgs>(args: SelectSubset<T, ExpirationRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExpirationRule.
     * @param {ExpirationRuleUpsertArgs} args - Arguments to update or create a ExpirationRule.
     * @example
     * // Update or create a ExpirationRule
     * const expirationRule = await prisma.expirationRule.upsert({
     *   create: {
     *     // ... data to create a ExpirationRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpirationRule we want to update
     *   }
     * })
     */
    upsert<T extends ExpirationRuleUpsertArgs>(args: SelectSubset<T, ExpirationRuleUpsertArgs<ExtArgs>>): Prisma__ExpirationRuleClient<$Result.GetResult<Prisma.$ExpirationRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExpirationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpirationRuleCountArgs} args - Arguments to filter ExpirationRules to count.
     * @example
     * // Count the number of ExpirationRules
     * const count = await prisma.expirationRule.count({
     *   where: {
     *     // ... the filter for the ExpirationRules we want to count
     *   }
     * })
    **/
    count<T extends ExpirationRuleCountArgs>(
      args?: Subset<T, ExpirationRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpirationRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpirationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpirationRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpirationRuleAggregateArgs>(args: Subset<T, ExpirationRuleAggregateArgs>): Prisma.PrismaPromise<GetExpirationRuleAggregateType<T>>

    /**
     * Group by ExpirationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpirationRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpirationRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpirationRuleGroupByArgs['orderBy'] }
        : { orderBy?: ExpirationRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpirationRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpirationRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpirationRule model
   */
  readonly fields: ExpirationRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpirationRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpirationRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpirationRule model
   */ 
  interface ExpirationRuleFieldRefs {
    readonly id: FieldRef<"ExpirationRule", 'String'>
    readonly nombre: FieldRef<"ExpirationRule", 'String'>
    readonly descripcion: FieldRef<"ExpirationRule", 'String'>
    readonly entidadTipo: FieldRef<"ExpirationRule", 'String'>
    readonly diasAnticipacion: FieldRef<"ExpirationRule", 'String'>
    readonly diasDespuesVencido: FieldRef<"ExpirationRule", 'String'>
    readonly activo: FieldRef<"ExpirationRule", 'Boolean'>
    readonly notificarResponsable: FieldRef<"ExpirationRule", 'Boolean'>
    readonly notificarSupervisor: FieldRef<"ExpirationRule", 'Boolean'>
    readonly rolesDestino: FieldRef<"ExpirationRule", 'String'>
    readonly enviarInApp: FieldRef<"ExpirationRule", 'Boolean'>
    readonly enviarEmail: FieldRef<"ExpirationRule", 'Boolean'>
    readonly fechaCreacion: FieldRef<"ExpirationRule", 'DateTime'>
    readonly fechaModificacion: FieldRef<"ExpirationRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpirationRule findUnique
   */
  export type ExpirationRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpirationRule
     */
    select?: ExpirationRuleSelect<ExtArgs> | null
    /**
     * Filter, which ExpirationRule to fetch.
     */
    where: ExpirationRuleWhereUniqueInput
  }

  /**
   * ExpirationRule findUniqueOrThrow
   */
  export type ExpirationRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpirationRule
     */
    select?: ExpirationRuleSelect<ExtArgs> | null
    /**
     * Filter, which ExpirationRule to fetch.
     */
    where: ExpirationRuleWhereUniqueInput
  }

  /**
   * ExpirationRule findFirst
   */
  export type ExpirationRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpirationRule
     */
    select?: ExpirationRuleSelect<ExtArgs> | null
    /**
     * Filter, which ExpirationRule to fetch.
     */
    where?: ExpirationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpirationRules to fetch.
     */
    orderBy?: ExpirationRuleOrderByWithRelationInput | ExpirationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpirationRules.
     */
    cursor?: ExpirationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpirationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpirationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpirationRules.
     */
    distinct?: ExpirationRuleScalarFieldEnum | ExpirationRuleScalarFieldEnum[]
  }

  /**
   * ExpirationRule findFirstOrThrow
   */
  export type ExpirationRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpirationRule
     */
    select?: ExpirationRuleSelect<ExtArgs> | null
    /**
     * Filter, which ExpirationRule to fetch.
     */
    where?: ExpirationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpirationRules to fetch.
     */
    orderBy?: ExpirationRuleOrderByWithRelationInput | ExpirationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpirationRules.
     */
    cursor?: ExpirationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpirationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpirationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpirationRules.
     */
    distinct?: ExpirationRuleScalarFieldEnum | ExpirationRuleScalarFieldEnum[]
  }

  /**
   * ExpirationRule findMany
   */
  export type ExpirationRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpirationRule
     */
    select?: ExpirationRuleSelect<ExtArgs> | null
    /**
     * Filter, which ExpirationRules to fetch.
     */
    where?: ExpirationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpirationRules to fetch.
     */
    orderBy?: ExpirationRuleOrderByWithRelationInput | ExpirationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpirationRules.
     */
    cursor?: ExpirationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpirationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpirationRules.
     */
    skip?: number
    distinct?: ExpirationRuleScalarFieldEnum | ExpirationRuleScalarFieldEnum[]
  }

  /**
   * ExpirationRule create
   */
  export type ExpirationRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpirationRule
     */
    select?: ExpirationRuleSelect<ExtArgs> | null
    /**
     * The data needed to create a ExpirationRule.
     */
    data: XOR<ExpirationRuleCreateInput, ExpirationRuleUncheckedCreateInput>
  }

  /**
   * ExpirationRule createMany
   */
  export type ExpirationRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpirationRules.
     */
    data: ExpirationRuleCreateManyInput | ExpirationRuleCreateManyInput[]
  }

  /**
   * ExpirationRule createManyAndReturn
   */
  export type ExpirationRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpirationRule
     */
    select?: ExpirationRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExpirationRules.
     */
    data: ExpirationRuleCreateManyInput | ExpirationRuleCreateManyInput[]
  }

  /**
   * ExpirationRule update
   */
  export type ExpirationRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpirationRule
     */
    select?: ExpirationRuleSelect<ExtArgs> | null
    /**
     * The data needed to update a ExpirationRule.
     */
    data: XOR<ExpirationRuleUpdateInput, ExpirationRuleUncheckedUpdateInput>
    /**
     * Choose, which ExpirationRule to update.
     */
    where: ExpirationRuleWhereUniqueInput
  }

  /**
   * ExpirationRule updateMany
   */
  export type ExpirationRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpirationRules.
     */
    data: XOR<ExpirationRuleUpdateManyMutationInput, ExpirationRuleUncheckedUpdateManyInput>
    /**
     * Filter which ExpirationRules to update
     */
    where?: ExpirationRuleWhereInput
  }

  /**
   * ExpirationRule upsert
   */
  export type ExpirationRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpirationRule
     */
    select?: ExpirationRuleSelect<ExtArgs> | null
    /**
     * The filter to search for the ExpirationRule to update in case it exists.
     */
    where: ExpirationRuleWhereUniqueInput
    /**
     * In case the ExpirationRule found by the `where` argument doesn't exist, create a new ExpirationRule with this data.
     */
    create: XOR<ExpirationRuleCreateInput, ExpirationRuleUncheckedCreateInput>
    /**
     * In case the ExpirationRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpirationRuleUpdateInput, ExpirationRuleUncheckedUpdateInput>
  }

  /**
   * ExpirationRule delete
   */
  export type ExpirationRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpirationRule
     */
    select?: ExpirationRuleSelect<ExtArgs> | null
    /**
     * Filter which ExpirationRule to delete.
     */
    where: ExpirationRuleWhereUniqueInput
  }

  /**
   * ExpirationRule deleteMany
   */
  export type ExpirationRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpirationRules to delete
     */
    where?: ExpirationRuleWhereInput
  }

  /**
   * ExpirationRule without action
   */
  export type ExpirationRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpirationRule
     */
    select?: ExpirationRuleSelect<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    tipo: string | null
    titulo: string | null
    mensaje: string | null
    severidad: string | null
    entidadTipo: string | null
    entidadId: string | null
    entidadNombre: string | null
    leida: boolean | null
    archivada: boolean | null
    enSeguimiento: boolean | null
    acciones: string | null
    attachmentTipo: string | null
    attachmentUrl: string | null
    attachmentTitulo: string | null
    attachmentSubtitulo: string | null
    metadata: string | null
    reglaId: string | null
    reglaTipo: string | null
    fechaCreacion: Date | null
    fechaLeida: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    tipo: string | null
    titulo: string | null
    mensaje: string | null
    severidad: string | null
    entidadTipo: string | null
    entidadId: string | null
    entidadNombre: string | null
    leida: boolean | null
    archivada: boolean | null
    enSeguimiento: boolean | null
    acciones: string | null
    attachmentTipo: string | null
    attachmentUrl: string | null
    attachmentTitulo: string | null
    attachmentSubtitulo: string | null
    metadata: string | null
    reglaId: string | null
    reglaTipo: string | null
    fechaCreacion: Date | null
    fechaLeida: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    usuarioId: number
    tipo: number
    titulo: number
    mensaje: number
    severidad: number
    entidadTipo: number
    entidadId: number
    entidadNombre: number
    leida: number
    archivada: number
    enSeguimiento: number
    acciones: number
    attachmentTipo: number
    attachmentUrl: number
    attachmentTitulo: number
    attachmentSubtitulo: number
    metadata: number
    reglaId: number
    reglaTipo: number
    fechaCreacion: number
    fechaLeida: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    usuarioId?: true
    tipo?: true
    titulo?: true
    mensaje?: true
    severidad?: true
    entidadTipo?: true
    entidadId?: true
    entidadNombre?: true
    leida?: true
    archivada?: true
    enSeguimiento?: true
    acciones?: true
    attachmentTipo?: true
    attachmentUrl?: true
    attachmentTitulo?: true
    attachmentSubtitulo?: true
    metadata?: true
    reglaId?: true
    reglaTipo?: true
    fechaCreacion?: true
    fechaLeida?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    tipo?: true
    titulo?: true
    mensaje?: true
    severidad?: true
    entidadTipo?: true
    entidadId?: true
    entidadNombre?: true
    leida?: true
    archivada?: true
    enSeguimiento?: true
    acciones?: true
    attachmentTipo?: true
    attachmentUrl?: true
    attachmentTitulo?: true
    attachmentSubtitulo?: true
    metadata?: true
    reglaId?: true
    reglaTipo?: true
    fechaCreacion?: true
    fechaLeida?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    usuarioId?: true
    tipo?: true
    titulo?: true
    mensaje?: true
    severidad?: true
    entidadTipo?: true
    entidadId?: true
    entidadNombre?: true
    leida?: true
    archivada?: true
    enSeguimiento?: true
    acciones?: true
    attachmentTipo?: true
    attachmentUrl?: true
    attachmentTitulo?: true
    attachmentSubtitulo?: true
    metadata?: true
    reglaId?: true
    reglaTipo?: true
    fechaCreacion?: true
    fechaLeida?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    usuarioId: string
    tipo: string
    titulo: string
    mensaje: string
    severidad: string
    entidadTipo: string | null
    entidadId: string | null
    entidadNombre: string | null
    leida: boolean
    archivada: boolean
    enSeguimiento: boolean
    acciones: string | null
    attachmentTipo: string | null
    attachmentUrl: string | null
    attachmentTitulo: string | null
    attachmentSubtitulo: string | null
    metadata: string | null
    reglaId: string | null
    reglaTipo: string | null
    fechaCreacion: Date
    fechaLeida: Date | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    severidad?: boolean
    entidadTipo?: boolean
    entidadId?: boolean
    entidadNombre?: boolean
    leida?: boolean
    archivada?: boolean
    enSeguimiento?: boolean
    acciones?: boolean
    attachmentTipo?: boolean
    attachmentUrl?: boolean
    attachmentTitulo?: boolean
    attachmentSubtitulo?: boolean
    metadata?: boolean
    reglaId?: boolean
    reglaTipo?: boolean
    fechaCreacion?: boolean
    fechaLeida?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    severidad?: boolean
    entidadTipo?: boolean
    entidadId?: boolean
    entidadNombre?: boolean
    leida?: boolean
    archivada?: boolean
    enSeguimiento?: boolean
    acciones?: boolean
    attachmentTipo?: boolean
    attachmentUrl?: boolean
    attachmentTitulo?: boolean
    attachmentSubtitulo?: boolean
    metadata?: boolean
    reglaId?: boolean
    reglaTipo?: boolean
    fechaCreacion?: boolean
    fechaLeida?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    severidad?: boolean
    entidadTipo?: boolean
    entidadId?: boolean
    entidadNombre?: boolean
    leida?: boolean
    archivada?: boolean
    enSeguimiento?: boolean
    acciones?: boolean
    attachmentTipo?: boolean
    attachmentUrl?: boolean
    attachmentTitulo?: boolean
    attachmentSubtitulo?: boolean
    metadata?: boolean
    reglaId?: boolean
    reglaTipo?: boolean
    fechaCreacion?: boolean
    fechaLeida?: boolean
  }


  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuarioId: string
      tipo: string
      titulo: string
      mensaje: string
      severidad: string
      entidadTipo: string | null
      entidadId: string | null
      entidadNombre: string | null
      leida: boolean
      archivada: boolean
      enSeguimiento: boolean
      acciones: string | null
      attachmentTipo: string | null
      attachmentUrl: string | null
      attachmentTitulo: string | null
      attachmentSubtitulo: string | null
      metadata: string | null
      reglaId: string | null
      reglaTipo: string | null
      fechaCreacion: Date
      fechaLeida: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly usuarioId: FieldRef<"Notification", 'String'>
    readonly tipo: FieldRef<"Notification", 'String'>
    readonly titulo: FieldRef<"Notification", 'String'>
    readonly mensaje: FieldRef<"Notification", 'String'>
    readonly severidad: FieldRef<"Notification", 'String'>
    readonly entidadTipo: FieldRef<"Notification", 'String'>
    readonly entidadId: FieldRef<"Notification", 'String'>
    readonly entidadNombre: FieldRef<"Notification", 'String'>
    readonly leida: FieldRef<"Notification", 'Boolean'>
    readonly archivada: FieldRef<"Notification", 'Boolean'>
    readonly enSeguimiento: FieldRef<"Notification", 'Boolean'>
    readonly acciones: FieldRef<"Notification", 'String'>
    readonly attachmentTipo: FieldRef<"Notification", 'String'>
    readonly attachmentUrl: FieldRef<"Notification", 'String'>
    readonly attachmentTitulo: FieldRef<"Notification", 'String'>
    readonly attachmentSubtitulo: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'String'>
    readonly reglaId: FieldRef<"Notification", 'String'>
    readonly reglaTipo: FieldRef<"Notification", 'String'>
    readonly fechaCreacion: FieldRef<"Notification", 'DateTime'>
    readonly fechaLeida: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
  }


  /**
   * Model UserNotificationPreferences
   */

  export type AggregateUserNotificationPreferences = {
    _count: UserNotificationPreferencesCountAggregateOutputType | null
    _avg: UserNotificationPreferencesAvgAggregateOutputType | null
    _sum: UserNotificationPreferencesSumAggregateOutputType | null
    _min: UserNotificationPreferencesMinAggregateOutputType | null
    _max: UserNotificationPreferencesMaxAggregateOutputType | null
  }

  export type UserNotificationPreferencesAvgAggregateOutputType = {
    rateLimitMaxPorHora: number | null
  }

  export type UserNotificationPreferencesSumAggregateOutputType = {
    rateLimitMaxPorHora: number | null
  }

  export type UserNotificationPreferencesMinAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    habilitado: boolean | null
    emailHabilitado: boolean | null
    inAppHabilitado: boolean | null
    preferenciasPorEntidad: string | null
    notificarInfo: boolean | null
    notificarWarning: boolean | null
    notificarCritical: boolean | null
    frecuenciaEmail: string | null
    horaResumen: string | null
    horarioNoMolestarHabilitado: boolean | null
    horarioNoMolestarInicio: string | null
    horarioNoMolestarFin: string | null
    horarioNoMolestarDias: string | null
    rateLimitHabilitado: boolean | null
    rateLimitMaxPorHora: number | null
    preferenciasPorModulo: string | null
    fechaCreacion: Date | null
    fechaModificacion: Date | null
  }

  export type UserNotificationPreferencesMaxAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    habilitado: boolean | null
    emailHabilitado: boolean | null
    inAppHabilitado: boolean | null
    preferenciasPorEntidad: string | null
    notificarInfo: boolean | null
    notificarWarning: boolean | null
    notificarCritical: boolean | null
    frecuenciaEmail: string | null
    horaResumen: string | null
    horarioNoMolestarHabilitado: boolean | null
    horarioNoMolestarInicio: string | null
    horarioNoMolestarFin: string | null
    horarioNoMolestarDias: string | null
    rateLimitHabilitado: boolean | null
    rateLimitMaxPorHora: number | null
    preferenciasPorModulo: string | null
    fechaCreacion: Date | null
    fechaModificacion: Date | null
  }

  export type UserNotificationPreferencesCountAggregateOutputType = {
    id: number
    usuarioId: number
    habilitado: number
    emailHabilitado: number
    inAppHabilitado: number
    preferenciasPorEntidad: number
    notificarInfo: number
    notificarWarning: number
    notificarCritical: number
    frecuenciaEmail: number
    horaResumen: number
    horarioNoMolestarHabilitado: number
    horarioNoMolestarInicio: number
    horarioNoMolestarFin: number
    horarioNoMolestarDias: number
    rateLimitHabilitado: number
    rateLimitMaxPorHora: number
    preferenciasPorModulo: number
    fechaCreacion: number
    fechaModificacion: number
    _all: number
  }


  export type UserNotificationPreferencesAvgAggregateInputType = {
    rateLimitMaxPorHora?: true
  }

  export type UserNotificationPreferencesSumAggregateInputType = {
    rateLimitMaxPorHora?: true
  }

  export type UserNotificationPreferencesMinAggregateInputType = {
    id?: true
    usuarioId?: true
    habilitado?: true
    emailHabilitado?: true
    inAppHabilitado?: true
    preferenciasPorEntidad?: true
    notificarInfo?: true
    notificarWarning?: true
    notificarCritical?: true
    frecuenciaEmail?: true
    horaResumen?: true
    horarioNoMolestarHabilitado?: true
    horarioNoMolestarInicio?: true
    horarioNoMolestarFin?: true
    horarioNoMolestarDias?: true
    rateLimitHabilitado?: true
    rateLimitMaxPorHora?: true
    preferenciasPorModulo?: true
    fechaCreacion?: true
    fechaModificacion?: true
  }

  export type UserNotificationPreferencesMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    habilitado?: true
    emailHabilitado?: true
    inAppHabilitado?: true
    preferenciasPorEntidad?: true
    notificarInfo?: true
    notificarWarning?: true
    notificarCritical?: true
    frecuenciaEmail?: true
    horaResumen?: true
    horarioNoMolestarHabilitado?: true
    horarioNoMolestarInicio?: true
    horarioNoMolestarFin?: true
    horarioNoMolestarDias?: true
    rateLimitHabilitado?: true
    rateLimitMaxPorHora?: true
    preferenciasPorModulo?: true
    fechaCreacion?: true
    fechaModificacion?: true
  }

  export type UserNotificationPreferencesCountAggregateInputType = {
    id?: true
    usuarioId?: true
    habilitado?: true
    emailHabilitado?: true
    inAppHabilitado?: true
    preferenciasPorEntidad?: true
    notificarInfo?: true
    notificarWarning?: true
    notificarCritical?: true
    frecuenciaEmail?: true
    horaResumen?: true
    horarioNoMolestarHabilitado?: true
    horarioNoMolestarInicio?: true
    horarioNoMolestarFin?: true
    horarioNoMolestarDias?: true
    rateLimitHabilitado?: true
    rateLimitMaxPorHora?: true
    preferenciasPorModulo?: true
    fechaCreacion?: true
    fechaModificacion?: true
    _all?: true
  }

  export type UserNotificationPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotificationPreferences to aggregate.
     */
    where?: UserNotificationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotificationPreferences to fetch.
     */
    orderBy?: UserNotificationPreferencesOrderByWithRelationInput | UserNotificationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserNotificationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserNotificationPreferences
    **/
    _count?: true | UserNotificationPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserNotificationPreferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserNotificationPreferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserNotificationPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserNotificationPreferencesMaxAggregateInputType
  }

  export type GetUserNotificationPreferencesAggregateType<T extends UserNotificationPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserNotificationPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserNotificationPreferences[P]>
      : GetScalarType<T[P], AggregateUserNotificationPreferences[P]>
  }




  export type UserNotificationPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNotificationPreferencesWhereInput
    orderBy?: UserNotificationPreferencesOrderByWithAggregationInput | UserNotificationPreferencesOrderByWithAggregationInput[]
    by: UserNotificationPreferencesScalarFieldEnum[] | UserNotificationPreferencesScalarFieldEnum
    having?: UserNotificationPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserNotificationPreferencesCountAggregateInputType | true
    _avg?: UserNotificationPreferencesAvgAggregateInputType
    _sum?: UserNotificationPreferencesSumAggregateInputType
    _min?: UserNotificationPreferencesMinAggregateInputType
    _max?: UserNotificationPreferencesMaxAggregateInputType
  }

  export type UserNotificationPreferencesGroupByOutputType = {
    id: string
    usuarioId: string
    habilitado: boolean
    emailHabilitado: boolean
    inAppHabilitado: boolean
    preferenciasPorEntidad: string | null
    notificarInfo: boolean
    notificarWarning: boolean
    notificarCritical: boolean
    frecuenciaEmail: string
    horaResumen: string
    horarioNoMolestarHabilitado: boolean
    horarioNoMolestarInicio: string | null
    horarioNoMolestarFin: string | null
    horarioNoMolestarDias: string | null
    rateLimitHabilitado: boolean
    rateLimitMaxPorHora: number
    preferenciasPorModulo: string | null
    fechaCreacion: Date
    fechaModificacion: Date
    _count: UserNotificationPreferencesCountAggregateOutputType | null
    _avg: UserNotificationPreferencesAvgAggregateOutputType | null
    _sum: UserNotificationPreferencesSumAggregateOutputType | null
    _min: UserNotificationPreferencesMinAggregateOutputType | null
    _max: UserNotificationPreferencesMaxAggregateOutputType | null
  }

  type GetUserNotificationPreferencesGroupByPayload<T extends UserNotificationPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserNotificationPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserNotificationPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserNotificationPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], UserNotificationPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type UserNotificationPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    habilitado?: boolean
    emailHabilitado?: boolean
    inAppHabilitado?: boolean
    preferenciasPorEntidad?: boolean
    notificarInfo?: boolean
    notificarWarning?: boolean
    notificarCritical?: boolean
    frecuenciaEmail?: boolean
    horaResumen?: boolean
    horarioNoMolestarHabilitado?: boolean
    horarioNoMolestarInicio?: boolean
    horarioNoMolestarFin?: boolean
    horarioNoMolestarDias?: boolean
    rateLimitHabilitado?: boolean
    rateLimitMaxPorHora?: boolean
    preferenciasPorModulo?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
  }, ExtArgs["result"]["userNotificationPreferences"]>

  export type UserNotificationPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    habilitado?: boolean
    emailHabilitado?: boolean
    inAppHabilitado?: boolean
    preferenciasPorEntidad?: boolean
    notificarInfo?: boolean
    notificarWarning?: boolean
    notificarCritical?: boolean
    frecuenciaEmail?: boolean
    horaResumen?: boolean
    horarioNoMolestarHabilitado?: boolean
    horarioNoMolestarInicio?: boolean
    horarioNoMolestarFin?: boolean
    horarioNoMolestarDias?: boolean
    rateLimitHabilitado?: boolean
    rateLimitMaxPorHora?: boolean
    preferenciasPorModulo?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
  }, ExtArgs["result"]["userNotificationPreferences"]>

  export type UserNotificationPreferencesSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    habilitado?: boolean
    emailHabilitado?: boolean
    inAppHabilitado?: boolean
    preferenciasPorEntidad?: boolean
    notificarInfo?: boolean
    notificarWarning?: boolean
    notificarCritical?: boolean
    frecuenciaEmail?: boolean
    horaResumen?: boolean
    horarioNoMolestarHabilitado?: boolean
    horarioNoMolestarInicio?: boolean
    horarioNoMolestarFin?: boolean
    horarioNoMolestarDias?: boolean
    rateLimitHabilitado?: boolean
    rateLimitMaxPorHora?: boolean
    preferenciasPorModulo?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
  }


  export type $UserNotificationPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserNotificationPreferences"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuarioId: string
      habilitado: boolean
      emailHabilitado: boolean
      inAppHabilitado: boolean
      preferenciasPorEntidad: string | null
      notificarInfo: boolean
      notificarWarning: boolean
      notificarCritical: boolean
      frecuenciaEmail: string
      horaResumen: string
      horarioNoMolestarHabilitado: boolean
      horarioNoMolestarInicio: string | null
      horarioNoMolestarFin: string | null
      horarioNoMolestarDias: string | null
      rateLimitHabilitado: boolean
      rateLimitMaxPorHora: number
      preferenciasPorModulo: string | null
      fechaCreacion: Date
      fechaModificacion: Date
    }, ExtArgs["result"]["userNotificationPreferences"]>
    composites: {}
  }

  type UserNotificationPreferencesGetPayload<S extends boolean | null | undefined | UserNotificationPreferencesDefaultArgs> = $Result.GetResult<Prisma.$UserNotificationPreferencesPayload, S>

  type UserNotificationPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserNotificationPreferencesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserNotificationPreferencesCountAggregateInputType | true
    }

  export interface UserNotificationPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserNotificationPreferences'], meta: { name: 'UserNotificationPreferences' } }
    /**
     * Find zero or one UserNotificationPreferences that matches the filter.
     * @param {UserNotificationPreferencesFindUniqueArgs} args - Arguments to find a UserNotificationPreferences
     * @example
     * // Get one UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserNotificationPreferencesFindUniqueArgs>(args: SelectSubset<T, UserNotificationPreferencesFindUniqueArgs<ExtArgs>>): Prisma__UserNotificationPreferencesClient<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserNotificationPreferences that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserNotificationPreferencesFindUniqueOrThrowArgs} args - Arguments to find a UserNotificationPreferences
     * @example
     * // Get one UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserNotificationPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserNotificationPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserNotificationPreferencesClient<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserNotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationPreferencesFindFirstArgs} args - Arguments to find a UserNotificationPreferences
     * @example
     * // Get one UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserNotificationPreferencesFindFirstArgs>(args?: SelectSubset<T, UserNotificationPreferencesFindFirstArgs<ExtArgs>>): Prisma__UserNotificationPreferencesClient<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserNotificationPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationPreferencesFindFirstOrThrowArgs} args - Arguments to find a UserNotificationPreferences
     * @example
     * // Get one UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserNotificationPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserNotificationPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserNotificationPreferencesClient<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserNotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.findMany()
     * 
     * // Get first 10 UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userNotificationPreferencesWithIdOnly = await prisma.userNotificationPreferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserNotificationPreferencesFindManyArgs>(args?: SelectSubset<T, UserNotificationPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserNotificationPreferences.
     * @param {UserNotificationPreferencesCreateArgs} args - Arguments to create a UserNotificationPreferences.
     * @example
     * // Create one UserNotificationPreferences
     * const UserNotificationPreferences = await prisma.userNotificationPreferences.create({
     *   data: {
     *     // ... data to create a UserNotificationPreferences
     *   }
     * })
     * 
     */
    create<T extends UserNotificationPreferencesCreateArgs>(args: SelectSubset<T, UserNotificationPreferencesCreateArgs<ExtArgs>>): Prisma__UserNotificationPreferencesClient<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserNotificationPreferences.
     * @param {UserNotificationPreferencesCreateManyArgs} args - Arguments to create many UserNotificationPreferences.
     * @example
     * // Create many UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserNotificationPreferencesCreateManyArgs>(args?: SelectSubset<T, UserNotificationPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserNotificationPreferences and returns the data saved in the database.
     * @param {UserNotificationPreferencesCreateManyAndReturnArgs} args - Arguments to create many UserNotificationPreferences.
     * @example
     * // Create many UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserNotificationPreferences and only return the `id`
     * const userNotificationPreferencesWithIdOnly = await prisma.userNotificationPreferences.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserNotificationPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, UserNotificationPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserNotificationPreferences.
     * @param {UserNotificationPreferencesDeleteArgs} args - Arguments to delete one UserNotificationPreferences.
     * @example
     * // Delete one UserNotificationPreferences
     * const UserNotificationPreferences = await prisma.userNotificationPreferences.delete({
     *   where: {
     *     // ... filter to delete one UserNotificationPreferences
     *   }
     * })
     * 
     */
    delete<T extends UserNotificationPreferencesDeleteArgs>(args: SelectSubset<T, UserNotificationPreferencesDeleteArgs<ExtArgs>>): Prisma__UserNotificationPreferencesClient<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserNotificationPreferences.
     * @param {UserNotificationPreferencesUpdateArgs} args - Arguments to update one UserNotificationPreferences.
     * @example
     * // Update one UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserNotificationPreferencesUpdateArgs>(args: SelectSubset<T, UserNotificationPreferencesUpdateArgs<ExtArgs>>): Prisma__UserNotificationPreferencesClient<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserNotificationPreferences.
     * @param {UserNotificationPreferencesDeleteManyArgs} args - Arguments to filter UserNotificationPreferences to delete.
     * @example
     * // Delete a few UserNotificationPreferences
     * const { count } = await prisma.userNotificationPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserNotificationPreferencesDeleteManyArgs>(args?: SelectSubset<T, UserNotificationPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserNotificationPreferencesUpdateManyArgs>(args: SelectSubset<T, UserNotificationPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserNotificationPreferences.
     * @param {UserNotificationPreferencesUpsertArgs} args - Arguments to update or create a UserNotificationPreferences.
     * @example
     * // Update or create a UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.upsert({
     *   create: {
     *     // ... data to create a UserNotificationPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserNotificationPreferences we want to update
     *   }
     * })
     */
    upsert<T extends UserNotificationPreferencesUpsertArgs>(args: SelectSubset<T, UserNotificationPreferencesUpsertArgs<ExtArgs>>): Prisma__UserNotificationPreferencesClient<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserNotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationPreferencesCountArgs} args - Arguments to filter UserNotificationPreferences to count.
     * @example
     * // Count the number of UserNotificationPreferences
     * const count = await prisma.userNotificationPreferences.count({
     *   where: {
     *     // ... the filter for the UserNotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserNotificationPreferencesCountArgs>(
      args?: Subset<T, UserNotificationPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserNotificationPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserNotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserNotificationPreferencesAggregateArgs>(args: Subset<T, UserNotificationPreferencesAggregateArgs>): Prisma.PrismaPromise<GetUserNotificationPreferencesAggregateType<T>>

    /**
     * Group by UserNotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserNotificationPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserNotificationPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: UserNotificationPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserNotificationPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserNotificationPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserNotificationPreferences model
   */
  readonly fields: UserNotificationPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserNotificationPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserNotificationPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserNotificationPreferences model
   */ 
  interface UserNotificationPreferencesFieldRefs {
    readonly id: FieldRef<"UserNotificationPreferences", 'String'>
    readonly usuarioId: FieldRef<"UserNotificationPreferences", 'String'>
    readonly habilitado: FieldRef<"UserNotificationPreferences", 'Boolean'>
    readonly emailHabilitado: FieldRef<"UserNotificationPreferences", 'Boolean'>
    readonly inAppHabilitado: FieldRef<"UserNotificationPreferences", 'Boolean'>
    readonly preferenciasPorEntidad: FieldRef<"UserNotificationPreferences", 'String'>
    readonly notificarInfo: FieldRef<"UserNotificationPreferences", 'Boolean'>
    readonly notificarWarning: FieldRef<"UserNotificationPreferences", 'Boolean'>
    readonly notificarCritical: FieldRef<"UserNotificationPreferences", 'Boolean'>
    readonly frecuenciaEmail: FieldRef<"UserNotificationPreferences", 'String'>
    readonly horaResumen: FieldRef<"UserNotificationPreferences", 'String'>
    readonly horarioNoMolestarHabilitado: FieldRef<"UserNotificationPreferences", 'Boolean'>
    readonly horarioNoMolestarInicio: FieldRef<"UserNotificationPreferences", 'String'>
    readonly horarioNoMolestarFin: FieldRef<"UserNotificationPreferences", 'String'>
    readonly horarioNoMolestarDias: FieldRef<"UserNotificationPreferences", 'String'>
    readonly rateLimitHabilitado: FieldRef<"UserNotificationPreferences", 'Boolean'>
    readonly rateLimitMaxPorHora: FieldRef<"UserNotificationPreferences", 'Int'>
    readonly preferenciasPorModulo: FieldRef<"UserNotificationPreferences", 'String'>
    readonly fechaCreacion: FieldRef<"UserNotificationPreferences", 'DateTime'>
    readonly fechaModificacion: FieldRef<"UserNotificationPreferences", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserNotificationPreferences findUnique
   */
  export type UserNotificationPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * Filter, which UserNotificationPreferences to fetch.
     */
    where: UserNotificationPreferencesWhereUniqueInput
  }

  /**
   * UserNotificationPreferences findUniqueOrThrow
   */
  export type UserNotificationPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * Filter, which UserNotificationPreferences to fetch.
     */
    where: UserNotificationPreferencesWhereUniqueInput
  }

  /**
   * UserNotificationPreferences findFirst
   */
  export type UserNotificationPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * Filter, which UserNotificationPreferences to fetch.
     */
    where?: UserNotificationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotificationPreferences to fetch.
     */
    orderBy?: UserNotificationPreferencesOrderByWithRelationInput | UserNotificationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotificationPreferences.
     */
    cursor?: UserNotificationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotificationPreferences.
     */
    distinct?: UserNotificationPreferencesScalarFieldEnum | UserNotificationPreferencesScalarFieldEnum[]
  }

  /**
   * UserNotificationPreferences findFirstOrThrow
   */
  export type UserNotificationPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * Filter, which UserNotificationPreferences to fetch.
     */
    where?: UserNotificationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotificationPreferences to fetch.
     */
    orderBy?: UserNotificationPreferencesOrderByWithRelationInput | UserNotificationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotificationPreferences.
     */
    cursor?: UserNotificationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotificationPreferences.
     */
    distinct?: UserNotificationPreferencesScalarFieldEnum | UserNotificationPreferencesScalarFieldEnum[]
  }

  /**
   * UserNotificationPreferences findMany
   */
  export type UserNotificationPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * Filter, which UserNotificationPreferences to fetch.
     */
    where?: UserNotificationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotificationPreferences to fetch.
     */
    orderBy?: UserNotificationPreferencesOrderByWithRelationInput | UserNotificationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserNotificationPreferences.
     */
    cursor?: UserNotificationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotificationPreferences.
     */
    skip?: number
    distinct?: UserNotificationPreferencesScalarFieldEnum | UserNotificationPreferencesScalarFieldEnum[]
  }

  /**
   * UserNotificationPreferences create
   */
  export type UserNotificationPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * The data needed to create a UserNotificationPreferences.
     */
    data: XOR<UserNotificationPreferencesCreateInput, UserNotificationPreferencesUncheckedCreateInput>
  }

  /**
   * UserNotificationPreferences createMany
   */
  export type UserNotificationPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserNotificationPreferences.
     */
    data: UserNotificationPreferencesCreateManyInput | UserNotificationPreferencesCreateManyInput[]
  }

  /**
   * UserNotificationPreferences createManyAndReturn
   */
  export type UserNotificationPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserNotificationPreferences.
     */
    data: UserNotificationPreferencesCreateManyInput | UserNotificationPreferencesCreateManyInput[]
  }

  /**
   * UserNotificationPreferences update
   */
  export type UserNotificationPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * The data needed to update a UserNotificationPreferences.
     */
    data: XOR<UserNotificationPreferencesUpdateInput, UserNotificationPreferencesUncheckedUpdateInput>
    /**
     * Choose, which UserNotificationPreferences to update.
     */
    where: UserNotificationPreferencesWhereUniqueInput
  }

  /**
   * UserNotificationPreferences updateMany
   */
  export type UserNotificationPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserNotificationPreferences.
     */
    data: XOR<UserNotificationPreferencesUpdateManyMutationInput, UserNotificationPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserNotificationPreferences to update
     */
    where?: UserNotificationPreferencesWhereInput
  }

  /**
   * UserNotificationPreferences upsert
   */
  export type UserNotificationPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * The filter to search for the UserNotificationPreferences to update in case it exists.
     */
    where: UserNotificationPreferencesWhereUniqueInput
    /**
     * In case the UserNotificationPreferences found by the `where` argument doesn't exist, create a new UserNotificationPreferences with this data.
     */
    create: XOR<UserNotificationPreferencesCreateInput, UserNotificationPreferencesUncheckedCreateInput>
    /**
     * In case the UserNotificationPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserNotificationPreferencesUpdateInput, UserNotificationPreferencesUncheckedUpdateInput>
  }

  /**
   * UserNotificationPreferences delete
   */
  export type UserNotificationPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * Filter which UserNotificationPreferences to delete.
     */
    where: UserNotificationPreferencesWhereUniqueInput
  }

  /**
   * UserNotificationPreferences deleteMany
   */
  export type UserNotificationPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotificationPreferences to delete
     */
    where?: UserNotificationPreferencesWhereInput
  }

  /**
   * UserNotificationPreferences without action
   */
  export type UserNotificationPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
  }


  /**
   * Model NotificationLog
   */

  export type AggregateNotificationLog = {
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  export type NotificationLogMinAggregateOutputType = {
    id: string | null
    notificationId: string | null
    usuarioId: string | null
    canal: string | null
    estado: string | null
    errorMensaje: string | null
    reglaId: string | null
    reglaTipo: string | null
    metadata: string | null
    fechaEnvio: Date | null
  }

  export type NotificationLogMaxAggregateOutputType = {
    id: string | null
    notificationId: string | null
    usuarioId: string | null
    canal: string | null
    estado: string | null
    errorMensaje: string | null
    reglaId: string | null
    reglaTipo: string | null
    metadata: string | null
    fechaEnvio: Date | null
  }

  export type NotificationLogCountAggregateOutputType = {
    id: number
    notificationId: number
    usuarioId: number
    canal: number
    estado: number
    errorMensaje: number
    reglaId: number
    reglaTipo: number
    metadata: number
    fechaEnvio: number
    _all: number
  }


  export type NotificationLogMinAggregateInputType = {
    id?: true
    notificationId?: true
    usuarioId?: true
    canal?: true
    estado?: true
    errorMensaje?: true
    reglaId?: true
    reglaTipo?: true
    metadata?: true
    fechaEnvio?: true
  }

  export type NotificationLogMaxAggregateInputType = {
    id?: true
    notificationId?: true
    usuarioId?: true
    canal?: true
    estado?: true
    errorMensaje?: true
    reglaId?: true
    reglaTipo?: true
    metadata?: true
    fechaEnvio?: true
  }

  export type NotificationLogCountAggregateInputType = {
    id?: true
    notificationId?: true
    usuarioId?: true
    canal?: true
    estado?: true
    errorMensaje?: true
    reglaId?: true
    reglaTipo?: true
    metadata?: true
    fechaEnvio?: true
    _all?: true
  }

  export type NotificationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLog to aggregate.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationLogs
    **/
    _count?: true | NotificationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationLogMaxAggregateInputType
  }

  export type GetNotificationLogAggregateType<T extends NotificationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationLog[P]>
      : GetScalarType<T[P], AggregateNotificationLog[P]>
  }




  export type NotificationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithAggregationInput | NotificationLogOrderByWithAggregationInput[]
    by: NotificationLogScalarFieldEnum[] | NotificationLogScalarFieldEnum
    having?: NotificationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationLogCountAggregateInputType | true
    _min?: NotificationLogMinAggregateInputType
    _max?: NotificationLogMaxAggregateInputType
  }

  export type NotificationLogGroupByOutputType = {
    id: string
    notificationId: string | null
    usuarioId: string
    canal: string
    estado: string
    errorMensaje: string | null
    reglaId: string | null
    reglaTipo: string | null
    metadata: string | null
    fechaEnvio: Date
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  type GetNotificationLogGroupByPayload<T extends NotificationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
        }
      >
    >


  export type NotificationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    usuarioId?: boolean
    canal?: boolean
    estado?: boolean
    errorMensaje?: boolean
    reglaId?: boolean
    reglaTipo?: boolean
    metadata?: boolean
    fechaEnvio?: boolean
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    usuarioId?: boolean
    canal?: boolean
    estado?: boolean
    errorMensaje?: boolean
    reglaId?: boolean
    reglaTipo?: boolean
    metadata?: boolean
    fechaEnvio?: boolean
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectScalar = {
    id?: boolean
    notificationId?: boolean
    usuarioId?: boolean
    canal?: boolean
    estado?: boolean
    errorMensaje?: boolean
    reglaId?: boolean
    reglaTipo?: boolean
    metadata?: boolean
    fechaEnvio?: boolean
  }


  export type $NotificationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      notificationId: string | null
      usuarioId: string
      canal: string
      estado: string
      errorMensaje: string | null
      reglaId: string | null
      reglaTipo: string | null
      metadata: string | null
      fechaEnvio: Date
    }, ExtArgs["result"]["notificationLog"]>
    composites: {}
  }

  type NotificationLogGetPayload<S extends boolean | null | undefined | NotificationLogDefaultArgs> = $Result.GetResult<Prisma.$NotificationLogPayload, S>

  type NotificationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationLogCountAggregateInputType | true
    }

  export interface NotificationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationLog'], meta: { name: 'NotificationLog' } }
    /**
     * Find zero or one NotificationLog that matches the filter.
     * @param {NotificationLogFindUniqueArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationLogFindUniqueArgs>(args: SelectSubset<T, NotificationLogFindUniqueArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationLogFindUniqueOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationLogFindFirstArgs>(args?: SelectSubset<T, NotificationLogFindFirstArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany()
     * 
     * // Get first 10 NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationLogFindManyArgs>(args?: SelectSubset<T, NotificationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationLog.
     * @param {NotificationLogCreateArgs} args - Arguments to create a NotificationLog.
     * @example
     * // Create one NotificationLog
     * const NotificationLog = await prisma.notificationLog.create({
     *   data: {
     *     // ... data to create a NotificationLog
     *   }
     * })
     * 
     */
    create<T extends NotificationLogCreateArgs>(args: SelectSubset<T, NotificationLogCreateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationLogs.
     * @param {NotificationLogCreateManyArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationLogCreateManyArgs>(args?: SelectSubset<T, NotificationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationLogs and returns the data saved in the database.
     * @param {NotificationLogCreateManyAndReturnArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationLogs and only return the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationLog.
     * @param {NotificationLogDeleteArgs} args - Arguments to delete one NotificationLog.
     * @example
     * // Delete one NotificationLog
     * const NotificationLog = await prisma.notificationLog.delete({
     *   where: {
     *     // ... filter to delete one NotificationLog
     *   }
     * })
     * 
     */
    delete<T extends NotificationLogDeleteArgs>(args: SelectSubset<T, NotificationLogDeleteArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationLog.
     * @param {NotificationLogUpdateArgs} args - Arguments to update one NotificationLog.
     * @example
     * // Update one NotificationLog
     * const notificationLog = await prisma.notificationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationLogUpdateArgs>(args: SelectSubset<T, NotificationLogUpdateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationLogs.
     * @param {NotificationLogDeleteManyArgs} args - Arguments to filter NotificationLogs to delete.
     * @example
     * // Delete a few NotificationLogs
     * const { count } = await prisma.notificationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationLogDeleteManyArgs>(args?: SelectSubset<T, NotificationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationLogUpdateManyArgs>(args: SelectSubset<T, NotificationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationLog.
     * @param {NotificationLogUpsertArgs} args - Arguments to update or create a NotificationLog.
     * @example
     * // Update or create a NotificationLog
     * const notificationLog = await prisma.notificationLog.upsert({
     *   create: {
     *     // ... data to create a NotificationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationLog we want to update
     *   }
     * })
     */
    upsert<T extends NotificationLogUpsertArgs>(args: SelectSubset<T, NotificationLogUpsertArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogCountArgs} args - Arguments to filter NotificationLogs to count.
     * @example
     * // Count the number of NotificationLogs
     * const count = await prisma.notificationLog.count({
     *   where: {
     *     // ... the filter for the NotificationLogs we want to count
     *   }
     * })
    **/
    count<T extends NotificationLogCountArgs>(
      args?: Subset<T, NotificationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationLogAggregateArgs>(args: Subset<T, NotificationLogAggregateArgs>): Prisma.PrismaPromise<GetNotificationLogAggregateType<T>>

    /**
     * Group by NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationLogGroupByArgs['orderBy'] }
        : { orderBy?: NotificationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationLog model
   */
  readonly fields: NotificationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationLog model
   */ 
  interface NotificationLogFieldRefs {
    readonly id: FieldRef<"NotificationLog", 'String'>
    readonly notificationId: FieldRef<"NotificationLog", 'String'>
    readonly usuarioId: FieldRef<"NotificationLog", 'String'>
    readonly canal: FieldRef<"NotificationLog", 'String'>
    readonly estado: FieldRef<"NotificationLog", 'String'>
    readonly errorMensaje: FieldRef<"NotificationLog", 'String'>
    readonly reglaId: FieldRef<"NotificationLog", 'String'>
    readonly reglaTipo: FieldRef<"NotificationLog", 'String'>
    readonly metadata: FieldRef<"NotificationLog", 'String'>
    readonly fechaEnvio: FieldRef<"NotificationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationLog findUnique
   */
  export type NotificationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findUniqueOrThrow
   */
  export type NotificationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findFirst
   */
  export type NotificationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findFirstOrThrow
   */
  export type NotificationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findMany
   */
  export type NotificationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLogs to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog create
   */
  export type NotificationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * The data needed to create a NotificationLog.
     */
    data: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
  }

  /**
   * NotificationLog createMany
   */
  export type NotificationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
  }

  /**
   * NotificationLog createManyAndReturn
   */
  export type NotificationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
  }

  /**
   * NotificationLog update
   */
  export type NotificationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * The data needed to update a NotificationLog.
     */
    data: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
    /**
     * Choose, which NotificationLog to update.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog updateMany
   */
  export type NotificationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
  }

  /**
   * NotificationLog upsert
   */
  export type NotificationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * The filter to search for the NotificationLog to update in case it exists.
     */
    where: NotificationLogWhereUniqueInput
    /**
     * In case the NotificationLog found by the `where` argument doesn't exist, create a new NotificationLog with this data.
     */
    create: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
    /**
     * In case the NotificationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
  }

  /**
   * NotificationLog delete
   */
  export type NotificationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter which NotificationLog to delete.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog deleteMany
   */
  export type NotificationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLogs to delete
     */
    where?: NotificationLogWhereInput
  }

  /**
   * NotificationLog without action
   */
  export type NotificationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
  }


  /**
   * Model NotificationProfile
   */

  export type AggregateNotificationProfile = {
    _count: NotificationProfileCountAggregateOutputType | null
    _min: NotificationProfileMinAggregateOutputType | null
    _max: NotificationProfileMaxAggregateOutputType | null
  }

  export type NotificationProfileMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    eventos: string | null
    seleccionEntidades: string | null
    filtrosEntidad: string | null
    destinatarios: string | null
    canales: string | null
    plantillaTitulo: string | null
    plantillaMensaje: string | null
    severidad: string | null
    estado: string | null
    horarioNoMolestar: string | null
    fechaCreacion: Date | null
    fechaModificacion: Date | null
    creadoPorId: string | null
  }

  export type NotificationProfileMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    eventos: string | null
    seleccionEntidades: string | null
    filtrosEntidad: string | null
    destinatarios: string | null
    canales: string | null
    plantillaTitulo: string | null
    plantillaMensaje: string | null
    severidad: string | null
    estado: string | null
    horarioNoMolestar: string | null
    fechaCreacion: Date | null
    fechaModificacion: Date | null
    creadoPorId: string | null
  }

  export type NotificationProfileCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    eventos: number
    seleccionEntidades: number
    filtrosEntidad: number
    destinatarios: number
    canales: number
    plantillaTitulo: number
    plantillaMensaje: number
    severidad: number
    estado: number
    horarioNoMolestar: number
    fechaCreacion: number
    fechaModificacion: number
    creadoPorId: number
    _all: number
  }


  export type NotificationProfileMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    eventos?: true
    seleccionEntidades?: true
    filtrosEntidad?: true
    destinatarios?: true
    canales?: true
    plantillaTitulo?: true
    plantillaMensaje?: true
    severidad?: true
    estado?: true
    horarioNoMolestar?: true
    fechaCreacion?: true
    fechaModificacion?: true
    creadoPorId?: true
  }

  export type NotificationProfileMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    eventos?: true
    seleccionEntidades?: true
    filtrosEntidad?: true
    destinatarios?: true
    canales?: true
    plantillaTitulo?: true
    plantillaMensaje?: true
    severidad?: true
    estado?: true
    horarioNoMolestar?: true
    fechaCreacion?: true
    fechaModificacion?: true
    creadoPorId?: true
  }

  export type NotificationProfileCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    eventos?: true
    seleccionEntidades?: true
    filtrosEntidad?: true
    destinatarios?: true
    canales?: true
    plantillaTitulo?: true
    plantillaMensaje?: true
    severidad?: true
    estado?: true
    horarioNoMolestar?: true
    fechaCreacion?: true
    fechaModificacion?: true
    creadoPorId?: true
    _all?: true
  }

  export type NotificationProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationProfile to aggregate.
     */
    where?: NotificationProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationProfiles to fetch.
     */
    orderBy?: NotificationProfileOrderByWithRelationInput | NotificationProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationProfiles
    **/
    _count?: true | NotificationProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationProfileMaxAggregateInputType
  }

  export type GetNotificationProfileAggregateType<T extends NotificationProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationProfile[P]>
      : GetScalarType<T[P], AggregateNotificationProfile[P]>
  }




  export type NotificationProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationProfileWhereInput
    orderBy?: NotificationProfileOrderByWithAggregationInput | NotificationProfileOrderByWithAggregationInput[]
    by: NotificationProfileScalarFieldEnum[] | NotificationProfileScalarFieldEnum
    having?: NotificationProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationProfileCountAggregateInputType | true
    _min?: NotificationProfileMinAggregateInputType
    _max?: NotificationProfileMaxAggregateInputType
  }

  export type NotificationProfileGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string | null
    eventos: string
    seleccionEntidades: string
    filtrosEntidad: string | null
    destinatarios: string
    canales: string
    plantillaTitulo: string | null
    plantillaMensaje: string | null
    severidad: string
    estado: string
    horarioNoMolestar: string | null
    fechaCreacion: Date
    fechaModificacion: Date
    creadoPorId: string | null
    _count: NotificationProfileCountAggregateOutputType | null
    _min: NotificationProfileMinAggregateOutputType | null
    _max: NotificationProfileMaxAggregateOutputType | null
  }

  type GetNotificationProfileGroupByPayload<T extends NotificationProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationProfileGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationProfileGroupByOutputType[P]>
        }
      >
    >


  export type NotificationProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    eventos?: boolean
    seleccionEntidades?: boolean
    filtrosEntidad?: boolean
    destinatarios?: boolean
    canales?: boolean
    plantillaTitulo?: boolean
    plantillaMensaje?: boolean
    severidad?: boolean
    estado?: boolean
    horarioNoMolestar?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
    creadoPorId?: boolean
  }, ExtArgs["result"]["notificationProfile"]>

  export type NotificationProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    eventos?: boolean
    seleccionEntidades?: boolean
    filtrosEntidad?: boolean
    destinatarios?: boolean
    canales?: boolean
    plantillaTitulo?: boolean
    plantillaMensaje?: boolean
    severidad?: boolean
    estado?: boolean
    horarioNoMolestar?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
    creadoPorId?: boolean
  }, ExtArgs["result"]["notificationProfile"]>

  export type NotificationProfileSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    eventos?: boolean
    seleccionEntidades?: boolean
    filtrosEntidad?: boolean
    destinatarios?: boolean
    canales?: boolean
    plantillaTitulo?: boolean
    plantillaMensaje?: boolean
    severidad?: boolean
    estado?: boolean
    horarioNoMolestar?: boolean
    fechaCreacion?: boolean
    fechaModificacion?: boolean
    creadoPorId?: boolean
  }


  export type $NotificationProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationProfile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      descripcion: string | null
      eventos: string
      seleccionEntidades: string
      filtrosEntidad: string | null
      destinatarios: string
      canales: string
      plantillaTitulo: string | null
      plantillaMensaje: string | null
      severidad: string
      estado: string
      horarioNoMolestar: string | null
      fechaCreacion: Date
      fechaModificacion: Date
      creadoPorId: string | null
    }, ExtArgs["result"]["notificationProfile"]>
    composites: {}
  }

  type NotificationProfileGetPayload<S extends boolean | null | undefined | NotificationProfileDefaultArgs> = $Result.GetResult<Prisma.$NotificationProfilePayload, S>

  type NotificationProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationProfileCountAggregateInputType | true
    }

  export interface NotificationProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationProfile'], meta: { name: 'NotificationProfile' } }
    /**
     * Find zero or one NotificationProfile that matches the filter.
     * @param {NotificationProfileFindUniqueArgs} args - Arguments to find a NotificationProfile
     * @example
     * // Get one NotificationProfile
     * const notificationProfile = await prisma.notificationProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationProfileFindUniqueArgs>(args: SelectSubset<T, NotificationProfileFindUniqueArgs<ExtArgs>>): Prisma__NotificationProfileClient<$Result.GetResult<Prisma.$NotificationProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationProfileFindUniqueOrThrowArgs} args - Arguments to find a NotificationProfile
     * @example
     * // Get one NotificationProfile
     * const notificationProfile = await prisma.notificationProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationProfileClient<$Result.GetResult<Prisma.$NotificationProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProfileFindFirstArgs} args - Arguments to find a NotificationProfile
     * @example
     * // Get one NotificationProfile
     * const notificationProfile = await prisma.notificationProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationProfileFindFirstArgs>(args?: SelectSubset<T, NotificationProfileFindFirstArgs<ExtArgs>>): Prisma__NotificationProfileClient<$Result.GetResult<Prisma.$NotificationProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProfileFindFirstOrThrowArgs} args - Arguments to find a NotificationProfile
     * @example
     * // Get one NotificationProfile
     * const notificationProfile = await prisma.notificationProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationProfileClient<$Result.GetResult<Prisma.$NotificationProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationProfiles
     * const notificationProfiles = await prisma.notificationProfile.findMany()
     * 
     * // Get first 10 NotificationProfiles
     * const notificationProfiles = await prisma.notificationProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationProfileWithIdOnly = await prisma.notificationProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationProfileFindManyArgs>(args?: SelectSubset<T, NotificationProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationProfile.
     * @param {NotificationProfileCreateArgs} args - Arguments to create a NotificationProfile.
     * @example
     * // Create one NotificationProfile
     * const NotificationProfile = await prisma.notificationProfile.create({
     *   data: {
     *     // ... data to create a NotificationProfile
     *   }
     * })
     * 
     */
    create<T extends NotificationProfileCreateArgs>(args: SelectSubset<T, NotificationProfileCreateArgs<ExtArgs>>): Prisma__NotificationProfileClient<$Result.GetResult<Prisma.$NotificationProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationProfiles.
     * @param {NotificationProfileCreateManyArgs} args - Arguments to create many NotificationProfiles.
     * @example
     * // Create many NotificationProfiles
     * const notificationProfile = await prisma.notificationProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationProfileCreateManyArgs>(args?: SelectSubset<T, NotificationProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationProfiles and returns the data saved in the database.
     * @param {NotificationProfileCreateManyAndReturnArgs} args - Arguments to create many NotificationProfiles.
     * @example
     * // Create many NotificationProfiles
     * const notificationProfile = await prisma.notificationProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationProfiles and only return the `id`
     * const notificationProfileWithIdOnly = await prisma.notificationProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationProfile.
     * @param {NotificationProfileDeleteArgs} args - Arguments to delete one NotificationProfile.
     * @example
     * // Delete one NotificationProfile
     * const NotificationProfile = await prisma.notificationProfile.delete({
     *   where: {
     *     // ... filter to delete one NotificationProfile
     *   }
     * })
     * 
     */
    delete<T extends NotificationProfileDeleteArgs>(args: SelectSubset<T, NotificationProfileDeleteArgs<ExtArgs>>): Prisma__NotificationProfileClient<$Result.GetResult<Prisma.$NotificationProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationProfile.
     * @param {NotificationProfileUpdateArgs} args - Arguments to update one NotificationProfile.
     * @example
     * // Update one NotificationProfile
     * const notificationProfile = await prisma.notificationProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationProfileUpdateArgs>(args: SelectSubset<T, NotificationProfileUpdateArgs<ExtArgs>>): Prisma__NotificationProfileClient<$Result.GetResult<Prisma.$NotificationProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationProfiles.
     * @param {NotificationProfileDeleteManyArgs} args - Arguments to filter NotificationProfiles to delete.
     * @example
     * // Delete a few NotificationProfiles
     * const { count } = await prisma.notificationProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationProfileDeleteManyArgs>(args?: SelectSubset<T, NotificationProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationProfiles
     * const notificationProfile = await prisma.notificationProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationProfileUpdateManyArgs>(args: SelectSubset<T, NotificationProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationProfile.
     * @param {NotificationProfileUpsertArgs} args - Arguments to update or create a NotificationProfile.
     * @example
     * // Update or create a NotificationProfile
     * const notificationProfile = await prisma.notificationProfile.upsert({
     *   create: {
     *     // ... data to create a NotificationProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationProfile we want to update
     *   }
     * })
     */
    upsert<T extends NotificationProfileUpsertArgs>(args: SelectSubset<T, NotificationProfileUpsertArgs<ExtArgs>>): Prisma__NotificationProfileClient<$Result.GetResult<Prisma.$NotificationProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProfileCountArgs} args - Arguments to filter NotificationProfiles to count.
     * @example
     * // Count the number of NotificationProfiles
     * const count = await prisma.notificationProfile.count({
     *   where: {
     *     // ... the filter for the NotificationProfiles we want to count
     *   }
     * })
    **/
    count<T extends NotificationProfileCountArgs>(
      args?: Subset<T, NotificationProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationProfileAggregateArgs>(args: Subset<T, NotificationProfileAggregateArgs>): Prisma.PrismaPromise<GetNotificationProfileAggregateType<T>>

    /**
     * Group by NotificationProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationProfileGroupByArgs['orderBy'] }
        : { orderBy?: NotificationProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationProfile model
   */
  readonly fields: NotificationProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationProfile model
   */ 
  interface NotificationProfileFieldRefs {
    readonly id: FieldRef<"NotificationProfile", 'String'>
    readonly nombre: FieldRef<"NotificationProfile", 'String'>
    readonly descripcion: FieldRef<"NotificationProfile", 'String'>
    readonly eventos: FieldRef<"NotificationProfile", 'String'>
    readonly seleccionEntidades: FieldRef<"NotificationProfile", 'String'>
    readonly filtrosEntidad: FieldRef<"NotificationProfile", 'String'>
    readonly destinatarios: FieldRef<"NotificationProfile", 'String'>
    readonly canales: FieldRef<"NotificationProfile", 'String'>
    readonly plantillaTitulo: FieldRef<"NotificationProfile", 'String'>
    readonly plantillaMensaje: FieldRef<"NotificationProfile", 'String'>
    readonly severidad: FieldRef<"NotificationProfile", 'String'>
    readonly estado: FieldRef<"NotificationProfile", 'String'>
    readonly horarioNoMolestar: FieldRef<"NotificationProfile", 'String'>
    readonly fechaCreacion: FieldRef<"NotificationProfile", 'DateTime'>
    readonly fechaModificacion: FieldRef<"NotificationProfile", 'DateTime'>
    readonly creadoPorId: FieldRef<"NotificationProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NotificationProfile findUnique
   */
  export type NotificationProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProfile
     */
    select?: NotificationProfileSelect<ExtArgs> | null
    /**
     * Filter, which NotificationProfile to fetch.
     */
    where: NotificationProfileWhereUniqueInput
  }

  /**
   * NotificationProfile findUniqueOrThrow
   */
  export type NotificationProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProfile
     */
    select?: NotificationProfileSelect<ExtArgs> | null
    /**
     * Filter, which NotificationProfile to fetch.
     */
    where: NotificationProfileWhereUniqueInput
  }

  /**
   * NotificationProfile findFirst
   */
  export type NotificationProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProfile
     */
    select?: NotificationProfileSelect<ExtArgs> | null
    /**
     * Filter, which NotificationProfile to fetch.
     */
    where?: NotificationProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationProfiles to fetch.
     */
    orderBy?: NotificationProfileOrderByWithRelationInput | NotificationProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationProfiles.
     */
    cursor?: NotificationProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationProfiles.
     */
    distinct?: NotificationProfileScalarFieldEnum | NotificationProfileScalarFieldEnum[]
  }

  /**
   * NotificationProfile findFirstOrThrow
   */
  export type NotificationProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProfile
     */
    select?: NotificationProfileSelect<ExtArgs> | null
    /**
     * Filter, which NotificationProfile to fetch.
     */
    where?: NotificationProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationProfiles to fetch.
     */
    orderBy?: NotificationProfileOrderByWithRelationInput | NotificationProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationProfiles.
     */
    cursor?: NotificationProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationProfiles.
     */
    distinct?: NotificationProfileScalarFieldEnum | NotificationProfileScalarFieldEnum[]
  }

  /**
   * NotificationProfile findMany
   */
  export type NotificationProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProfile
     */
    select?: NotificationProfileSelect<ExtArgs> | null
    /**
     * Filter, which NotificationProfiles to fetch.
     */
    where?: NotificationProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationProfiles to fetch.
     */
    orderBy?: NotificationProfileOrderByWithRelationInput | NotificationProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationProfiles.
     */
    cursor?: NotificationProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationProfiles.
     */
    skip?: number
    distinct?: NotificationProfileScalarFieldEnum | NotificationProfileScalarFieldEnum[]
  }

  /**
   * NotificationProfile create
   */
  export type NotificationProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProfile
     */
    select?: NotificationProfileSelect<ExtArgs> | null
    /**
     * The data needed to create a NotificationProfile.
     */
    data: XOR<NotificationProfileCreateInput, NotificationProfileUncheckedCreateInput>
  }

  /**
   * NotificationProfile createMany
   */
  export type NotificationProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationProfiles.
     */
    data: NotificationProfileCreateManyInput | NotificationProfileCreateManyInput[]
  }

  /**
   * NotificationProfile createManyAndReturn
   */
  export type NotificationProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProfile
     */
    select?: NotificationProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationProfiles.
     */
    data: NotificationProfileCreateManyInput | NotificationProfileCreateManyInput[]
  }

  /**
   * NotificationProfile update
   */
  export type NotificationProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProfile
     */
    select?: NotificationProfileSelect<ExtArgs> | null
    /**
     * The data needed to update a NotificationProfile.
     */
    data: XOR<NotificationProfileUpdateInput, NotificationProfileUncheckedUpdateInput>
    /**
     * Choose, which NotificationProfile to update.
     */
    where: NotificationProfileWhereUniqueInput
  }

  /**
   * NotificationProfile updateMany
   */
  export type NotificationProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationProfiles.
     */
    data: XOR<NotificationProfileUpdateManyMutationInput, NotificationProfileUncheckedUpdateManyInput>
    /**
     * Filter which NotificationProfiles to update
     */
    where?: NotificationProfileWhereInput
  }

  /**
   * NotificationProfile upsert
   */
  export type NotificationProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProfile
     */
    select?: NotificationProfileSelect<ExtArgs> | null
    /**
     * The filter to search for the NotificationProfile to update in case it exists.
     */
    where: NotificationProfileWhereUniqueInput
    /**
     * In case the NotificationProfile found by the `where` argument doesn't exist, create a new NotificationProfile with this data.
     */
    create: XOR<NotificationProfileCreateInput, NotificationProfileUncheckedCreateInput>
    /**
     * In case the NotificationProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationProfileUpdateInput, NotificationProfileUncheckedUpdateInput>
  }

  /**
   * NotificationProfile delete
   */
  export type NotificationProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProfile
     */
    select?: NotificationProfileSelect<ExtArgs> | null
    /**
     * Filter which NotificationProfile to delete.
     */
    where: NotificationProfileWhereUniqueInput
  }

  /**
   * NotificationProfile deleteMany
   */
  export type NotificationProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationProfiles to delete
     */
    where?: NotificationProfileWhereInput
  }

  /**
   * NotificationProfile without action
   */
  export type NotificationProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProfile
     */
    select?: NotificationProfileSelect<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    progress: number | null
  }

  export type ProjectSumAggregateOutputType = {
    progress: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    responsibleUserId: string | null
    orgUnitId: string | null
    priority: string | null
    status: string | null
    progress: number | null
    reminderDays: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    responsibleUserId: string | null
    orgUnitId: string | null
    priority: string | null
    status: string | null
    progress: number | null
    reminderDays: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    startDate: number
    endDate: number
    responsibleUserId: number
    orgUnitId: number
    priority: number
    status: number
    progress: number
    reminderDays: number
    createdAt: number
    createdBy: number
    updatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    progress?: true
  }

  export type ProjectSumAggregateInputType = {
    progress?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    responsibleUserId?: true
    orgUnitId?: true
    priority?: true
    status?: true
    progress?: true
    reminderDays?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    responsibleUserId?: true
    orgUnitId?: true
    priority?: true
    status?: true
    progress?: true
    reminderDays?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    responsibleUserId?: true
    orgUnitId?: true
    priority?: true
    status?: true
    progress?: true
    reminderDays?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string | null
    startDate: Date
    endDate: Date
    responsibleUserId: string
    orgUnitId: string | null
    priority: string
    status: string
    progress: number
    reminderDays: string
    createdAt: Date
    createdBy: string
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    responsibleUserId?: boolean
    orgUnitId?: boolean
    priority?: boolean
    status?: boolean
    progress?: boolean
    reminderDays?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    objectives?: boolean | Project$objectivesArgs<ExtArgs>
    kpis?: boolean | Project$kpisArgs<ExtArgs>
    phases?: boolean | Project$phasesArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    responsibleUserId?: boolean
    orgUnitId?: boolean
    priority?: boolean
    status?: boolean
    progress?: boolean
    reminderDays?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    responsibleUserId?: boolean
    orgUnitId?: boolean
    priority?: boolean
    status?: boolean
    progress?: boolean
    reminderDays?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    objectives?: boolean | Project$objectivesArgs<ExtArgs>
    kpis?: boolean | Project$kpisArgs<ExtArgs>
    phases?: boolean | Project$phasesArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      objectives: Prisma.$ProjectObjectivePayload<ExtArgs>[]
      kpis: Prisma.$ProjectKPIPayload<ExtArgs>[]
      phases: Prisma.$ProjectPhasePayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      startDate: Date
      endDate: Date
      responsibleUserId: string
      orgUnitId: string | null
      priority: string
      status: string
      progress: number
      reminderDays: string
      createdAt: Date
      createdBy: string
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    objectives<T extends Project$objectivesArgs<ExtArgs> = {}>(args?: Subset<T, Project$objectivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectObjectivePayload<ExtArgs>, T, "findMany"> | Null>
    kpis<T extends Project$kpisArgs<ExtArgs> = {}>(args?: Subset<T, Project$kpisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectKPIPayload<ExtArgs>, T, "findMany"> | Null>
    phases<T extends Project$phasesArgs<ExtArgs> = {}>(args?: Subset<T, Project$phasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Project$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Project$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly responsibleUserId: FieldRef<"Project", 'String'>
    readonly orgUnitId: FieldRef<"Project", 'String'>
    readonly priority: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'String'>
    readonly progress: FieldRef<"Project", 'Int'>
    readonly reminderDays: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly createdBy: FieldRef<"Project", 'String'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.objectives
   */
  export type Project$objectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectObjective
     */
    select?: ProjectObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectObjectiveInclude<ExtArgs> | null
    where?: ProjectObjectiveWhereInput
    orderBy?: ProjectObjectiveOrderByWithRelationInput | ProjectObjectiveOrderByWithRelationInput[]
    cursor?: ProjectObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectObjectiveScalarFieldEnum | ProjectObjectiveScalarFieldEnum[]
  }

  /**
   * Project.kpis
   */
  export type Project$kpisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectKPI
     */
    select?: ProjectKPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectKPIInclude<ExtArgs> | null
    where?: ProjectKPIWhereInput
    orderBy?: ProjectKPIOrderByWithRelationInput | ProjectKPIOrderByWithRelationInput[]
    cursor?: ProjectKPIWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectKPIScalarFieldEnum | ProjectKPIScalarFieldEnum[]
  }

  /**
   * Project.phases
   */
  export type Project$phasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    where?: ProjectPhaseWhereInput
    orderBy?: ProjectPhaseOrderByWithRelationInput | ProjectPhaseOrderByWithRelationInput[]
    cursor?: ProjectPhaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectPhaseScalarFieldEnum | ProjectPhaseScalarFieldEnum[]
  }

  /**
   * Project.tasks
   */
  export type Project$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectObjective
   */

  export type AggregateProjectObjective = {
    _count: ProjectObjectiveCountAggregateOutputType | null
    _min: ProjectObjectiveMinAggregateOutputType | null
    _max: ProjectObjectiveMaxAggregateOutputType | null
  }

  export type ProjectObjectiveMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    description: string | null
    category: string | null
    status: string | null
    targetDate: Date | null
    completedDate: Date | null
  }

  export type ProjectObjectiveMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    description: string | null
    category: string | null
    status: string | null
    targetDate: Date | null
    completedDate: Date | null
  }

  export type ProjectObjectiveCountAggregateOutputType = {
    id: number
    projectId: number
    description: number
    category: number
    status: number
    targetDate: number
    completedDate: number
    _all: number
  }


  export type ProjectObjectiveMinAggregateInputType = {
    id?: true
    projectId?: true
    description?: true
    category?: true
    status?: true
    targetDate?: true
    completedDate?: true
  }

  export type ProjectObjectiveMaxAggregateInputType = {
    id?: true
    projectId?: true
    description?: true
    category?: true
    status?: true
    targetDate?: true
    completedDate?: true
  }

  export type ProjectObjectiveCountAggregateInputType = {
    id?: true
    projectId?: true
    description?: true
    category?: true
    status?: true
    targetDate?: true
    completedDate?: true
    _all?: true
  }

  export type ProjectObjectiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectObjective to aggregate.
     */
    where?: ProjectObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectObjectives to fetch.
     */
    orderBy?: ProjectObjectiveOrderByWithRelationInput | ProjectObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectObjectives
    **/
    _count?: true | ProjectObjectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectObjectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectObjectiveMaxAggregateInputType
  }

  export type GetProjectObjectiveAggregateType<T extends ProjectObjectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectObjective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectObjective[P]>
      : GetScalarType<T[P], AggregateProjectObjective[P]>
  }




  export type ProjectObjectiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectObjectiveWhereInput
    orderBy?: ProjectObjectiveOrderByWithAggregationInput | ProjectObjectiveOrderByWithAggregationInput[]
    by: ProjectObjectiveScalarFieldEnum[] | ProjectObjectiveScalarFieldEnum
    having?: ProjectObjectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectObjectiveCountAggregateInputType | true
    _min?: ProjectObjectiveMinAggregateInputType
    _max?: ProjectObjectiveMaxAggregateInputType
  }

  export type ProjectObjectiveGroupByOutputType = {
    id: string
    projectId: string
    description: string
    category: string
    status: string
    targetDate: Date | null
    completedDate: Date | null
    _count: ProjectObjectiveCountAggregateOutputType | null
    _min: ProjectObjectiveMinAggregateOutputType | null
    _max: ProjectObjectiveMaxAggregateOutputType | null
  }

  type GetProjectObjectiveGroupByPayload<T extends ProjectObjectiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectObjectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectObjectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectObjectiveGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectObjectiveGroupByOutputType[P]>
        }
      >
    >


  export type ProjectObjectiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    targetDate?: boolean
    completedDate?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectObjective"]>

  export type ProjectObjectiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    targetDate?: boolean
    completedDate?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectObjective"]>

  export type ProjectObjectiveSelectScalar = {
    id?: boolean
    projectId?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    targetDate?: boolean
    completedDate?: boolean
  }

  export type ProjectObjectiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectObjectiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectObjectivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectObjective"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      description: string
      category: string
      status: string
      targetDate: Date | null
      completedDate: Date | null
    }, ExtArgs["result"]["projectObjective"]>
    composites: {}
  }

  type ProjectObjectiveGetPayload<S extends boolean | null | undefined | ProjectObjectiveDefaultArgs> = $Result.GetResult<Prisma.$ProjectObjectivePayload, S>

  type ProjectObjectiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectObjectiveFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectObjectiveCountAggregateInputType | true
    }

  export interface ProjectObjectiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectObjective'], meta: { name: 'ProjectObjective' } }
    /**
     * Find zero or one ProjectObjective that matches the filter.
     * @param {ProjectObjectiveFindUniqueArgs} args - Arguments to find a ProjectObjective
     * @example
     * // Get one ProjectObjective
     * const projectObjective = await prisma.projectObjective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectObjectiveFindUniqueArgs>(args: SelectSubset<T, ProjectObjectiveFindUniqueArgs<ExtArgs>>): Prisma__ProjectObjectiveClient<$Result.GetResult<Prisma.$ProjectObjectivePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectObjective that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectObjectiveFindUniqueOrThrowArgs} args - Arguments to find a ProjectObjective
     * @example
     * // Get one ProjectObjective
     * const projectObjective = await prisma.projectObjective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectObjectiveFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectObjectiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectObjectiveClient<$Result.GetResult<Prisma.$ProjectObjectivePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectObjective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectObjectiveFindFirstArgs} args - Arguments to find a ProjectObjective
     * @example
     * // Get one ProjectObjective
     * const projectObjective = await prisma.projectObjective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectObjectiveFindFirstArgs>(args?: SelectSubset<T, ProjectObjectiveFindFirstArgs<ExtArgs>>): Prisma__ProjectObjectiveClient<$Result.GetResult<Prisma.$ProjectObjectivePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectObjective that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectObjectiveFindFirstOrThrowArgs} args - Arguments to find a ProjectObjective
     * @example
     * // Get one ProjectObjective
     * const projectObjective = await prisma.projectObjective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectObjectiveFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectObjectiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectObjectiveClient<$Result.GetResult<Prisma.$ProjectObjectivePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectObjectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectObjectiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectObjectives
     * const projectObjectives = await prisma.projectObjective.findMany()
     * 
     * // Get first 10 ProjectObjectives
     * const projectObjectives = await prisma.projectObjective.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectObjectiveWithIdOnly = await prisma.projectObjective.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectObjectiveFindManyArgs>(args?: SelectSubset<T, ProjectObjectiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectObjectivePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectObjective.
     * @param {ProjectObjectiveCreateArgs} args - Arguments to create a ProjectObjective.
     * @example
     * // Create one ProjectObjective
     * const ProjectObjective = await prisma.projectObjective.create({
     *   data: {
     *     // ... data to create a ProjectObjective
     *   }
     * })
     * 
     */
    create<T extends ProjectObjectiveCreateArgs>(args: SelectSubset<T, ProjectObjectiveCreateArgs<ExtArgs>>): Prisma__ProjectObjectiveClient<$Result.GetResult<Prisma.$ProjectObjectivePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectObjectives.
     * @param {ProjectObjectiveCreateManyArgs} args - Arguments to create many ProjectObjectives.
     * @example
     * // Create many ProjectObjectives
     * const projectObjective = await prisma.projectObjective.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectObjectiveCreateManyArgs>(args?: SelectSubset<T, ProjectObjectiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectObjectives and returns the data saved in the database.
     * @param {ProjectObjectiveCreateManyAndReturnArgs} args - Arguments to create many ProjectObjectives.
     * @example
     * // Create many ProjectObjectives
     * const projectObjective = await prisma.projectObjective.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectObjectives and only return the `id`
     * const projectObjectiveWithIdOnly = await prisma.projectObjective.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectObjectiveCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectObjectiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectObjectivePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectObjective.
     * @param {ProjectObjectiveDeleteArgs} args - Arguments to delete one ProjectObjective.
     * @example
     * // Delete one ProjectObjective
     * const ProjectObjective = await prisma.projectObjective.delete({
     *   where: {
     *     // ... filter to delete one ProjectObjective
     *   }
     * })
     * 
     */
    delete<T extends ProjectObjectiveDeleteArgs>(args: SelectSubset<T, ProjectObjectiveDeleteArgs<ExtArgs>>): Prisma__ProjectObjectiveClient<$Result.GetResult<Prisma.$ProjectObjectivePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectObjective.
     * @param {ProjectObjectiveUpdateArgs} args - Arguments to update one ProjectObjective.
     * @example
     * // Update one ProjectObjective
     * const projectObjective = await prisma.projectObjective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectObjectiveUpdateArgs>(args: SelectSubset<T, ProjectObjectiveUpdateArgs<ExtArgs>>): Prisma__ProjectObjectiveClient<$Result.GetResult<Prisma.$ProjectObjectivePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectObjectives.
     * @param {ProjectObjectiveDeleteManyArgs} args - Arguments to filter ProjectObjectives to delete.
     * @example
     * // Delete a few ProjectObjectives
     * const { count } = await prisma.projectObjective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectObjectiveDeleteManyArgs>(args?: SelectSubset<T, ProjectObjectiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectObjectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectObjectives
     * const projectObjective = await prisma.projectObjective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectObjectiveUpdateManyArgs>(args: SelectSubset<T, ProjectObjectiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectObjective.
     * @param {ProjectObjectiveUpsertArgs} args - Arguments to update or create a ProjectObjective.
     * @example
     * // Update or create a ProjectObjective
     * const projectObjective = await prisma.projectObjective.upsert({
     *   create: {
     *     // ... data to create a ProjectObjective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectObjective we want to update
     *   }
     * })
     */
    upsert<T extends ProjectObjectiveUpsertArgs>(args: SelectSubset<T, ProjectObjectiveUpsertArgs<ExtArgs>>): Prisma__ProjectObjectiveClient<$Result.GetResult<Prisma.$ProjectObjectivePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectObjectiveCountArgs} args - Arguments to filter ProjectObjectives to count.
     * @example
     * // Count the number of ProjectObjectives
     * const count = await prisma.projectObjective.count({
     *   where: {
     *     // ... the filter for the ProjectObjectives we want to count
     *   }
     * })
    **/
    count<T extends ProjectObjectiveCountArgs>(
      args?: Subset<T, ProjectObjectiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectObjectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectObjectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectObjectiveAggregateArgs>(args: Subset<T, ProjectObjectiveAggregateArgs>): Prisma.PrismaPromise<GetProjectObjectiveAggregateType<T>>

    /**
     * Group by ProjectObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectObjectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectObjectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectObjectiveGroupByArgs['orderBy'] }
        : { orderBy?: ProjectObjectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectObjectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectObjectiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectObjective model
   */
  readonly fields: ProjectObjectiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectObjective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectObjectiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectObjective model
   */ 
  interface ProjectObjectiveFieldRefs {
    readonly id: FieldRef<"ProjectObjective", 'String'>
    readonly projectId: FieldRef<"ProjectObjective", 'String'>
    readonly description: FieldRef<"ProjectObjective", 'String'>
    readonly category: FieldRef<"ProjectObjective", 'String'>
    readonly status: FieldRef<"ProjectObjective", 'String'>
    readonly targetDate: FieldRef<"ProjectObjective", 'DateTime'>
    readonly completedDate: FieldRef<"ProjectObjective", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectObjective findUnique
   */
  export type ProjectObjectiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectObjective
     */
    select?: ProjectObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which ProjectObjective to fetch.
     */
    where: ProjectObjectiveWhereUniqueInput
  }

  /**
   * ProjectObjective findUniqueOrThrow
   */
  export type ProjectObjectiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectObjective
     */
    select?: ProjectObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which ProjectObjective to fetch.
     */
    where: ProjectObjectiveWhereUniqueInput
  }

  /**
   * ProjectObjective findFirst
   */
  export type ProjectObjectiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectObjective
     */
    select?: ProjectObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which ProjectObjective to fetch.
     */
    where?: ProjectObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectObjectives to fetch.
     */
    orderBy?: ProjectObjectiveOrderByWithRelationInput | ProjectObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectObjectives.
     */
    cursor?: ProjectObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectObjectives.
     */
    distinct?: ProjectObjectiveScalarFieldEnum | ProjectObjectiveScalarFieldEnum[]
  }

  /**
   * ProjectObjective findFirstOrThrow
   */
  export type ProjectObjectiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectObjective
     */
    select?: ProjectObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which ProjectObjective to fetch.
     */
    where?: ProjectObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectObjectives to fetch.
     */
    orderBy?: ProjectObjectiveOrderByWithRelationInput | ProjectObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectObjectives.
     */
    cursor?: ProjectObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectObjectives.
     */
    distinct?: ProjectObjectiveScalarFieldEnum | ProjectObjectiveScalarFieldEnum[]
  }

  /**
   * ProjectObjective findMany
   */
  export type ProjectObjectiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectObjective
     */
    select?: ProjectObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which ProjectObjectives to fetch.
     */
    where?: ProjectObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectObjectives to fetch.
     */
    orderBy?: ProjectObjectiveOrderByWithRelationInput | ProjectObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectObjectives.
     */
    cursor?: ProjectObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectObjectives.
     */
    skip?: number
    distinct?: ProjectObjectiveScalarFieldEnum | ProjectObjectiveScalarFieldEnum[]
  }

  /**
   * ProjectObjective create
   */
  export type ProjectObjectiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectObjective
     */
    select?: ProjectObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectObjective.
     */
    data: XOR<ProjectObjectiveCreateInput, ProjectObjectiveUncheckedCreateInput>
  }

  /**
   * ProjectObjective createMany
   */
  export type ProjectObjectiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectObjectives.
     */
    data: ProjectObjectiveCreateManyInput | ProjectObjectiveCreateManyInput[]
  }

  /**
   * ProjectObjective createManyAndReturn
   */
  export type ProjectObjectiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectObjective
     */
    select?: ProjectObjectiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectObjectives.
     */
    data: ProjectObjectiveCreateManyInput | ProjectObjectiveCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectObjectiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectObjective update
   */
  export type ProjectObjectiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectObjective
     */
    select?: ProjectObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectObjective.
     */
    data: XOR<ProjectObjectiveUpdateInput, ProjectObjectiveUncheckedUpdateInput>
    /**
     * Choose, which ProjectObjective to update.
     */
    where: ProjectObjectiveWhereUniqueInput
  }

  /**
   * ProjectObjective updateMany
   */
  export type ProjectObjectiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectObjectives.
     */
    data: XOR<ProjectObjectiveUpdateManyMutationInput, ProjectObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which ProjectObjectives to update
     */
    where?: ProjectObjectiveWhereInput
  }

  /**
   * ProjectObjective upsert
   */
  export type ProjectObjectiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectObjective
     */
    select?: ProjectObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectObjectiveInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectObjective to update in case it exists.
     */
    where: ProjectObjectiveWhereUniqueInput
    /**
     * In case the ProjectObjective found by the `where` argument doesn't exist, create a new ProjectObjective with this data.
     */
    create: XOR<ProjectObjectiveCreateInput, ProjectObjectiveUncheckedCreateInput>
    /**
     * In case the ProjectObjective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectObjectiveUpdateInput, ProjectObjectiveUncheckedUpdateInput>
  }

  /**
   * ProjectObjective delete
   */
  export type ProjectObjectiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectObjective
     */
    select?: ProjectObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectObjectiveInclude<ExtArgs> | null
    /**
     * Filter which ProjectObjective to delete.
     */
    where: ProjectObjectiveWhereUniqueInput
  }

  /**
   * ProjectObjective deleteMany
   */
  export type ProjectObjectiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectObjectives to delete
     */
    where?: ProjectObjectiveWhereInput
  }

  /**
   * ProjectObjective without action
   */
  export type ProjectObjectiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectObjective
     */
    select?: ProjectObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectObjectiveInclude<ExtArgs> | null
  }


  /**
   * Model ProjectKPI
   */

  export type AggregateProjectKPI = {
    _count: ProjectKPICountAggregateOutputType | null
    _avg: ProjectKPIAvgAggregateOutputType | null
    _sum: ProjectKPISumAggregateOutputType | null
    _min: ProjectKPIMinAggregateOutputType | null
    _max: ProjectKPIMaxAggregateOutputType | null
  }

  export type ProjectKPIAvgAggregateOutputType = {
    targetValue: number | null
    currentValue: number | null
  }

  export type ProjectKPISumAggregateOutputType = {
    targetValue: number | null
    currentValue: number | null
  }

  export type ProjectKPIMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    description: string | null
    targetValue: number | null
    currentValue: number | null
    unit: string | null
    formulaType: string | null
    formula: string | null
    status: string | null
  }

  export type ProjectKPIMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    description: string | null
    targetValue: number | null
    currentValue: number | null
    unit: string | null
    formulaType: string | null
    formula: string | null
    status: string | null
  }

  export type ProjectKPICountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    description: number
    targetValue: number
    currentValue: number
    unit: number
    formulaType: number
    formula: number
    status: number
    _all: number
  }


  export type ProjectKPIAvgAggregateInputType = {
    targetValue?: true
    currentValue?: true
  }

  export type ProjectKPISumAggregateInputType = {
    targetValue?: true
    currentValue?: true
  }

  export type ProjectKPIMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    targetValue?: true
    currentValue?: true
    unit?: true
    formulaType?: true
    formula?: true
    status?: true
  }

  export type ProjectKPIMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    targetValue?: true
    currentValue?: true
    unit?: true
    formulaType?: true
    formula?: true
    status?: true
  }

  export type ProjectKPICountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    targetValue?: true
    currentValue?: true
    unit?: true
    formulaType?: true
    formula?: true
    status?: true
    _all?: true
  }

  export type ProjectKPIAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectKPI to aggregate.
     */
    where?: ProjectKPIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectKPIS to fetch.
     */
    orderBy?: ProjectKPIOrderByWithRelationInput | ProjectKPIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectKPIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectKPIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectKPIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectKPIS
    **/
    _count?: true | ProjectKPICountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectKPIAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectKPISumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectKPIMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectKPIMaxAggregateInputType
  }

  export type GetProjectKPIAggregateType<T extends ProjectKPIAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectKPI]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectKPI[P]>
      : GetScalarType<T[P], AggregateProjectKPI[P]>
  }




  export type ProjectKPIGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectKPIWhereInput
    orderBy?: ProjectKPIOrderByWithAggregationInput | ProjectKPIOrderByWithAggregationInput[]
    by: ProjectKPIScalarFieldEnum[] | ProjectKPIScalarFieldEnum
    having?: ProjectKPIScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectKPICountAggregateInputType | true
    _avg?: ProjectKPIAvgAggregateInputType
    _sum?: ProjectKPISumAggregateInputType
    _min?: ProjectKPIMinAggregateInputType
    _max?: ProjectKPIMaxAggregateInputType
  }

  export type ProjectKPIGroupByOutputType = {
    id: string
    projectId: string
    name: string
    description: string | null
    targetValue: number
    currentValue: number
    unit: string
    formulaType: string
    formula: string | null
    status: string
    _count: ProjectKPICountAggregateOutputType | null
    _avg: ProjectKPIAvgAggregateOutputType | null
    _sum: ProjectKPISumAggregateOutputType | null
    _min: ProjectKPIMinAggregateOutputType | null
    _max: ProjectKPIMaxAggregateOutputType | null
  }

  type GetProjectKPIGroupByPayload<T extends ProjectKPIGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectKPIGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectKPIGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectKPIGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectKPIGroupByOutputType[P]>
        }
      >
    >


  export type ProjectKPISelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    targetValue?: boolean
    currentValue?: boolean
    unit?: boolean
    formulaType?: boolean
    formula?: boolean
    status?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectKPI"]>

  export type ProjectKPISelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    targetValue?: boolean
    currentValue?: boolean
    unit?: boolean
    formulaType?: boolean
    formula?: boolean
    status?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectKPI"]>

  export type ProjectKPISelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    targetValue?: boolean
    currentValue?: boolean
    unit?: boolean
    formulaType?: boolean
    formula?: boolean
    status?: boolean
  }

  export type ProjectKPIInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectKPIIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectKPIPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectKPI"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      description: string | null
      targetValue: number
      currentValue: number
      unit: string
      formulaType: string
      formula: string | null
      status: string
    }, ExtArgs["result"]["projectKPI"]>
    composites: {}
  }

  type ProjectKPIGetPayload<S extends boolean | null | undefined | ProjectKPIDefaultArgs> = $Result.GetResult<Prisma.$ProjectKPIPayload, S>

  type ProjectKPICountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectKPIFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectKPICountAggregateInputType | true
    }

  export interface ProjectKPIDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectKPI'], meta: { name: 'ProjectKPI' } }
    /**
     * Find zero or one ProjectKPI that matches the filter.
     * @param {ProjectKPIFindUniqueArgs} args - Arguments to find a ProjectKPI
     * @example
     * // Get one ProjectKPI
     * const projectKPI = await prisma.projectKPI.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectKPIFindUniqueArgs>(args: SelectSubset<T, ProjectKPIFindUniqueArgs<ExtArgs>>): Prisma__ProjectKPIClient<$Result.GetResult<Prisma.$ProjectKPIPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectKPI that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectKPIFindUniqueOrThrowArgs} args - Arguments to find a ProjectKPI
     * @example
     * // Get one ProjectKPI
     * const projectKPI = await prisma.projectKPI.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectKPIFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectKPIFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectKPIClient<$Result.GetResult<Prisma.$ProjectKPIPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectKPI that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectKPIFindFirstArgs} args - Arguments to find a ProjectKPI
     * @example
     * // Get one ProjectKPI
     * const projectKPI = await prisma.projectKPI.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectKPIFindFirstArgs>(args?: SelectSubset<T, ProjectKPIFindFirstArgs<ExtArgs>>): Prisma__ProjectKPIClient<$Result.GetResult<Prisma.$ProjectKPIPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectKPI that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectKPIFindFirstOrThrowArgs} args - Arguments to find a ProjectKPI
     * @example
     * // Get one ProjectKPI
     * const projectKPI = await prisma.projectKPI.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectKPIFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectKPIFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectKPIClient<$Result.GetResult<Prisma.$ProjectKPIPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectKPIS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectKPIFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectKPIS
     * const projectKPIS = await prisma.projectKPI.findMany()
     * 
     * // Get first 10 ProjectKPIS
     * const projectKPIS = await prisma.projectKPI.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectKPIWithIdOnly = await prisma.projectKPI.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectKPIFindManyArgs>(args?: SelectSubset<T, ProjectKPIFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectKPIPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectKPI.
     * @param {ProjectKPICreateArgs} args - Arguments to create a ProjectKPI.
     * @example
     * // Create one ProjectKPI
     * const ProjectKPI = await prisma.projectKPI.create({
     *   data: {
     *     // ... data to create a ProjectKPI
     *   }
     * })
     * 
     */
    create<T extends ProjectKPICreateArgs>(args: SelectSubset<T, ProjectKPICreateArgs<ExtArgs>>): Prisma__ProjectKPIClient<$Result.GetResult<Prisma.$ProjectKPIPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectKPIS.
     * @param {ProjectKPICreateManyArgs} args - Arguments to create many ProjectKPIS.
     * @example
     * // Create many ProjectKPIS
     * const projectKPI = await prisma.projectKPI.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectKPICreateManyArgs>(args?: SelectSubset<T, ProjectKPICreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectKPIS and returns the data saved in the database.
     * @param {ProjectKPICreateManyAndReturnArgs} args - Arguments to create many ProjectKPIS.
     * @example
     * // Create many ProjectKPIS
     * const projectKPI = await prisma.projectKPI.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectKPIS and only return the `id`
     * const projectKPIWithIdOnly = await prisma.projectKPI.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectKPICreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectKPICreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectKPIPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectKPI.
     * @param {ProjectKPIDeleteArgs} args - Arguments to delete one ProjectKPI.
     * @example
     * // Delete one ProjectKPI
     * const ProjectKPI = await prisma.projectKPI.delete({
     *   where: {
     *     // ... filter to delete one ProjectKPI
     *   }
     * })
     * 
     */
    delete<T extends ProjectKPIDeleteArgs>(args: SelectSubset<T, ProjectKPIDeleteArgs<ExtArgs>>): Prisma__ProjectKPIClient<$Result.GetResult<Prisma.$ProjectKPIPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectKPI.
     * @param {ProjectKPIUpdateArgs} args - Arguments to update one ProjectKPI.
     * @example
     * // Update one ProjectKPI
     * const projectKPI = await prisma.projectKPI.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectKPIUpdateArgs>(args: SelectSubset<T, ProjectKPIUpdateArgs<ExtArgs>>): Prisma__ProjectKPIClient<$Result.GetResult<Prisma.$ProjectKPIPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectKPIS.
     * @param {ProjectKPIDeleteManyArgs} args - Arguments to filter ProjectKPIS to delete.
     * @example
     * // Delete a few ProjectKPIS
     * const { count } = await prisma.projectKPI.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectKPIDeleteManyArgs>(args?: SelectSubset<T, ProjectKPIDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectKPIS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectKPIUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectKPIS
     * const projectKPI = await prisma.projectKPI.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectKPIUpdateManyArgs>(args: SelectSubset<T, ProjectKPIUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectKPI.
     * @param {ProjectKPIUpsertArgs} args - Arguments to update or create a ProjectKPI.
     * @example
     * // Update or create a ProjectKPI
     * const projectKPI = await prisma.projectKPI.upsert({
     *   create: {
     *     // ... data to create a ProjectKPI
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectKPI we want to update
     *   }
     * })
     */
    upsert<T extends ProjectKPIUpsertArgs>(args: SelectSubset<T, ProjectKPIUpsertArgs<ExtArgs>>): Prisma__ProjectKPIClient<$Result.GetResult<Prisma.$ProjectKPIPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectKPIS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectKPICountArgs} args - Arguments to filter ProjectKPIS to count.
     * @example
     * // Count the number of ProjectKPIS
     * const count = await prisma.projectKPI.count({
     *   where: {
     *     // ... the filter for the ProjectKPIS we want to count
     *   }
     * })
    **/
    count<T extends ProjectKPICountArgs>(
      args?: Subset<T, ProjectKPICountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectKPICountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectKPI.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectKPIAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectKPIAggregateArgs>(args: Subset<T, ProjectKPIAggregateArgs>): Prisma.PrismaPromise<GetProjectKPIAggregateType<T>>

    /**
     * Group by ProjectKPI.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectKPIGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectKPIGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectKPIGroupByArgs['orderBy'] }
        : { orderBy?: ProjectKPIGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectKPIGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectKPIGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectKPI model
   */
  readonly fields: ProjectKPIFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectKPI.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectKPIClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectKPI model
   */ 
  interface ProjectKPIFieldRefs {
    readonly id: FieldRef<"ProjectKPI", 'String'>
    readonly projectId: FieldRef<"ProjectKPI", 'String'>
    readonly name: FieldRef<"ProjectKPI", 'String'>
    readonly description: FieldRef<"ProjectKPI", 'String'>
    readonly targetValue: FieldRef<"ProjectKPI", 'Float'>
    readonly currentValue: FieldRef<"ProjectKPI", 'Float'>
    readonly unit: FieldRef<"ProjectKPI", 'String'>
    readonly formulaType: FieldRef<"ProjectKPI", 'String'>
    readonly formula: FieldRef<"ProjectKPI", 'String'>
    readonly status: FieldRef<"ProjectKPI", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectKPI findUnique
   */
  export type ProjectKPIFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectKPI
     */
    select?: ProjectKPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectKPIInclude<ExtArgs> | null
    /**
     * Filter, which ProjectKPI to fetch.
     */
    where: ProjectKPIWhereUniqueInput
  }

  /**
   * ProjectKPI findUniqueOrThrow
   */
  export type ProjectKPIFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectKPI
     */
    select?: ProjectKPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectKPIInclude<ExtArgs> | null
    /**
     * Filter, which ProjectKPI to fetch.
     */
    where: ProjectKPIWhereUniqueInput
  }

  /**
   * ProjectKPI findFirst
   */
  export type ProjectKPIFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectKPI
     */
    select?: ProjectKPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectKPIInclude<ExtArgs> | null
    /**
     * Filter, which ProjectKPI to fetch.
     */
    where?: ProjectKPIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectKPIS to fetch.
     */
    orderBy?: ProjectKPIOrderByWithRelationInput | ProjectKPIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectKPIS.
     */
    cursor?: ProjectKPIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectKPIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectKPIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectKPIS.
     */
    distinct?: ProjectKPIScalarFieldEnum | ProjectKPIScalarFieldEnum[]
  }

  /**
   * ProjectKPI findFirstOrThrow
   */
  export type ProjectKPIFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectKPI
     */
    select?: ProjectKPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectKPIInclude<ExtArgs> | null
    /**
     * Filter, which ProjectKPI to fetch.
     */
    where?: ProjectKPIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectKPIS to fetch.
     */
    orderBy?: ProjectKPIOrderByWithRelationInput | ProjectKPIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectKPIS.
     */
    cursor?: ProjectKPIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectKPIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectKPIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectKPIS.
     */
    distinct?: ProjectKPIScalarFieldEnum | ProjectKPIScalarFieldEnum[]
  }

  /**
   * ProjectKPI findMany
   */
  export type ProjectKPIFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectKPI
     */
    select?: ProjectKPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectKPIInclude<ExtArgs> | null
    /**
     * Filter, which ProjectKPIS to fetch.
     */
    where?: ProjectKPIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectKPIS to fetch.
     */
    orderBy?: ProjectKPIOrderByWithRelationInput | ProjectKPIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectKPIS.
     */
    cursor?: ProjectKPIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectKPIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectKPIS.
     */
    skip?: number
    distinct?: ProjectKPIScalarFieldEnum | ProjectKPIScalarFieldEnum[]
  }

  /**
   * ProjectKPI create
   */
  export type ProjectKPICreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectKPI
     */
    select?: ProjectKPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectKPIInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectKPI.
     */
    data: XOR<ProjectKPICreateInput, ProjectKPIUncheckedCreateInput>
  }

  /**
   * ProjectKPI createMany
   */
  export type ProjectKPICreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectKPIS.
     */
    data: ProjectKPICreateManyInput | ProjectKPICreateManyInput[]
  }

  /**
   * ProjectKPI createManyAndReturn
   */
  export type ProjectKPICreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectKPI
     */
    select?: ProjectKPISelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectKPIS.
     */
    data: ProjectKPICreateManyInput | ProjectKPICreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectKPIIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectKPI update
   */
  export type ProjectKPIUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectKPI
     */
    select?: ProjectKPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectKPIInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectKPI.
     */
    data: XOR<ProjectKPIUpdateInput, ProjectKPIUncheckedUpdateInput>
    /**
     * Choose, which ProjectKPI to update.
     */
    where: ProjectKPIWhereUniqueInput
  }

  /**
   * ProjectKPI updateMany
   */
  export type ProjectKPIUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectKPIS.
     */
    data: XOR<ProjectKPIUpdateManyMutationInput, ProjectKPIUncheckedUpdateManyInput>
    /**
     * Filter which ProjectKPIS to update
     */
    where?: ProjectKPIWhereInput
  }

  /**
   * ProjectKPI upsert
   */
  export type ProjectKPIUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectKPI
     */
    select?: ProjectKPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectKPIInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectKPI to update in case it exists.
     */
    where: ProjectKPIWhereUniqueInput
    /**
     * In case the ProjectKPI found by the `where` argument doesn't exist, create a new ProjectKPI with this data.
     */
    create: XOR<ProjectKPICreateInput, ProjectKPIUncheckedCreateInput>
    /**
     * In case the ProjectKPI was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectKPIUpdateInput, ProjectKPIUncheckedUpdateInput>
  }

  /**
   * ProjectKPI delete
   */
  export type ProjectKPIDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectKPI
     */
    select?: ProjectKPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectKPIInclude<ExtArgs> | null
    /**
     * Filter which ProjectKPI to delete.
     */
    where: ProjectKPIWhereUniqueInput
  }

  /**
   * ProjectKPI deleteMany
   */
  export type ProjectKPIDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectKPIS to delete
     */
    where?: ProjectKPIWhereInput
  }

  /**
   * ProjectKPI without action
   */
  export type ProjectKPIDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectKPI
     */
    select?: ProjectKPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectKPIInclude<ExtArgs> | null
  }


  /**
   * Model ProjectPhase
   */

  export type AggregateProjectPhase = {
    _count: ProjectPhaseCountAggregateOutputType | null
    _avg: ProjectPhaseAvgAggregateOutputType | null
    _sum: ProjectPhaseSumAggregateOutputType | null
    _min: ProjectPhaseMinAggregateOutputType | null
    _max: ProjectPhaseMaxAggregateOutputType | null
  }

  export type ProjectPhaseAvgAggregateOutputType = {
    orderNum: number | null
    weight: number | null
    progress: number | null
  }

  export type ProjectPhaseSumAggregateOutputType = {
    orderNum: number | null
    weight: number | null
    progress: number | null
  }

  export type ProjectPhaseMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    description: string | null
    orderNum: number | null
    startDate: Date | null
    endDate: Date | null
    actualStartDate: Date | null
    actualEndDate: Date | null
    status: string | null
    weight: number | null
    dependsOnPhaseId: string | null
    progress: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectPhaseMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    description: string | null
    orderNum: number | null
    startDate: Date | null
    endDate: Date | null
    actualStartDate: Date | null
    actualEndDate: Date | null
    status: string | null
    weight: number | null
    dependsOnPhaseId: string | null
    progress: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectPhaseCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    description: number
    orderNum: number
    startDate: number
    endDate: number
    actualStartDate: number
    actualEndDate: number
    status: number
    weight: number
    dependsOnPhaseId: number
    progress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectPhaseAvgAggregateInputType = {
    orderNum?: true
    weight?: true
    progress?: true
  }

  export type ProjectPhaseSumAggregateInputType = {
    orderNum?: true
    weight?: true
    progress?: true
  }

  export type ProjectPhaseMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    orderNum?: true
    startDate?: true
    endDate?: true
    actualStartDate?: true
    actualEndDate?: true
    status?: true
    weight?: true
    dependsOnPhaseId?: true
    progress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectPhaseMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    orderNum?: true
    startDate?: true
    endDate?: true
    actualStartDate?: true
    actualEndDate?: true
    status?: true
    weight?: true
    dependsOnPhaseId?: true
    progress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectPhaseCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    orderNum?: true
    startDate?: true
    endDate?: true
    actualStartDate?: true
    actualEndDate?: true
    status?: true
    weight?: true
    dependsOnPhaseId?: true
    progress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectPhaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectPhase to aggregate.
     */
    where?: ProjectPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectPhases to fetch.
     */
    orderBy?: ProjectPhaseOrderByWithRelationInput | ProjectPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectPhases
    **/
    _count?: true | ProjectPhaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectPhaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectPhaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectPhaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectPhaseMaxAggregateInputType
  }

  export type GetProjectPhaseAggregateType<T extends ProjectPhaseAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectPhase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectPhase[P]>
      : GetScalarType<T[P], AggregateProjectPhase[P]>
  }




  export type ProjectPhaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectPhaseWhereInput
    orderBy?: ProjectPhaseOrderByWithAggregationInput | ProjectPhaseOrderByWithAggregationInput[]
    by: ProjectPhaseScalarFieldEnum[] | ProjectPhaseScalarFieldEnum
    having?: ProjectPhaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectPhaseCountAggregateInputType | true
    _avg?: ProjectPhaseAvgAggregateInputType
    _sum?: ProjectPhaseSumAggregateInputType
    _min?: ProjectPhaseMinAggregateInputType
    _max?: ProjectPhaseMaxAggregateInputType
  }

  export type ProjectPhaseGroupByOutputType = {
    id: string
    projectId: string
    name: string
    description: string | null
    orderNum: number
    startDate: Date
    endDate: Date
    actualStartDate: Date | null
    actualEndDate: Date | null
    status: string
    weight: number
    dependsOnPhaseId: string | null
    progress: number
    createdAt: Date
    updatedAt: Date
    _count: ProjectPhaseCountAggregateOutputType | null
    _avg: ProjectPhaseAvgAggregateOutputType | null
    _sum: ProjectPhaseSumAggregateOutputType | null
    _min: ProjectPhaseMinAggregateOutputType | null
    _max: ProjectPhaseMaxAggregateOutputType | null
  }

  type GetProjectPhaseGroupByPayload<T extends ProjectPhaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectPhaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectPhaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectPhaseGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectPhaseGroupByOutputType[P]>
        }
      >
    >


  export type ProjectPhaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    orderNum?: boolean
    startDate?: boolean
    endDate?: boolean
    actualStartDate?: boolean
    actualEndDate?: boolean
    status?: boolean
    weight?: boolean
    dependsOnPhaseId?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    dependsOn?: boolean | ProjectPhase$dependsOnArgs<ExtArgs>
    dependents?: boolean | ProjectPhase$dependentsArgs<ExtArgs>
    tasks?: boolean | ProjectPhase$tasksArgs<ExtArgs>
    _count?: boolean | ProjectPhaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectPhase"]>

  export type ProjectPhaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    orderNum?: boolean
    startDate?: boolean
    endDate?: boolean
    actualStartDate?: boolean
    actualEndDate?: boolean
    status?: boolean
    weight?: boolean
    dependsOnPhaseId?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    dependsOn?: boolean | ProjectPhase$dependsOnArgs<ExtArgs>
  }, ExtArgs["result"]["projectPhase"]>

  export type ProjectPhaseSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    orderNum?: boolean
    startDate?: boolean
    endDate?: boolean
    actualStartDate?: boolean
    actualEndDate?: boolean
    status?: boolean
    weight?: boolean
    dependsOnPhaseId?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectPhaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    dependsOn?: boolean | ProjectPhase$dependsOnArgs<ExtArgs>
    dependents?: boolean | ProjectPhase$dependentsArgs<ExtArgs>
    tasks?: boolean | ProjectPhase$tasksArgs<ExtArgs>
    _count?: boolean | ProjectPhaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectPhaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    dependsOn?: boolean | ProjectPhase$dependsOnArgs<ExtArgs>
  }

  export type $ProjectPhasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectPhase"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      dependsOn: Prisma.$ProjectPhasePayload<ExtArgs> | null
      dependents: Prisma.$ProjectPhasePayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      description: string | null
      orderNum: number
      startDate: Date
      endDate: Date
      actualStartDate: Date | null
      actualEndDate: Date | null
      status: string
      weight: number
      dependsOnPhaseId: string | null
      progress: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectPhase"]>
    composites: {}
  }

  type ProjectPhaseGetPayload<S extends boolean | null | undefined | ProjectPhaseDefaultArgs> = $Result.GetResult<Prisma.$ProjectPhasePayload, S>

  type ProjectPhaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectPhaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectPhaseCountAggregateInputType | true
    }

  export interface ProjectPhaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectPhase'], meta: { name: 'ProjectPhase' } }
    /**
     * Find zero or one ProjectPhase that matches the filter.
     * @param {ProjectPhaseFindUniqueArgs} args - Arguments to find a ProjectPhase
     * @example
     * // Get one ProjectPhase
     * const projectPhase = await prisma.projectPhase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectPhaseFindUniqueArgs>(args: SelectSubset<T, ProjectPhaseFindUniqueArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectPhase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectPhaseFindUniqueOrThrowArgs} args - Arguments to find a ProjectPhase
     * @example
     * // Get one ProjectPhase
     * const projectPhase = await prisma.projectPhase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectPhaseFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectPhaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectPhase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectPhaseFindFirstArgs} args - Arguments to find a ProjectPhase
     * @example
     * // Get one ProjectPhase
     * const projectPhase = await prisma.projectPhase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectPhaseFindFirstArgs>(args?: SelectSubset<T, ProjectPhaseFindFirstArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectPhase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectPhaseFindFirstOrThrowArgs} args - Arguments to find a ProjectPhase
     * @example
     * // Get one ProjectPhase
     * const projectPhase = await prisma.projectPhase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectPhaseFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectPhaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectPhases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectPhaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectPhases
     * const projectPhases = await prisma.projectPhase.findMany()
     * 
     * // Get first 10 ProjectPhases
     * const projectPhases = await prisma.projectPhase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectPhaseWithIdOnly = await prisma.projectPhase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectPhaseFindManyArgs>(args?: SelectSubset<T, ProjectPhaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectPhase.
     * @param {ProjectPhaseCreateArgs} args - Arguments to create a ProjectPhase.
     * @example
     * // Create one ProjectPhase
     * const ProjectPhase = await prisma.projectPhase.create({
     *   data: {
     *     // ... data to create a ProjectPhase
     *   }
     * })
     * 
     */
    create<T extends ProjectPhaseCreateArgs>(args: SelectSubset<T, ProjectPhaseCreateArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectPhases.
     * @param {ProjectPhaseCreateManyArgs} args - Arguments to create many ProjectPhases.
     * @example
     * // Create many ProjectPhases
     * const projectPhase = await prisma.projectPhase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectPhaseCreateManyArgs>(args?: SelectSubset<T, ProjectPhaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectPhases and returns the data saved in the database.
     * @param {ProjectPhaseCreateManyAndReturnArgs} args - Arguments to create many ProjectPhases.
     * @example
     * // Create many ProjectPhases
     * const projectPhase = await prisma.projectPhase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectPhases and only return the `id`
     * const projectPhaseWithIdOnly = await prisma.projectPhase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectPhaseCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectPhaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectPhase.
     * @param {ProjectPhaseDeleteArgs} args - Arguments to delete one ProjectPhase.
     * @example
     * // Delete one ProjectPhase
     * const ProjectPhase = await prisma.projectPhase.delete({
     *   where: {
     *     // ... filter to delete one ProjectPhase
     *   }
     * })
     * 
     */
    delete<T extends ProjectPhaseDeleteArgs>(args: SelectSubset<T, ProjectPhaseDeleteArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectPhase.
     * @param {ProjectPhaseUpdateArgs} args - Arguments to update one ProjectPhase.
     * @example
     * // Update one ProjectPhase
     * const projectPhase = await prisma.projectPhase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectPhaseUpdateArgs>(args: SelectSubset<T, ProjectPhaseUpdateArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectPhases.
     * @param {ProjectPhaseDeleteManyArgs} args - Arguments to filter ProjectPhases to delete.
     * @example
     * // Delete a few ProjectPhases
     * const { count } = await prisma.projectPhase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectPhaseDeleteManyArgs>(args?: SelectSubset<T, ProjectPhaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectPhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectPhaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectPhases
     * const projectPhase = await prisma.projectPhase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectPhaseUpdateManyArgs>(args: SelectSubset<T, ProjectPhaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectPhase.
     * @param {ProjectPhaseUpsertArgs} args - Arguments to update or create a ProjectPhase.
     * @example
     * // Update or create a ProjectPhase
     * const projectPhase = await prisma.projectPhase.upsert({
     *   create: {
     *     // ... data to create a ProjectPhase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectPhase we want to update
     *   }
     * })
     */
    upsert<T extends ProjectPhaseUpsertArgs>(args: SelectSubset<T, ProjectPhaseUpsertArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectPhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectPhaseCountArgs} args - Arguments to filter ProjectPhases to count.
     * @example
     * // Count the number of ProjectPhases
     * const count = await prisma.projectPhase.count({
     *   where: {
     *     // ... the filter for the ProjectPhases we want to count
     *   }
     * })
    **/
    count<T extends ProjectPhaseCountArgs>(
      args?: Subset<T, ProjectPhaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectPhaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectPhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectPhaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectPhaseAggregateArgs>(args: Subset<T, ProjectPhaseAggregateArgs>): Prisma.PrismaPromise<GetProjectPhaseAggregateType<T>>

    /**
     * Group by ProjectPhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectPhaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectPhaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectPhaseGroupByArgs['orderBy'] }
        : { orderBy?: ProjectPhaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectPhaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectPhaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectPhase model
   */
  readonly fields: ProjectPhaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectPhase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectPhaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    dependsOn<T extends ProjectPhase$dependsOnArgs<ExtArgs> = {}>(args?: Subset<T, ProjectPhase$dependsOnArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    dependents<T extends ProjectPhase$dependentsArgs<ExtArgs> = {}>(args?: Subset<T, ProjectPhase$dependentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends ProjectPhase$tasksArgs<ExtArgs> = {}>(args?: Subset<T, ProjectPhase$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectPhase model
   */ 
  interface ProjectPhaseFieldRefs {
    readonly id: FieldRef<"ProjectPhase", 'String'>
    readonly projectId: FieldRef<"ProjectPhase", 'String'>
    readonly name: FieldRef<"ProjectPhase", 'String'>
    readonly description: FieldRef<"ProjectPhase", 'String'>
    readonly orderNum: FieldRef<"ProjectPhase", 'Int'>
    readonly startDate: FieldRef<"ProjectPhase", 'DateTime'>
    readonly endDate: FieldRef<"ProjectPhase", 'DateTime'>
    readonly actualStartDate: FieldRef<"ProjectPhase", 'DateTime'>
    readonly actualEndDate: FieldRef<"ProjectPhase", 'DateTime'>
    readonly status: FieldRef<"ProjectPhase", 'String'>
    readonly weight: FieldRef<"ProjectPhase", 'Int'>
    readonly dependsOnPhaseId: FieldRef<"ProjectPhase", 'String'>
    readonly progress: FieldRef<"ProjectPhase", 'Int'>
    readonly createdAt: FieldRef<"ProjectPhase", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectPhase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectPhase findUnique
   */
  export type ProjectPhaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * Filter, which ProjectPhase to fetch.
     */
    where: ProjectPhaseWhereUniqueInput
  }

  /**
   * ProjectPhase findUniqueOrThrow
   */
  export type ProjectPhaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * Filter, which ProjectPhase to fetch.
     */
    where: ProjectPhaseWhereUniqueInput
  }

  /**
   * ProjectPhase findFirst
   */
  export type ProjectPhaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * Filter, which ProjectPhase to fetch.
     */
    where?: ProjectPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectPhases to fetch.
     */
    orderBy?: ProjectPhaseOrderByWithRelationInput | ProjectPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectPhases.
     */
    cursor?: ProjectPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectPhases.
     */
    distinct?: ProjectPhaseScalarFieldEnum | ProjectPhaseScalarFieldEnum[]
  }

  /**
   * ProjectPhase findFirstOrThrow
   */
  export type ProjectPhaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * Filter, which ProjectPhase to fetch.
     */
    where?: ProjectPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectPhases to fetch.
     */
    orderBy?: ProjectPhaseOrderByWithRelationInput | ProjectPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectPhases.
     */
    cursor?: ProjectPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectPhases.
     */
    distinct?: ProjectPhaseScalarFieldEnum | ProjectPhaseScalarFieldEnum[]
  }

  /**
   * ProjectPhase findMany
   */
  export type ProjectPhaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * Filter, which ProjectPhases to fetch.
     */
    where?: ProjectPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectPhases to fetch.
     */
    orderBy?: ProjectPhaseOrderByWithRelationInput | ProjectPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectPhases.
     */
    cursor?: ProjectPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectPhases.
     */
    skip?: number
    distinct?: ProjectPhaseScalarFieldEnum | ProjectPhaseScalarFieldEnum[]
  }

  /**
   * ProjectPhase create
   */
  export type ProjectPhaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectPhase.
     */
    data: XOR<ProjectPhaseCreateInput, ProjectPhaseUncheckedCreateInput>
  }

  /**
   * ProjectPhase createMany
   */
  export type ProjectPhaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectPhases.
     */
    data: ProjectPhaseCreateManyInput | ProjectPhaseCreateManyInput[]
  }

  /**
   * ProjectPhase createManyAndReturn
   */
  export type ProjectPhaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectPhases.
     */
    data: ProjectPhaseCreateManyInput | ProjectPhaseCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectPhase update
   */
  export type ProjectPhaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectPhase.
     */
    data: XOR<ProjectPhaseUpdateInput, ProjectPhaseUncheckedUpdateInput>
    /**
     * Choose, which ProjectPhase to update.
     */
    where: ProjectPhaseWhereUniqueInput
  }

  /**
   * ProjectPhase updateMany
   */
  export type ProjectPhaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectPhases.
     */
    data: XOR<ProjectPhaseUpdateManyMutationInput, ProjectPhaseUncheckedUpdateManyInput>
    /**
     * Filter which ProjectPhases to update
     */
    where?: ProjectPhaseWhereInput
  }

  /**
   * ProjectPhase upsert
   */
  export type ProjectPhaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectPhase to update in case it exists.
     */
    where: ProjectPhaseWhereUniqueInput
    /**
     * In case the ProjectPhase found by the `where` argument doesn't exist, create a new ProjectPhase with this data.
     */
    create: XOR<ProjectPhaseCreateInput, ProjectPhaseUncheckedCreateInput>
    /**
     * In case the ProjectPhase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectPhaseUpdateInput, ProjectPhaseUncheckedUpdateInput>
  }

  /**
   * ProjectPhase delete
   */
  export type ProjectPhaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * Filter which ProjectPhase to delete.
     */
    where: ProjectPhaseWhereUniqueInput
  }

  /**
   * ProjectPhase deleteMany
   */
  export type ProjectPhaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectPhases to delete
     */
    where?: ProjectPhaseWhereInput
  }

  /**
   * ProjectPhase.dependsOn
   */
  export type ProjectPhase$dependsOnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    where?: ProjectPhaseWhereInput
  }

  /**
   * ProjectPhase.dependents
   */
  export type ProjectPhase$dependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    where?: ProjectPhaseWhereInput
    orderBy?: ProjectPhaseOrderByWithRelationInput | ProjectPhaseOrderByWithRelationInput[]
    cursor?: ProjectPhaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectPhaseScalarFieldEnum | ProjectPhaseScalarFieldEnum[]
  }

  /**
   * ProjectPhase.tasks
   */
  export type ProjectPhase$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * ProjectPhase without action
   */
  export type ProjectPhaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    progress: number | null
    estimatedHours: number | null
    actualHours: number | null
  }

  export type TaskSumAggregateOutputType = {
    progress: number | null
    estimatedHours: number | null
    actualHours: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    phaseId: string | null
    title: string | null
    description: string | null
    assignedTo: string | null
    assignedBy: string | null
    assignedAt: Date | null
    startDate: Date | null
    dueDate: Date | null
    completedDate: Date | null
    progress: number | null
    status: string | null
    priority: string | null
    estimatedHours: number | null
    actualHours: number | null
    taskType: string | null
    linkedEntityType: string | null
    linkedEntityId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    phaseId: string | null
    title: string | null
    description: string | null
    assignedTo: string | null
    assignedBy: string | null
    assignedAt: Date | null
    startDate: Date | null
    dueDate: Date | null
    completedDate: Date | null
    progress: number | null
    status: string | null
    priority: string | null
    estimatedHours: number | null
    actualHours: number | null
    taskType: string | null
    linkedEntityType: string | null
    linkedEntityId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    projectId: number
    phaseId: number
    title: number
    description: number
    assignedTo: number
    assignedBy: number
    assignedAt: number
    startDate: number
    dueDate: number
    completedDate: number
    progress: number
    status: number
    priority: number
    estimatedHours: number
    actualHours: number
    taskType: number
    linkedEntityType: number
    linkedEntityId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    progress?: true
    estimatedHours?: true
    actualHours?: true
  }

  export type TaskSumAggregateInputType = {
    progress?: true
    estimatedHours?: true
    actualHours?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    projectId?: true
    phaseId?: true
    title?: true
    description?: true
    assignedTo?: true
    assignedBy?: true
    assignedAt?: true
    startDate?: true
    dueDate?: true
    completedDate?: true
    progress?: true
    status?: true
    priority?: true
    estimatedHours?: true
    actualHours?: true
    taskType?: true
    linkedEntityType?: true
    linkedEntityId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    projectId?: true
    phaseId?: true
    title?: true
    description?: true
    assignedTo?: true
    assignedBy?: true
    assignedAt?: true
    startDate?: true
    dueDate?: true
    completedDate?: true
    progress?: true
    status?: true
    priority?: true
    estimatedHours?: true
    actualHours?: true
    taskType?: true
    linkedEntityType?: true
    linkedEntityId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    projectId?: true
    phaseId?: true
    title?: true
    description?: true
    assignedTo?: true
    assignedBy?: true
    assignedAt?: true
    startDate?: true
    dueDate?: true
    completedDate?: true
    progress?: true
    status?: true
    priority?: true
    estimatedHours?: true
    actualHours?: true
    taskType?: true
    linkedEntityType?: true
    linkedEntityId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    projectId: string
    phaseId: string
    title: string
    description: string | null
    assignedTo: string
    assignedBy: string
    assignedAt: Date
    startDate: Date
    dueDate: Date
    completedDate: Date | null
    progress: number
    status: string
    priority: string
    estimatedHours: number | null
    actualHours: number | null
    taskType: string
    linkedEntityType: string | null
    linkedEntityId: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    phaseId?: boolean
    title?: boolean
    description?: boolean
    assignedTo?: boolean
    assignedBy?: boolean
    assignedAt?: boolean
    startDate?: boolean
    dueDate?: boolean
    completedDate?: boolean
    progress?: boolean
    status?: boolean
    priority?: boolean
    estimatedHours?: boolean
    actualHours?: boolean
    taskType?: boolean
    linkedEntityType?: boolean
    linkedEntityId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    phase?: boolean | ProjectPhaseDefaultArgs<ExtArgs>
    evidences?: boolean | Task$evidencesArgs<ExtArgs>
    history?: boolean | Task$historyArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    phaseId?: boolean
    title?: boolean
    description?: boolean
    assignedTo?: boolean
    assignedBy?: boolean
    assignedAt?: boolean
    startDate?: boolean
    dueDate?: boolean
    completedDate?: boolean
    progress?: boolean
    status?: boolean
    priority?: boolean
    estimatedHours?: boolean
    actualHours?: boolean
    taskType?: boolean
    linkedEntityType?: boolean
    linkedEntityId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    phase?: boolean | ProjectPhaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    projectId?: boolean
    phaseId?: boolean
    title?: boolean
    description?: boolean
    assignedTo?: boolean
    assignedBy?: boolean
    assignedAt?: boolean
    startDate?: boolean
    dueDate?: boolean
    completedDate?: boolean
    progress?: boolean
    status?: boolean
    priority?: boolean
    estimatedHours?: boolean
    actualHours?: boolean
    taskType?: boolean
    linkedEntityType?: boolean
    linkedEntityId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    phase?: boolean | ProjectPhaseDefaultArgs<ExtArgs>
    evidences?: boolean | Task$evidencesArgs<ExtArgs>
    history?: boolean | Task$historyArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    phase?: boolean | ProjectPhaseDefaultArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      phase: Prisma.$ProjectPhasePayload<ExtArgs>
      evidences: Prisma.$TaskEvidencePayload<ExtArgs>[]
      history: Prisma.$TaskHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      phaseId: string
      title: string
      description: string | null
      assignedTo: string
      assignedBy: string
      assignedAt: Date
      startDate: Date
      dueDate: Date
      completedDate: Date | null
      progress: number
      status: string
      priority: string
      estimatedHours: number | null
      actualHours: number | null
      taskType: string
      linkedEntityType: string | null
      linkedEntityId: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    phase<T extends ProjectPhaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectPhaseDefaultArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    evidences<T extends Task$evidencesArgs<ExtArgs> = {}>(args?: Subset<T, Task$evidencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskEvidencePayload<ExtArgs>, T, "findMany"> | Null>
    history<T extends Task$historyArgs<ExtArgs> = {}>(args?: Subset<T, Task$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly projectId: FieldRef<"Task", 'String'>
    readonly phaseId: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly assignedTo: FieldRef<"Task", 'String'>
    readonly assignedBy: FieldRef<"Task", 'String'>
    readonly assignedAt: FieldRef<"Task", 'DateTime'>
    readonly startDate: FieldRef<"Task", 'DateTime'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly completedDate: FieldRef<"Task", 'DateTime'>
    readonly progress: FieldRef<"Task", 'Int'>
    readonly status: FieldRef<"Task", 'String'>
    readonly priority: FieldRef<"Task", 'String'>
    readonly estimatedHours: FieldRef<"Task", 'Float'>
    readonly actualHours: FieldRef<"Task", 'Float'>
    readonly taskType: FieldRef<"Task", 'String'>
    readonly linkedEntityType: FieldRef<"Task", 'String'>
    readonly linkedEntityId: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly createdBy: FieldRef<"Task", 'String'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }

  /**
   * Task.evidences
   */
  export type Task$evidencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvidence
     */
    select?: TaskEvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEvidenceInclude<ExtArgs> | null
    where?: TaskEvidenceWhereInput
    orderBy?: TaskEvidenceOrderByWithRelationInput | TaskEvidenceOrderByWithRelationInput[]
    cursor?: TaskEvidenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskEvidenceScalarFieldEnum | TaskEvidenceScalarFieldEnum[]
  }

  /**
   * Task.history
   */
  export type Task$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskHistory
     */
    select?: TaskHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskHistoryInclude<ExtArgs> | null
    where?: TaskHistoryWhereInput
    orderBy?: TaskHistoryOrderByWithRelationInput | TaskHistoryOrderByWithRelationInput[]
    cursor?: TaskHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskHistoryScalarFieldEnum | TaskHistoryScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskEvidence
   */

  export type AggregateTaskEvidence = {
    _count: TaskEvidenceCountAggregateOutputType | null
    _avg: TaskEvidenceAvgAggregateOutputType | null
    _sum: TaskEvidenceSumAggregateOutputType | null
    _min: TaskEvidenceMinAggregateOutputType | null
    _max: TaskEvidenceMaxAggregateOutputType | null
  }

  export type TaskEvidenceAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type TaskEvidenceSumAggregateOutputType = {
    fileSize: number | null
  }

  export type TaskEvidenceMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    fileName: string | null
    fileType: string | null
    fileSize: number | null
    storageUrl: string | null
    evidenceType: string | null
    description: string | null
    documentDate: Date | null
    uploadedBy: string | null
    uploadedAt: Date | null
  }

  export type TaskEvidenceMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    fileName: string | null
    fileType: string | null
    fileSize: number | null
    storageUrl: string | null
    evidenceType: string | null
    description: string | null
    documentDate: Date | null
    uploadedBy: string | null
    uploadedAt: Date | null
  }

  export type TaskEvidenceCountAggregateOutputType = {
    id: number
    taskId: number
    fileName: number
    fileType: number
    fileSize: number
    storageUrl: number
    evidenceType: number
    description: number
    documentDate: number
    uploadedBy: number
    uploadedAt: number
    _all: number
  }


  export type TaskEvidenceAvgAggregateInputType = {
    fileSize?: true
  }

  export type TaskEvidenceSumAggregateInputType = {
    fileSize?: true
  }

  export type TaskEvidenceMinAggregateInputType = {
    id?: true
    taskId?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    storageUrl?: true
    evidenceType?: true
    description?: true
    documentDate?: true
    uploadedBy?: true
    uploadedAt?: true
  }

  export type TaskEvidenceMaxAggregateInputType = {
    id?: true
    taskId?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    storageUrl?: true
    evidenceType?: true
    description?: true
    documentDate?: true
    uploadedBy?: true
    uploadedAt?: true
  }

  export type TaskEvidenceCountAggregateInputType = {
    id?: true
    taskId?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    storageUrl?: true
    evidenceType?: true
    description?: true
    documentDate?: true
    uploadedBy?: true
    uploadedAt?: true
    _all?: true
  }

  export type TaskEvidenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskEvidence to aggregate.
     */
    where?: TaskEvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskEvidences to fetch.
     */
    orderBy?: TaskEvidenceOrderByWithRelationInput | TaskEvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskEvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskEvidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskEvidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskEvidences
    **/
    _count?: true | TaskEvidenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskEvidenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskEvidenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskEvidenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskEvidenceMaxAggregateInputType
  }

  export type GetTaskEvidenceAggregateType<T extends TaskEvidenceAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskEvidence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskEvidence[P]>
      : GetScalarType<T[P], AggregateTaskEvidence[P]>
  }




  export type TaskEvidenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskEvidenceWhereInput
    orderBy?: TaskEvidenceOrderByWithAggregationInput | TaskEvidenceOrderByWithAggregationInput[]
    by: TaskEvidenceScalarFieldEnum[] | TaskEvidenceScalarFieldEnum
    having?: TaskEvidenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskEvidenceCountAggregateInputType | true
    _avg?: TaskEvidenceAvgAggregateInputType
    _sum?: TaskEvidenceSumAggregateInputType
    _min?: TaskEvidenceMinAggregateInputType
    _max?: TaskEvidenceMaxAggregateInputType
  }

  export type TaskEvidenceGroupByOutputType = {
    id: string
    taskId: string
    fileName: string
    fileType: string
    fileSize: number
    storageUrl: string
    evidenceType: string
    description: string | null
    documentDate: Date | null
    uploadedBy: string
    uploadedAt: Date
    _count: TaskEvidenceCountAggregateOutputType | null
    _avg: TaskEvidenceAvgAggregateOutputType | null
    _sum: TaskEvidenceSumAggregateOutputType | null
    _min: TaskEvidenceMinAggregateOutputType | null
    _max: TaskEvidenceMaxAggregateOutputType | null
  }

  type GetTaskEvidenceGroupByPayload<T extends TaskEvidenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskEvidenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskEvidenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskEvidenceGroupByOutputType[P]>
            : GetScalarType<T[P], TaskEvidenceGroupByOutputType[P]>
        }
      >
    >


  export type TaskEvidenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    storageUrl?: boolean
    evidenceType?: boolean
    description?: boolean
    documentDate?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskEvidence"]>

  export type TaskEvidenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    storageUrl?: boolean
    evidenceType?: boolean
    description?: boolean
    documentDate?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskEvidence"]>

  export type TaskEvidenceSelectScalar = {
    id?: boolean
    taskId?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    storageUrl?: boolean
    evidenceType?: boolean
    description?: boolean
    documentDate?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
  }

  export type TaskEvidenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskEvidenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskEvidencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskEvidence"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      fileName: string
      fileType: string
      fileSize: number
      storageUrl: string
      evidenceType: string
      description: string | null
      documentDate: Date | null
      uploadedBy: string
      uploadedAt: Date
    }, ExtArgs["result"]["taskEvidence"]>
    composites: {}
  }

  type TaskEvidenceGetPayload<S extends boolean | null | undefined | TaskEvidenceDefaultArgs> = $Result.GetResult<Prisma.$TaskEvidencePayload, S>

  type TaskEvidenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskEvidenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskEvidenceCountAggregateInputType | true
    }

  export interface TaskEvidenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskEvidence'], meta: { name: 'TaskEvidence' } }
    /**
     * Find zero or one TaskEvidence that matches the filter.
     * @param {TaskEvidenceFindUniqueArgs} args - Arguments to find a TaskEvidence
     * @example
     * // Get one TaskEvidence
     * const taskEvidence = await prisma.taskEvidence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskEvidenceFindUniqueArgs>(args: SelectSubset<T, TaskEvidenceFindUniqueArgs<ExtArgs>>): Prisma__TaskEvidenceClient<$Result.GetResult<Prisma.$TaskEvidencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskEvidence that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskEvidenceFindUniqueOrThrowArgs} args - Arguments to find a TaskEvidence
     * @example
     * // Get one TaskEvidence
     * const taskEvidence = await prisma.taskEvidence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskEvidenceFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskEvidenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskEvidenceClient<$Result.GetResult<Prisma.$TaskEvidencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskEvidence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEvidenceFindFirstArgs} args - Arguments to find a TaskEvidence
     * @example
     * // Get one TaskEvidence
     * const taskEvidence = await prisma.taskEvidence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskEvidenceFindFirstArgs>(args?: SelectSubset<T, TaskEvidenceFindFirstArgs<ExtArgs>>): Prisma__TaskEvidenceClient<$Result.GetResult<Prisma.$TaskEvidencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskEvidence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEvidenceFindFirstOrThrowArgs} args - Arguments to find a TaskEvidence
     * @example
     * // Get one TaskEvidence
     * const taskEvidence = await prisma.taskEvidence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskEvidenceFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskEvidenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskEvidenceClient<$Result.GetResult<Prisma.$TaskEvidencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskEvidences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEvidenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskEvidences
     * const taskEvidences = await prisma.taskEvidence.findMany()
     * 
     * // Get first 10 TaskEvidences
     * const taskEvidences = await prisma.taskEvidence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskEvidenceWithIdOnly = await prisma.taskEvidence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskEvidenceFindManyArgs>(args?: SelectSubset<T, TaskEvidenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskEvidencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskEvidence.
     * @param {TaskEvidenceCreateArgs} args - Arguments to create a TaskEvidence.
     * @example
     * // Create one TaskEvidence
     * const TaskEvidence = await prisma.taskEvidence.create({
     *   data: {
     *     // ... data to create a TaskEvidence
     *   }
     * })
     * 
     */
    create<T extends TaskEvidenceCreateArgs>(args: SelectSubset<T, TaskEvidenceCreateArgs<ExtArgs>>): Prisma__TaskEvidenceClient<$Result.GetResult<Prisma.$TaskEvidencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskEvidences.
     * @param {TaskEvidenceCreateManyArgs} args - Arguments to create many TaskEvidences.
     * @example
     * // Create many TaskEvidences
     * const taskEvidence = await prisma.taskEvidence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskEvidenceCreateManyArgs>(args?: SelectSubset<T, TaskEvidenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskEvidences and returns the data saved in the database.
     * @param {TaskEvidenceCreateManyAndReturnArgs} args - Arguments to create many TaskEvidences.
     * @example
     * // Create many TaskEvidences
     * const taskEvidence = await prisma.taskEvidence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskEvidences and only return the `id`
     * const taskEvidenceWithIdOnly = await prisma.taskEvidence.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskEvidenceCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskEvidenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskEvidencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskEvidence.
     * @param {TaskEvidenceDeleteArgs} args - Arguments to delete one TaskEvidence.
     * @example
     * // Delete one TaskEvidence
     * const TaskEvidence = await prisma.taskEvidence.delete({
     *   where: {
     *     // ... filter to delete one TaskEvidence
     *   }
     * })
     * 
     */
    delete<T extends TaskEvidenceDeleteArgs>(args: SelectSubset<T, TaskEvidenceDeleteArgs<ExtArgs>>): Prisma__TaskEvidenceClient<$Result.GetResult<Prisma.$TaskEvidencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskEvidence.
     * @param {TaskEvidenceUpdateArgs} args - Arguments to update one TaskEvidence.
     * @example
     * // Update one TaskEvidence
     * const taskEvidence = await prisma.taskEvidence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskEvidenceUpdateArgs>(args: SelectSubset<T, TaskEvidenceUpdateArgs<ExtArgs>>): Prisma__TaskEvidenceClient<$Result.GetResult<Prisma.$TaskEvidencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskEvidences.
     * @param {TaskEvidenceDeleteManyArgs} args - Arguments to filter TaskEvidences to delete.
     * @example
     * // Delete a few TaskEvidences
     * const { count } = await prisma.taskEvidence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskEvidenceDeleteManyArgs>(args?: SelectSubset<T, TaskEvidenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskEvidences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEvidenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskEvidences
     * const taskEvidence = await prisma.taskEvidence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskEvidenceUpdateManyArgs>(args: SelectSubset<T, TaskEvidenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskEvidence.
     * @param {TaskEvidenceUpsertArgs} args - Arguments to update or create a TaskEvidence.
     * @example
     * // Update or create a TaskEvidence
     * const taskEvidence = await prisma.taskEvidence.upsert({
     *   create: {
     *     // ... data to create a TaskEvidence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskEvidence we want to update
     *   }
     * })
     */
    upsert<T extends TaskEvidenceUpsertArgs>(args: SelectSubset<T, TaskEvidenceUpsertArgs<ExtArgs>>): Prisma__TaskEvidenceClient<$Result.GetResult<Prisma.$TaskEvidencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskEvidences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEvidenceCountArgs} args - Arguments to filter TaskEvidences to count.
     * @example
     * // Count the number of TaskEvidences
     * const count = await prisma.taskEvidence.count({
     *   where: {
     *     // ... the filter for the TaskEvidences we want to count
     *   }
     * })
    **/
    count<T extends TaskEvidenceCountArgs>(
      args?: Subset<T, TaskEvidenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskEvidenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskEvidence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEvidenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskEvidenceAggregateArgs>(args: Subset<T, TaskEvidenceAggregateArgs>): Prisma.PrismaPromise<GetTaskEvidenceAggregateType<T>>

    /**
     * Group by TaskEvidence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEvidenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskEvidenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskEvidenceGroupByArgs['orderBy'] }
        : { orderBy?: TaskEvidenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskEvidenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskEvidenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskEvidence model
   */
  readonly fields: TaskEvidenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskEvidence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskEvidenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskEvidence model
   */ 
  interface TaskEvidenceFieldRefs {
    readonly id: FieldRef<"TaskEvidence", 'String'>
    readonly taskId: FieldRef<"TaskEvidence", 'String'>
    readonly fileName: FieldRef<"TaskEvidence", 'String'>
    readonly fileType: FieldRef<"TaskEvidence", 'String'>
    readonly fileSize: FieldRef<"TaskEvidence", 'Int'>
    readonly storageUrl: FieldRef<"TaskEvidence", 'String'>
    readonly evidenceType: FieldRef<"TaskEvidence", 'String'>
    readonly description: FieldRef<"TaskEvidence", 'String'>
    readonly documentDate: FieldRef<"TaskEvidence", 'DateTime'>
    readonly uploadedBy: FieldRef<"TaskEvidence", 'String'>
    readonly uploadedAt: FieldRef<"TaskEvidence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskEvidence findUnique
   */
  export type TaskEvidenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvidence
     */
    select?: TaskEvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEvidenceInclude<ExtArgs> | null
    /**
     * Filter, which TaskEvidence to fetch.
     */
    where: TaskEvidenceWhereUniqueInput
  }

  /**
   * TaskEvidence findUniqueOrThrow
   */
  export type TaskEvidenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvidence
     */
    select?: TaskEvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEvidenceInclude<ExtArgs> | null
    /**
     * Filter, which TaskEvidence to fetch.
     */
    where: TaskEvidenceWhereUniqueInput
  }

  /**
   * TaskEvidence findFirst
   */
  export type TaskEvidenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvidence
     */
    select?: TaskEvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEvidenceInclude<ExtArgs> | null
    /**
     * Filter, which TaskEvidence to fetch.
     */
    where?: TaskEvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskEvidences to fetch.
     */
    orderBy?: TaskEvidenceOrderByWithRelationInput | TaskEvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskEvidences.
     */
    cursor?: TaskEvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskEvidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskEvidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskEvidences.
     */
    distinct?: TaskEvidenceScalarFieldEnum | TaskEvidenceScalarFieldEnum[]
  }

  /**
   * TaskEvidence findFirstOrThrow
   */
  export type TaskEvidenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvidence
     */
    select?: TaskEvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEvidenceInclude<ExtArgs> | null
    /**
     * Filter, which TaskEvidence to fetch.
     */
    where?: TaskEvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskEvidences to fetch.
     */
    orderBy?: TaskEvidenceOrderByWithRelationInput | TaskEvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskEvidences.
     */
    cursor?: TaskEvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskEvidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskEvidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskEvidences.
     */
    distinct?: TaskEvidenceScalarFieldEnum | TaskEvidenceScalarFieldEnum[]
  }

  /**
   * TaskEvidence findMany
   */
  export type TaskEvidenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvidence
     */
    select?: TaskEvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEvidenceInclude<ExtArgs> | null
    /**
     * Filter, which TaskEvidences to fetch.
     */
    where?: TaskEvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskEvidences to fetch.
     */
    orderBy?: TaskEvidenceOrderByWithRelationInput | TaskEvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskEvidences.
     */
    cursor?: TaskEvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskEvidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskEvidences.
     */
    skip?: number
    distinct?: TaskEvidenceScalarFieldEnum | TaskEvidenceScalarFieldEnum[]
  }

  /**
   * TaskEvidence create
   */
  export type TaskEvidenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvidence
     */
    select?: TaskEvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEvidenceInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskEvidence.
     */
    data: XOR<TaskEvidenceCreateInput, TaskEvidenceUncheckedCreateInput>
  }

  /**
   * TaskEvidence createMany
   */
  export type TaskEvidenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskEvidences.
     */
    data: TaskEvidenceCreateManyInput | TaskEvidenceCreateManyInput[]
  }

  /**
   * TaskEvidence createManyAndReturn
   */
  export type TaskEvidenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvidence
     */
    select?: TaskEvidenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskEvidences.
     */
    data: TaskEvidenceCreateManyInput | TaskEvidenceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEvidenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskEvidence update
   */
  export type TaskEvidenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvidence
     */
    select?: TaskEvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEvidenceInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskEvidence.
     */
    data: XOR<TaskEvidenceUpdateInput, TaskEvidenceUncheckedUpdateInput>
    /**
     * Choose, which TaskEvidence to update.
     */
    where: TaskEvidenceWhereUniqueInput
  }

  /**
   * TaskEvidence updateMany
   */
  export type TaskEvidenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskEvidences.
     */
    data: XOR<TaskEvidenceUpdateManyMutationInput, TaskEvidenceUncheckedUpdateManyInput>
    /**
     * Filter which TaskEvidences to update
     */
    where?: TaskEvidenceWhereInput
  }

  /**
   * TaskEvidence upsert
   */
  export type TaskEvidenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvidence
     */
    select?: TaskEvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEvidenceInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskEvidence to update in case it exists.
     */
    where: TaskEvidenceWhereUniqueInput
    /**
     * In case the TaskEvidence found by the `where` argument doesn't exist, create a new TaskEvidence with this data.
     */
    create: XOR<TaskEvidenceCreateInput, TaskEvidenceUncheckedCreateInput>
    /**
     * In case the TaskEvidence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskEvidenceUpdateInput, TaskEvidenceUncheckedUpdateInput>
  }

  /**
   * TaskEvidence delete
   */
  export type TaskEvidenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvidence
     */
    select?: TaskEvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEvidenceInclude<ExtArgs> | null
    /**
     * Filter which TaskEvidence to delete.
     */
    where: TaskEvidenceWhereUniqueInput
  }

  /**
   * TaskEvidence deleteMany
   */
  export type TaskEvidenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskEvidences to delete
     */
    where?: TaskEvidenceWhereInput
  }

  /**
   * TaskEvidence without action
   */
  export type TaskEvidenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvidence
     */
    select?: TaskEvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEvidenceInclude<ExtArgs> | null
  }


  /**
   * Model TaskHistory
   */

  export type AggregateTaskHistory = {
    _count: TaskHistoryCountAggregateOutputType | null
    _min: TaskHistoryMinAggregateOutputType | null
    _max: TaskHistoryMaxAggregateOutputType | null
  }

  export type TaskHistoryMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
    action: string | null
    changes: string | null
    comment: string | null
    timestamp: Date | null
  }

  export type TaskHistoryMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
    action: string | null
    changes: string | null
    comment: string | null
    timestamp: Date | null
  }

  export type TaskHistoryCountAggregateOutputType = {
    id: number
    taskId: number
    userId: number
    action: number
    changes: number
    comment: number
    timestamp: number
    _all: number
  }


  export type TaskHistoryMinAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    action?: true
    changes?: true
    comment?: true
    timestamp?: true
  }

  export type TaskHistoryMaxAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    action?: true
    changes?: true
    comment?: true
    timestamp?: true
  }

  export type TaskHistoryCountAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    action?: true
    changes?: true
    comment?: true
    timestamp?: true
    _all?: true
  }

  export type TaskHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskHistory to aggregate.
     */
    where?: TaskHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskHistories to fetch.
     */
    orderBy?: TaskHistoryOrderByWithRelationInput | TaskHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskHistories
    **/
    _count?: true | TaskHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskHistoryMaxAggregateInputType
  }

  export type GetTaskHistoryAggregateType<T extends TaskHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskHistory[P]>
      : GetScalarType<T[P], AggregateTaskHistory[P]>
  }




  export type TaskHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskHistoryWhereInput
    orderBy?: TaskHistoryOrderByWithAggregationInput | TaskHistoryOrderByWithAggregationInput[]
    by: TaskHistoryScalarFieldEnum[] | TaskHistoryScalarFieldEnum
    having?: TaskHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskHistoryCountAggregateInputType | true
    _min?: TaskHistoryMinAggregateInputType
    _max?: TaskHistoryMaxAggregateInputType
  }

  export type TaskHistoryGroupByOutputType = {
    id: string
    taskId: string
    userId: string
    action: string
    changes: string | null
    comment: string | null
    timestamp: Date
    _count: TaskHistoryCountAggregateOutputType | null
    _min: TaskHistoryMinAggregateOutputType | null
    _max: TaskHistoryMaxAggregateOutputType | null
  }

  type GetTaskHistoryGroupByPayload<T extends TaskHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], TaskHistoryGroupByOutputType[P]>
        }
      >
    >


  export type TaskHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    action?: boolean
    changes?: boolean
    comment?: boolean
    timestamp?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskHistory"]>

  export type TaskHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    action?: boolean
    changes?: boolean
    comment?: boolean
    timestamp?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskHistory"]>

  export type TaskHistorySelectScalar = {
    id?: boolean
    taskId?: boolean
    userId?: boolean
    action?: boolean
    changes?: boolean
    comment?: boolean
    timestamp?: boolean
  }

  export type TaskHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskHistory"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      userId: string
      action: string
      changes: string | null
      comment: string | null
      timestamp: Date
    }, ExtArgs["result"]["taskHistory"]>
    composites: {}
  }

  type TaskHistoryGetPayload<S extends boolean | null | undefined | TaskHistoryDefaultArgs> = $Result.GetResult<Prisma.$TaskHistoryPayload, S>

  type TaskHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskHistoryCountAggregateInputType | true
    }

  export interface TaskHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskHistory'], meta: { name: 'TaskHistory' } }
    /**
     * Find zero or one TaskHistory that matches the filter.
     * @param {TaskHistoryFindUniqueArgs} args - Arguments to find a TaskHistory
     * @example
     * // Get one TaskHistory
     * const taskHistory = await prisma.taskHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskHistoryFindUniqueArgs>(args: SelectSubset<T, TaskHistoryFindUniqueArgs<ExtArgs>>): Prisma__TaskHistoryClient<$Result.GetResult<Prisma.$TaskHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskHistoryFindUniqueOrThrowArgs} args - Arguments to find a TaskHistory
     * @example
     * // Get one TaskHistory
     * const taskHistory = await prisma.taskHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskHistoryClient<$Result.GetResult<Prisma.$TaskHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskHistoryFindFirstArgs} args - Arguments to find a TaskHistory
     * @example
     * // Get one TaskHistory
     * const taskHistory = await prisma.taskHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskHistoryFindFirstArgs>(args?: SelectSubset<T, TaskHistoryFindFirstArgs<ExtArgs>>): Prisma__TaskHistoryClient<$Result.GetResult<Prisma.$TaskHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskHistoryFindFirstOrThrowArgs} args - Arguments to find a TaskHistory
     * @example
     * // Get one TaskHistory
     * const taskHistory = await prisma.taskHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskHistoryClient<$Result.GetResult<Prisma.$TaskHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskHistories
     * const taskHistories = await prisma.taskHistory.findMany()
     * 
     * // Get first 10 TaskHistories
     * const taskHistories = await prisma.taskHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskHistoryWithIdOnly = await prisma.taskHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskHistoryFindManyArgs>(args?: SelectSubset<T, TaskHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskHistory.
     * @param {TaskHistoryCreateArgs} args - Arguments to create a TaskHistory.
     * @example
     * // Create one TaskHistory
     * const TaskHistory = await prisma.taskHistory.create({
     *   data: {
     *     // ... data to create a TaskHistory
     *   }
     * })
     * 
     */
    create<T extends TaskHistoryCreateArgs>(args: SelectSubset<T, TaskHistoryCreateArgs<ExtArgs>>): Prisma__TaskHistoryClient<$Result.GetResult<Prisma.$TaskHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskHistories.
     * @param {TaskHistoryCreateManyArgs} args - Arguments to create many TaskHistories.
     * @example
     * // Create many TaskHistories
     * const taskHistory = await prisma.taskHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskHistoryCreateManyArgs>(args?: SelectSubset<T, TaskHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskHistories and returns the data saved in the database.
     * @param {TaskHistoryCreateManyAndReturnArgs} args - Arguments to create many TaskHistories.
     * @example
     * // Create many TaskHistories
     * const taskHistory = await prisma.taskHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskHistories and only return the `id`
     * const taskHistoryWithIdOnly = await prisma.taskHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskHistory.
     * @param {TaskHistoryDeleteArgs} args - Arguments to delete one TaskHistory.
     * @example
     * // Delete one TaskHistory
     * const TaskHistory = await prisma.taskHistory.delete({
     *   where: {
     *     // ... filter to delete one TaskHistory
     *   }
     * })
     * 
     */
    delete<T extends TaskHistoryDeleteArgs>(args: SelectSubset<T, TaskHistoryDeleteArgs<ExtArgs>>): Prisma__TaskHistoryClient<$Result.GetResult<Prisma.$TaskHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskHistory.
     * @param {TaskHistoryUpdateArgs} args - Arguments to update one TaskHistory.
     * @example
     * // Update one TaskHistory
     * const taskHistory = await prisma.taskHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskHistoryUpdateArgs>(args: SelectSubset<T, TaskHistoryUpdateArgs<ExtArgs>>): Prisma__TaskHistoryClient<$Result.GetResult<Prisma.$TaskHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskHistories.
     * @param {TaskHistoryDeleteManyArgs} args - Arguments to filter TaskHistories to delete.
     * @example
     * // Delete a few TaskHistories
     * const { count } = await prisma.taskHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskHistoryDeleteManyArgs>(args?: SelectSubset<T, TaskHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskHistories
     * const taskHistory = await prisma.taskHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskHistoryUpdateManyArgs>(args: SelectSubset<T, TaskHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskHistory.
     * @param {TaskHistoryUpsertArgs} args - Arguments to update or create a TaskHistory.
     * @example
     * // Update or create a TaskHistory
     * const taskHistory = await prisma.taskHistory.upsert({
     *   create: {
     *     // ... data to create a TaskHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskHistory we want to update
     *   }
     * })
     */
    upsert<T extends TaskHistoryUpsertArgs>(args: SelectSubset<T, TaskHistoryUpsertArgs<ExtArgs>>): Prisma__TaskHistoryClient<$Result.GetResult<Prisma.$TaskHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskHistoryCountArgs} args - Arguments to filter TaskHistories to count.
     * @example
     * // Count the number of TaskHistories
     * const count = await prisma.taskHistory.count({
     *   where: {
     *     // ... the filter for the TaskHistories we want to count
     *   }
     * })
    **/
    count<T extends TaskHistoryCountArgs>(
      args?: Subset<T, TaskHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskHistoryAggregateArgs>(args: Subset<T, TaskHistoryAggregateArgs>): Prisma.PrismaPromise<GetTaskHistoryAggregateType<T>>

    /**
     * Group by TaskHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskHistoryGroupByArgs['orderBy'] }
        : { orderBy?: TaskHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskHistory model
   */
  readonly fields: TaskHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskHistory model
   */ 
  interface TaskHistoryFieldRefs {
    readonly id: FieldRef<"TaskHistory", 'String'>
    readonly taskId: FieldRef<"TaskHistory", 'String'>
    readonly userId: FieldRef<"TaskHistory", 'String'>
    readonly action: FieldRef<"TaskHistory", 'String'>
    readonly changes: FieldRef<"TaskHistory", 'String'>
    readonly comment: FieldRef<"TaskHistory", 'String'>
    readonly timestamp: FieldRef<"TaskHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskHistory findUnique
   */
  export type TaskHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskHistory
     */
    select?: TaskHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TaskHistory to fetch.
     */
    where: TaskHistoryWhereUniqueInput
  }

  /**
   * TaskHistory findUniqueOrThrow
   */
  export type TaskHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskHistory
     */
    select?: TaskHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TaskHistory to fetch.
     */
    where: TaskHistoryWhereUniqueInput
  }

  /**
   * TaskHistory findFirst
   */
  export type TaskHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskHistory
     */
    select?: TaskHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TaskHistory to fetch.
     */
    where?: TaskHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskHistories to fetch.
     */
    orderBy?: TaskHistoryOrderByWithRelationInput | TaskHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskHistories.
     */
    cursor?: TaskHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskHistories.
     */
    distinct?: TaskHistoryScalarFieldEnum | TaskHistoryScalarFieldEnum[]
  }

  /**
   * TaskHistory findFirstOrThrow
   */
  export type TaskHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskHistory
     */
    select?: TaskHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TaskHistory to fetch.
     */
    where?: TaskHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskHistories to fetch.
     */
    orderBy?: TaskHistoryOrderByWithRelationInput | TaskHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskHistories.
     */
    cursor?: TaskHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskHistories.
     */
    distinct?: TaskHistoryScalarFieldEnum | TaskHistoryScalarFieldEnum[]
  }

  /**
   * TaskHistory findMany
   */
  export type TaskHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskHistory
     */
    select?: TaskHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TaskHistories to fetch.
     */
    where?: TaskHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskHistories to fetch.
     */
    orderBy?: TaskHistoryOrderByWithRelationInput | TaskHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskHistories.
     */
    cursor?: TaskHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskHistories.
     */
    skip?: number
    distinct?: TaskHistoryScalarFieldEnum | TaskHistoryScalarFieldEnum[]
  }

  /**
   * TaskHistory create
   */
  export type TaskHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskHistory
     */
    select?: TaskHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskHistory.
     */
    data: XOR<TaskHistoryCreateInput, TaskHistoryUncheckedCreateInput>
  }

  /**
   * TaskHistory createMany
   */
  export type TaskHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskHistories.
     */
    data: TaskHistoryCreateManyInput | TaskHistoryCreateManyInput[]
  }

  /**
   * TaskHistory createManyAndReturn
   */
  export type TaskHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskHistory
     */
    select?: TaskHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskHistories.
     */
    data: TaskHistoryCreateManyInput | TaskHistoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskHistory update
   */
  export type TaskHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskHistory
     */
    select?: TaskHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskHistory.
     */
    data: XOR<TaskHistoryUpdateInput, TaskHistoryUncheckedUpdateInput>
    /**
     * Choose, which TaskHistory to update.
     */
    where: TaskHistoryWhereUniqueInput
  }

  /**
   * TaskHistory updateMany
   */
  export type TaskHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskHistories.
     */
    data: XOR<TaskHistoryUpdateManyMutationInput, TaskHistoryUncheckedUpdateManyInput>
    /**
     * Filter which TaskHistories to update
     */
    where?: TaskHistoryWhereInput
  }

  /**
   * TaskHistory upsert
   */
  export type TaskHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskHistory
     */
    select?: TaskHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskHistory to update in case it exists.
     */
    where: TaskHistoryWhereUniqueInput
    /**
     * In case the TaskHistory found by the `where` argument doesn't exist, create a new TaskHistory with this data.
     */
    create: XOR<TaskHistoryCreateInput, TaskHistoryUncheckedCreateInput>
    /**
     * In case the TaskHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskHistoryUpdateInput, TaskHistoryUncheckedUpdateInput>
  }

  /**
   * TaskHistory delete
   */
  export type TaskHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskHistory
     */
    select?: TaskHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskHistoryInclude<ExtArgs> | null
    /**
     * Filter which TaskHistory to delete.
     */
    where: TaskHistoryWhereUniqueInput
  }

  /**
   * TaskHistory deleteMany
   */
  export type TaskHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskHistories to delete
     */
    where?: TaskHistoryWhereInput
  }

  /**
   * TaskHistory without action
   */
  export type TaskHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskHistory
     */
    select?: TaskHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskHistoryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido: 'apellido',
    email: 'email',
    password: 'password',
    telefono: 'telefono',
    avatar: 'avatar',
    estado: 'estado',
    departamento: 'departamento',
    cargo: 'cargo',
    region: 'region',
    autenticacionDosFactor: 'autenticacionDosFactor',
    cambioPasswordRequerido: 'cambioPasswordRequerido',
    sesionesActivas: 'sesionesActivas',
    maxSesionesPermitidas: 'maxSesionesPermitidas',
    ultimoCambioPassword: 'ultimoCambioPassword',
    intentosFallidos: 'intentosFallidos',
    fechaCreacion: 'fechaCreacion',
    fechaExpiracion: 'fechaExpiracion',
    ultimoAcceso: 'ultimoAcceso',
    updatedAt: 'updatedAt'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const RolScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    nivelAcceso: 'nivelAcceso',
    region: 'region',
    tipoArbol: 'tipoArbol',
    color: 'color',
    icono: 'icono',
    activo: 'activo',
    esRolSistema: 'esRolSistema',
    fechaCreacion: 'fechaCreacion',
    fechaModificacion: 'fechaModificacion'
  };

  export type RolScalarFieldEnum = (typeof RolScalarFieldEnum)[keyof typeof RolScalarFieldEnum]


  export const PermisoScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    nombre: 'nombre',
    descripcion: 'descripcion',
    modulo: 'modulo',
    categoria: 'categoria',
    activo: 'activo',
    padreId: 'padreId'
  };

  export type PermisoScalarFieldEnum = (typeof PermisoScalarFieldEnum)[keyof typeof PermisoScalarFieldEnum]


  export const ModuloScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    icono: 'icono',
    orden: 'orden',
    activo: 'activo',
    permisoCreacion: 'permisoCreacion',
    permisoEdicion: 'permisoEdicion',
    permisoVisualizacion: 'permisoVisualizacion',
    permisoEliminacion: 'permisoEliminacion'
  };

  export type ModuloScalarFieldEnum = (typeof ModuloScalarFieldEnum)[keyof typeof ModuloScalarFieldEnum]


  export const UsuarioRolScalarFieldEnum: {
    usuarioId: 'usuarioId',
    rolId: 'rolId',
    fechaAsignacion: 'fechaAsignacion'
  };

  export type UsuarioRolScalarFieldEnum = (typeof UsuarioRolScalarFieldEnum)[keyof typeof UsuarioRolScalarFieldEnum]


  export const RolPermisoScalarFieldEnum: {
    rolId: 'rolId',
    permisoId: 'permisoId'
  };

  export type RolPermisoScalarFieldEnum = (typeof RolPermisoScalarFieldEnum)[keyof typeof RolPermisoScalarFieldEnum]


  export const UsuarioActivoScalarFieldEnum: {
    usuarioId: 'usuarioId',
    activoId: 'activoId',
    nivelAcceso: 'nivelAcceso'
  };

  export type UsuarioActivoScalarFieldEnum = (typeof UsuarioActivoScalarFieldEnum)[keyof typeof UsuarioActivoScalarFieldEnum]


  export const LogAuditoriaScalarFieldEnum: {
    id: 'id',
    accion: 'accion',
    entidad: 'entidad',
    entidadId: 'entidadId',
    entidadNombre: 'entidadNombre',
    detalles: 'detalles',
    ip: 'ip',
    userAgent: 'userAgent',
    fecha: 'fecha',
    usuarioId: 'usuarioId'
  };

  export type LogAuditoriaScalarFieldEnum = (typeof LogAuditoriaScalarFieldEnum)[keyof typeof LogAuditoriaScalarFieldEnum]


  export const ActivoAccesoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    tipo: 'tipo',
    icono: 'icono',
    nivelAcceso: 'nivelAcceso',
    expanded: 'expanded',
    padreId: 'padreId'
  };

  export type ActivoAccesoScalarFieldEnum = (typeof ActivoAccesoScalarFieldEnum)[keyof typeof ActivoAccesoScalarFieldEnum]


  export const PlantillaActivoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    tipoActivo: 'tipoActivo',
    descripcion: 'descripcion',
    icono: 'icono',
    color: 'color',
    propiedades: 'propiedades',
    activo: 'activo',
    fechaCreacion: 'fechaCreacion'
  };

  export type PlantillaActivoScalarFieldEnum = (typeof PlantillaActivoScalarFieldEnum)[keyof typeof PlantillaActivoScalarFieldEnum]


  export const ActivoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    tipo: 'tipo',
    criticidad: 'criticidad',
    responsable: 'responsable',
    departamento: 'departamento',
    fechaRegistro: 'fechaRegistro',
    updatedAt: 'updatedAt',
    plantillaId: 'plantillaId',
    propiedadesCustom: 'propiedadesCustom'
  };

  export type ActivoScalarFieldEnum = (typeof ActivoScalarFieldEnum)[keyof typeof ActivoScalarFieldEnum]


  export const RiesgoScalarFieldEnum: {
    id: 'id',
    activoId: 'activoId',
    descripcion: 'descripcion',
    probabilidad: 'probabilidad',
    impacto: 'impacto',
    estado: 'estado',
    fechaIdentificacion: 'fechaIdentificacion',
    responsable: 'responsable',
    updatedAt: 'updatedAt'
  };

  export type RiesgoScalarFieldEnum = (typeof RiesgoScalarFieldEnum)[keyof typeof RiesgoScalarFieldEnum]


  export const IncidenteScalarFieldEnum: {
    id: 'id',
    activoId: 'activoId',
    titulo: 'titulo',
    descripcion: 'descripcion',
    severidad: 'severidad',
    estado: 'estado',
    fechaReporte: 'fechaReporte',
    reportadoPor: 'reportadoPor',
    updatedAt: 'updatedAt'
  };

  export type IncidenteScalarFieldEnum = (typeof IncidenteScalarFieldEnum)[keyof typeof IncidenteScalarFieldEnum]


  export const DefectoScalarFieldEnum: {
    id: 'id',
    activoId: 'activoId',
    titulo: 'titulo',
    descripcion: 'descripcion',
    tipo: 'tipo',
    prioridad: 'prioridad',
    estado: 'estado',
    fechaDeteccion: 'fechaDeteccion',
    detectadoPor: 'detectadoPor',
    updatedAt: 'updatedAt'
  };

  export type DefectoScalarFieldEnum = (typeof DefectoScalarFieldEnum)[keyof typeof DefectoScalarFieldEnum]


  export const OrganigramaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    fechaCreacion: 'fechaCreacion',
    updatedAt: 'updatedAt'
  };

  export type OrganigramaScalarFieldEnum = (typeof OrganigramaScalarFieldEnum)[keyof typeof OrganigramaScalarFieldEnum]


  export const NodoOrganigramaScalarFieldEnum: {
    id: 'id',
    organigramaId: 'organigramaId',
    nombre: 'nombre',
    cargo: 'cargo',
    departamento: 'departamento',
    email: 'email',
    telefono: 'telefono',
    foto: 'foto',
    padreId: 'padreId'
  };

  export type NodoOrganigramaScalarFieldEnum = (typeof NodoOrganigramaScalarFieldEnum)[keyof typeof NodoOrganigramaScalarFieldEnum]


  export const MarcoNormativoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    acronimo: 'acronimo',
    version: 'version',
    fechaVigencia: 'fechaVigencia',
    descripcion: 'descripcion',
    activo: 'activo',
    fechaCreacion: 'fechaCreacion'
  };

  export type MarcoNormativoScalarFieldEnum = (typeof MarcoNormativoScalarFieldEnum)[keyof typeof MarcoNormativoScalarFieldEnum]


  export const RequisitoNormativoScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    nombre: 'nombre',
    descripcion: 'descripcion',
    marcoId: 'marcoId',
    controlesAsociados: 'controlesAsociados'
  };

  export type RequisitoNormativoScalarFieldEnum = (typeof RequisitoNormativoScalarFieldEnum)[keyof typeof RequisitoNormativoScalarFieldEnum]


  export const CuestionarioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    categoria: 'categoria',
    tipo: 'tipo',
    tipoEvaluacion: 'tipoEvaluacion',
    estado: 'estado',
    marcoNormativoId: 'marcoNormativoId',
    periodicidad: 'periodicidad',
    tasaCompletado: 'tasaCompletado',
    fechaCreacion: 'fechaCreacion',
    fechaModificacion: 'fechaModificacion',
    umbrales: 'umbrales',
    areasObjetivo: 'areasObjetivo',
    responsables: 'responsables'
  };

  export type CuestionarioScalarFieldEnum = (typeof CuestionarioScalarFieldEnum)[keyof typeof CuestionarioScalarFieldEnum]


  export const SeccionScalarFieldEnum: {
    id: 'id',
    cuestionarioId: 'cuestionarioId',
    nombre: 'nombre',
    descripcion: 'descripcion',
    peso: 'peso',
    requerida: 'requerida',
    orden: 'orden'
  };

  export type SeccionScalarFieldEnum = (typeof SeccionScalarFieldEnum)[keyof typeof SeccionScalarFieldEnum]


  export const PreguntaScalarFieldEnum: {
    id: 'id',
    seccionId: 'seccionId',
    texto: 'texto',
    tipo: 'tipo',
    requerida: 'requerida',
    peso: 'peso',
    opciones: 'opciones',
    escalaMin: 'escalaMin',
    escalaMax: 'escalaMax',
    ayuda: 'ayuda',
    placeholder: 'placeholder',
    requisitoNormativoId: 'requisitoNormativoId',
    controlAsociado: 'controlAsociado',
    requiereEvidencia: 'requiereEvidencia',
    maxStars: 'maxStars',
    leftAnchor: 'leftAnchor',
    rightAnchor: 'rightAnchor',
    likertLabels: 'likertLabels',
    displayConditionQuestionId: 'displayConditionQuestionId',
    displayConditionAnswer: 'displayConditionAnswer',
    logicaCondicional: 'logicaCondicional',
    isCalculated: 'isCalculated',
    formula: 'formula',
    orden: 'orden'
  };

  export type PreguntaScalarFieldEnum = (typeof PreguntaScalarFieldEnum)[keyof typeof PreguntaScalarFieldEnum]


  export const AsignacionCuestionarioScalarFieldEnum: {
    id: 'id',
    cuestionarioId: 'cuestionarioId',
    cuestionarioIds: 'cuestionarioIds',
    titulo: 'titulo',
    descripcion: 'descripcion',
    tipoRevision: 'tipoRevision',
    usuariosAsignados: 'usuariosAsignados',
    usuariosAsignadosNombres: 'usuariosAsignadosNombres',
    emailsExternos: 'emailsExternos',
    contrasenaAcceso: 'contrasenaAcceso',
    activosObjetivo: 'activosObjetivo',
    activosObjetivoNombres: 'activosObjetivoNombres',
    procesosObjetivo: 'procesosObjetivo',
    procesosObjetivoNombres: 'procesosObjetivoNombres',
    aprobadores: 'aprobadores',
    aprobadoresNombres: 'aprobadoresNombres',
    evaluadosInternos: 'evaluadosInternos',
    evaluadosInternosNombres: 'evaluadosInternosNombres',
    areaId: 'areaId',
    areaNombre: 'areaNombre',
    responsableId: 'responsableId',
    responsableNombre: 'responsableNombre',
    fechaAsignacion: 'fechaAsignacion',
    fechaInicio: 'fechaInicio',
    fechaVencimiento: 'fechaVencimiento',
    estado: 'estado',
    progreso: 'progreso',
    instrucciones: 'instrucciones',
    recordatorios: 'recordatorios',
    tokenAccesoExterno: 'tokenAccesoExterno',
    recurrencia: 'recurrencia'
  };

  export type AsignacionCuestionarioScalarFieldEnum = (typeof AsignacionCuestionarioScalarFieldEnum)[keyof typeof AsignacionCuestionarioScalarFieldEnum]


  export const EvaluadoExternoScalarFieldEnum: {
    id: 'id',
    asignacionId: 'asignacionId',
    nombre: 'nombre',
    email: 'email',
    password: 'password',
    invitacionEnviada: 'invitacionEnviada',
    fechaInvitacion: 'fechaInvitacion',
    haRespondido: 'haRespondido',
    fechaRespuesta: 'fechaRespuesta'
  };

  export type EvaluadoExternoScalarFieldEnum = (typeof EvaluadoExternoScalarFieldEnum)[keyof typeof EvaluadoExternoScalarFieldEnum]


  export const RespuestaCuestionarioScalarFieldEnum: {
    id: 'id',
    asignacionId: 'asignacionId',
    cuestionarioId: 'cuestionarioId',
    respondidoPorId: 'respondidoPorId',
    fechaInicio: 'fechaInicio',
    fechaEnvio: 'fechaEnvio',
    estado: 'estado',
    puntuacionTotal: 'puntuacionTotal',
    nivelCumplimiento: 'nivelCumplimiento',
    comentariosGenerales: 'comentariosGenerales'
  };

  export type RespuestaCuestionarioScalarFieldEnum = (typeof RespuestaCuestionarioScalarFieldEnum)[keyof typeof RespuestaCuestionarioScalarFieldEnum]


  export const RespuestaPreguntaScalarFieldEnum: {
    id: 'id',
    respuestaCuestionarioId: 'respuestaCuestionarioId',
    preguntaId: 'preguntaId',
    valor: 'valor',
    comentario: 'comentario',
    archivosAdjuntos: 'archivosAdjuntos',
    marcadaParaRevision: 'marcadaParaRevision',
    estadoRevision: 'estadoRevision',
    comentarioRevisor: 'comentarioRevisor'
  };

  export type RespuestaPreguntaScalarFieldEnum = (typeof RespuestaPreguntaScalarFieldEnum)[keyof typeof RespuestaPreguntaScalarFieldEnum]


  export const EvidenciaScalarFieldEnum: {
    id: 'id',
    respuestaPreguntaId: 'respuestaPreguntaId',
    nombre: 'nombre',
    tipo: 'tipo',
    tamano: 'tamano',
    fechaCarga: 'fechaCarga',
    url: 'url',
    descripcion: 'descripcion',
    vigencia: 'vigencia',
    estado: 'estado'
  };

  export type EvidenciaScalarFieldEnum = (typeof EvidenciaScalarFieldEnum)[keyof typeof EvidenciaScalarFieldEnum]


  export const HallazgoScalarFieldEnum: {
    id: 'id',
    preguntaId: 'preguntaId',
    tipo: 'tipo',
    descripcion: 'descripcion',
    requisitoNormativo: 'requisitoNormativo',
    accionCorrectiva: 'accionCorrectiva',
    responsable: 'responsable',
    fechaLimite: 'fechaLimite',
    estado: 'estado',
    fechaCreacion: 'fechaCreacion'
  };

  export type HallazgoScalarFieldEnum = (typeof HallazgoScalarFieldEnum)[keyof typeof HallazgoScalarFieldEnum]


  export const MensajeChatScalarFieldEnum: {
    id: 'id',
    asignacionId: 'asignacionId',
    cuestionarioId: 'cuestionarioId',
    activoProcesoId: 'activoProcesoId',
    usuarioId: 'usuarioId',
    usuarioNombre: 'usuarioNombre',
    usuarioRol: 'usuarioRol',
    mensaje: 'mensaje',
    fecha: 'fecha',
    leido: 'leido'
  };

  export type MensajeChatScalarFieldEnum = (typeof MensajeChatScalarFieldEnum)[keyof typeof MensajeChatScalarFieldEnum]


  export const AlertaCumplimientoScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    severidad: 'severidad',
    titulo: 'titulo',
    descripcion: 'descripcion',
    entidadId: 'entidadId',
    entidadTipo: 'entidadTipo',
    fechaGeneracion: 'fechaGeneracion',
    estado: 'estado',
    responsable: 'responsable',
    marcoNormativo: 'marcoNormativo'
  };

  export type AlertaCumplimientoScalarFieldEnum = (typeof AlertaCumplimientoScalarFieldEnum)[keyof typeof AlertaCumplimientoScalarFieldEnum]


  export const ProcesoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    version: 'version',
    estado: 'estado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type ProcesoScalarFieldEnum = (typeof ProcesoScalarFieldEnum)[keyof typeof ProcesoScalarFieldEnum]


  export const ProcessNodeScalarFieldEnum: {
    id: 'id',
    procesoId: 'procesoId',
    type: 'type',
    label: 'label',
    descripcion: 'descripcion',
    config: 'config',
    positionX: 'positionX',
    positionY: 'positionY'
  };

  export type ProcessNodeScalarFieldEnum = (typeof ProcessNodeScalarFieldEnum)[keyof typeof ProcessNodeScalarFieldEnum]


  export const ProcessEdgeScalarFieldEnum: {
    id: 'id',
    procesoId: 'procesoId',
    sourceNodeId: 'sourceNodeId',
    targetNodeId: 'targetNodeId',
    sourceHandle: 'sourceHandle',
    targetHandle: 'targetHandle',
    label: 'label'
  };

  export type ProcessEdgeScalarFieldEnum = (typeof ProcessEdgeScalarFieldEnum)[keyof typeof ProcessEdgeScalarFieldEnum]


  export const ObjetivoProcesoScalarFieldEnum: {
    id: 'id',
    procesoId: 'procesoId',
    nombre: 'nombre',
    descripcion: 'descripcion',
    tipo: 'tipo',
    progreso: 'progreso'
  };

  export type ObjetivoProcesoScalarFieldEnum = (typeof ObjetivoProcesoScalarFieldEnum)[keyof typeof ObjetivoProcesoScalarFieldEnum]


  export const KpiProcesoScalarFieldEnum: {
    id: 'id',
    procesoId: 'procesoId',
    objetivoId: 'objetivoId',
    nombre: 'nombre',
    descripcion: 'descripcion',
    unidad: 'unidad',
    meta: 'meta',
    valorActual: 'valorActual',
    fechaUltimaActualizacion: 'fechaUltimaActualizacion',
    alertaAdvertencia: 'alertaAdvertencia',
    alertaCritico: 'alertaCritico',
    alertaDireccion: 'alertaDireccion'
  };

  export type KpiProcesoScalarFieldEnum = (typeof KpiProcesoScalarFieldEnum)[keyof typeof KpiProcesoScalarFieldEnum]


  export const KpiHistoricoScalarFieldEnum: {
    id: 'id',
    kpiId: 'kpiId',
    valor: 'valor',
    timestamp: 'timestamp',
    procesoId: 'procesoId',
    nodoId: 'nodoId',
    metadatos: 'metadatos'
  };

  export type KpiHistoricoScalarFieldEnum = (typeof KpiHistoricoScalarFieldEnum)[keyof typeof KpiHistoricoScalarFieldEnum]


  export const DashboardConfigScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    isDefault: 'isDefault',
    isLocked: 'isLocked',
    columns: 'columns',
    rowHeight: 'rowHeight',
    gap: 'gap',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type DashboardConfigScalarFieldEnum = (typeof DashboardConfigScalarFieldEnum)[keyof typeof DashboardConfigScalarFieldEnum]


  export const DashboardWidgetScalarFieldEnum: {
    id: 'id',
    dashboardId: 'dashboardId',
    tipo: 'tipo',
    titulo: 'titulo',
    subtitulo: 'subtitulo',
    icono: 'icono',
    config: 'config',
    x: 'x',
    y: 'y',
    cols: 'cols',
    rows: 'rows',
    canResize: 'canResize',
    canDrag: 'canDrag',
    canRemove: 'canRemove',
    canEdit: 'canEdit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DashboardWidgetScalarFieldEnum = (typeof DashboardWidgetScalarFieldEnum)[keyof typeof DashboardWidgetScalarFieldEnum]


  export const CatalogoScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    codigo: 'codigo',
    nombre: 'nombre',
    descripcion: 'descripcion',
    orden: 'orden',
    activo: 'activo',
    color: 'color',
    icono: 'icono',
    metadata: 'metadata'
  };

  export type CatalogoScalarFieldEnum = (typeof CatalogoScalarFieldEnum)[keyof typeof CatalogoScalarFieldEnum]


  export const NotificationRuleScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    entidadTipo: 'entidadTipo',
    eventoTipo: 'eventoTipo',
    activo: 'activo',
    notificarCreador: 'notificarCreador',
    notificarResponsable: 'notificarResponsable',
    notificarAprobadores: 'notificarAprobadores',
    rolesDestino: 'rolesDestino',
    usuariosDestino: 'usuariosDestino',
    enviarInApp: 'enviarInApp',
    enviarEmail: 'enviarEmail',
    plantillaMensaje: 'plantillaMensaje',
    severidad: 'severidad',
    fechaCreacion: 'fechaCreacion',
    fechaModificacion: 'fechaModificacion'
  };

  export type NotificationRuleScalarFieldEnum = (typeof NotificationRuleScalarFieldEnum)[keyof typeof NotificationRuleScalarFieldEnum]


  export const AlertRuleScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    entidadTipo: 'entidadTipo',
    entidadId: 'entidadId',
    metricaNombre: 'metricaNombre',
    operador: 'operador',
    valorUmbral: 'valorUmbral',
    tipoAgregacion: 'tipoAgregacion',
    periodoEvaluacion: 'periodoEvaluacion',
    activo: 'activo',
    rolesDestino: 'rolesDestino',
    usuariosDestino: 'usuariosDestino',
    enviarInApp: 'enviarInApp',
    enviarEmail: 'enviarEmail',
    severidad: 'severidad',
    cooldownMinutos: 'cooldownMinutos',
    ultimaEjecucion: 'ultimaEjecucion',
    fechaCreacion: 'fechaCreacion',
    fechaModificacion: 'fechaModificacion'
  };

  export type AlertRuleScalarFieldEnum = (typeof AlertRuleScalarFieldEnum)[keyof typeof AlertRuleScalarFieldEnum]


  export const ExpirationRuleScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    entidadTipo: 'entidadTipo',
    diasAnticipacion: 'diasAnticipacion',
    diasDespuesVencido: 'diasDespuesVencido',
    activo: 'activo',
    notificarResponsable: 'notificarResponsable',
    notificarSupervisor: 'notificarSupervisor',
    rolesDestino: 'rolesDestino',
    enviarInApp: 'enviarInApp',
    enviarEmail: 'enviarEmail',
    fechaCreacion: 'fechaCreacion',
    fechaModificacion: 'fechaModificacion'
  };

  export type ExpirationRuleScalarFieldEnum = (typeof ExpirationRuleScalarFieldEnum)[keyof typeof ExpirationRuleScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    tipo: 'tipo',
    titulo: 'titulo',
    mensaje: 'mensaje',
    severidad: 'severidad',
    entidadTipo: 'entidadTipo',
    entidadId: 'entidadId',
    entidadNombre: 'entidadNombre',
    leida: 'leida',
    archivada: 'archivada',
    enSeguimiento: 'enSeguimiento',
    acciones: 'acciones',
    attachmentTipo: 'attachmentTipo',
    attachmentUrl: 'attachmentUrl',
    attachmentTitulo: 'attachmentTitulo',
    attachmentSubtitulo: 'attachmentSubtitulo',
    metadata: 'metadata',
    reglaId: 'reglaId',
    reglaTipo: 'reglaTipo',
    fechaCreacion: 'fechaCreacion',
    fechaLeida: 'fechaLeida'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const UserNotificationPreferencesScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    habilitado: 'habilitado',
    emailHabilitado: 'emailHabilitado',
    inAppHabilitado: 'inAppHabilitado',
    preferenciasPorEntidad: 'preferenciasPorEntidad',
    notificarInfo: 'notificarInfo',
    notificarWarning: 'notificarWarning',
    notificarCritical: 'notificarCritical',
    frecuenciaEmail: 'frecuenciaEmail',
    horaResumen: 'horaResumen',
    horarioNoMolestarHabilitado: 'horarioNoMolestarHabilitado',
    horarioNoMolestarInicio: 'horarioNoMolestarInicio',
    horarioNoMolestarFin: 'horarioNoMolestarFin',
    horarioNoMolestarDias: 'horarioNoMolestarDias',
    rateLimitHabilitado: 'rateLimitHabilitado',
    rateLimitMaxPorHora: 'rateLimitMaxPorHora',
    preferenciasPorModulo: 'preferenciasPorModulo',
    fechaCreacion: 'fechaCreacion',
    fechaModificacion: 'fechaModificacion'
  };

  export type UserNotificationPreferencesScalarFieldEnum = (typeof UserNotificationPreferencesScalarFieldEnum)[keyof typeof UserNotificationPreferencesScalarFieldEnum]


  export const NotificationLogScalarFieldEnum: {
    id: 'id',
    notificationId: 'notificationId',
    usuarioId: 'usuarioId',
    canal: 'canal',
    estado: 'estado',
    errorMensaje: 'errorMensaje',
    reglaId: 'reglaId',
    reglaTipo: 'reglaTipo',
    metadata: 'metadata',
    fechaEnvio: 'fechaEnvio'
  };

  export type NotificationLogScalarFieldEnum = (typeof NotificationLogScalarFieldEnum)[keyof typeof NotificationLogScalarFieldEnum]


  export const NotificationProfileScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    eventos: 'eventos',
    seleccionEntidades: 'seleccionEntidades',
    filtrosEntidad: 'filtrosEntidad',
    destinatarios: 'destinatarios',
    canales: 'canales',
    plantillaTitulo: 'plantillaTitulo',
    plantillaMensaje: 'plantillaMensaje',
    severidad: 'severidad',
    estado: 'estado',
    horarioNoMolestar: 'horarioNoMolestar',
    fechaCreacion: 'fechaCreacion',
    fechaModificacion: 'fechaModificacion',
    creadoPorId: 'creadoPorId'
  };

  export type NotificationProfileScalarFieldEnum = (typeof NotificationProfileScalarFieldEnum)[keyof typeof NotificationProfileScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    responsibleUserId: 'responsibleUserId',
    orgUnitId: 'orgUnitId',
    priority: 'priority',
    status: 'status',
    progress: 'progress',
    reminderDays: 'reminderDays',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectObjectiveScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    description: 'description',
    category: 'category',
    status: 'status',
    targetDate: 'targetDate',
    completedDate: 'completedDate'
  };

  export type ProjectObjectiveScalarFieldEnum = (typeof ProjectObjectiveScalarFieldEnum)[keyof typeof ProjectObjectiveScalarFieldEnum]


  export const ProjectKPIScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    description: 'description',
    targetValue: 'targetValue',
    currentValue: 'currentValue',
    unit: 'unit',
    formulaType: 'formulaType',
    formula: 'formula',
    status: 'status'
  };

  export type ProjectKPIScalarFieldEnum = (typeof ProjectKPIScalarFieldEnum)[keyof typeof ProjectKPIScalarFieldEnum]


  export const ProjectPhaseScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    description: 'description',
    orderNum: 'orderNum',
    startDate: 'startDate',
    endDate: 'endDate',
    actualStartDate: 'actualStartDate',
    actualEndDate: 'actualEndDate',
    status: 'status',
    weight: 'weight',
    dependsOnPhaseId: 'dependsOnPhaseId',
    progress: 'progress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectPhaseScalarFieldEnum = (typeof ProjectPhaseScalarFieldEnum)[keyof typeof ProjectPhaseScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    phaseId: 'phaseId',
    title: 'title',
    description: 'description',
    assignedTo: 'assignedTo',
    assignedBy: 'assignedBy',
    assignedAt: 'assignedAt',
    startDate: 'startDate',
    dueDate: 'dueDate',
    completedDate: 'completedDate',
    progress: 'progress',
    status: 'status',
    priority: 'priority',
    estimatedHours: 'estimatedHours',
    actualHours: 'actualHours',
    taskType: 'taskType',
    linkedEntityType: 'linkedEntityType',
    linkedEntityId: 'linkedEntityId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskEvidenceScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    fileName: 'fileName',
    fileType: 'fileType',
    fileSize: 'fileSize',
    storageUrl: 'storageUrl',
    evidenceType: 'evidenceType',
    description: 'description',
    documentDate: 'documentDate',
    uploadedBy: 'uploadedBy',
    uploadedAt: 'uploadedAt'
  };

  export type TaskEvidenceScalarFieldEnum = (typeof TaskEvidenceScalarFieldEnum)[keyof typeof TaskEvidenceScalarFieldEnum]


  export const TaskHistoryScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId',
    action: 'action',
    changes: 'changes',
    comment: 'comment',
    timestamp: 'timestamp'
  };

  export type TaskHistoryScalarFieldEnum = (typeof TaskHistoryScalarFieldEnum)[keyof typeof TaskHistoryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: StringFilter<"Usuario"> | string
    nombre?: StringFilter<"Usuario"> | string
    apellido?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    password?: StringNullableFilter<"Usuario"> | string | null
    telefono?: StringNullableFilter<"Usuario"> | string | null
    avatar?: StringNullableFilter<"Usuario"> | string | null
    estado?: StringFilter<"Usuario"> | string
    departamento?: StringNullableFilter<"Usuario"> | string | null
    cargo?: StringNullableFilter<"Usuario"> | string | null
    region?: StringFilter<"Usuario"> | string
    autenticacionDosFactor?: BoolFilter<"Usuario"> | boolean
    cambioPasswordRequerido?: BoolFilter<"Usuario"> | boolean
    sesionesActivas?: IntFilter<"Usuario"> | number
    maxSesionesPermitidas?: IntFilter<"Usuario"> | number
    ultimoCambioPassword?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    intentosFallidos?: IntFilter<"Usuario"> | number
    fechaCreacion?: DateTimeFilter<"Usuario"> | Date | string
    fechaExpiracion?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    ultimoAcceso?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    roles?: UsuarioRolListRelationFilter
    activosAcceso?: UsuarioActivoListRelationFilter
    logsAuditoria?: LogAuditoriaListRelationFilter
    respuestasCuestionario?: RespuestaCuestionarioListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    estado?: SortOrder
    departamento?: SortOrderInput | SortOrder
    cargo?: SortOrderInput | SortOrder
    region?: SortOrder
    autenticacionDosFactor?: SortOrder
    cambioPasswordRequerido?: SortOrder
    sesionesActivas?: SortOrder
    maxSesionesPermitidas?: SortOrder
    ultimoCambioPassword?: SortOrderInput | SortOrder
    intentosFallidos?: SortOrder
    fechaCreacion?: SortOrder
    fechaExpiracion?: SortOrderInput | SortOrder
    ultimoAcceso?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    roles?: UsuarioRolOrderByRelationAggregateInput
    activosAcceso?: UsuarioActivoOrderByRelationAggregateInput
    logsAuditoria?: LogAuditoriaOrderByRelationAggregateInput
    respuestasCuestionario?: RespuestaCuestionarioOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombre?: StringFilter<"Usuario"> | string
    apellido?: StringFilter<"Usuario"> | string
    password?: StringNullableFilter<"Usuario"> | string | null
    telefono?: StringNullableFilter<"Usuario"> | string | null
    avatar?: StringNullableFilter<"Usuario"> | string | null
    estado?: StringFilter<"Usuario"> | string
    departamento?: StringNullableFilter<"Usuario"> | string | null
    cargo?: StringNullableFilter<"Usuario"> | string | null
    region?: StringFilter<"Usuario"> | string
    autenticacionDosFactor?: BoolFilter<"Usuario"> | boolean
    cambioPasswordRequerido?: BoolFilter<"Usuario"> | boolean
    sesionesActivas?: IntFilter<"Usuario"> | number
    maxSesionesPermitidas?: IntFilter<"Usuario"> | number
    ultimoCambioPassword?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    intentosFallidos?: IntFilter<"Usuario"> | number
    fechaCreacion?: DateTimeFilter<"Usuario"> | Date | string
    fechaExpiracion?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    ultimoAcceso?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    roles?: UsuarioRolListRelationFilter
    activosAcceso?: UsuarioActivoListRelationFilter
    logsAuditoria?: LogAuditoriaListRelationFilter
    respuestasCuestionario?: RespuestaCuestionarioListRelationFilter
  }, "id" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    estado?: SortOrder
    departamento?: SortOrderInput | SortOrder
    cargo?: SortOrderInput | SortOrder
    region?: SortOrder
    autenticacionDosFactor?: SortOrder
    cambioPasswordRequerido?: SortOrder
    sesionesActivas?: SortOrder
    maxSesionesPermitidas?: SortOrder
    ultimoCambioPassword?: SortOrderInput | SortOrder
    intentosFallidos?: SortOrder
    fechaCreacion?: SortOrder
    fechaExpiracion?: SortOrderInput | SortOrder
    ultimoAcceso?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Usuario"> | string
    nombre?: StringWithAggregatesFilter<"Usuario"> | string
    apellido?: StringWithAggregatesFilter<"Usuario"> | string
    email?: StringWithAggregatesFilter<"Usuario"> | string
    password?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    estado?: StringWithAggregatesFilter<"Usuario"> | string
    departamento?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    cargo?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    region?: StringWithAggregatesFilter<"Usuario"> | string
    autenticacionDosFactor?: BoolWithAggregatesFilter<"Usuario"> | boolean
    cambioPasswordRequerido?: BoolWithAggregatesFilter<"Usuario"> | boolean
    sesionesActivas?: IntWithAggregatesFilter<"Usuario"> | number
    maxSesionesPermitidas?: IntWithAggregatesFilter<"Usuario"> | number
    ultimoCambioPassword?: DateTimeNullableWithAggregatesFilter<"Usuario"> | Date | string | null
    intentosFallidos?: IntWithAggregatesFilter<"Usuario"> | number
    fechaCreacion?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    fechaExpiracion?: DateTimeNullableWithAggregatesFilter<"Usuario"> | Date | string | null
    ultimoAcceso?: DateTimeNullableWithAggregatesFilter<"Usuario"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type RolWhereInput = {
    AND?: RolWhereInput | RolWhereInput[]
    OR?: RolWhereInput[]
    NOT?: RolWhereInput | RolWhereInput[]
    id?: StringFilter<"Rol"> | string
    nombre?: StringFilter<"Rol"> | string
    descripcion?: StringFilter<"Rol"> | string
    nivelAcceso?: StringFilter<"Rol"> | string
    region?: StringFilter<"Rol"> | string
    tipoArbol?: StringFilter<"Rol"> | string
    color?: StringNullableFilter<"Rol"> | string | null
    icono?: StringNullableFilter<"Rol"> | string | null
    activo?: BoolFilter<"Rol"> | boolean
    esRolSistema?: BoolFilter<"Rol"> | boolean
    fechaCreacion?: DateTimeFilter<"Rol"> | Date | string
    fechaModificacion?: DateTimeFilter<"Rol"> | Date | string
    usuarios?: UsuarioRolListRelationFilter
    permisos?: RolPermisoListRelationFilter
  }

  export type RolOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    nivelAcceso?: SortOrder
    region?: SortOrder
    tipoArbol?: SortOrder
    color?: SortOrderInput | SortOrder
    icono?: SortOrderInput | SortOrder
    activo?: SortOrder
    esRolSistema?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
    usuarios?: UsuarioRolOrderByRelationAggregateInput
    permisos?: RolPermisoOrderByRelationAggregateInput
  }

  export type RolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nombre?: string
    AND?: RolWhereInput | RolWhereInput[]
    OR?: RolWhereInput[]
    NOT?: RolWhereInput | RolWhereInput[]
    descripcion?: StringFilter<"Rol"> | string
    nivelAcceso?: StringFilter<"Rol"> | string
    region?: StringFilter<"Rol"> | string
    tipoArbol?: StringFilter<"Rol"> | string
    color?: StringNullableFilter<"Rol"> | string | null
    icono?: StringNullableFilter<"Rol"> | string | null
    activo?: BoolFilter<"Rol"> | boolean
    esRolSistema?: BoolFilter<"Rol"> | boolean
    fechaCreacion?: DateTimeFilter<"Rol"> | Date | string
    fechaModificacion?: DateTimeFilter<"Rol"> | Date | string
    usuarios?: UsuarioRolListRelationFilter
    permisos?: RolPermisoListRelationFilter
  }, "id" | "nombre">

  export type RolOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    nivelAcceso?: SortOrder
    region?: SortOrder
    tipoArbol?: SortOrder
    color?: SortOrderInput | SortOrder
    icono?: SortOrderInput | SortOrder
    activo?: SortOrder
    esRolSistema?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
    _count?: RolCountOrderByAggregateInput
    _max?: RolMaxOrderByAggregateInput
    _min?: RolMinOrderByAggregateInput
  }

  export type RolScalarWhereWithAggregatesInput = {
    AND?: RolScalarWhereWithAggregatesInput | RolScalarWhereWithAggregatesInput[]
    OR?: RolScalarWhereWithAggregatesInput[]
    NOT?: RolScalarWhereWithAggregatesInput | RolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Rol"> | string
    nombre?: StringWithAggregatesFilter<"Rol"> | string
    descripcion?: StringWithAggregatesFilter<"Rol"> | string
    nivelAcceso?: StringWithAggregatesFilter<"Rol"> | string
    region?: StringWithAggregatesFilter<"Rol"> | string
    tipoArbol?: StringWithAggregatesFilter<"Rol"> | string
    color?: StringNullableWithAggregatesFilter<"Rol"> | string | null
    icono?: StringNullableWithAggregatesFilter<"Rol"> | string | null
    activo?: BoolWithAggregatesFilter<"Rol"> | boolean
    esRolSistema?: BoolWithAggregatesFilter<"Rol"> | boolean
    fechaCreacion?: DateTimeWithAggregatesFilter<"Rol"> | Date | string
    fechaModificacion?: DateTimeWithAggregatesFilter<"Rol"> | Date | string
  }

  export type PermisoWhereInput = {
    AND?: PermisoWhereInput | PermisoWhereInput[]
    OR?: PermisoWhereInput[]
    NOT?: PermisoWhereInput | PermisoWhereInput[]
    id?: StringFilter<"Permiso"> | string
    codigo?: StringFilter<"Permiso"> | string
    nombre?: StringFilter<"Permiso"> | string
    descripcion?: StringFilter<"Permiso"> | string
    modulo?: StringFilter<"Permiso"> | string
    categoria?: StringFilter<"Permiso"> | string
    activo?: BoolFilter<"Permiso"> | boolean
    padreId?: StringNullableFilter<"Permiso"> | string | null
    padre?: XOR<PermisoNullableRelationFilter, PermisoWhereInput> | null
    hijos?: PermisoListRelationFilter
    roles?: RolPermisoListRelationFilter
  }

  export type PermisoOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    modulo?: SortOrder
    categoria?: SortOrder
    activo?: SortOrder
    padreId?: SortOrderInput | SortOrder
    padre?: PermisoOrderByWithRelationInput
    hijos?: PermisoOrderByRelationAggregateInput
    roles?: RolPermisoOrderByRelationAggregateInput
  }

  export type PermisoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    codigo?: string
    AND?: PermisoWhereInput | PermisoWhereInput[]
    OR?: PermisoWhereInput[]
    NOT?: PermisoWhereInput | PermisoWhereInput[]
    nombre?: StringFilter<"Permiso"> | string
    descripcion?: StringFilter<"Permiso"> | string
    modulo?: StringFilter<"Permiso"> | string
    categoria?: StringFilter<"Permiso"> | string
    activo?: BoolFilter<"Permiso"> | boolean
    padreId?: StringNullableFilter<"Permiso"> | string | null
    padre?: XOR<PermisoNullableRelationFilter, PermisoWhereInput> | null
    hijos?: PermisoListRelationFilter
    roles?: RolPermisoListRelationFilter
  }, "id" | "codigo">

  export type PermisoOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    modulo?: SortOrder
    categoria?: SortOrder
    activo?: SortOrder
    padreId?: SortOrderInput | SortOrder
    _count?: PermisoCountOrderByAggregateInput
    _max?: PermisoMaxOrderByAggregateInput
    _min?: PermisoMinOrderByAggregateInput
  }

  export type PermisoScalarWhereWithAggregatesInput = {
    AND?: PermisoScalarWhereWithAggregatesInput | PermisoScalarWhereWithAggregatesInput[]
    OR?: PermisoScalarWhereWithAggregatesInput[]
    NOT?: PermisoScalarWhereWithAggregatesInput | PermisoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permiso"> | string
    codigo?: StringWithAggregatesFilter<"Permiso"> | string
    nombre?: StringWithAggregatesFilter<"Permiso"> | string
    descripcion?: StringWithAggregatesFilter<"Permiso"> | string
    modulo?: StringWithAggregatesFilter<"Permiso"> | string
    categoria?: StringWithAggregatesFilter<"Permiso"> | string
    activo?: BoolWithAggregatesFilter<"Permiso"> | boolean
    padreId?: StringNullableWithAggregatesFilter<"Permiso"> | string | null
  }

  export type ModuloWhereInput = {
    AND?: ModuloWhereInput | ModuloWhereInput[]
    OR?: ModuloWhereInput[]
    NOT?: ModuloWhereInput | ModuloWhereInput[]
    id?: StringFilter<"Modulo"> | string
    nombre?: StringFilter<"Modulo"> | string
    descripcion?: StringNullableFilter<"Modulo"> | string | null
    icono?: StringNullableFilter<"Modulo"> | string | null
    orden?: IntFilter<"Modulo"> | number
    activo?: BoolFilter<"Modulo"> | boolean
    permisoCreacion?: BoolFilter<"Modulo"> | boolean
    permisoEdicion?: BoolFilter<"Modulo"> | boolean
    permisoVisualizacion?: BoolFilter<"Modulo"> | boolean
    permisoEliminacion?: BoolFilter<"Modulo"> | boolean
  }

  export type ModuloOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    icono?: SortOrderInput | SortOrder
    orden?: SortOrder
    activo?: SortOrder
    permisoCreacion?: SortOrder
    permisoEdicion?: SortOrder
    permisoVisualizacion?: SortOrder
    permisoEliminacion?: SortOrder
  }

  export type ModuloWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nombre?: string
    AND?: ModuloWhereInput | ModuloWhereInput[]
    OR?: ModuloWhereInput[]
    NOT?: ModuloWhereInput | ModuloWhereInput[]
    descripcion?: StringNullableFilter<"Modulo"> | string | null
    icono?: StringNullableFilter<"Modulo"> | string | null
    orden?: IntFilter<"Modulo"> | number
    activo?: BoolFilter<"Modulo"> | boolean
    permisoCreacion?: BoolFilter<"Modulo"> | boolean
    permisoEdicion?: BoolFilter<"Modulo"> | boolean
    permisoVisualizacion?: BoolFilter<"Modulo"> | boolean
    permisoEliminacion?: BoolFilter<"Modulo"> | boolean
  }, "id" | "nombre">

  export type ModuloOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    icono?: SortOrderInput | SortOrder
    orden?: SortOrder
    activo?: SortOrder
    permisoCreacion?: SortOrder
    permisoEdicion?: SortOrder
    permisoVisualizacion?: SortOrder
    permisoEliminacion?: SortOrder
    _count?: ModuloCountOrderByAggregateInput
    _avg?: ModuloAvgOrderByAggregateInput
    _max?: ModuloMaxOrderByAggregateInput
    _min?: ModuloMinOrderByAggregateInput
    _sum?: ModuloSumOrderByAggregateInput
  }

  export type ModuloScalarWhereWithAggregatesInput = {
    AND?: ModuloScalarWhereWithAggregatesInput | ModuloScalarWhereWithAggregatesInput[]
    OR?: ModuloScalarWhereWithAggregatesInput[]
    NOT?: ModuloScalarWhereWithAggregatesInput | ModuloScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Modulo"> | string
    nombre?: StringWithAggregatesFilter<"Modulo"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Modulo"> | string | null
    icono?: StringNullableWithAggregatesFilter<"Modulo"> | string | null
    orden?: IntWithAggregatesFilter<"Modulo"> | number
    activo?: BoolWithAggregatesFilter<"Modulo"> | boolean
    permisoCreacion?: BoolWithAggregatesFilter<"Modulo"> | boolean
    permisoEdicion?: BoolWithAggregatesFilter<"Modulo"> | boolean
    permisoVisualizacion?: BoolWithAggregatesFilter<"Modulo"> | boolean
    permisoEliminacion?: BoolWithAggregatesFilter<"Modulo"> | boolean
  }

  export type UsuarioRolWhereInput = {
    AND?: UsuarioRolWhereInput | UsuarioRolWhereInput[]
    OR?: UsuarioRolWhereInput[]
    NOT?: UsuarioRolWhereInput | UsuarioRolWhereInput[]
    usuarioId?: StringFilter<"UsuarioRol"> | string
    rolId?: StringFilter<"UsuarioRol"> | string
    fechaAsignacion?: DateTimeFilter<"UsuarioRol"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    rol?: XOR<RolRelationFilter, RolWhereInput>
  }

  export type UsuarioRolOrderByWithRelationInput = {
    usuarioId?: SortOrder
    rolId?: SortOrder
    fechaAsignacion?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    rol?: RolOrderByWithRelationInput
  }

  export type UsuarioRolWhereUniqueInput = Prisma.AtLeast<{
    usuarioId_rolId?: UsuarioRolUsuarioIdRolIdCompoundUniqueInput
    AND?: UsuarioRolWhereInput | UsuarioRolWhereInput[]
    OR?: UsuarioRolWhereInput[]
    NOT?: UsuarioRolWhereInput | UsuarioRolWhereInput[]
    usuarioId?: StringFilter<"UsuarioRol"> | string
    rolId?: StringFilter<"UsuarioRol"> | string
    fechaAsignacion?: DateTimeFilter<"UsuarioRol"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    rol?: XOR<RolRelationFilter, RolWhereInput>
  }, "usuarioId_rolId">

  export type UsuarioRolOrderByWithAggregationInput = {
    usuarioId?: SortOrder
    rolId?: SortOrder
    fechaAsignacion?: SortOrder
    _count?: UsuarioRolCountOrderByAggregateInput
    _max?: UsuarioRolMaxOrderByAggregateInput
    _min?: UsuarioRolMinOrderByAggregateInput
  }

  export type UsuarioRolScalarWhereWithAggregatesInput = {
    AND?: UsuarioRolScalarWhereWithAggregatesInput | UsuarioRolScalarWhereWithAggregatesInput[]
    OR?: UsuarioRolScalarWhereWithAggregatesInput[]
    NOT?: UsuarioRolScalarWhereWithAggregatesInput | UsuarioRolScalarWhereWithAggregatesInput[]
    usuarioId?: StringWithAggregatesFilter<"UsuarioRol"> | string
    rolId?: StringWithAggregatesFilter<"UsuarioRol"> | string
    fechaAsignacion?: DateTimeWithAggregatesFilter<"UsuarioRol"> | Date | string
  }

  export type RolPermisoWhereInput = {
    AND?: RolPermisoWhereInput | RolPermisoWhereInput[]
    OR?: RolPermisoWhereInput[]
    NOT?: RolPermisoWhereInput | RolPermisoWhereInput[]
    rolId?: StringFilter<"RolPermiso"> | string
    permisoId?: StringFilter<"RolPermiso"> | string
    rol?: XOR<RolRelationFilter, RolWhereInput>
    permiso?: XOR<PermisoRelationFilter, PermisoWhereInput>
  }

  export type RolPermisoOrderByWithRelationInput = {
    rolId?: SortOrder
    permisoId?: SortOrder
    rol?: RolOrderByWithRelationInput
    permiso?: PermisoOrderByWithRelationInput
  }

  export type RolPermisoWhereUniqueInput = Prisma.AtLeast<{
    rolId_permisoId?: RolPermisoRolIdPermisoIdCompoundUniqueInput
    AND?: RolPermisoWhereInput | RolPermisoWhereInput[]
    OR?: RolPermisoWhereInput[]
    NOT?: RolPermisoWhereInput | RolPermisoWhereInput[]
    rolId?: StringFilter<"RolPermiso"> | string
    permisoId?: StringFilter<"RolPermiso"> | string
    rol?: XOR<RolRelationFilter, RolWhereInput>
    permiso?: XOR<PermisoRelationFilter, PermisoWhereInput>
  }, "rolId_permisoId">

  export type RolPermisoOrderByWithAggregationInput = {
    rolId?: SortOrder
    permisoId?: SortOrder
    _count?: RolPermisoCountOrderByAggregateInput
    _max?: RolPermisoMaxOrderByAggregateInput
    _min?: RolPermisoMinOrderByAggregateInput
  }

  export type RolPermisoScalarWhereWithAggregatesInput = {
    AND?: RolPermisoScalarWhereWithAggregatesInput | RolPermisoScalarWhereWithAggregatesInput[]
    OR?: RolPermisoScalarWhereWithAggregatesInput[]
    NOT?: RolPermisoScalarWhereWithAggregatesInput | RolPermisoScalarWhereWithAggregatesInput[]
    rolId?: StringWithAggregatesFilter<"RolPermiso"> | string
    permisoId?: StringWithAggregatesFilter<"RolPermiso"> | string
  }

  export type UsuarioActivoWhereInput = {
    AND?: UsuarioActivoWhereInput | UsuarioActivoWhereInput[]
    OR?: UsuarioActivoWhereInput[]
    NOT?: UsuarioActivoWhereInput | UsuarioActivoWhereInput[]
    usuarioId?: StringFilter<"UsuarioActivo"> | string
    activoId?: StringFilter<"UsuarioActivo"> | string
    nivelAcceso?: StringFilter<"UsuarioActivo"> | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    activo?: XOR<ActivoAccesoRelationFilter, ActivoAccesoWhereInput>
  }

  export type UsuarioActivoOrderByWithRelationInput = {
    usuarioId?: SortOrder
    activoId?: SortOrder
    nivelAcceso?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    activo?: ActivoAccesoOrderByWithRelationInput
  }

  export type UsuarioActivoWhereUniqueInput = Prisma.AtLeast<{
    usuarioId_activoId?: UsuarioActivoUsuarioIdActivoIdCompoundUniqueInput
    AND?: UsuarioActivoWhereInput | UsuarioActivoWhereInput[]
    OR?: UsuarioActivoWhereInput[]
    NOT?: UsuarioActivoWhereInput | UsuarioActivoWhereInput[]
    usuarioId?: StringFilter<"UsuarioActivo"> | string
    activoId?: StringFilter<"UsuarioActivo"> | string
    nivelAcceso?: StringFilter<"UsuarioActivo"> | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    activo?: XOR<ActivoAccesoRelationFilter, ActivoAccesoWhereInput>
  }, "usuarioId_activoId">

  export type UsuarioActivoOrderByWithAggregationInput = {
    usuarioId?: SortOrder
    activoId?: SortOrder
    nivelAcceso?: SortOrder
    _count?: UsuarioActivoCountOrderByAggregateInput
    _max?: UsuarioActivoMaxOrderByAggregateInput
    _min?: UsuarioActivoMinOrderByAggregateInput
  }

  export type UsuarioActivoScalarWhereWithAggregatesInput = {
    AND?: UsuarioActivoScalarWhereWithAggregatesInput | UsuarioActivoScalarWhereWithAggregatesInput[]
    OR?: UsuarioActivoScalarWhereWithAggregatesInput[]
    NOT?: UsuarioActivoScalarWhereWithAggregatesInput | UsuarioActivoScalarWhereWithAggregatesInput[]
    usuarioId?: StringWithAggregatesFilter<"UsuarioActivo"> | string
    activoId?: StringWithAggregatesFilter<"UsuarioActivo"> | string
    nivelAcceso?: StringWithAggregatesFilter<"UsuarioActivo"> | string
  }

  export type LogAuditoriaWhereInput = {
    AND?: LogAuditoriaWhereInput | LogAuditoriaWhereInput[]
    OR?: LogAuditoriaWhereInput[]
    NOT?: LogAuditoriaWhereInput | LogAuditoriaWhereInput[]
    id?: StringFilter<"LogAuditoria"> | string
    accion?: StringFilter<"LogAuditoria"> | string
    entidad?: StringFilter<"LogAuditoria"> | string
    entidadId?: StringFilter<"LogAuditoria"> | string
    entidadNombre?: StringFilter<"LogAuditoria"> | string
    detalles?: StringNullableFilter<"LogAuditoria"> | string | null
    ip?: StringNullableFilter<"LogAuditoria"> | string | null
    userAgent?: StringNullableFilter<"LogAuditoria"> | string | null
    fecha?: DateTimeFilter<"LogAuditoria"> | Date | string
    usuarioId?: StringFilter<"LogAuditoria"> | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type LogAuditoriaOrderByWithRelationInput = {
    id?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    entidadNombre?: SortOrder
    detalles?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    fecha?: SortOrder
    usuarioId?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type LogAuditoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LogAuditoriaWhereInput | LogAuditoriaWhereInput[]
    OR?: LogAuditoriaWhereInput[]
    NOT?: LogAuditoriaWhereInput | LogAuditoriaWhereInput[]
    accion?: StringFilter<"LogAuditoria"> | string
    entidad?: StringFilter<"LogAuditoria"> | string
    entidadId?: StringFilter<"LogAuditoria"> | string
    entidadNombre?: StringFilter<"LogAuditoria"> | string
    detalles?: StringNullableFilter<"LogAuditoria"> | string | null
    ip?: StringNullableFilter<"LogAuditoria"> | string | null
    userAgent?: StringNullableFilter<"LogAuditoria"> | string | null
    fecha?: DateTimeFilter<"LogAuditoria"> | Date | string
    usuarioId?: StringFilter<"LogAuditoria"> | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id">

  export type LogAuditoriaOrderByWithAggregationInput = {
    id?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    entidadNombre?: SortOrder
    detalles?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    fecha?: SortOrder
    usuarioId?: SortOrder
    _count?: LogAuditoriaCountOrderByAggregateInput
    _max?: LogAuditoriaMaxOrderByAggregateInput
    _min?: LogAuditoriaMinOrderByAggregateInput
  }

  export type LogAuditoriaScalarWhereWithAggregatesInput = {
    AND?: LogAuditoriaScalarWhereWithAggregatesInput | LogAuditoriaScalarWhereWithAggregatesInput[]
    OR?: LogAuditoriaScalarWhereWithAggregatesInput[]
    NOT?: LogAuditoriaScalarWhereWithAggregatesInput | LogAuditoriaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LogAuditoria"> | string
    accion?: StringWithAggregatesFilter<"LogAuditoria"> | string
    entidad?: StringWithAggregatesFilter<"LogAuditoria"> | string
    entidadId?: StringWithAggregatesFilter<"LogAuditoria"> | string
    entidadNombre?: StringWithAggregatesFilter<"LogAuditoria"> | string
    detalles?: StringNullableWithAggregatesFilter<"LogAuditoria"> | string | null
    ip?: StringNullableWithAggregatesFilter<"LogAuditoria"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"LogAuditoria"> | string | null
    fecha?: DateTimeWithAggregatesFilter<"LogAuditoria"> | Date | string
    usuarioId?: StringWithAggregatesFilter<"LogAuditoria"> | string
  }

  export type ActivoAccesoWhereInput = {
    AND?: ActivoAccesoWhereInput | ActivoAccesoWhereInput[]
    OR?: ActivoAccesoWhereInput[]
    NOT?: ActivoAccesoWhereInput | ActivoAccesoWhereInput[]
    id?: StringFilter<"ActivoAcceso"> | string
    nombre?: StringFilter<"ActivoAcceso"> | string
    tipo?: StringFilter<"ActivoAcceso"> | string
    icono?: StringNullableFilter<"ActivoAcceso"> | string | null
    nivelAcceso?: StringNullableFilter<"ActivoAcceso"> | string | null
    expanded?: BoolFilter<"ActivoAcceso"> | boolean
    padreId?: StringNullableFilter<"ActivoAcceso"> | string | null
    padre?: XOR<ActivoAccesoNullableRelationFilter, ActivoAccesoWhereInput> | null
    hijos?: ActivoAccesoListRelationFilter
    usuarios?: UsuarioActivoListRelationFilter
  }

  export type ActivoAccesoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    icono?: SortOrderInput | SortOrder
    nivelAcceso?: SortOrderInput | SortOrder
    expanded?: SortOrder
    padreId?: SortOrderInput | SortOrder
    padre?: ActivoAccesoOrderByWithRelationInput
    hijos?: ActivoAccesoOrderByRelationAggregateInput
    usuarios?: UsuarioActivoOrderByRelationAggregateInput
  }

  export type ActivoAccesoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivoAccesoWhereInput | ActivoAccesoWhereInput[]
    OR?: ActivoAccesoWhereInput[]
    NOT?: ActivoAccesoWhereInput | ActivoAccesoWhereInput[]
    nombre?: StringFilter<"ActivoAcceso"> | string
    tipo?: StringFilter<"ActivoAcceso"> | string
    icono?: StringNullableFilter<"ActivoAcceso"> | string | null
    nivelAcceso?: StringNullableFilter<"ActivoAcceso"> | string | null
    expanded?: BoolFilter<"ActivoAcceso"> | boolean
    padreId?: StringNullableFilter<"ActivoAcceso"> | string | null
    padre?: XOR<ActivoAccesoNullableRelationFilter, ActivoAccesoWhereInput> | null
    hijos?: ActivoAccesoListRelationFilter
    usuarios?: UsuarioActivoListRelationFilter
  }, "id">

  export type ActivoAccesoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    icono?: SortOrderInput | SortOrder
    nivelAcceso?: SortOrderInput | SortOrder
    expanded?: SortOrder
    padreId?: SortOrderInput | SortOrder
    _count?: ActivoAccesoCountOrderByAggregateInput
    _max?: ActivoAccesoMaxOrderByAggregateInput
    _min?: ActivoAccesoMinOrderByAggregateInput
  }

  export type ActivoAccesoScalarWhereWithAggregatesInput = {
    AND?: ActivoAccesoScalarWhereWithAggregatesInput | ActivoAccesoScalarWhereWithAggregatesInput[]
    OR?: ActivoAccesoScalarWhereWithAggregatesInput[]
    NOT?: ActivoAccesoScalarWhereWithAggregatesInput | ActivoAccesoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivoAcceso"> | string
    nombre?: StringWithAggregatesFilter<"ActivoAcceso"> | string
    tipo?: StringWithAggregatesFilter<"ActivoAcceso"> | string
    icono?: StringNullableWithAggregatesFilter<"ActivoAcceso"> | string | null
    nivelAcceso?: StringNullableWithAggregatesFilter<"ActivoAcceso"> | string | null
    expanded?: BoolWithAggregatesFilter<"ActivoAcceso"> | boolean
    padreId?: StringNullableWithAggregatesFilter<"ActivoAcceso"> | string | null
  }

  export type PlantillaActivoWhereInput = {
    AND?: PlantillaActivoWhereInput | PlantillaActivoWhereInput[]
    OR?: PlantillaActivoWhereInput[]
    NOT?: PlantillaActivoWhereInput | PlantillaActivoWhereInput[]
    id?: StringFilter<"PlantillaActivo"> | string
    nombre?: StringFilter<"PlantillaActivo"> | string
    tipoActivo?: StringFilter<"PlantillaActivo"> | string
    descripcion?: StringFilter<"PlantillaActivo"> | string
    icono?: StringNullableFilter<"PlantillaActivo"> | string | null
    color?: StringNullableFilter<"PlantillaActivo"> | string | null
    propiedades?: StringFilter<"PlantillaActivo"> | string
    activo?: BoolFilter<"PlantillaActivo"> | boolean
    fechaCreacion?: DateTimeFilter<"PlantillaActivo"> | Date | string
    activos?: ActivoListRelationFilter
  }

  export type PlantillaActivoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipoActivo?: SortOrder
    descripcion?: SortOrder
    icono?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    propiedades?: SortOrder
    activo?: SortOrder
    fechaCreacion?: SortOrder
    activos?: ActivoOrderByRelationAggregateInput
  }

  export type PlantillaActivoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlantillaActivoWhereInput | PlantillaActivoWhereInput[]
    OR?: PlantillaActivoWhereInput[]
    NOT?: PlantillaActivoWhereInput | PlantillaActivoWhereInput[]
    nombre?: StringFilter<"PlantillaActivo"> | string
    tipoActivo?: StringFilter<"PlantillaActivo"> | string
    descripcion?: StringFilter<"PlantillaActivo"> | string
    icono?: StringNullableFilter<"PlantillaActivo"> | string | null
    color?: StringNullableFilter<"PlantillaActivo"> | string | null
    propiedades?: StringFilter<"PlantillaActivo"> | string
    activo?: BoolFilter<"PlantillaActivo"> | boolean
    fechaCreacion?: DateTimeFilter<"PlantillaActivo"> | Date | string
    activos?: ActivoListRelationFilter
  }, "id">

  export type PlantillaActivoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipoActivo?: SortOrder
    descripcion?: SortOrder
    icono?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    propiedades?: SortOrder
    activo?: SortOrder
    fechaCreacion?: SortOrder
    _count?: PlantillaActivoCountOrderByAggregateInput
    _max?: PlantillaActivoMaxOrderByAggregateInput
    _min?: PlantillaActivoMinOrderByAggregateInput
  }

  export type PlantillaActivoScalarWhereWithAggregatesInput = {
    AND?: PlantillaActivoScalarWhereWithAggregatesInput | PlantillaActivoScalarWhereWithAggregatesInput[]
    OR?: PlantillaActivoScalarWhereWithAggregatesInput[]
    NOT?: PlantillaActivoScalarWhereWithAggregatesInput | PlantillaActivoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlantillaActivo"> | string
    nombre?: StringWithAggregatesFilter<"PlantillaActivo"> | string
    tipoActivo?: StringWithAggregatesFilter<"PlantillaActivo"> | string
    descripcion?: StringWithAggregatesFilter<"PlantillaActivo"> | string
    icono?: StringNullableWithAggregatesFilter<"PlantillaActivo"> | string | null
    color?: StringNullableWithAggregatesFilter<"PlantillaActivo"> | string | null
    propiedades?: StringWithAggregatesFilter<"PlantillaActivo"> | string
    activo?: BoolWithAggregatesFilter<"PlantillaActivo"> | boolean
    fechaCreacion?: DateTimeWithAggregatesFilter<"PlantillaActivo"> | Date | string
  }

  export type ActivoWhereInput = {
    AND?: ActivoWhereInput | ActivoWhereInput[]
    OR?: ActivoWhereInput[]
    NOT?: ActivoWhereInput | ActivoWhereInput[]
    id?: StringFilter<"Activo"> | string
    nombre?: StringFilter<"Activo"> | string
    descripcion?: StringFilter<"Activo"> | string
    tipo?: StringFilter<"Activo"> | string
    criticidad?: StringFilter<"Activo"> | string
    responsable?: StringFilter<"Activo"> | string
    departamento?: StringFilter<"Activo"> | string
    fechaRegistro?: DateTimeFilter<"Activo"> | Date | string
    updatedAt?: DateTimeFilter<"Activo"> | Date | string
    plantillaId?: StringNullableFilter<"Activo"> | string | null
    propiedadesCustom?: StringNullableFilter<"Activo"> | string | null
    plantilla?: XOR<PlantillaActivoNullableRelationFilter, PlantillaActivoWhereInput> | null
    riesgos?: RiesgoListRelationFilter
    incidentes?: IncidenteListRelationFilter
    defectos?: DefectoListRelationFilter
  }

  export type ActivoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    criticidad?: SortOrder
    responsable?: SortOrder
    departamento?: SortOrder
    fechaRegistro?: SortOrder
    updatedAt?: SortOrder
    plantillaId?: SortOrderInput | SortOrder
    propiedadesCustom?: SortOrderInput | SortOrder
    plantilla?: PlantillaActivoOrderByWithRelationInput
    riesgos?: RiesgoOrderByRelationAggregateInput
    incidentes?: IncidenteOrderByRelationAggregateInput
    defectos?: DefectoOrderByRelationAggregateInput
  }

  export type ActivoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivoWhereInput | ActivoWhereInput[]
    OR?: ActivoWhereInput[]
    NOT?: ActivoWhereInput | ActivoWhereInput[]
    nombre?: StringFilter<"Activo"> | string
    descripcion?: StringFilter<"Activo"> | string
    tipo?: StringFilter<"Activo"> | string
    criticidad?: StringFilter<"Activo"> | string
    responsable?: StringFilter<"Activo"> | string
    departamento?: StringFilter<"Activo"> | string
    fechaRegistro?: DateTimeFilter<"Activo"> | Date | string
    updatedAt?: DateTimeFilter<"Activo"> | Date | string
    plantillaId?: StringNullableFilter<"Activo"> | string | null
    propiedadesCustom?: StringNullableFilter<"Activo"> | string | null
    plantilla?: XOR<PlantillaActivoNullableRelationFilter, PlantillaActivoWhereInput> | null
    riesgos?: RiesgoListRelationFilter
    incidentes?: IncidenteListRelationFilter
    defectos?: DefectoListRelationFilter
  }, "id">

  export type ActivoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    criticidad?: SortOrder
    responsable?: SortOrder
    departamento?: SortOrder
    fechaRegistro?: SortOrder
    updatedAt?: SortOrder
    plantillaId?: SortOrderInput | SortOrder
    propiedadesCustom?: SortOrderInput | SortOrder
    _count?: ActivoCountOrderByAggregateInput
    _max?: ActivoMaxOrderByAggregateInput
    _min?: ActivoMinOrderByAggregateInput
  }

  export type ActivoScalarWhereWithAggregatesInput = {
    AND?: ActivoScalarWhereWithAggregatesInput | ActivoScalarWhereWithAggregatesInput[]
    OR?: ActivoScalarWhereWithAggregatesInput[]
    NOT?: ActivoScalarWhereWithAggregatesInput | ActivoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activo"> | string
    nombre?: StringWithAggregatesFilter<"Activo"> | string
    descripcion?: StringWithAggregatesFilter<"Activo"> | string
    tipo?: StringWithAggregatesFilter<"Activo"> | string
    criticidad?: StringWithAggregatesFilter<"Activo"> | string
    responsable?: StringWithAggregatesFilter<"Activo"> | string
    departamento?: StringWithAggregatesFilter<"Activo"> | string
    fechaRegistro?: DateTimeWithAggregatesFilter<"Activo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Activo"> | Date | string
    plantillaId?: StringNullableWithAggregatesFilter<"Activo"> | string | null
    propiedadesCustom?: StringNullableWithAggregatesFilter<"Activo"> | string | null
  }

  export type RiesgoWhereInput = {
    AND?: RiesgoWhereInput | RiesgoWhereInput[]
    OR?: RiesgoWhereInput[]
    NOT?: RiesgoWhereInput | RiesgoWhereInput[]
    id?: StringFilter<"Riesgo"> | string
    activoId?: StringFilter<"Riesgo"> | string
    descripcion?: StringFilter<"Riesgo"> | string
    probabilidad?: IntFilter<"Riesgo"> | number
    impacto?: IntFilter<"Riesgo"> | number
    estado?: StringFilter<"Riesgo"> | string
    fechaIdentificacion?: DateTimeFilter<"Riesgo"> | Date | string
    responsable?: StringFilter<"Riesgo"> | string
    updatedAt?: DateTimeFilter<"Riesgo"> | Date | string
    activo?: XOR<ActivoRelationFilter, ActivoWhereInput>
  }

  export type RiesgoOrderByWithRelationInput = {
    id?: SortOrder
    activoId?: SortOrder
    descripcion?: SortOrder
    probabilidad?: SortOrder
    impacto?: SortOrder
    estado?: SortOrder
    fechaIdentificacion?: SortOrder
    responsable?: SortOrder
    updatedAt?: SortOrder
    activo?: ActivoOrderByWithRelationInput
  }

  export type RiesgoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RiesgoWhereInput | RiesgoWhereInput[]
    OR?: RiesgoWhereInput[]
    NOT?: RiesgoWhereInput | RiesgoWhereInput[]
    activoId?: StringFilter<"Riesgo"> | string
    descripcion?: StringFilter<"Riesgo"> | string
    probabilidad?: IntFilter<"Riesgo"> | number
    impacto?: IntFilter<"Riesgo"> | number
    estado?: StringFilter<"Riesgo"> | string
    fechaIdentificacion?: DateTimeFilter<"Riesgo"> | Date | string
    responsable?: StringFilter<"Riesgo"> | string
    updatedAt?: DateTimeFilter<"Riesgo"> | Date | string
    activo?: XOR<ActivoRelationFilter, ActivoWhereInput>
  }, "id">

  export type RiesgoOrderByWithAggregationInput = {
    id?: SortOrder
    activoId?: SortOrder
    descripcion?: SortOrder
    probabilidad?: SortOrder
    impacto?: SortOrder
    estado?: SortOrder
    fechaIdentificacion?: SortOrder
    responsable?: SortOrder
    updatedAt?: SortOrder
    _count?: RiesgoCountOrderByAggregateInput
    _avg?: RiesgoAvgOrderByAggregateInput
    _max?: RiesgoMaxOrderByAggregateInput
    _min?: RiesgoMinOrderByAggregateInput
    _sum?: RiesgoSumOrderByAggregateInput
  }

  export type RiesgoScalarWhereWithAggregatesInput = {
    AND?: RiesgoScalarWhereWithAggregatesInput | RiesgoScalarWhereWithAggregatesInput[]
    OR?: RiesgoScalarWhereWithAggregatesInput[]
    NOT?: RiesgoScalarWhereWithAggregatesInput | RiesgoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Riesgo"> | string
    activoId?: StringWithAggregatesFilter<"Riesgo"> | string
    descripcion?: StringWithAggregatesFilter<"Riesgo"> | string
    probabilidad?: IntWithAggregatesFilter<"Riesgo"> | number
    impacto?: IntWithAggregatesFilter<"Riesgo"> | number
    estado?: StringWithAggregatesFilter<"Riesgo"> | string
    fechaIdentificacion?: DateTimeWithAggregatesFilter<"Riesgo"> | Date | string
    responsable?: StringWithAggregatesFilter<"Riesgo"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Riesgo"> | Date | string
  }

  export type IncidenteWhereInput = {
    AND?: IncidenteWhereInput | IncidenteWhereInput[]
    OR?: IncidenteWhereInput[]
    NOT?: IncidenteWhereInput | IncidenteWhereInput[]
    id?: StringFilter<"Incidente"> | string
    activoId?: StringFilter<"Incidente"> | string
    titulo?: StringFilter<"Incidente"> | string
    descripcion?: StringFilter<"Incidente"> | string
    severidad?: StringFilter<"Incidente"> | string
    estado?: StringFilter<"Incidente"> | string
    fechaReporte?: DateTimeFilter<"Incidente"> | Date | string
    reportadoPor?: StringFilter<"Incidente"> | string
    updatedAt?: DateTimeFilter<"Incidente"> | Date | string
    activo?: XOR<ActivoRelationFilter, ActivoWhereInput>
  }

  export type IncidenteOrderByWithRelationInput = {
    id?: SortOrder
    activoId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    severidad?: SortOrder
    estado?: SortOrder
    fechaReporte?: SortOrder
    reportadoPor?: SortOrder
    updatedAt?: SortOrder
    activo?: ActivoOrderByWithRelationInput
  }

  export type IncidenteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidenteWhereInput | IncidenteWhereInput[]
    OR?: IncidenteWhereInput[]
    NOT?: IncidenteWhereInput | IncidenteWhereInput[]
    activoId?: StringFilter<"Incidente"> | string
    titulo?: StringFilter<"Incidente"> | string
    descripcion?: StringFilter<"Incidente"> | string
    severidad?: StringFilter<"Incidente"> | string
    estado?: StringFilter<"Incidente"> | string
    fechaReporte?: DateTimeFilter<"Incidente"> | Date | string
    reportadoPor?: StringFilter<"Incidente"> | string
    updatedAt?: DateTimeFilter<"Incidente"> | Date | string
    activo?: XOR<ActivoRelationFilter, ActivoWhereInput>
  }, "id">

  export type IncidenteOrderByWithAggregationInput = {
    id?: SortOrder
    activoId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    severidad?: SortOrder
    estado?: SortOrder
    fechaReporte?: SortOrder
    reportadoPor?: SortOrder
    updatedAt?: SortOrder
    _count?: IncidenteCountOrderByAggregateInput
    _max?: IncidenteMaxOrderByAggregateInput
    _min?: IncidenteMinOrderByAggregateInput
  }

  export type IncidenteScalarWhereWithAggregatesInput = {
    AND?: IncidenteScalarWhereWithAggregatesInput | IncidenteScalarWhereWithAggregatesInput[]
    OR?: IncidenteScalarWhereWithAggregatesInput[]
    NOT?: IncidenteScalarWhereWithAggregatesInput | IncidenteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Incidente"> | string
    activoId?: StringWithAggregatesFilter<"Incidente"> | string
    titulo?: StringWithAggregatesFilter<"Incidente"> | string
    descripcion?: StringWithAggregatesFilter<"Incidente"> | string
    severidad?: StringWithAggregatesFilter<"Incidente"> | string
    estado?: StringWithAggregatesFilter<"Incidente"> | string
    fechaReporte?: DateTimeWithAggregatesFilter<"Incidente"> | Date | string
    reportadoPor?: StringWithAggregatesFilter<"Incidente"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Incidente"> | Date | string
  }

  export type DefectoWhereInput = {
    AND?: DefectoWhereInput | DefectoWhereInput[]
    OR?: DefectoWhereInput[]
    NOT?: DefectoWhereInput | DefectoWhereInput[]
    id?: StringFilter<"Defecto"> | string
    activoId?: StringFilter<"Defecto"> | string
    titulo?: StringFilter<"Defecto"> | string
    descripcion?: StringFilter<"Defecto"> | string
    tipo?: StringFilter<"Defecto"> | string
    prioridad?: StringFilter<"Defecto"> | string
    estado?: StringFilter<"Defecto"> | string
    fechaDeteccion?: DateTimeFilter<"Defecto"> | Date | string
    detectadoPor?: StringFilter<"Defecto"> | string
    updatedAt?: DateTimeFilter<"Defecto"> | Date | string
    activo?: XOR<ActivoRelationFilter, ActivoWhereInput>
  }

  export type DefectoOrderByWithRelationInput = {
    id?: SortOrder
    activoId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    prioridad?: SortOrder
    estado?: SortOrder
    fechaDeteccion?: SortOrder
    detectadoPor?: SortOrder
    updatedAt?: SortOrder
    activo?: ActivoOrderByWithRelationInput
  }

  export type DefectoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DefectoWhereInput | DefectoWhereInput[]
    OR?: DefectoWhereInput[]
    NOT?: DefectoWhereInput | DefectoWhereInput[]
    activoId?: StringFilter<"Defecto"> | string
    titulo?: StringFilter<"Defecto"> | string
    descripcion?: StringFilter<"Defecto"> | string
    tipo?: StringFilter<"Defecto"> | string
    prioridad?: StringFilter<"Defecto"> | string
    estado?: StringFilter<"Defecto"> | string
    fechaDeteccion?: DateTimeFilter<"Defecto"> | Date | string
    detectadoPor?: StringFilter<"Defecto"> | string
    updatedAt?: DateTimeFilter<"Defecto"> | Date | string
    activo?: XOR<ActivoRelationFilter, ActivoWhereInput>
  }, "id">

  export type DefectoOrderByWithAggregationInput = {
    id?: SortOrder
    activoId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    prioridad?: SortOrder
    estado?: SortOrder
    fechaDeteccion?: SortOrder
    detectadoPor?: SortOrder
    updatedAt?: SortOrder
    _count?: DefectoCountOrderByAggregateInput
    _max?: DefectoMaxOrderByAggregateInput
    _min?: DefectoMinOrderByAggregateInput
  }

  export type DefectoScalarWhereWithAggregatesInput = {
    AND?: DefectoScalarWhereWithAggregatesInput | DefectoScalarWhereWithAggregatesInput[]
    OR?: DefectoScalarWhereWithAggregatesInput[]
    NOT?: DefectoScalarWhereWithAggregatesInput | DefectoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Defecto"> | string
    activoId?: StringWithAggregatesFilter<"Defecto"> | string
    titulo?: StringWithAggregatesFilter<"Defecto"> | string
    descripcion?: StringWithAggregatesFilter<"Defecto"> | string
    tipo?: StringWithAggregatesFilter<"Defecto"> | string
    prioridad?: StringWithAggregatesFilter<"Defecto"> | string
    estado?: StringWithAggregatesFilter<"Defecto"> | string
    fechaDeteccion?: DateTimeWithAggregatesFilter<"Defecto"> | Date | string
    detectadoPor?: StringWithAggregatesFilter<"Defecto"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Defecto"> | Date | string
  }

  export type OrganigramaWhereInput = {
    AND?: OrganigramaWhereInput | OrganigramaWhereInput[]
    OR?: OrganigramaWhereInput[]
    NOT?: OrganigramaWhereInput | OrganigramaWhereInput[]
    id?: StringFilter<"Organigrama"> | string
    nombre?: StringFilter<"Organigrama"> | string
    descripcion?: StringFilter<"Organigrama"> | string
    fechaCreacion?: DateTimeFilter<"Organigrama"> | Date | string
    updatedAt?: DateTimeFilter<"Organigrama"> | Date | string
    nodos?: NodoOrganigramaListRelationFilter
  }

  export type OrganigramaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    fechaCreacion?: SortOrder
    updatedAt?: SortOrder
    nodos?: NodoOrganigramaOrderByRelationAggregateInput
  }

  export type OrganigramaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganigramaWhereInput | OrganigramaWhereInput[]
    OR?: OrganigramaWhereInput[]
    NOT?: OrganigramaWhereInput | OrganigramaWhereInput[]
    nombre?: StringFilter<"Organigrama"> | string
    descripcion?: StringFilter<"Organigrama"> | string
    fechaCreacion?: DateTimeFilter<"Organigrama"> | Date | string
    updatedAt?: DateTimeFilter<"Organigrama"> | Date | string
    nodos?: NodoOrganigramaListRelationFilter
  }, "id">

  export type OrganigramaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    fechaCreacion?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganigramaCountOrderByAggregateInput
    _max?: OrganigramaMaxOrderByAggregateInput
    _min?: OrganigramaMinOrderByAggregateInput
  }

  export type OrganigramaScalarWhereWithAggregatesInput = {
    AND?: OrganigramaScalarWhereWithAggregatesInput | OrganigramaScalarWhereWithAggregatesInput[]
    OR?: OrganigramaScalarWhereWithAggregatesInput[]
    NOT?: OrganigramaScalarWhereWithAggregatesInput | OrganigramaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organigrama"> | string
    nombre?: StringWithAggregatesFilter<"Organigrama"> | string
    descripcion?: StringWithAggregatesFilter<"Organigrama"> | string
    fechaCreacion?: DateTimeWithAggregatesFilter<"Organigrama"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organigrama"> | Date | string
  }

  export type NodoOrganigramaWhereInput = {
    AND?: NodoOrganigramaWhereInput | NodoOrganigramaWhereInput[]
    OR?: NodoOrganigramaWhereInput[]
    NOT?: NodoOrganigramaWhereInput | NodoOrganigramaWhereInput[]
    id?: StringFilter<"NodoOrganigrama"> | string
    organigramaId?: StringFilter<"NodoOrganigrama"> | string
    nombre?: StringFilter<"NodoOrganigrama"> | string
    cargo?: StringFilter<"NodoOrganigrama"> | string
    departamento?: StringFilter<"NodoOrganigrama"> | string
    email?: StringFilter<"NodoOrganigrama"> | string
    telefono?: StringNullableFilter<"NodoOrganigrama"> | string | null
    foto?: StringNullableFilter<"NodoOrganigrama"> | string | null
    padreId?: StringNullableFilter<"NodoOrganigrama"> | string | null
    organigrama?: XOR<OrganigramaRelationFilter, OrganigramaWhereInput>
    padre?: XOR<NodoOrganigramaNullableRelationFilter, NodoOrganigramaWhereInput> | null
    subordinados?: NodoOrganigramaListRelationFilter
  }

  export type NodoOrganigramaOrderByWithRelationInput = {
    id?: SortOrder
    organigramaId?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    departamento?: SortOrder
    email?: SortOrder
    telefono?: SortOrderInput | SortOrder
    foto?: SortOrderInput | SortOrder
    padreId?: SortOrderInput | SortOrder
    organigrama?: OrganigramaOrderByWithRelationInput
    padre?: NodoOrganigramaOrderByWithRelationInput
    subordinados?: NodoOrganigramaOrderByRelationAggregateInput
  }

  export type NodoOrganigramaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NodoOrganigramaWhereInput | NodoOrganigramaWhereInput[]
    OR?: NodoOrganigramaWhereInput[]
    NOT?: NodoOrganigramaWhereInput | NodoOrganigramaWhereInput[]
    organigramaId?: StringFilter<"NodoOrganigrama"> | string
    nombre?: StringFilter<"NodoOrganigrama"> | string
    cargo?: StringFilter<"NodoOrganigrama"> | string
    departamento?: StringFilter<"NodoOrganigrama"> | string
    email?: StringFilter<"NodoOrganigrama"> | string
    telefono?: StringNullableFilter<"NodoOrganigrama"> | string | null
    foto?: StringNullableFilter<"NodoOrganigrama"> | string | null
    padreId?: StringNullableFilter<"NodoOrganigrama"> | string | null
    organigrama?: XOR<OrganigramaRelationFilter, OrganigramaWhereInput>
    padre?: XOR<NodoOrganigramaNullableRelationFilter, NodoOrganigramaWhereInput> | null
    subordinados?: NodoOrganigramaListRelationFilter
  }, "id">

  export type NodoOrganigramaOrderByWithAggregationInput = {
    id?: SortOrder
    organigramaId?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    departamento?: SortOrder
    email?: SortOrder
    telefono?: SortOrderInput | SortOrder
    foto?: SortOrderInput | SortOrder
    padreId?: SortOrderInput | SortOrder
    _count?: NodoOrganigramaCountOrderByAggregateInput
    _max?: NodoOrganigramaMaxOrderByAggregateInput
    _min?: NodoOrganigramaMinOrderByAggregateInput
  }

  export type NodoOrganigramaScalarWhereWithAggregatesInput = {
    AND?: NodoOrganigramaScalarWhereWithAggregatesInput | NodoOrganigramaScalarWhereWithAggregatesInput[]
    OR?: NodoOrganigramaScalarWhereWithAggregatesInput[]
    NOT?: NodoOrganigramaScalarWhereWithAggregatesInput | NodoOrganigramaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NodoOrganigrama"> | string
    organigramaId?: StringWithAggregatesFilter<"NodoOrganigrama"> | string
    nombre?: StringWithAggregatesFilter<"NodoOrganigrama"> | string
    cargo?: StringWithAggregatesFilter<"NodoOrganigrama"> | string
    departamento?: StringWithAggregatesFilter<"NodoOrganigrama"> | string
    email?: StringWithAggregatesFilter<"NodoOrganigrama"> | string
    telefono?: StringNullableWithAggregatesFilter<"NodoOrganigrama"> | string | null
    foto?: StringNullableWithAggregatesFilter<"NodoOrganigrama"> | string | null
    padreId?: StringNullableWithAggregatesFilter<"NodoOrganigrama"> | string | null
  }

  export type MarcoNormativoWhereInput = {
    AND?: MarcoNormativoWhereInput | MarcoNormativoWhereInput[]
    OR?: MarcoNormativoWhereInput[]
    NOT?: MarcoNormativoWhereInput | MarcoNormativoWhereInput[]
    id?: StringFilter<"MarcoNormativo"> | string
    nombre?: StringFilter<"MarcoNormativo"> | string
    acronimo?: StringFilter<"MarcoNormativo"> | string
    version?: StringFilter<"MarcoNormativo"> | string
    fechaVigencia?: DateTimeFilter<"MarcoNormativo"> | Date | string
    descripcion?: StringFilter<"MarcoNormativo"> | string
    activo?: BoolFilter<"MarcoNormativo"> | boolean
    fechaCreacion?: DateTimeFilter<"MarcoNormativo"> | Date | string
    requisitos?: RequisitoNormativoListRelationFilter
    cuestionarios?: CuestionarioListRelationFilter
  }

  export type MarcoNormativoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    acronimo?: SortOrder
    version?: SortOrder
    fechaVigencia?: SortOrder
    descripcion?: SortOrder
    activo?: SortOrder
    fechaCreacion?: SortOrder
    requisitos?: RequisitoNormativoOrderByRelationAggregateInput
    cuestionarios?: CuestionarioOrderByRelationAggregateInput
  }

  export type MarcoNormativoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarcoNormativoWhereInput | MarcoNormativoWhereInput[]
    OR?: MarcoNormativoWhereInput[]
    NOT?: MarcoNormativoWhereInput | MarcoNormativoWhereInput[]
    nombre?: StringFilter<"MarcoNormativo"> | string
    acronimo?: StringFilter<"MarcoNormativo"> | string
    version?: StringFilter<"MarcoNormativo"> | string
    fechaVigencia?: DateTimeFilter<"MarcoNormativo"> | Date | string
    descripcion?: StringFilter<"MarcoNormativo"> | string
    activo?: BoolFilter<"MarcoNormativo"> | boolean
    fechaCreacion?: DateTimeFilter<"MarcoNormativo"> | Date | string
    requisitos?: RequisitoNormativoListRelationFilter
    cuestionarios?: CuestionarioListRelationFilter
  }, "id">

  export type MarcoNormativoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    acronimo?: SortOrder
    version?: SortOrder
    fechaVigencia?: SortOrder
    descripcion?: SortOrder
    activo?: SortOrder
    fechaCreacion?: SortOrder
    _count?: MarcoNormativoCountOrderByAggregateInput
    _max?: MarcoNormativoMaxOrderByAggregateInput
    _min?: MarcoNormativoMinOrderByAggregateInput
  }

  export type MarcoNormativoScalarWhereWithAggregatesInput = {
    AND?: MarcoNormativoScalarWhereWithAggregatesInput | MarcoNormativoScalarWhereWithAggregatesInput[]
    OR?: MarcoNormativoScalarWhereWithAggregatesInput[]
    NOT?: MarcoNormativoScalarWhereWithAggregatesInput | MarcoNormativoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarcoNormativo"> | string
    nombre?: StringWithAggregatesFilter<"MarcoNormativo"> | string
    acronimo?: StringWithAggregatesFilter<"MarcoNormativo"> | string
    version?: StringWithAggregatesFilter<"MarcoNormativo"> | string
    fechaVigencia?: DateTimeWithAggregatesFilter<"MarcoNormativo"> | Date | string
    descripcion?: StringWithAggregatesFilter<"MarcoNormativo"> | string
    activo?: BoolWithAggregatesFilter<"MarcoNormativo"> | boolean
    fechaCreacion?: DateTimeWithAggregatesFilter<"MarcoNormativo"> | Date | string
  }

  export type RequisitoNormativoWhereInput = {
    AND?: RequisitoNormativoWhereInput | RequisitoNormativoWhereInput[]
    OR?: RequisitoNormativoWhereInput[]
    NOT?: RequisitoNormativoWhereInput | RequisitoNormativoWhereInput[]
    id?: StringFilter<"RequisitoNormativo"> | string
    codigo?: StringFilter<"RequisitoNormativo"> | string
    nombre?: StringFilter<"RequisitoNormativo"> | string
    descripcion?: StringFilter<"RequisitoNormativo"> | string
    marcoId?: StringFilter<"RequisitoNormativo"> | string
    controlesAsociados?: StringFilter<"RequisitoNormativo"> | string
    marco?: XOR<MarcoNormativoRelationFilter, MarcoNormativoWhereInput>
  }

  export type RequisitoNormativoOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    marcoId?: SortOrder
    controlesAsociados?: SortOrder
    marco?: MarcoNormativoOrderByWithRelationInput
  }

  export type RequisitoNormativoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RequisitoNormativoWhereInput | RequisitoNormativoWhereInput[]
    OR?: RequisitoNormativoWhereInput[]
    NOT?: RequisitoNormativoWhereInput | RequisitoNormativoWhereInput[]
    codigo?: StringFilter<"RequisitoNormativo"> | string
    nombre?: StringFilter<"RequisitoNormativo"> | string
    descripcion?: StringFilter<"RequisitoNormativo"> | string
    marcoId?: StringFilter<"RequisitoNormativo"> | string
    controlesAsociados?: StringFilter<"RequisitoNormativo"> | string
    marco?: XOR<MarcoNormativoRelationFilter, MarcoNormativoWhereInput>
  }, "id">

  export type RequisitoNormativoOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    marcoId?: SortOrder
    controlesAsociados?: SortOrder
    _count?: RequisitoNormativoCountOrderByAggregateInput
    _max?: RequisitoNormativoMaxOrderByAggregateInput
    _min?: RequisitoNormativoMinOrderByAggregateInput
  }

  export type RequisitoNormativoScalarWhereWithAggregatesInput = {
    AND?: RequisitoNormativoScalarWhereWithAggregatesInput | RequisitoNormativoScalarWhereWithAggregatesInput[]
    OR?: RequisitoNormativoScalarWhereWithAggregatesInput[]
    NOT?: RequisitoNormativoScalarWhereWithAggregatesInput | RequisitoNormativoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RequisitoNormativo"> | string
    codigo?: StringWithAggregatesFilter<"RequisitoNormativo"> | string
    nombre?: StringWithAggregatesFilter<"RequisitoNormativo"> | string
    descripcion?: StringWithAggregatesFilter<"RequisitoNormativo"> | string
    marcoId?: StringWithAggregatesFilter<"RequisitoNormativo"> | string
    controlesAsociados?: StringWithAggregatesFilter<"RequisitoNormativo"> | string
  }

  export type CuestionarioWhereInput = {
    AND?: CuestionarioWhereInput | CuestionarioWhereInput[]
    OR?: CuestionarioWhereInput[]
    NOT?: CuestionarioWhereInput | CuestionarioWhereInput[]
    id?: StringFilter<"Cuestionario"> | string
    nombre?: StringFilter<"Cuestionario"> | string
    descripcion?: StringFilter<"Cuestionario"> | string
    categoria?: StringFilter<"Cuestionario"> | string
    tipo?: StringFilter<"Cuestionario"> | string
    tipoEvaluacion?: StringFilter<"Cuestionario"> | string
    estado?: StringFilter<"Cuestionario"> | string
    marcoNormativoId?: StringNullableFilter<"Cuestionario"> | string | null
    periodicidad?: StringFilter<"Cuestionario"> | string
    tasaCompletado?: FloatFilter<"Cuestionario"> | number
    fechaCreacion?: DateTimeFilter<"Cuestionario"> | Date | string
    fechaModificacion?: DateTimeFilter<"Cuestionario"> | Date | string
    umbrales?: StringFilter<"Cuestionario"> | string
    areasObjetivo?: StringFilter<"Cuestionario"> | string
    responsables?: StringFilter<"Cuestionario"> | string
    marcoNormativo?: XOR<MarcoNormativoNullableRelationFilter, MarcoNormativoWhereInput> | null
    secciones?: SeccionListRelationFilter
    asignaciones?: AsignacionCuestionarioListRelationFilter
  }

  export type CuestionarioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    categoria?: SortOrder
    tipo?: SortOrder
    tipoEvaluacion?: SortOrder
    estado?: SortOrder
    marcoNormativoId?: SortOrderInput | SortOrder
    periodicidad?: SortOrder
    tasaCompletado?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
    umbrales?: SortOrder
    areasObjetivo?: SortOrder
    responsables?: SortOrder
    marcoNormativo?: MarcoNormativoOrderByWithRelationInput
    secciones?: SeccionOrderByRelationAggregateInput
    asignaciones?: AsignacionCuestionarioOrderByRelationAggregateInput
  }

  export type CuestionarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CuestionarioWhereInput | CuestionarioWhereInput[]
    OR?: CuestionarioWhereInput[]
    NOT?: CuestionarioWhereInput | CuestionarioWhereInput[]
    nombre?: StringFilter<"Cuestionario"> | string
    descripcion?: StringFilter<"Cuestionario"> | string
    categoria?: StringFilter<"Cuestionario"> | string
    tipo?: StringFilter<"Cuestionario"> | string
    tipoEvaluacion?: StringFilter<"Cuestionario"> | string
    estado?: StringFilter<"Cuestionario"> | string
    marcoNormativoId?: StringNullableFilter<"Cuestionario"> | string | null
    periodicidad?: StringFilter<"Cuestionario"> | string
    tasaCompletado?: FloatFilter<"Cuestionario"> | number
    fechaCreacion?: DateTimeFilter<"Cuestionario"> | Date | string
    fechaModificacion?: DateTimeFilter<"Cuestionario"> | Date | string
    umbrales?: StringFilter<"Cuestionario"> | string
    areasObjetivo?: StringFilter<"Cuestionario"> | string
    responsables?: StringFilter<"Cuestionario"> | string
    marcoNormativo?: XOR<MarcoNormativoNullableRelationFilter, MarcoNormativoWhereInput> | null
    secciones?: SeccionListRelationFilter
    asignaciones?: AsignacionCuestionarioListRelationFilter
  }, "id">

  export type CuestionarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    categoria?: SortOrder
    tipo?: SortOrder
    tipoEvaluacion?: SortOrder
    estado?: SortOrder
    marcoNormativoId?: SortOrderInput | SortOrder
    periodicidad?: SortOrder
    tasaCompletado?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
    umbrales?: SortOrder
    areasObjetivo?: SortOrder
    responsables?: SortOrder
    _count?: CuestionarioCountOrderByAggregateInput
    _avg?: CuestionarioAvgOrderByAggregateInput
    _max?: CuestionarioMaxOrderByAggregateInput
    _min?: CuestionarioMinOrderByAggregateInput
    _sum?: CuestionarioSumOrderByAggregateInput
  }

  export type CuestionarioScalarWhereWithAggregatesInput = {
    AND?: CuestionarioScalarWhereWithAggregatesInput | CuestionarioScalarWhereWithAggregatesInput[]
    OR?: CuestionarioScalarWhereWithAggregatesInput[]
    NOT?: CuestionarioScalarWhereWithAggregatesInput | CuestionarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cuestionario"> | string
    nombre?: StringWithAggregatesFilter<"Cuestionario"> | string
    descripcion?: StringWithAggregatesFilter<"Cuestionario"> | string
    categoria?: StringWithAggregatesFilter<"Cuestionario"> | string
    tipo?: StringWithAggregatesFilter<"Cuestionario"> | string
    tipoEvaluacion?: StringWithAggregatesFilter<"Cuestionario"> | string
    estado?: StringWithAggregatesFilter<"Cuestionario"> | string
    marcoNormativoId?: StringNullableWithAggregatesFilter<"Cuestionario"> | string | null
    periodicidad?: StringWithAggregatesFilter<"Cuestionario"> | string
    tasaCompletado?: FloatWithAggregatesFilter<"Cuestionario"> | number
    fechaCreacion?: DateTimeWithAggregatesFilter<"Cuestionario"> | Date | string
    fechaModificacion?: DateTimeWithAggregatesFilter<"Cuestionario"> | Date | string
    umbrales?: StringWithAggregatesFilter<"Cuestionario"> | string
    areasObjetivo?: StringWithAggregatesFilter<"Cuestionario"> | string
    responsables?: StringWithAggregatesFilter<"Cuestionario"> | string
  }

  export type SeccionWhereInput = {
    AND?: SeccionWhereInput | SeccionWhereInput[]
    OR?: SeccionWhereInput[]
    NOT?: SeccionWhereInput | SeccionWhereInput[]
    id?: StringFilter<"Seccion"> | string
    cuestionarioId?: StringFilter<"Seccion"> | string
    nombre?: StringFilter<"Seccion"> | string
    descripcion?: StringFilter<"Seccion"> | string
    peso?: FloatFilter<"Seccion"> | number
    requerida?: BoolFilter<"Seccion"> | boolean
    orden?: IntFilter<"Seccion"> | number
    cuestionario?: XOR<CuestionarioRelationFilter, CuestionarioWhereInput>
    preguntas?: PreguntaListRelationFilter
  }

  export type SeccionOrderByWithRelationInput = {
    id?: SortOrder
    cuestionarioId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    peso?: SortOrder
    requerida?: SortOrder
    orden?: SortOrder
    cuestionario?: CuestionarioOrderByWithRelationInput
    preguntas?: PreguntaOrderByRelationAggregateInput
  }

  export type SeccionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SeccionWhereInput | SeccionWhereInput[]
    OR?: SeccionWhereInput[]
    NOT?: SeccionWhereInput | SeccionWhereInput[]
    cuestionarioId?: StringFilter<"Seccion"> | string
    nombre?: StringFilter<"Seccion"> | string
    descripcion?: StringFilter<"Seccion"> | string
    peso?: FloatFilter<"Seccion"> | number
    requerida?: BoolFilter<"Seccion"> | boolean
    orden?: IntFilter<"Seccion"> | number
    cuestionario?: XOR<CuestionarioRelationFilter, CuestionarioWhereInput>
    preguntas?: PreguntaListRelationFilter
  }, "id">

  export type SeccionOrderByWithAggregationInput = {
    id?: SortOrder
    cuestionarioId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    peso?: SortOrder
    requerida?: SortOrder
    orden?: SortOrder
    _count?: SeccionCountOrderByAggregateInput
    _avg?: SeccionAvgOrderByAggregateInput
    _max?: SeccionMaxOrderByAggregateInput
    _min?: SeccionMinOrderByAggregateInput
    _sum?: SeccionSumOrderByAggregateInput
  }

  export type SeccionScalarWhereWithAggregatesInput = {
    AND?: SeccionScalarWhereWithAggregatesInput | SeccionScalarWhereWithAggregatesInput[]
    OR?: SeccionScalarWhereWithAggregatesInput[]
    NOT?: SeccionScalarWhereWithAggregatesInput | SeccionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Seccion"> | string
    cuestionarioId?: StringWithAggregatesFilter<"Seccion"> | string
    nombre?: StringWithAggregatesFilter<"Seccion"> | string
    descripcion?: StringWithAggregatesFilter<"Seccion"> | string
    peso?: FloatWithAggregatesFilter<"Seccion"> | number
    requerida?: BoolWithAggregatesFilter<"Seccion"> | boolean
    orden?: IntWithAggregatesFilter<"Seccion"> | number
  }

  export type PreguntaWhereInput = {
    AND?: PreguntaWhereInput | PreguntaWhereInput[]
    OR?: PreguntaWhereInput[]
    NOT?: PreguntaWhereInput | PreguntaWhereInput[]
    id?: StringFilter<"Pregunta"> | string
    seccionId?: StringFilter<"Pregunta"> | string
    texto?: StringFilter<"Pregunta"> | string
    tipo?: StringFilter<"Pregunta"> | string
    requerida?: BoolFilter<"Pregunta"> | boolean
    peso?: FloatFilter<"Pregunta"> | number
    opciones?: StringNullableFilter<"Pregunta"> | string | null
    escalaMin?: IntNullableFilter<"Pregunta"> | number | null
    escalaMax?: IntNullableFilter<"Pregunta"> | number | null
    ayuda?: StringNullableFilter<"Pregunta"> | string | null
    placeholder?: StringNullableFilter<"Pregunta"> | string | null
    requisitoNormativoId?: StringNullableFilter<"Pregunta"> | string | null
    controlAsociado?: StringNullableFilter<"Pregunta"> | string | null
    requiereEvidencia?: BoolFilter<"Pregunta"> | boolean
    maxStars?: IntNullableFilter<"Pregunta"> | number | null
    leftAnchor?: StringNullableFilter<"Pregunta"> | string | null
    rightAnchor?: StringNullableFilter<"Pregunta"> | string | null
    likertLabels?: StringNullableFilter<"Pregunta"> | string | null
    displayConditionQuestionId?: StringNullableFilter<"Pregunta"> | string | null
    displayConditionAnswer?: StringNullableFilter<"Pregunta"> | string | null
    logicaCondicional?: StringNullableFilter<"Pregunta"> | string | null
    isCalculated?: BoolFilter<"Pregunta"> | boolean
    formula?: StringNullableFilter<"Pregunta"> | string | null
    orden?: IntFilter<"Pregunta"> | number
    seccion?: XOR<SeccionRelationFilter, SeccionWhereInput>
    respuestas?: RespuestaPreguntaListRelationFilter
    hallazgos?: HallazgoListRelationFilter
  }

  export type PreguntaOrderByWithRelationInput = {
    id?: SortOrder
    seccionId?: SortOrder
    texto?: SortOrder
    tipo?: SortOrder
    requerida?: SortOrder
    peso?: SortOrder
    opciones?: SortOrderInput | SortOrder
    escalaMin?: SortOrderInput | SortOrder
    escalaMax?: SortOrderInput | SortOrder
    ayuda?: SortOrderInput | SortOrder
    placeholder?: SortOrderInput | SortOrder
    requisitoNormativoId?: SortOrderInput | SortOrder
    controlAsociado?: SortOrderInput | SortOrder
    requiereEvidencia?: SortOrder
    maxStars?: SortOrderInput | SortOrder
    leftAnchor?: SortOrderInput | SortOrder
    rightAnchor?: SortOrderInput | SortOrder
    likertLabels?: SortOrderInput | SortOrder
    displayConditionQuestionId?: SortOrderInput | SortOrder
    displayConditionAnswer?: SortOrderInput | SortOrder
    logicaCondicional?: SortOrderInput | SortOrder
    isCalculated?: SortOrder
    formula?: SortOrderInput | SortOrder
    orden?: SortOrder
    seccion?: SeccionOrderByWithRelationInput
    respuestas?: RespuestaPreguntaOrderByRelationAggregateInput
    hallazgos?: HallazgoOrderByRelationAggregateInput
  }

  export type PreguntaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PreguntaWhereInput | PreguntaWhereInput[]
    OR?: PreguntaWhereInput[]
    NOT?: PreguntaWhereInput | PreguntaWhereInput[]
    seccionId?: StringFilter<"Pregunta"> | string
    texto?: StringFilter<"Pregunta"> | string
    tipo?: StringFilter<"Pregunta"> | string
    requerida?: BoolFilter<"Pregunta"> | boolean
    peso?: FloatFilter<"Pregunta"> | number
    opciones?: StringNullableFilter<"Pregunta"> | string | null
    escalaMin?: IntNullableFilter<"Pregunta"> | number | null
    escalaMax?: IntNullableFilter<"Pregunta"> | number | null
    ayuda?: StringNullableFilter<"Pregunta"> | string | null
    placeholder?: StringNullableFilter<"Pregunta"> | string | null
    requisitoNormativoId?: StringNullableFilter<"Pregunta"> | string | null
    controlAsociado?: StringNullableFilter<"Pregunta"> | string | null
    requiereEvidencia?: BoolFilter<"Pregunta"> | boolean
    maxStars?: IntNullableFilter<"Pregunta"> | number | null
    leftAnchor?: StringNullableFilter<"Pregunta"> | string | null
    rightAnchor?: StringNullableFilter<"Pregunta"> | string | null
    likertLabels?: StringNullableFilter<"Pregunta"> | string | null
    displayConditionQuestionId?: StringNullableFilter<"Pregunta"> | string | null
    displayConditionAnswer?: StringNullableFilter<"Pregunta"> | string | null
    logicaCondicional?: StringNullableFilter<"Pregunta"> | string | null
    isCalculated?: BoolFilter<"Pregunta"> | boolean
    formula?: StringNullableFilter<"Pregunta"> | string | null
    orden?: IntFilter<"Pregunta"> | number
    seccion?: XOR<SeccionRelationFilter, SeccionWhereInput>
    respuestas?: RespuestaPreguntaListRelationFilter
    hallazgos?: HallazgoListRelationFilter
  }, "id">

  export type PreguntaOrderByWithAggregationInput = {
    id?: SortOrder
    seccionId?: SortOrder
    texto?: SortOrder
    tipo?: SortOrder
    requerida?: SortOrder
    peso?: SortOrder
    opciones?: SortOrderInput | SortOrder
    escalaMin?: SortOrderInput | SortOrder
    escalaMax?: SortOrderInput | SortOrder
    ayuda?: SortOrderInput | SortOrder
    placeholder?: SortOrderInput | SortOrder
    requisitoNormativoId?: SortOrderInput | SortOrder
    controlAsociado?: SortOrderInput | SortOrder
    requiereEvidencia?: SortOrder
    maxStars?: SortOrderInput | SortOrder
    leftAnchor?: SortOrderInput | SortOrder
    rightAnchor?: SortOrderInput | SortOrder
    likertLabels?: SortOrderInput | SortOrder
    displayConditionQuestionId?: SortOrderInput | SortOrder
    displayConditionAnswer?: SortOrderInput | SortOrder
    logicaCondicional?: SortOrderInput | SortOrder
    isCalculated?: SortOrder
    formula?: SortOrderInput | SortOrder
    orden?: SortOrder
    _count?: PreguntaCountOrderByAggregateInput
    _avg?: PreguntaAvgOrderByAggregateInput
    _max?: PreguntaMaxOrderByAggregateInput
    _min?: PreguntaMinOrderByAggregateInput
    _sum?: PreguntaSumOrderByAggregateInput
  }

  export type PreguntaScalarWhereWithAggregatesInput = {
    AND?: PreguntaScalarWhereWithAggregatesInput | PreguntaScalarWhereWithAggregatesInput[]
    OR?: PreguntaScalarWhereWithAggregatesInput[]
    NOT?: PreguntaScalarWhereWithAggregatesInput | PreguntaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pregunta"> | string
    seccionId?: StringWithAggregatesFilter<"Pregunta"> | string
    texto?: StringWithAggregatesFilter<"Pregunta"> | string
    tipo?: StringWithAggregatesFilter<"Pregunta"> | string
    requerida?: BoolWithAggregatesFilter<"Pregunta"> | boolean
    peso?: FloatWithAggregatesFilter<"Pregunta"> | number
    opciones?: StringNullableWithAggregatesFilter<"Pregunta"> | string | null
    escalaMin?: IntNullableWithAggregatesFilter<"Pregunta"> | number | null
    escalaMax?: IntNullableWithAggregatesFilter<"Pregunta"> | number | null
    ayuda?: StringNullableWithAggregatesFilter<"Pregunta"> | string | null
    placeholder?: StringNullableWithAggregatesFilter<"Pregunta"> | string | null
    requisitoNormativoId?: StringNullableWithAggregatesFilter<"Pregunta"> | string | null
    controlAsociado?: StringNullableWithAggregatesFilter<"Pregunta"> | string | null
    requiereEvidencia?: BoolWithAggregatesFilter<"Pregunta"> | boolean
    maxStars?: IntNullableWithAggregatesFilter<"Pregunta"> | number | null
    leftAnchor?: StringNullableWithAggregatesFilter<"Pregunta"> | string | null
    rightAnchor?: StringNullableWithAggregatesFilter<"Pregunta"> | string | null
    likertLabels?: StringNullableWithAggregatesFilter<"Pregunta"> | string | null
    displayConditionQuestionId?: StringNullableWithAggregatesFilter<"Pregunta"> | string | null
    displayConditionAnswer?: StringNullableWithAggregatesFilter<"Pregunta"> | string | null
    logicaCondicional?: StringNullableWithAggregatesFilter<"Pregunta"> | string | null
    isCalculated?: BoolWithAggregatesFilter<"Pregunta"> | boolean
    formula?: StringNullableWithAggregatesFilter<"Pregunta"> | string | null
    orden?: IntWithAggregatesFilter<"Pregunta"> | number
  }

  export type AsignacionCuestionarioWhereInput = {
    AND?: AsignacionCuestionarioWhereInput | AsignacionCuestionarioWhereInput[]
    OR?: AsignacionCuestionarioWhereInput[]
    NOT?: AsignacionCuestionarioWhereInput | AsignacionCuestionarioWhereInput[]
    id?: StringFilter<"AsignacionCuestionario"> | string
    cuestionarioId?: StringFilter<"AsignacionCuestionario"> | string
    cuestionarioIds?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    titulo?: StringFilter<"AsignacionCuestionario"> | string
    descripcion?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    tipoRevision?: StringFilter<"AsignacionCuestionario"> | string
    usuariosAsignados?: StringFilter<"AsignacionCuestionario"> | string
    usuariosAsignadosNombres?: StringFilter<"AsignacionCuestionario"> | string
    emailsExternos?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    contrasenaAcceso?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    activosObjetivo?: StringFilter<"AsignacionCuestionario"> | string
    activosObjetivoNombres?: StringFilter<"AsignacionCuestionario"> | string
    procesosObjetivo?: StringFilter<"AsignacionCuestionario"> | string
    procesosObjetivoNombres?: StringFilter<"AsignacionCuestionario"> | string
    aprobadores?: StringFilter<"AsignacionCuestionario"> | string
    aprobadoresNombres?: StringFilter<"AsignacionCuestionario"> | string
    evaluadosInternos?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    evaluadosInternosNombres?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    areaId?: StringFilter<"AsignacionCuestionario"> | string
    areaNombre?: StringFilter<"AsignacionCuestionario"> | string
    responsableId?: StringFilter<"AsignacionCuestionario"> | string
    responsableNombre?: StringFilter<"AsignacionCuestionario"> | string
    fechaAsignacion?: DateTimeFilter<"AsignacionCuestionario"> | Date | string
    fechaInicio?: DateTimeFilter<"AsignacionCuestionario"> | Date | string
    fechaVencimiento?: DateTimeFilter<"AsignacionCuestionario"> | Date | string
    estado?: StringFilter<"AsignacionCuestionario"> | string
    progreso?: FloatFilter<"AsignacionCuestionario"> | number
    instrucciones?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    recordatorios?: BoolFilter<"AsignacionCuestionario"> | boolean
    tokenAccesoExterno?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    recurrencia?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    cuestionario?: XOR<CuestionarioRelationFilter, CuestionarioWhereInput>
    evaluadosExternos?: EvaluadoExternoListRelationFilter
    respuestas?: RespuestaCuestionarioListRelationFilter
    mensajesChat?: MensajeChatListRelationFilter
  }

  export type AsignacionCuestionarioOrderByWithRelationInput = {
    id?: SortOrder
    cuestionarioId?: SortOrder
    cuestionarioIds?: SortOrderInput | SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    tipoRevision?: SortOrder
    usuariosAsignados?: SortOrder
    usuariosAsignadosNombres?: SortOrder
    emailsExternos?: SortOrderInput | SortOrder
    contrasenaAcceso?: SortOrderInput | SortOrder
    activosObjetivo?: SortOrder
    activosObjetivoNombres?: SortOrder
    procesosObjetivo?: SortOrder
    procesosObjetivoNombres?: SortOrder
    aprobadores?: SortOrder
    aprobadoresNombres?: SortOrder
    evaluadosInternos?: SortOrderInput | SortOrder
    evaluadosInternosNombres?: SortOrderInput | SortOrder
    areaId?: SortOrder
    areaNombre?: SortOrder
    responsableId?: SortOrder
    responsableNombre?: SortOrder
    fechaAsignacion?: SortOrder
    fechaInicio?: SortOrder
    fechaVencimiento?: SortOrder
    estado?: SortOrder
    progreso?: SortOrder
    instrucciones?: SortOrderInput | SortOrder
    recordatorios?: SortOrder
    tokenAccesoExterno?: SortOrderInput | SortOrder
    recurrencia?: SortOrderInput | SortOrder
    cuestionario?: CuestionarioOrderByWithRelationInput
    evaluadosExternos?: EvaluadoExternoOrderByRelationAggregateInput
    respuestas?: RespuestaCuestionarioOrderByRelationAggregateInput
    mensajesChat?: MensajeChatOrderByRelationAggregateInput
  }

  export type AsignacionCuestionarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AsignacionCuestionarioWhereInput | AsignacionCuestionarioWhereInput[]
    OR?: AsignacionCuestionarioWhereInput[]
    NOT?: AsignacionCuestionarioWhereInput | AsignacionCuestionarioWhereInput[]
    cuestionarioId?: StringFilter<"AsignacionCuestionario"> | string
    cuestionarioIds?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    titulo?: StringFilter<"AsignacionCuestionario"> | string
    descripcion?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    tipoRevision?: StringFilter<"AsignacionCuestionario"> | string
    usuariosAsignados?: StringFilter<"AsignacionCuestionario"> | string
    usuariosAsignadosNombres?: StringFilter<"AsignacionCuestionario"> | string
    emailsExternos?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    contrasenaAcceso?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    activosObjetivo?: StringFilter<"AsignacionCuestionario"> | string
    activosObjetivoNombres?: StringFilter<"AsignacionCuestionario"> | string
    procesosObjetivo?: StringFilter<"AsignacionCuestionario"> | string
    procesosObjetivoNombres?: StringFilter<"AsignacionCuestionario"> | string
    aprobadores?: StringFilter<"AsignacionCuestionario"> | string
    aprobadoresNombres?: StringFilter<"AsignacionCuestionario"> | string
    evaluadosInternos?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    evaluadosInternosNombres?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    areaId?: StringFilter<"AsignacionCuestionario"> | string
    areaNombre?: StringFilter<"AsignacionCuestionario"> | string
    responsableId?: StringFilter<"AsignacionCuestionario"> | string
    responsableNombre?: StringFilter<"AsignacionCuestionario"> | string
    fechaAsignacion?: DateTimeFilter<"AsignacionCuestionario"> | Date | string
    fechaInicio?: DateTimeFilter<"AsignacionCuestionario"> | Date | string
    fechaVencimiento?: DateTimeFilter<"AsignacionCuestionario"> | Date | string
    estado?: StringFilter<"AsignacionCuestionario"> | string
    progreso?: FloatFilter<"AsignacionCuestionario"> | number
    instrucciones?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    recordatorios?: BoolFilter<"AsignacionCuestionario"> | boolean
    tokenAccesoExterno?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    recurrencia?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    cuestionario?: XOR<CuestionarioRelationFilter, CuestionarioWhereInput>
    evaluadosExternos?: EvaluadoExternoListRelationFilter
    respuestas?: RespuestaCuestionarioListRelationFilter
    mensajesChat?: MensajeChatListRelationFilter
  }, "id">

  export type AsignacionCuestionarioOrderByWithAggregationInput = {
    id?: SortOrder
    cuestionarioId?: SortOrder
    cuestionarioIds?: SortOrderInput | SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    tipoRevision?: SortOrder
    usuariosAsignados?: SortOrder
    usuariosAsignadosNombres?: SortOrder
    emailsExternos?: SortOrderInput | SortOrder
    contrasenaAcceso?: SortOrderInput | SortOrder
    activosObjetivo?: SortOrder
    activosObjetivoNombres?: SortOrder
    procesosObjetivo?: SortOrder
    procesosObjetivoNombres?: SortOrder
    aprobadores?: SortOrder
    aprobadoresNombres?: SortOrder
    evaluadosInternos?: SortOrderInput | SortOrder
    evaluadosInternosNombres?: SortOrderInput | SortOrder
    areaId?: SortOrder
    areaNombre?: SortOrder
    responsableId?: SortOrder
    responsableNombre?: SortOrder
    fechaAsignacion?: SortOrder
    fechaInicio?: SortOrder
    fechaVencimiento?: SortOrder
    estado?: SortOrder
    progreso?: SortOrder
    instrucciones?: SortOrderInput | SortOrder
    recordatorios?: SortOrder
    tokenAccesoExterno?: SortOrderInput | SortOrder
    recurrencia?: SortOrderInput | SortOrder
    _count?: AsignacionCuestionarioCountOrderByAggregateInput
    _avg?: AsignacionCuestionarioAvgOrderByAggregateInput
    _max?: AsignacionCuestionarioMaxOrderByAggregateInput
    _min?: AsignacionCuestionarioMinOrderByAggregateInput
    _sum?: AsignacionCuestionarioSumOrderByAggregateInput
  }

  export type AsignacionCuestionarioScalarWhereWithAggregatesInput = {
    AND?: AsignacionCuestionarioScalarWhereWithAggregatesInput | AsignacionCuestionarioScalarWhereWithAggregatesInput[]
    OR?: AsignacionCuestionarioScalarWhereWithAggregatesInput[]
    NOT?: AsignacionCuestionarioScalarWhereWithAggregatesInput | AsignacionCuestionarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    cuestionarioId?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    cuestionarioIds?: StringNullableWithAggregatesFilter<"AsignacionCuestionario"> | string | null
    titulo?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    descripcion?: StringNullableWithAggregatesFilter<"AsignacionCuestionario"> | string | null
    tipoRevision?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    usuariosAsignados?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    usuariosAsignadosNombres?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    emailsExternos?: StringNullableWithAggregatesFilter<"AsignacionCuestionario"> | string | null
    contrasenaAcceso?: StringNullableWithAggregatesFilter<"AsignacionCuestionario"> | string | null
    activosObjetivo?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    activosObjetivoNombres?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    procesosObjetivo?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    procesosObjetivoNombres?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    aprobadores?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    aprobadoresNombres?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    evaluadosInternos?: StringNullableWithAggregatesFilter<"AsignacionCuestionario"> | string | null
    evaluadosInternosNombres?: StringNullableWithAggregatesFilter<"AsignacionCuestionario"> | string | null
    areaId?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    areaNombre?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    responsableId?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    responsableNombre?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    fechaAsignacion?: DateTimeWithAggregatesFilter<"AsignacionCuestionario"> | Date | string
    fechaInicio?: DateTimeWithAggregatesFilter<"AsignacionCuestionario"> | Date | string
    fechaVencimiento?: DateTimeWithAggregatesFilter<"AsignacionCuestionario"> | Date | string
    estado?: StringWithAggregatesFilter<"AsignacionCuestionario"> | string
    progreso?: FloatWithAggregatesFilter<"AsignacionCuestionario"> | number
    instrucciones?: StringNullableWithAggregatesFilter<"AsignacionCuestionario"> | string | null
    recordatorios?: BoolWithAggregatesFilter<"AsignacionCuestionario"> | boolean
    tokenAccesoExterno?: StringNullableWithAggregatesFilter<"AsignacionCuestionario"> | string | null
    recurrencia?: StringNullableWithAggregatesFilter<"AsignacionCuestionario"> | string | null
  }

  export type EvaluadoExternoWhereInput = {
    AND?: EvaluadoExternoWhereInput | EvaluadoExternoWhereInput[]
    OR?: EvaluadoExternoWhereInput[]
    NOT?: EvaluadoExternoWhereInput | EvaluadoExternoWhereInput[]
    id?: StringFilter<"EvaluadoExterno"> | string
    asignacionId?: StringFilter<"EvaluadoExterno"> | string
    nombre?: StringFilter<"EvaluadoExterno"> | string
    email?: StringFilter<"EvaluadoExterno"> | string
    password?: StringNullableFilter<"EvaluadoExterno"> | string | null
    invitacionEnviada?: BoolFilter<"EvaluadoExterno"> | boolean
    fechaInvitacion?: DateTimeNullableFilter<"EvaluadoExterno"> | Date | string | null
    haRespondido?: BoolFilter<"EvaluadoExterno"> | boolean
    fechaRespuesta?: DateTimeNullableFilter<"EvaluadoExterno"> | Date | string | null
    asignacion?: XOR<AsignacionCuestionarioRelationFilter, AsignacionCuestionarioWhereInput>
  }

  export type EvaluadoExternoOrderByWithRelationInput = {
    id?: SortOrder
    asignacionId?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    invitacionEnviada?: SortOrder
    fechaInvitacion?: SortOrderInput | SortOrder
    haRespondido?: SortOrder
    fechaRespuesta?: SortOrderInput | SortOrder
    asignacion?: AsignacionCuestionarioOrderByWithRelationInput
  }

  export type EvaluadoExternoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EvaluadoExternoWhereInput | EvaluadoExternoWhereInput[]
    OR?: EvaluadoExternoWhereInput[]
    NOT?: EvaluadoExternoWhereInput | EvaluadoExternoWhereInput[]
    asignacionId?: StringFilter<"EvaluadoExterno"> | string
    nombre?: StringFilter<"EvaluadoExterno"> | string
    email?: StringFilter<"EvaluadoExterno"> | string
    password?: StringNullableFilter<"EvaluadoExterno"> | string | null
    invitacionEnviada?: BoolFilter<"EvaluadoExterno"> | boolean
    fechaInvitacion?: DateTimeNullableFilter<"EvaluadoExterno"> | Date | string | null
    haRespondido?: BoolFilter<"EvaluadoExterno"> | boolean
    fechaRespuesta?: DateTimeNullableFilter<"EvaluadoExterno"> | Date | string | null
    asignacion?: XOR<AsignacionCuestionarioRelationFilter, AsignacionCuestionarioWhereInput>
  }, "id">

  export type EvaluadoExternoOrderByWithAggregationInput = {
    id?: SortOrder
    asignacionId?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    invitacionEnviada?: SortOrder
    fechaInvitacion?: SortOrderInput | SortOrder
    haRespondido?: SortOrder
    fechaRespuesta?: SortOrderInput | SortOrder
    _count?: EvaluadoExternoCountOrderByAggregateInput
    _max?: EvaluadoExternoMaxOrderByAggregateInput
    _min?: EvaluadoExternoMinOrderByAggregateInput
  }

  export type EvaluadoExternoScalarWhereWithAggregatesInput = {
    AND?: EvaluadoExternoScalarWhereWithAggregatesInput | EvaluadoExternoScalarWhereWithAggregatesInput[]
    OR?: EvaluadoExternoScalarWhereWithAggregatesInput[]
    NOT?: EvaluadoExternoScalarWhereWithAggregatesInput | EvaluadoExternoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvaluadoExterno"> | string
    asignacionId?: StringWithAggregatesFilter<"EvaluadoExterno"> | string
    nombre?: StringWithAggregatesFilter<"EvaluadoExterno"> | string
    email?: StringWithAggregatesFilter<"EvaluadoExterno"> | string
    password?: StringNullableWithAggregatesFilter<"EvaluadoExterno"> | string | null
    invitacionEnviada?: BoolWithAggregatesFilter<"EvaluadoExterno"> | boolean
    fechaInvitacion?: DateTimeNullableWithAggregatesFilter<"EvaluadoExterno"> | Date | string | null
    haRespondido?: BoolWithAggregatesFilter<"EvaluadoExterno"> | boolean
    fechaRespuesta?: DateTimeNullableWithAggregatesFilter<"EvaluadoExterno"> | Date | string | null
  }

  export type RespuestaCuestionarioWhereInput = {
    AND?: RespuestaCuestionarioWhereInput | RespuestaCuestionarioWhereInput[]
    OR?: RespuestaCuestionarioWhereInput[]
    NOT?: RespuestaCuestionarioWhereInput | RespuestaCuestionarioWhereInput[]
    id?: StringFilter<"RespuestaCuestionario"> | string
    asignacionId?: StringFilter<"RespuestaCuestionario"> | string
    cuestionarioId?: StringFilter<"RespuestaCuestionario"> | string
    respondidoPorId?: StringFilter<"RespuestaCuestionario"> | string
    fechaInicio?: DateTimeFilter<"RespuestaCuestionario"> | Date | string
    fechaEnvio?: DateTimeNullableFilter<"RespuestaCuestionario"> | Date | string | null
    estado?: StringFilter<"RespuestaCuestionario"> | string
    puntuacionTotal?: FloatFilter<"RespuestaCuestionario"> | number
    nivelCumplimiento?: StringNullableFilter<"RespuestaCuestionario"> | string | null
    comentariosGenerales?: StringNullableFilter<"RespuestaCuestionario"> | string | null
    asignacion?: XOR<AsignacionCuestionarioRelationFilter, AsignacionCuestionarioWhereInput>
    respondidoPor?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    respuestas?: RespuestaPreguntaListRelationFilter
  }

  export type RespuestaCuestionarioOrderByWithRelationInput = {
    id?: SortOrder
    asignacionId?: SortOrder
    cuestionarioId?: SortOrder
    respondidoPorId?: SortOrder
    fechaInicio?: SortOrder
    fechaEnvio?: SortOrderInput | SortOrder
    estado?: SortOrder
    puntuacionTotal?: SortOrder
    nivelCumplimiento?: SortOrderInput | SortOrder
    comentariosGenerales?: SortOrderInput | SortOrder
    asignacion?: AsignacionCuestionarioOrderByWithRelationInput
    respondidoPor?: UsuarioOrderByWithRelationInput
    respuestas?: RespuestaPreguntaOrderByRelationAggregateInput
  }

  export type RespuestaCuestionarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RespuestaCuestionarioWhereInput | RespuestaCuestionarioWhereInput[]
    OR?: RespuestaCuestionarioWhereInput[]
    NOT?: RespuestaCuestionarioWhereInput | RespuestaCuestionarioWhereInput[]
    asignacionId?: StringFilter<"RespuestaCuestionario"> | string
    cuestionarioId?: StringFilter<"RespuestaCuestionario"> | string
    respondidoPorId?: StringFilter<"RespuestaCuestionario"> | string
    fechaInicio?: DateTimeFilter<"RespuestaCuestionario"> | Date | string
    fechaEnvio?: DateTimeNullableFilter<"RespuestaCuestionario"> | Date | string | null
    estado?: StringFilter<"RespuestaCuestionario"> | string
    puntuacionTotal?: FloatFilter<"RespuestaCuestionario"> | number
    nivelCumplimiento?: StringNullableFilter<"RespuestaCuestionario"> | string | null
    comentariosGenerales?: StringNullableFilter<"RespuestaCuestionario"> | string | null
    asignacion?: XOR<AsignacionCuestionarioRelationFilter, AsignacionCuestionarioWhereInput>
    respondidoPor?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    respuestas?: RespuestaPreguntaListRelationFilter
  }, "id">

  export type RespuestaCuestionarioOrderByWithAggregationInput = {
    id?: SortOrder
    asignacionId?: SortOrder
    cuestionarioId?: SortOrder
    respondidoPorId?: SortOrder
    fechaInicio?: SortOrder
    fechaEnvio?: SortOrderInput | SortOrder
    estado?: SortOrder
    puntuacionTotal?: SortOrder
    nivelCumplimiento?: SortOrderInput | SortOrder
    comentariosGenerales?: SortOrderInput | SortOrder
    _count?: RespuestaCuestionarioCountOrderByAggregateInput
    _avg?: RespuestaCuestionarioAvgOrderByAggregateInput
    _max?: RespuestaCuestionarioMaxOrderByAggregateInput
    _min?: RespuestaCuestionarioMinOrderByAggregateInput
    _sum?: RespuestaCuestionarioSumOrderByAggregateInput
  }

  export type RespuestaCuestionarioScalarWhereWithAggregatesInput = {
    AND?: RespuestaCuestionarioScalarWhereWithAggregatesInput | RespuestaCuestionarioScalarWhereWithAggregatesInput[]
    OR?: RespuestaCuestionarioScalarWhereWithAggregatesInput[]
    NOT?: RespuestaCuestionarioScalarWhereWithAggregatesInput | RespuestaCuestionarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RespuestaCuestionario"> | string
    asignacionId?: StringWithAggregatesFilter<"RespuestaCuestionario"> | string
    cuestionarioId?: StringWithAggregatesFilter<"RespuestaCuestionario"> | string
    respondidoPorId?: StringWithAggregatesFilter<"RespuestaCuestionario"> | string
    fechaInicio?: DateTimeWithAggregatesFilter<"RespuestaCuestionario"> | Date | string
    fechaEnvio?: DateTimeNullableWithAggregatesFilter<"RespuestaCuestionario"> | Date | string | null
    estado?: StringWithAggregatesFilter<"RespuestaCuestionario"> | string
    puntuacionTotal?: FloatWithAggregatesFilter<"RespuestaCuestionario"> | number
    nivelCumplimiento?: StringNullableWithAggregatesFilter<"RespuestaCuestionario"> | string | null
    comentariosGenerales?: StringNullableWithAggregatesFilter<"RespuestaCuestionario"> | string | null
  }

  export type RespuestaPreguntaWhereInput = {
    AND?: RespuestaPreguntaWhereInput | RespuestaPreguntaWhereInput[]
    OR?: RespuestaPreguntaWhereInput[]
    NOT?: RespuestaPreguntaWhereInput | RespuestaPreguntaWhereInput[]
    id?: StringFilter<"RespuestaPregunta"> | string
    respuestaCuestionarioId?: StringFilter<"RespuestaPregunta"> | string
    preguntaId?: StringFilter<"RespuestaPregunta"> | string
    valor?: StringNullableFilter<"RespuestaPregunta"> | string | null
    comentario?: StringNullableFilter<"RespuestaPregunta"> | string | null
    archivosAdjuntos?: StringNullableFilter<"RespuestaPregunta"> | string | null
    marcadaParaRevision?: BoolFilter<"RespuestaPregunta"> | boolean
    estadoRevision?: StringFilter<"RespuestaPregunta"> | string
    comentarioRevisor?: StringNullableFilter<"RespuestaPregunta"> | string | null
    respuestaCuestionario?: XOR<RespuestaCuestionarioRelationFilter, RespuestaCuestionarioWhereInput>
    pregunta?: XOR<PreguntaRelationFilter, PreguntaWhereInput>
    evidencias?: EvidenciaListRelationFilter
  }

  export type RespuestaPreguntaOrderByWithRelationInput = {
    id?: SortOrder
    respuestaCuestionarioId?: SortOrder
    preguntaId?: SortOrder
    valor?: SortOrderInput | SortOrder
    comentario?: SortOrderInput | SortOrder
    archivosAdjuntos?: SortOrderInput | SortOrder
    marcadaParaRevision?: SortOrder
    estadoRevision?: SortOrder
    comentarioRevisor?: SortOrderInput | SortOrder
    respuestaCuestionario?: RespuestaCuestionarioOrderByWithRelationInput
    pregunta?: PreguntaOrderByWithRelationInput
    evidencias?: EvidenciaOrderByRelationAggregateInput
  }

  export type RespuestaPreguntaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RespuestaPreguntaWhereInput | RespuestaPreguntaWhereInput[]
    OR?: RespuestaPreguntaWhereInput[]
    NOT?: RespuestaPreguntaWhereInput | RespuestaPreguntaWhereInput[]
    respuestaCuestionarioId?: StringFilter<"RespuestaPregunta"> | string
    preguntaId?: StringFilter<"RespuestaPregunta"> | string
    valor?: StringNullableFilter<"RespuestaPregunta"> | string | null
    comentario?: StringNullableFilter<"RespuestaPregunta"> | string | null
    archivosAdjuntos?: StringNullableFilter<"RespuestaPregunta"> | string | null
    marcadaParaRevision?: BoolFilter<"RespuestaPregunta"> | boolean
    estadoRevision?: StringFilter<"RespuestaPregunta"> | string
    comentarioRevisor?: StringNullableFilter<"RespuestaPregunta"> | string | null
    respuestaCuestionario?: XOR<RespuestaCuestionarioRelationFilter, RespuestaCuestionarioWhereInput>
    pregunta?: XOR<PreguntaRelationFilter, PreguntaWhereInput>
    evidencias?: EvidenciaListRelationFilter
  }, "id">

  export type RespuestaPreguntaOrderByWithAggregationInput = {
    id?: SortOrder
    respuestaCuestionarioId?: SortOrder
    preguntaId?: SortOrder
    valor?: SortOrderInput | SortOrder
    comentario?: SortOrderInput | SortOrder
    archivosAdjuntos?: SortOrderInput | SortOrder
    marcadaParaRevision?: SortOrder
    estadoRevision?: SortOrder
    comentarioRevisor?: SortOrderInput | SortOrder
    _count?: RespuestaPreguntaCountOrderByAggregateInput
    _max?: RespuestaPreguntaMaxOrderByAggregateInput
    _min?: RespuestaPreguntaMinOrderByAggregateInput
  }

  export type RespuestaPreguntaScalarWhereWithAggregatesInput = {
    AND?: RespuestaPreguntaScalarWhereWithAggregatesInput | RespuestaPreguntaScalarWhereWithAggregatesInput[]
    OR?: RespuestaPreguntaScalarWhereWithAggregatesInput[]
    NOT?: RespuestaPreguntaScalarWhereWithAggregatesInput | RespuestaPreguntaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RespuestaPregunta"> | string
    respuestaCuestionarioId?: StringWithAggregatesFilter<"RespuestaPregunta"> | string
    preguntaId?: StringWithAggregatesFilter<"RespuestaPregunta"> | string
    valor?: StringNullableWithAggregatesFilter<"RespuestaPregunta"> | string | null
    comentario?: StringNullableWithAggregatesFilter<"RespuestaPregunta"> | string | null
    archivosAdjuntos?: StringNullableWithAggregatesFilter<"RespuestaPregunta"> | string | null
    marcadaParaRevision?: BoolWithAggregatesFilter<"RespuestaPregunta"> | boolean
    estadoRevision?: StringWithAggregatesFilter<"RespuestaPregunta"> | string
    comentarioRevisor?: StringNullableWithAggregatesFilter<"RespuestaPregunta"> | string | null
  }

  export type EvidenciaWhereInput = {
    AND?: EvidenciaWhereInput | EvidenciaWhereInput[]
    OR?: EvidenciaWhereInput[]
    NOT?: EvidenciaWhereInput | EvidenciaWhereInput[]
    id?: StringFilter<"Evidencia"> | string
    respuestaPreguntaId?: StringFilter<"Evidencia"> | string
    nombre?: StringFilter<"Evidencia"> | string
    tipo?: StringFilter<"Evidencia"> | string
    tamano?: IntFilter<"Evidencia"> | number
    fechaCarga?: DateTimeFilter<"Evidencia"> | Date | string
    url?: StringFilter<"Evidencia"> | string
    descripcion?: StringNullableFilter<"Evidencia"> | string | null
    vigencia?: DateTimeNullableFilter<"Evidencia"> | Date | string | null
    estado?: StringFilter<"Evidencia"> | string
    respuestaPregunta?: XOR<RespuestaPreguntaRelationFilter, RespuestaPreguntaWhereInput>
  }

  export type EvidenciaOrderByWithRelationInput = {
    id?: SortOrder
    respuestaPreguntaId?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    tamano?: SortOrder
    fechaCarga?: SortOrder
    url?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    vigencia?: SortOrderInput | SortOrder
    estado?: SortOrder
    respuestaPregunta?: RespuestaPreguntaOrderByWithRelationInput
  }

  export type EvidenciaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EvidenciaWhereInput | EvidenciaWhereInput[]
    OR?: EvidenciaWhereInput[]
    NOT?: EvidenciaWhereInput | EvidenciaWhereInput[]
    respuestaPreguntaId?: StringFilter<"Evidencia"> | string
    nombre?: StringFilter<"Evidencia"> | string
    tipo?: StringFilter<"Evidencia"> | string
    tamano?: IntFilter<"Evidencia"> | number
    fechaCarga?: DateTimeFilter<"Evidencia"> | Date | string
    url?: StringFilter<"Evidencia"> | string
    descripcion?: StringNullableFilter<"Evidencia"> | string | null
    vigencia?: DateTimeNullableFilter<"Evidencia"> | Date | string | null
    estado?: StringFilter<"Evidencia"> | string
    respuestaPregunta?: XOR<RespuestaPreguntaRelationFilter, RespuestaPreguntaWhereInput>
  }, "id">

  export type EvidenciaOrderByWithAggregationInput = {
    id?: SortOrder
    respuestaPreguntaId?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    tamano?: SortOrder
    fechaCarga?: SortOrder
    url?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    vigencia?: SortOrderInput | SortOrder
    estado?: SortOrder
    _count?: EvidenciaCountOrderByAggregateInput
    _avg?: EvidenciaAvgOrderByAggregateInput
    _max?: EvidenciaMaxOrderByAggregateInput
    _min?: EvidenciaMinOrderByAggregateInput
    _sum?: EvidenciaSumOrderByAggregateInput
  }

  export type EvidenciaScalarWhereWithAggregatesInput = {
    AND?: EvidenciaScalarWhereWithAggregatesInput | EvidenciaScalarWhereWithAggregatesInput[]
    OR?: EvidenciaScalarWhereWithAggregatesInput[]
    NOT?: EvidenciaScalarWhereWithAggregatesInput | EvidenciaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Evidencia"> | string
    respuestaPreguntaId?: StringWithAggregatesFilter<"Evidencia"> | string
    nombre?: StringWithAggregatesFilter<"Evidencia"> | string
    tipo?: StringWithAggregatesFilter<"Evidencia"> | string
    tamano?: IntWithAggregatesFilter<"Evidencia"> | number
    fechaCarga?: DateTimeWithAggregatesFilter<"Evidencia"> | Date | string
    url?: StringWithAggregatesFilter<"Evidencia"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Evidencia"> | string | null
    vigencia?: DateTimeNullableWithAggregatesFilter<"Evidencia"> | Date | string | null
    estado?: StringWithAggregatesFilter<"Evidencia"> | string
  }

  export type HallazgoWhereInput = {
    AND?: HallazgoWhereInput | HallazgoWhereInput[]
    OR?: HallazgoWhereInput[]
    NOT?: HallazgoWhereInput | HallazgoWhereInput[]
    id?: StringFilter<"Hallazgo"> | string
    preguntaId?: StringFilter<"Hallazgo"> | string
    tipo?: StringFilter<"Hallazgo"> | string
    descripcion?: StringFilter<"Hallazgo"> | string
    requisitoNormativo?: StringNullableFilter<"Hallazgo"> | string | null
    accionCorrectiva?: StringNullableFilter<"Hallazgo"> | string | null
    responsable?: StringFilter<"Hallazgo"> | string
    fechaLimite?: DateTimeNullableFilter<"Hallazgo"> | Date | string | null
    estado?: StringFilter<"Hallazgo"> | string
    fechaCreacion?: DateTimeFilter<"Hallazgo"> | Date | string
    pregunta?: XOR<PreguntaRelationFilter, PreguntaWhereInput>
  }

  export type HallazgoOrderByWithRelationInput = {
    id?: SortOrder
    preguntaId?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    requisitoNormativo?: SortOrderInput | SortOrder
    accionCorrectiva?: SortOrderInput | SortOrder
    responsable?: SortOrder
    fechaLimite?: SortOrderInput | SortOrder
    estado?: SortOrder
    fechaCreacion?: SortOrder
    pregunta?: PreguntaOrderByWithRelationInput
  }

  export type HallazgoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HallazgoWhereInput | HallazgoWhereInput[]
    OR?: HallazgoWhereInput[]
    NOT?: HallazgoWhereInput | HallazgoWhereInput[]
    preguntaId?: StringFilter<"Hallazgo"> | string
    tipo?: StringFilter<"Hallazgo"> | string
    descripcion?: StringFilter<"Hallazgo"> | string
    requisitoNormativo?: StringNullableFilter<"Hallazgo"> | string | null
    accionCorrectiva?: StringNullableFilter<"Hallazgo"> | string | null
    responsable?: StringFilter<"Hallazgo"> | string
    fechaLimite?: DateTimeNullableFilter<"Hallazgo"> | Date | string | null
    estado?: StringFilter<"Hallazgo"> | string
    fechaCreacion?: DateTimeFilter<"Hallazgo"> | Date | string
    pregunta?: XOR<PreguntaRelationFilter, PreguntaWhereInput>
  }, "id">

  export type HallazgoOrderByWithAggregationInput = {
    id?: SortOrder
    preguntaId?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    requisitoNormativo?: SortOrderInput | SortOrder
    accionCorrectiva?: SortOrderInput | SortOrder
    responsable?: SortOrder
    fechaLimite?: SortOrderInput | SortOrder
    estado?: SortOrder
    fechaCreacion?: SortOrder
    _count?: HallazgoCountOrderByAggregateInput
    _max?: HallazgoMaxOrderByAggregateInput
    _min?: HallazgoMinOrderByAggregateInput
  }

  export type HallazgoScalarWhereWithAggregatesInput = {
    AND?: HallazgoScalarWhereWithAggregatesInput | HallazgoScalarWhereWithAggregatesInput[]
    OR?: HallazgoScalarWhereWithAggregatesInput[]
    NOT?: HallazgoScalarWhereWithAggregatesInput | HallazgoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Hallazgo"> | string
    preguntaId?: StringWithAggregatesFilter<"Hallazgo"> | string
    tipo?: StringWithAggregatesFilter<"Hallazgo"> | string
    descripcion?: StringWithAggregatesFilter<"Hallazgo"> | string
    requisitoNormativo?: StringNullableWithAggregatesFilter<"Hallazgo"> | string | null
    accionCorrectiva?: StringNullableWithAggregatesFilter<"Hallazgo"> | string | null
    responsable?: StringWithAggregatesFilter<"Hallazgo"> | string
    fechaLimite?: DateTimeNullableWithAggregatesFilter<"Hallazgo"> | Date | string | null
    estado?: StringWithAggregatesFilter<"Hallazgo"> | string
    fechaCreacion?: DateTimeWithAggregatesFilter<"Hallazgo"> | Date | string
  }

  export type MensajeChatWhereInput = {
    AND?: MensajeChatWhereInput | MensajeChatWhereInput[]
    OR?: MensajeChatWhereInput[]
    NOT?: MensajeChatWhereInput | MensajeChatWhereInput[]
    id?: StringFilter<"MensajeChat"> | string
    asignacionId?: StringFilter<"MensajeChat"> | string
    cuestionarioId?: StringNullableFilter<"MensajeChat"> | string | null
    activoProcesoId?: StringNullableFilter<"MensajeChat"> | string | null
    usuarioId?: StringFilter<"MensajeChat"> | string
    usuarioNombre?: StringFilter<"MensajeChat"> | string
    usuarioRol?: StringFilter<"MensajeChat"> | string
    mensaje?: StringFilter<"MensajeChat"> | string
    fecha?: DateTimeFilter<"MensajeChat"> | Date | string
    leido?: BoolFilter<"MensajeChat"> | boolean
    asignacion?: XOR<AsignacionCuestionarioRelationFilter, AsignacionCuestionarioWhereInput>
  }

  export type MensajeChatOrderByWithRelationInput = {
    id?: SortOrder
    asignacionId?: SortOrder
    cuestionarioId?: SortOrderInput | SortOrder
    activoProcesoId?: SortOrderInput | SortOrder
    usuarioId?: SortOrder
    usuarioNombre?: SortOrder
    usuarioRol?: SortOrder
    mensaje?: SortOrder
    fecha?: SortOrder
    leido?: SortOrder
    asignacion?: AsignacionCuestionarioOrderByWithRelationInput
  }

  export type MensajeChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MensajeChatWhereInput | MensajeChatWhereInput[]
    OR?: MensajeChatWhereInput[]
    NOT?: MensajeChatWhereInput | MensajeChatWhereInput[]
    asignacionId?: StringFilter<"MensajeChat"> | string
    cuestionarioId?: StringNullableFilter<"MensajeChat"> | string | null
    activoProcesoId?: StringNullableFilter<"MensajeChat"> | string | null
    usuarioId?: StringFilter<"MensajeChat"> | string
    usuarioNombre?: StringFilter<"MensajeChat"> | string
    usuarioRol?: StringFilter<"MensajeChat"> | string
    mensaje?: StringFilter<"MensajeChat"> | string
    fecha?: DateTimeFilter<"MensajeChat"> | Date | string
    leido?: BoolFilter<"MensajeChat"> | boolean
    asignacion?: XOR<AsignacionCuestionarioRelationFilter, AsignacionCuestionarioWhereInput>
  }, "id">

  export type MensajeChatOrderByWithAggregationInput = {
    id?: SortOrder
    asignacionId?: SortOrder
    cuestionarioId?: SortOrderInput | SortOrder
    activoProcesoId?: SortOrderInput | SortOrder
    usuarioId?: SortOrder
    usuarioNombre?: SortOrder
    usuarioRol?: SortOrder
    mensaje?: SortOrder
    fecha?: SortOrder
    leido?: SortOrder
    _count?: MensajeChatCountOrderByAggregateInput
    _max?: MensajeChatMaxOrderByAggregateInput
    _min?: MensajeChatMinOrderByAggregateInput
  }

  export type MensajeChatScalarWhereWithAggregatesInput = {
    AND?: MensajeChatScalarWhereWithAggregatesInput | MensajeChatScalarWhereWithAggregatesInput[]
    OR?: MensajeChatScalarWhereWithAggregatesInput[]
    NOT?: MensajeChatScalarWhereWithAggregatesInput | MensajeChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MensajeChat"> | string
    asignacionId?: StringWithAggregatesFilter<"MensajeChat"> | string
    cuestionarioId?: StringNullableWithAggregatesFilter<"MensajeChat"> | string | null
    activoProcesoId?: StringNullableWithAggregatesFilter<"MensajeChat"> | string | null
    usuarioId?: StringWithAggregatesFilter<"MensajeChat"> | string
    usuarioNombre?: StringWithAggregatesFilter<"MensajeChat"> | string
    usuarioRol?: StringWithAggregatesFilter<"MensajeChat"> | string
    mensaje?: StringWithAggregatesFilter<"MensajeChat"> | string
    fecha?: DateTimeWithAggregatesFilter<"MensajeChat"> | Date | string
    leido?: BoolWithAggregatesFilter<"MensajeChat"> | boolean
  }

  export type AlertaCumplimientoWhereInput = {
    AND?: AlertaCumplimientoWhereInput | AlertaCumplimientoWhereInput[]
    OR?: AlertaCumplimientoWhereInput[]
    NOT?: AlertaCumplimientoWhereInput | AlertaCumplimientoWhereInput[]
    id?: StringFilter<"AlertaCumplimiento"> | string
    tipo?: StringFilter<"AlertaCumplimiento"> | string
    severidad?: StringFilter<"AlertaCumplimiento"> | string
    titulo?: StringFilter<"AlertaCumplimiento"> | string
    descripcion?: StringFilter<"AlertaCumplimiento"> | string
    entidadId?: StringFilter<"AlertaCumplimiento"> | string
    entidadTipo?: StringFilter<"AlertaCumplimiento"> | string
    fechaGeneracion?: DateTimeFilter<"AlertaCumplimiento"> | Date | string
    estado?: StringFilter<"AlertaCumplimiento"> | string
    responsable?: StringNullableFilter<"AlertaCumplimiento"> | string | null
    marcoNormativo?: StringNullableFilter<"AlertaCumplimiento"> | string | null
  }

  export type AlertaCumplimientoOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    severidad?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    entidadId?: SortOrder
    entidadTipo?: SortOrder
    fechaGeneracion?: SortOrder
    estado?: SortOrder
    responsable?: SortOrderInput | SortOrder
    marcoNormativo?: SortOrderInput | SortOrder
  }

  export type AlertaCumplimientoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertaCumplimientoWhereInput | AlertaCumplimientoWhereInput[]
    OR?: AlertaCumplimientoWhereInput[]
    NOT?: AlertaCumplimientoWhereInput | AlertaCumplimientoWhereInput[]
    tipo?: StringFilter<"AlertaCumplimiento"> | string
    severidad?: StringFilter<"AlertaCumplimiento"> | string
    titulo?: StringFilter<"AlertaCumplimiento"> | string
    descripcion?: StringFilter<"AlertaCumplimiento"> | string
    entidadId?: StringFilter<"AlertaCumplimiento"> | string
    entidadTipo?: StringFilter<"AlertaCumplimiento"> | string
    fechaGeneracion?: DateTimeFilter<"AlertaCumplimiento"> | Date | string
    estado?: StringFilter<"AlertaCumplimiento"> | string
    responsable?: StringNullableFilter<"AlertaCumplimiento"> | string | null
    marcoNormativo?: StringNullableFilter<"AlertaCumplimiento"> | string | null
  }, "id">

  export type AlertaCumplimientoOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    severidad?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    entidadId?: SortOrder
    entidadTipo?: SortOrder
    fechaGeneracion?: SortOrder
    estado?: SortOrder
    responsable?: SortOrderInput | SortOrder
    marcoNormativo?: SortOrderInput | SortOrder
    _count?: AlertaCumplimientoCountOrderByAggregateInput
    _max?: AlertaCumplimientoMaxOrderByAggregateInput
    _min?: AlertaCumplimientoMinOrderByAggregateInput
  }

  export type AlertaCumplimientoScalarWhereWithAggregatesInput = {
    AND?: AlertaCumplimientoScalarWhereWithAggregatesInput | AlertaCumplimientoScalarWhereWithAggregatesInput[]
    OR?: AlertaCumplimientoScalarWhereWithAggregatesInput[]
    NOT?: AlertaCumplimientoScalarWhereWithAggregatesInput | AlertaCumplimientoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AlertaCumplimiento"> | string
    tipo?: StringWithAggregatesFilter<"AlertaCumplimiento"> | string
    severidad?: StringWithAggregatesFilter<"AlertaCumplimiento"> | string
    titulo?: StringWithAggregatesFilter<"AlertaCumplimiento"> | string
    descripcion?: StringWithAggregatesFilter<"AlertaCumplimiento"> | string
    entidadId?: StringWithAggregatesFilter<"AlertaCumplimiento"> | string
    entidadTipo?: StringWithAggregatesFilter<"AlertaCumplimiento"> | string
    fechaGeneracion?: DateTimeWithAggregatesFilter<"AlertaCumplimiento"> | Date | string
    estado?: StringWithAggregatesFilter<"AlertaCumplimiento"> | string
    responsable?: StringNullableWithAggregatesFilter<"AlertaCumplimiento"> | string | null
    marcoNormativo?: StringNullableWithAggregatesFilter<"AlertaCumplimiento"> | string | null
  }

  export type ProcesoWhereInput = {
    AND?: ProcesoWhereInput | ProcesoWhereInput[]
    OR?: ProcesoWhereInput[]
    NOT?: ProcesoWhereInput | ProcesoWhereInput[]
    id?: StringFilter<"Proceso"> | string
    nombre?: StringFilter<"Proceso"> | string
    descripcion?: StringFilter<"Proceso"> | string
    version?: StringFilter<"Proceso"> | string
    estado?: StringFilter<"Proceso"> | string
    createdAt?: DateTimeFilter<"Proceso"> | Date | string
    updatedAt?: DateTimeFilter<"Proceso"> | Date | string
    createdBy?: StringFilter<"Proceso"> | string
    nodos?: ProcessNodeListRelationFilter
    edges?: ProcessEdgeListRelationFilter
    objetivos?: ObjetivoProcesoListRelationFilter
    kpis?: KpiProcesoListRelationFilter
  }

  export type ProcesoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    version?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    nodos?: ProcessNodeOrderByRelationAggregateInput
    edges?: ProcessEdgeOrderByRelationAggregateInput
    objetivos?: ObjetivoProcesoOrderByRelationAggregateInput
    kpis?: KpiProcesoOrderByRelationAggregateInput
  }

  export type ProcesoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcesoWhereInput | ProcesoWhereInput[]
    OR?: ProcesoWhereInput[]
    NOT?: ProcesoWhereInput | ProcesoWhereInput[]
    nombre?: StringFilter<"Proceso"> | string
    descripcion?: StringFilter<"Proceso"> | string
    version?: StringFilter<"Proceso"> | string
    estado?: StringFilter<"Proceso"> | string
    createdAt?: DateTimeFilter<"Proceso"> | Date | string
    updatedAt?: DateTimeFilter<"Proceso"> | Date | string
    createdBy?: StringFilter<"Proceso"> | string
    nodos?: ProcessNodeListRelationFilter
    edges?: ProcessEdgeListRelationFilter
    objetivos?: ObjetivoProcesoListRelationFilter
    kpis?: KpiProcesoListRelationFilter
  }, "id">

  export type ProcesoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    version?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    _count?: ProcesoCountOrderByAggregateInput
    _max?: ProcesoMaxOrderByAggregateInput
    _min?: ProcesoMinOrderByAggregateInput
  }

  export type ProcesoScalarWhereWithAggregatesInput = {
    AND?: ProcesoScalarWhereWithAggregatesInput | ProcesoScalarWhereWithAggregatesInput[]
    OR?: ProcesoScalarWhereWithAggregatesInput[]
    NOT?: ProcesoScalarWhereWithAggregatesInput | ProcesoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Proceso"> | string
    nombre?: StringWithAggregatesFilter<"Proceso"> | string
    descripcion?: StringWithAggregatesFilter<"Proceso"> | string
    version?: StringWithAggregatesFilter<"Proceso"> | string
    estado?: StringWithAggregatesFilter<"Proceso"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Proceso"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Proceso"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Proceso"> | string
  }

  export type ProcessNodeWhereInput = {
    AND?: ProcessNodeWhereInput | ProcessNodeWhereInput[]
    OR?: ProcessNodeWhereInput[]
    NOT?: ProcessNodeWhereInput | ProcessNodeWhereInput[]
    id?: StringFilter<"ProcessNode"> | string
    procesoId?: StringFilter<"ProcessNode"> | string
    type?: StringFilter<"ProcessNode"> | string
    label?: StringFilter<"ProcessNode"> | string
    descripcion?: StringNullableFilter<"ProcessNode"> | string | null
    config?: StringFilter<"ProcessNode"> | string
    positionX?: FloatFilter<"ProcessNode"> | number
    positionY?: FloatFilter<"ProcessNode"> | number
    proceso?: XOR<ProcesoRelationFilter, ProcesoWhereInput>
    edgesFrom?: ProcessEdgeListRelationFilter
    edgesTo?: ProcessEdgeListRelationFilter
    kpiHistorico?: KpiHistoricoListRelationFilter
  }

  export type ProcessNodeOrderByWithRelationInput = {
    id?: SortOrder
    procesoId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    config?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    proceso?: ProcesoOrderByWithRelationInput
    edgesFrom?: ProcessEdgeOrderByRelationAggregateInput
    edgesTo?: ProcessEdgeOrderByRelationAggregateInput
    kpiHistorico?: KpiHistoricoOrderByRelationAggregateInput
  }

  export type ProcessNodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcessNodeWhereInput | ProcessNodeWhereInput[]
    OR?: ProcessNodeWhereInput[]
    NOT?: ProcessNodeWhereInput | ProcessNodeWhereInput[]
    procesoId?: StringFilter<"ProcessNode"> | string
    type?: StringFilter<"ProcessNode"> | string
    label?: StringFilter<"ProcessNode"> | string
    descripcion?: StringNullableFilter<"ProcessNode"> | string | null
    config?: StringFilter<"ProcessNode"> | string
    positionX?: FloatFilter<"ProcessNode"> | number
    positionY?: FloatFilter<"ProcessNode"> | number
    proceso?: XOR<ProcesoRelationFilter, ProcesoWhereInput>
    edgesFrom?: ProcessEdgeListRelationFilter
    edgesTo?: ProcessEdgeListRelationFilter
    kpiHistorico?: KpiHistoricoListRelationFilter
  }, "id">

  export type ProcessNodeOrderByWithAggregationInput = {
    id?: SortOrder
    procesoId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    config?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    _count?: ProcessNodeCountOrderByAggregateInput
    _avg?: ProcessNodeAvgOrderByAggregateInput
    _max?: ProcessNodeMaxOrderByAggregateInput
    _min?: ProcessNodeMinOrderByAggregateInput
    _sum?: ProcessNodeSumOrderByAggregateInput
  }

  export type ProcessNodeScalarWhereWithAggregatesInput = {
    AND?: ProcessNodeScalarWhereWithAggregatesInput | ProcessNodeScalarWhereWithAggregatesInput[]
    OR?: ProcessNodeScalarWhereWithAggregatesInput[]
    NOT?: ProcessNodeScalarWhereWithAggregatesInput | ProcessNodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProcessNode"> | string
    procesoId?: StringWithAggregatesFilter<"ProcessNode"> | string
    type?: StringWithAggregatesFilter<"ProcessNode"> | string
    label?: StringWithAggregatesFilter<"ProcessNode"> | string
    descripcion?: StringNullableWithAggregatesFilter<"ProcessNode"> | string | null
    config?: StringWithAggregatesFilter<"ProcessNode"> | string
    positionX?: FloatWithAggregatesFilter<"ProcessNode"> | number
    positionY?: FloatWithAggregatesFilter<"ProcessNode"> | number
  }

  export type ProcessEdgeWhereInput = {
    AND?: ProcessEdgeWhereInput | ProcessEdgeWhereInput[]
    OR?: ProcessEdgeWhereInput[]
    NOT?: ProcessEdgeWhereInput | ProcessEdgeWhereInput[]
    id?: StringFilter<"ProcessEdge"> | string
    procesoId?: StringFilter<"ProcessEdge"> | string
    sourceNodeId?: StringFilter<"ProcessEdge"> | string
    targetNodeId?: StringFilter<"ProcessEdge"> | string
    sourceHandle?: StringNullableFilter<"ProcessEdge"> | string | null
    targetHandle?: StringNullableFilter<"ProcessEdge"> | string | null
    label?: StringNullableFilter<"ProcessEdge"> | string | null
    proceso?: XOR<ProcesoRelationFilter, ProcesoWhereInput>
    sourceNode?: XOR<ProcessNodeRelationFilter, ProcessNodeWhereInput>
    targetNode?: XOR<ProcessNodeRelationFilter, ProcessNodeWhereInput>
  }

  export type ProcessEdgeOrderByWithRelationInput = {
    id?: SortOrder
    procesoId?: SortOrder
    sourceNodeId?: SortOrder
    targetNodeId?: SortOrder
    sourceHandle?: SortOrderInput | SortOrder
    targetHandle?: SortOrderInput | SortOrder
    label?: SortOrderInput | SortOrder
    proceso?: ProcesoOrderByWithRelationInput
    sourceNode?: ProcessNodeOrderByWithRelationInput
    targetNode?: ProcessNodeOrderByWithRelationInput
  }

  export type ProcessEdgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcessEdgeWhereInput | ProcessEdgeWhereInput[]
    OR?: ProcessEdgeWhereInput[]
    NOT?: ProcessEdgeWhereInput | ProcessEdgeWhereInput[]
    procesoId?: StringFilter<"ProcessEdge"> | string
    sourceNodeId?: StringFilter<"ProcessEdge"> | string
    targetNodeId?: StringFilter<"ProcessEdge"> | string
    sourceHandle?: StringNullableFilter<"ProcessEdge"> | string | null
    targetHandle?: StringNullableFilter<"ProcessEdge"> | string | null
    label?: StringNullableFilter<"ProcessEdge"> | string | null
    proceso?: XOR<ProcesoRelationFilter, ProcesoWhereInput>
    sourceNode?: XOR<ProcessNodeRelationFilter, ProcessNodeWhereInput>
    targetNode?: XOR<ProcessNodeRelationFilter, ProcessNodeWhereInput>
  }, "id">

  export type ProcessEdgeOrderByWithAggregationInput = {
    id?: SortOrder
    procesoId?: SortOrder
    sourceNodeId?: SortOrder
    targetNodeId?: SortOrder
    sourceHandle?: SortOrderInput | SortOrder
    targetHandle?: SortOrderInput | SortOrder
    label?: SortOrderInput | SortOrder
    _count?: ProcessEdgeCountOrderByAggregateInput
    _max?: ProcessEdgeMaxOrderByAggregateInput
    _min?: ProcessEdgeMinOrderByAggregateInput
  }

  export type ProcessEdgeScalarWhereWithAggregatesInput = {
    AND?: ProcessEdgeScalarWhereWithAggregatesInput | ProcessEdgeScalarWhereWithAggregatesInput[]
    OR?: ProcessEdgeScalarWhereWithAggregatesInput[]
    NOT?: ProcessEdgeScalarWhereWithAggregatesInput | ProcessEdgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProcessEdge"> | string
    procesoId?: StringWithAggregatesFilter<"ProcessEdge"> | string
    sourceNodeId?: StringWithAggregatesFilter<"ProcessEdge"> | string
    targetNodeId?: StringWithAggregatesFilter<"ProcessEdge"> | string
    sourceHandle?: StringNullableWithAggregatesFilter<"ProcessEdge"> | string | null
    targetHandle?: StringNullableWithAggregatesFilter<"ProcessEdge"> | string | null
    label?: StringNullableWithAggregatesFilter<"ProcessEdge"> | string | null
  }

  export type ObjetivoProcesoWhereInput = {
    AND?: ObjetivoProcesoWhereInput | ObjetivoProcesoWhereInput[]
    OR?: ObjetivoProcesoWhereInput[]
    NOT?: ObjetivoProcesoWhereInput | ObjetivoProcesoWhereInput[]
    id?: StringFilter<"ObjetivoProceso"> | string
    procesoId?: StringFilter<"ObjetivoProceso"> | string
    nombre?: StringFilter<"ObjetivoProceso"> | string
    descripcion?: StringFilter<"ObjetivoProceso"> | string
    tipo?: StringFilter<"ObjetivoProceso"> | string
    progreso?: FloatFilter<"ObjetivoProceso"> | number
    proceso?: XOR<ProcesoRelationFilter, ProcesoWhereInput>
    kpis?: KpiProcesoListRelationFilter
  }

  export type ObjetivoProcesoOrderByWithRelationInput = {
    id?: SortOrder
    procesoId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    progreso?: SortOrder
    proceso?: ProcesoOrderByWithRelationInput
    kpis?: KpiProcesoOrderByRelationAggregateInput
  }

  export type ObjetivoProcesoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ObjetivoProcesoWhereInput | ObjetivoProcesoWhereInput[]
    OR?: ObjetivoProcesoWhereInput[]
    NOT?: ObjetivoProcesoWhereInput | ObjetivoProcesoWhereInput[]
    procesoId?: StringFilter<"ObjetivoProceso"> | string
    nombre?: StringFilter<"ObjetivoProceso"> | string
    descripcion?: StringFilter<"ObjetivoProceso"> | string
    tipo?: StringFilter<"ObjetivoProceso"> | string
    progreso?: FloatFilter<"ObjetivoProceso"> | number
    proceso?: XOR<ProcesoRelationFilter, ProcesoWhereInput>
    kpis?: KpiProcesoListRelationFilter
  }, "id">

  export type ObjetivoProcesoOrderByWithAggregationInput = {
    id?: SortOrder
    procesoId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    progreso?: SortOrder
    _count?: ObjetivoProcesoCountOrderByAggregateInput
    _avg?: ObjetivoProcesoAvgOrderByAggregateInput
    _max?: ObjetivoProcesoMaxOrderByAggregateInput
    _min?: ObjetivoProcesoMinOrderByAggregateInput
    _sum?: ObjetivoProcesoSumOrderByAggregateInput
  }

  export type ObjetivoProcesoScalarWhereWithAggregatesInput = {
    AND?: ObjetivoProcesoScalarWhereWithAggregatesInput | ObjetivoProcesoScalarWhereWithAggregatesInput[]
    OR?: ObjetivoProcesoScalarWhereWithAggregatesInput[]
    NOT?: ObjetivoProcesoScalarWhereWithAggregatesInput | ObjetivoProcesoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ObjetivoProceso"> | string
    procesoId?: StringWithAggregatesFilter<"ObjetivoProceso"> | string
    nombre?: StringWithAggregatesFilter<"ObjetivoProceso"> | string
    descripcion?: StringWithAggregatesFilter<"ObjetivoProceso"> | string
    tipo?: StringWithAggregatesFilter<"ObjetivoProceso"> | string
    progreso?: FloatWithAggregatesFilter<"ObjetivoProceso"> | number
  }

  export type KpiProcesoWhereInput = {
    AND?: KpiProcesoWhereInput | KpiProcesoWhereInput[]
    OR?: KpiProcesoWhereInput[]
    NOT?: KpiProcesoWhereInput | KpiProcesoWhereInput[]
    id?: StringFilter<"KpiProceso"> | string
    procesoId?: StringFilter<"KpiProceso"> | string
    objetivoId?: StringNullableFilter<"KpiProceso"> | string | null
    nombre?: StringFilter<"KpiProceso"> | string
    descripcion?: StringNullableFilter<"KpiProceso"> | string | null
    unidad?: StringFilter<"KpiProceso"> | string
    meta?: FloatFilter<"KpiProceso"> | number
    valorActual?: FloatFilter<"KpiProceso"> | number
    fechaUltimaActualizacion?: DateTimeNullableFilter<"KpiProceso"> | Date | string | null
    alertaAdvertencia?: FloatNullableFilter<"KpiProceso"> | number | null
    alertaCritico?: FloatNullableFilter<"KpiProceso"> | number | null
    alertaDireccion?: StringFilter<"KpiProceso"> | string
    proceso?: XOR<ProcesoRelationFilter, ProcesoWhereInput>
    objetivo?: XOR<ObjetivoProcesoNullableRelationFilter, ObjetivoProcesoWhereInput> | null
    historico?: KpiHistoricoListRelationFilter
  }

  export type KpiProcesoOrderByWithRelationInput = {
    id?: SortOrder
    procesoId?: SortOrder
    objetivoId?: SortOrderInput | SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    unidad?: SortOrder
    meta?: SortOrder
    valorActual?: SortOrder
    fechaUltimaActualizacion?: SortOrderInput | SortOrder
    alertaAdvertencia?: SortOrderInput | SortOrder
    alertaCritico?: SortOrderInput | SortOrder
    alertaDireccion?: SortOrder
    proceso?: ProcesoOrderByWithRelationInput
    objetivo?: ObjetivoProcesoOrderByWithRelationInput
    historico?: KpiHistoricoOrderByRelationAggregateInput
  }

  export type KpiProcesoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KpiProcesoWhereInput | KpiProcesoWhereInput[]
    OR?: KpiProcesoWhereInput[]
    NOT?: KpiProcesoWhereInput | KpiProcesoWhereInput[]
    procesoId?: StringFilter<"KpiProceso"> | string
    objetivoId?: StringNullableFilter<"KpiProceso"> | string | null
    nombre?: StringFilter<"KpiProceso"> | string
    descripcion?: StringNullableFilter<"KpiProceso"> | string | null
    unidad?: StringFilter<"KpiProceso"> | string
    meta?: FloatFilter<"KpiProceso"> | number
    valorActual?: FloatFilter<"KpiProceso"> | number
    fechaUltimaActualizacion?: DateTimeNullableFilter<"KpiProceso"> | Date | string | null
    alertaAdvertencia?: FloatNullableFilter<"KpiProceso"> | number | null
    alertaCritico?: FloatNullableFilter<"KpiProceso"> | number | null
    alertaDireccion?: StringFilter<"KpiProceso"> | string
    proceso?: XOR<ProcesoRelationFilter, ProcesoWhereInput>
    objetivo?: XOR<ObjetivoProcesoNullableRelationFilter, ObjetivoProcesoWhereInput> | null
    historico?: KpiHistoricoListRelationFilter
  }, "id">

  export type KpiProcesoOrderByWithAggregationInput = {
    id?: SortOrder
    procesoId?: SortOrder
    objetivoId?: SortOrderInput | SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    unidad?: SortOrder
    meta?: SortOrder
    valorActual?: SortOrder
    fechaUltimaActualizacion?: SortOrderInput | SortOrder
    alertaAdvertencia?: SortOrderInput | SortOrder
    alertaCritico?: SortOrderInput | SortOrder
    alertaDireccion?: SortOrder
    _count?: KpiProcesoCountOrderByAggregateInput
    _avg?: KpiProcesoAvgOrderByAggregateInput
    _max?: KpiProcesoMaxOrderByAggregateInput
    _min?: KpiProcesoMinOrderByAggregateInput
    _sum?: KpiProcesoSumOrderByAggregateInput
  }

  export type KpiProcesoScalarWhereWithAggregatesInput = {
    AND?: KpiProcesoScalarWhereWithAggregatesInput | KpiProcesoScalarWhereWithAggregatesInput[]
    OR?: KpiProcesoScalarWhereWithAggregatesInput[]
    NOT?: KpiProcesoScalarWhereWithAggregatesInput | KpiProcesoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KpiProceso"> | string
    procesoId?: StringWithAggregatesFilter<"KpiProceso"> | string
    objetivoId?: StringNullableWithAggregatesFilter<"KpiProceso"> | string | null
    nombre?: StringWithAggregatesFilter<"KpiProceso"> | string
    descripcion?: StringNullableWithAggregatesFilter<"KpiProceso"> | string | null
    unidad?: StringWithAggregatesFilter<"KpiProceso"> | string
    meta?: FloatWithAggregatesFilter<"KpiProceso"> | number
    valorActual?: FloatWithAggregatesFilter<"KpiProceso"> | number
    fechaUltimaActualizacion?: DateTimeNullableWithAggregatesFilter<"KpiProceso"> | Date | string | null
    alertaAdvertencia?: FloatNullableWithAggregatesFilter<"KpiProceso"> | number | null
    alertaCritico?: FloatNullableWithAggregatesFilter<"KpiProceso"> | number | null
    alertaDireccion?: StringWithAggregatesFilter<"KpiProceso"> | string
  }

  export type KpiHistoricoWhereInput = {
    AND?: KpiHistoricoWhereInput | KpiHistoricoWhereInput[]
    OR?: KpiHistoricoWhereInput[]
    NOT?: KpiHistoricoWhereInput | KpiHistoricoWhereInput[]
    id?: StringFilter<"KpiHistorico"> | string
    kpiId?: StringFilter<"KpiHistorico"> | string
    valor?: FloatFilter<"KpiHistorico"> | number
    timestamp?: DateTimeFilter<"KpiHistorico"> | Date | string
    procesoId?: StringFilter<"KpiHistorico"> | string
    nodoId?: StringNullableFilter<"KpiHistorico"> | string | null
    metadatos?: StringNullableFilter<"KpiHistorico"> | string | null
    kpi?: XOR<KpiProcesoRelationFilter, KpiProcesoWhereInput>
    nodo?: XOR<ProcessNodeNullableRelationFilter, ProcessNodeWhereInput> | null
  }

  export type KpiHistoricoOrderByWithRelationInput = {
    id?: SortOrder
    kpiId?: SortOrder
    valor?: SortOrder
    timestamp?: SortOrder
    procesoId?: SortOrder
    nodoId?: SortOrderInput | SortOrder
    metadatos?: SortOrderInput | SortOrder
    kpi?: KpiProcesoOrderByWithRelationInput
    nodo?: ProcessNodeOrderByWithRelationInput
  }

  export type KpiHistoricoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KpiHistoricoWhereInput | KpiHistoricoWhereInput[]
    OR?: KpiHistoricoWhereInput[]
    NOT?: KpiHistoricoWhereInput | KpiHistoricoWhereInput[]
    kpiId?: StringFilter<"KpiHistorico"> | string
    valor?: FloatFilter<"KpiHistorico"> | number
    timestamp?: DateTimeFilter<"KpiHistorico"> | Date | string
    procesoId?: StringFilter<"KpiHistorico"> | string
    nodoId?: StringNullableFilter<"KpiHistorico"> | string | null
    metadatos?: StringNullableFilter<"KpiHistorico"> | string | null
    kpi?: XOR<KpiProcesoRelationFilter, KpiProcesoWhereInput>
    nodo?: XOR<ProcessNodeNullableRelationFilter, ProcessNodeWhereInput> | null
  }, "id">

  export type KpiHistoricoOrderByWithAggregationInput = {
    id?: SortOrder
    kpiId?: SortOrder
    valor?: SortOrder
    timestamp?: SortOrder
    procesoId?: SortOrder
    nodoId?: SortOrderInput | SortOrder
    metadatos?: SortOrderInput | SortOrder
    _count?: KpiHistoricoCountOrderByAggregateInput
    _avg?: KpiHistoricoAvgOrderByAggregateInput
    _max?: KpiHistoricoMaxOrderByAggregateInput
    _min?: KpiHistoricoMinOrderByAggregateInput
    _sum?: KpiHistoricoSumOrderByAggregateInput
  }

  export type KpiHistoricoScalarWhereWithAggregatesInput = {
    AND?: KpiHistoricoScalarWhereWithAggregatesInput | KpiHistoricoScalarWhereWithAggregatesInput[]
    OR?: KpiHistoricoScalarWhereWithAggregatesInput[]
    NOT?: KpiHistoricoScalarWhereWithAggregatesInput | KpiHistoricoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KpiHistorico"> | string
    kpiId?: StringWithAggregatesFilter<"KpiHistorico"> | string
    valor?: FloatWithAggregatesFilter<"KpiHistorico"> | number
    timestamp?: DateTimeWithAggregatesFilter<"KpiHistorico"> | Date | string
    procesoId?: StringWithAggregatesFilter<"KpiHistorico"> | string
    nodoId?: StringNullableWithAggregatesFilter<"KpiHistorico"> | string | null
    metadatos?: StringNullableWithAggregatesFilter<"KpiHistorico"> | string | null
  }

  export type DashboardConfigWhereInput = {
    AND?: DashboardConfigWhereInput | DashboardConfigWhereInput[]
    OR?: DashboardConfigWhereInput[]
    NOT?: DashboardConfigWhereInput | DashboardConfigWhereInput[]
    id?: StringFilter<"DashboardConfig"> | string
    nombre?: StringFilter<"DashboardConfig"> | string
    descripcion?: StringNullableFilter<"DashboardConfig"> | string | null
    isDefault?: BoolFilter<"DashboardConfig"> | boolean
    isLocked?: BoolFilter<"DashboardConfig"> | boolean
    columns?: IntFilter<"DashboardConfig"> | number
    rowHeight?: IntFilter<"DashboardConfig"> | number
    gap?: IntFilter<"DashboardConfig"> | number
    createdAt?: DateTimeFilter<"DashboardConfig"> | Date | string
    updatedAt?: DateTimeFilter<"DashboardConfig"> | Date | string
    createdBy?: StringNullableFilter<"DashboardConfig"> | string | null
    widgets?: DashboardWidgetListRelationFilter
  }

  export type DashboardConfigOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isLocked?: SortOrder
    columns?: SortOrder
    rowHeight?: SortOrder
    gap?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    widgets?: DashboardWidgetOrderByRelationAggregateInput
  }

  export type DashboardConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DashboardConfigWhereInput | DashboardConfigWhereInput[]
    OR?: DashboardConfigWhereInput[]
    NOT?: DashboardConfigWhereInput | DashboardConfigWhereInput[]
    nombre?: StringFilter<"DashboardConfig"> | string
    descripcion?: StringNullableFilter<"DashboardConfig"> | string | null
    isDefault?: BoolFilter<"DashboardConfig"> | boolean
    isLocked?: BoolFilter<"DashboardConfig"> | boolean
    columns?: IntFilter<"DashboardConfig"> | number
    rowHeight?: IntFilter<"DashboardConfig"> | number
    gap?: IntFilter<"DashboardConfig"> | number
    createdAt?: DateTimeFilter<"DashboardConfig"> | Date | string
    updatedAt?: DateTimeFilter<"DashboardConfig"> | Date | string
    createdBy?: StringNullableFilter<"DashboardConfig"> | string | null
    widgets?: DashboardWidgetListRelationFilter
  }, "id">

  export type DashboardConfigOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isLocked?: SortOrder
    columns?: SortOrder
    rowHeight?: SortOrder
    gap?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: DashboardConfigCountOrderByAggregateInput
    _avg?: DashboardConfigAvgOrderByAggregateInput
    _max?: DashboardConfigMaxOrderByAggregateInput
    _min?: DashboardConfigMinOrderByAggregateInput
    _sum?: DashboardConfigSumOrderByAggregateInput
  }

  export type DashboardConfigScalarWhereWithAggregatesInput = {
    AND?: DashboardConfigScalarWhereWithAggregatesInput | DashboardConfigScalarWhereWithAggregatesInput[]
    OR?: DashboardConfigScalarWhereWithAggregatesInput[]
    NOT?: DashboardConfigScalarWhereWithAggregatesInput | DashboardConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DashboardConfig"> | string
    nombre?: StringWithAggregatesFilter<"DashboardConfig"> | string
    descripcion?: StringNullableWithAggregatesFilter<"DashboardConfig"> | string | null
    isDefault?: BoolWithAggregatesFilter<"DashboardConfig"> | boolean
    isLocked?: BoolWithAggregatesFilter<"DashboardConfig"> | boolean
    columns?: IntWithAggregatesFilter<"DashboardConfig"> | number
    rowHeight?: IntWithAggregatesFilter<"DashboardConfig"> | number
    gap?: IntWithAggregatesFilter<"DashboardConfig"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DashboardConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DashboardConfig"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"DashboardConfig"> | string | null
  }

  export type DashboardWidgetWhereInput = {
    AND?: DashboardWidgetWhereInput | DashboardWidgetWhereInput[]
    OR?: DashboardWidgetWhereInput[]
    NOT?: DashboardWidgetWhereInput | DashboardWidgetWhereInput[]
    id?: StringFilter<"DashboardWidget"> | string
    dashboardId?: StringFilter<"DashboardWidget"> | string
    tipo?: StringFilter<"DashboardWidget"> | string
    titulo?: StringFilter<"DashboardWidget"> | string
    subtitulo?: StringNullableFilter<"DashboardWidget"> | string | null
    icono?: StringNullableFilter<"DashboardWidget"> | string | null
    config?: StringFilter<"DashboardWidget"> | string
    x?: IntFilter<"DashboardWidget"> | number
    y?: IntFilter<"DashboardWidget"> | number
    cols?: IntFilter<"DashboardWidget"> | number
    rows?: IntFilter<"DashboardWidget"> | number
    canResize?: BoolFilter<"DashboardWidget"> | boolean
    canDrag?: BoolFilter<"DashboardWidget"> | boolean
    canRemove?: BoolFilter<"DashboardWidget"> | boolean
    canEdit?: BoolFilter<"DashboardWidget"> | boolean
    createdAt?: DateTimeFilter<"DashboardWidget"> | Date | string
    updatedAt?: DateTimeFilter<"DashboardWidget"> | Date | string
    dashboard?: XOR<DashboardConfigRelationFilter, DashboardConfigWhereInput>
  }

  export type DashboardWidgetOrderByWithRelationInput = {
    id?: SortOrder
    dashboardId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    subtitulo?: SortOrderInput | SortOrder
    icono?: SortOrderInput | SortOrder
    config?: SortOrder
    x?: SortOrder
    y?: SortOrder
    cols?: SortOrder
    rows?: SortOrder
    canResize?: SortOrder
    canDrag?: SortOrder
    canRemove?: SortOrder
    canEdit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dashboard?: DashboardConfigOrderByWithRelationInput
  }

  export type DashboardWidgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DashboardWidgetWhereInput | DashboardWidgetWhereInput[]
    OR?: DashboardWidgetWhereInput[]
    NOT?: DashboardWidgetWhereInput | DashboardWidgetWhereInput[]
    dashboardId?: StringFilter<"DashboardWidget"> | string
    tipo?: StringFilter<"DashboardWidget"> | string
    titulo?: StringFilter<"DashboardWidget"> | string
    subtitulo?: StringNullableFilter<"DashboardWidget"> | string | null
    icono?: StringNullableFilter<"DashboardWidget"> | string | null
    config?: StringFilter<"DashboardWidget"> | string
    x?: IntFilter<"DashboardWidget"> | number
    y?: IntFilter<"DashboardWidget"> | number
    cols?: IntFilter<"DashboardWidget"> | number
    rows?: IntFilter<"DashboardWidget"> | number
    canResize?: BoolFilter<"DashboardWidget"> | boolean
    canDrag?: BoolFilter<"DashboardWidget"> | boolean
    canRemove?: BoolFilter<"DashboardWidget"> | boolean
    canEdit?: BoolFilter<"DashboardWidget"> | boolean
    createdAt?: DateTimeFilter<"DashboardWidget"> | Date | string
    updatedAt?: DateTimeFilter<"DashboardWidget"> | Date | string
    dashboard?: XOR<DashboardConfigRelationFilter, DashboardConfigWhereInput>
  }, "id">

  export type DashboardWidgetOrderByWithAggregationInput = {
    id?: SortOrder
    dashboardId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    subtitulo?: SortOrderInput | SortOrder
    icono?: SortOrderInput | SortOrder
    config?: SortOrder
    x?: SortOrder
    y?: SortOrder
    cols?: SortOrder
    rows?: SortOrder
    canResize?: SortOrder
    canDrag?: SortOrder
    canRemove?: SortOrder
    canEdit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DashboardWidgetCountOrderByAggregateInput
    _avg?: DashboardWidgetAvgOrderByAggregateInput
    _max?: DashboardWidgetMaxOrderByAggregateInput
    _min?: DashboardWidgetMinOrderByAggregateInput
    _sum?: DashboardWidgetSumOrderByAggregateInput
  }

  export type DashboardWidgetScalarWhereWithAggregatesInput = {
    AND?: DashboardWidgetScalarWhereWithAggregatesInput | DashboardWidgetScalarWhereWithAggregatesInput[]
    OR?: DashboardWidgetScalarWhereWithAggregatesInput[]
    NOT?: DashboardWidgetScalarWhereWithAggregatesInput | DashboardWidgetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DashboardWidget"> | string
    dashboardId?: StringWithAggregatesFilter<"DashboardWidget"> | string
    tipo?: StringWithAggregatesFilter<"DashboardWidget"> | string
    titulo?: StringWithAggregatesFilter<"DashboardWidget"> | string
    subtitulo?: StringNullableWithAggregatesFilter<"DashboardWidget"> | string | null
    icono?: StringNullableWithAggregatesFilter<"DashboardWidget"> | string | null
    config?: StringWithAggregatesFilter<"DashboardWidget"> | string
    x?: IntWithAggregatesFilter<"DashboardWidget"> | number
    y?: IntWithAggregatesFilter<"DashboardWidget"> | number
    cols?: IntWithAggregatesFilter<"DashboardWidget"> | number
    rows?: IntWithAggregatesFilter<"DashboardWidget"> | number
    canResize?: BoolWithAggregatesFilter<"DashboardWidget"> | boolean
    canDrag?: BoolWithAggregatesFilter<"DashboardWidget"> | boolean
    canRemove?: BoolWithAggregatesFilter<"DashboardWidget"> | boolean
    canEdit?: BoolWithAggregatesFilter<"DashboardWidget"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DashboardWidget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DashboardWidget"> | Date | string
  }

  export type CatalogoWhereInput = {
    AND?: CatalogoWhereInput | CatalogoWhereInput[]
    OR?: CatalogoWhereInput[]
    NOT?: CatalogoWhereInput | CatalogoWhereInput[]
    id?: StringFilter<"Catalogo"> | string
    tipo?: StringFilter<"Catalogo"> | string
    codigo?: StringFilter<"Catalogo"> | string
    nombre?: StringFilter<"Catalogo"> | string
    descripcion?: StringNullableFilter<"Catalogo"> | string | null
    orden?: IntFilter<"Catalogo"> | number
    activo?: BoolFilter<"Catalogo"> | boolean
    color?: StringNullableFilter<"Catalogo"> | string | null
    icono?: StringNullableFilter<"Catalogo"> | string | null
    metadata?: StringNullableFilter<"Catalogo"> | string | null
  }

  export type CatalogoOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    orden?: SortOrder
    activo?: SortOrder
    color?: SortOrderInput | SortOrder
    icono?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type CatalogoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tipo_codigo?: CatalogoTipoCodigoCompoundUniqueInput
    AND?: CatalogoWhereInput | CatalogoWhereInput[]
    OR?: CatalogoWhereInput[]
    NOT?: CatalogoWhereInput | CatalogoWhereInput[]
    tipo?: StringFilter<"Catalogo"> | string
    codigo?: StringFilter<"Catalogo"> | string
    nombre?: StringFilter<"Catalogo"> | string
    descripcion?: StringNullableFilter<"Catalogo"> | string | null
    orden?: IntFilter<"Catalogo"> | number
    activo?: BoolFilter<"Catalogo"> | boolean
    color?: StringNullableFilter<"Catalogo"> | string | null
    icono?: StringNullableFilter<"Catalogo"> | string | null
    metadata?: StringNullableFilter<"Catalogo"> | string | null
  }, "id" | "tipo_codigo">

  export type CatalogoOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    orden?: SortOrder
    activo?: SortOrder
    color?: SortOrderInput | SortOrder
    icono?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: CatalogoCountOrderByAggregateInput
    _avg?: CatalogoAvgOrderByAggregateInput
    _max?: CatalogoMaxOrderByAggregateInput
    _min?: CatalogoMinOrderByAggregateInput
    _sum?: CatalogoSumOrderByAggregateInput
  }

  export type CatalogoScalarWhereWithAggregatesInput = {
    AND?: CatalogoScalarWhereWithAggregatesInput | CatalogoScalarWhereWithAggregatesInput[]
    OR?: CatalogoScalarWhereWithAggregatesInput[]
    NOT?: CatalogoScalarWhereWithAggregatesInput | CatalogoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Catalogo"> | string
    tipo?: StringWithAggregatesFilter<"Catalogo"> | string
    codigo?: StringWithAggregatesFilter<"Catalogo"> | string
    nombre?: StringWithAggregatesFilter<"Catalogo"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Catalogo"> | string | null
    orden?: IntWithAggregatesFilter<"Catalogo"> | number
    activo?: BoolWithAggregatesFilter<"Catalogo"> | boolean
    color?: StringNullableWithAggregatesFilter<"Catalogo"> | string | null
    icono?: StringNullableWithAggregatesFilter<"Catalogo"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"Catalogo"> | string | null
  }

  export type NotificationRuleWhereInput = {
    AND?: NotificationRuleWhereInput | NotificationRuleWhereInput[]
    OR?: NotificationRuleWhereInput[]
    NOT?: NotificationRuleWhereInput | NotificationRuleWhereInput[]
    id?: StringFilter<"NotificationRule"> | string
    nombre?: StringFilter<"NotificationRule"> | string
    descripcion?: StringNullableFilter<"NotificationRule"> | string | null
    entidadTipo?: StringFilter<"NotificationRule"> | string
    eventoTipo?: StringFilter<"NotificationRule"> | string
    activo?: BoolFilter<"NotificationRule"> | boolean
    notificarCreador?: BoolFilter<"NotificationRule"> | boolean
    notificarResponsable?: BoolFilter<"NotificationRule"> | boolean
    notificarAprobadores?: BoolFilter<"NotificationRule"> | boolean
    rolesDestino?: StringNullableFilter<"NotificationRule"> | string | null
    usuariosDestino?: StringNullableFilter<"NotificationRule"> | string | null
    enviarInApp?: BoolFilter<"NotificationRule"> | boolean
    enviarEmail?: BoolFilter<"NotificationRule"> | boolean
    plantillaMensaje?: StringNullableFilter<"NotificationRule"> | string | null
    severidad?: StringFilter<"NotificationRule"> | string
    fechaCreacion?: DateTimeFilter<"NotificationRule"> | Date | string
    fechaModificacion?: DateTimeFilter<"NotificationRule"> | Date | string
  }

  export type NotificationRuleOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    entidadTipo?: SortOrder
    eventoTipo?: SortOrder
    activo?: SortOrder
    notificarCreador?: SortOrder
    notificarResponsable?: SortOrder
    notificarAprobadores?: SortOrder
    rolesDestino?: SortOrderInput | SortOrder
    usuariosDestino?: SortOrderInput | SortOrder
    enviarInApp?: SortOrder
    enviarEmail?: SortOrder
    plantillaMensaje?: SortOrderInput | SortOrder
    severidad?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type NotificationRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationRuleWhereInput | NotificationRuleWhereInput[]
    OR?: NotificationRuleWhereInput[]
    NOT?: NotificationRuleWhereInput | NotificationRuleWhereInput[]
    nombre?: StringFilter<"NotificationRule"> | string
    descripcion?: StringNullableFilter<"NotificationRule"> | string | null
    entidadTipo?: StringFilter<"NotificationRule"> | string
    eventoTipo?: StringFilter<"NotificationRule"> | string
    activo?: BoolFilter<"NotificationRule"> | boolean
    notificarCreador?: BoolFilter<"NotificationRule"> | boolean
    notificarResponsable?: BoolFilter<"NotificationRule"> | boolean
    notificarAprobadores?: BoolFilter<"NotificationRule"> | boolean
    rolesDestino?: StringNullableFilter<"NotificationRule"> | string | null
    usuariosDestino?: StringNullableFilter<"NotificationRule"> | string | null
    enviarInApp?: BoolFilter<"NotificationRule"> | boolean
    enviarEmail?: BoolFilter<"NotificationRule"> | boolean
    plantillaMensaje?: StringNullableFilter<"NotificationRule"> | string | null
    severidad?: StringFilter<"NotificationRule"> | string
    fechaCreacion?: DateTimeFilter<"NotificationRule"> | Date | string
    fechaModificacion?: DateTimeFilter<"NotificationRule"> | Date | string
  }, "id">

  export type NotificationRuleOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    entidadTipo?: SortOrder
    eventoTipo?: SortOrder
    activo?: SortOrder
    notificarCreador?: SortOrder
    notificarResponsable?: SortOrder
    notificarAprobadores?: SortOrder
    rolesDestino?: SortOrderInput | SortOrder
    usuariosDestino?: SortOrderInput | SortOrder
    enviarInApp?: SortOrder
    enviarEmail?: SortOrder
    plantillaMensaje?: SortOrderInput | SortOrder
    severidad?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
    _count?: NotificationRuleCountOrderByAggregateInput
    _max?: NotificationRuleMaxOrderByAggregateInput
    _min?: NotificationRuleMinOrderByAggregateInput
  }

  export type NotificationRuleScalarWhereWithAggregatesInput = {
    AND?: NotificationRuleScalarWhereWithAggregatesInput | NotificationRuleScalarWhereWithAggregatesInput[]
    OR?: NotificationRuleScalarWhereWithAggregatesInput[]
    NOT?: NotificationRuleScalarWhereWithAggregatesInput | NotificationRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationRule"> | string
    nombre?: StringWithAggregatesFilter<"NotificationRule"> | string
    descripcion?: StringNullableWithAggregatesFilter<"NotificationRule"> | string | null
    entidadTipo?: StringWithAggregatesFilter<"NotificationRule"> | string
    eventoTipo?: StringWithAggregatesFilter<"NotificationRule"> | string
    activo?: BoolWithAggregatesFilter<"NotificationRule"> | boolean
    notificarCreador?: BoolWithAggregatesFilter<"NotificationRule"> | boolean
    notificarResponsable?: BoolWithAggregatesFilter<"NotificationRule"> | boolean
    notificarAprobadores?: BoolWithAggregatesFilter<"NotificationRule"> | boolean
    rolesDestino?: StringNullableWithAggregatesFilter<"NotificationRule"> | string | null
    usuariosDestino?: StringNullableWithAggregatesFilter<"NotificationRule"> | string | null
    enviarInApp?: BoolWithAggregatesFilter<"NotificationRule"> | boolean
    enviarEmail?: BoolWithAggregatesFilter<"NotificationRule"> | boolean
    plantillaMensaje?: StringNullableWithAggregatesFilter<"NotificationRule"> | string | null
    severidad?: StringWithAggregatesFilter<"NotificationRule"> | string
    fechaCreacion?: DateTimeWithAggregatesFilter<"NotificationRule"> | Date | string
    fechaModificacion?: DateTimeWithAggregatesFilter<"NotificationRule"> | Date | string
  }

  export type AlertRuleWhereInput = {
    AND?: AlertRuleWhereInput | AlertRuleWhereInput[]
    OR?: AlertRuleWhereInput[]
    NOT?: AlertRuleWhereInput | AlertRuleWhereInput[]
    id?: StringFilter<"AlertRule"> | string
    nombre?: StringFilter<"AlertRule"> | string
    descripcion?: StringNullableFilter<"AlertRule"> | string | null
    entidadTipo?: StringFilter<"AlertRule"> | string
    entidadId?: StringNullableFilter<"AlertRule"> | string | null
    metricaNombre?: StringFilter<"AlertRule"> | string
    operador?: StringFilter<"AlertRule"> | string
    valorUmbral?: FloatFilter<"AlertRule"> | number
    tipoAgregacion?: StringFilter<"AlertRule"> | string
    periodoEvaluacion?: StringNullableFilter<"AlertRule"> | string | null
    activo?: BoolFilter<"AlertRule"> | boolean
    rolesDestino?: StringNullableFilter<"AlertRule"> | string | null
    usuariosDestino?: StringNullableFilter<"AlertRule"> | string | null
    enviarInApp?: BoolFilter<"AlertRule"> | boolean
    enviarEmail?: BoolFilter<"AlertRule"> | boolean
    severidad?: StringFilter<"AlertRule"> | string
    cooldownMinutos?: IntFilter<"AlertRule"> | number
    ultimaEjecucion?: DateTimeNullableFilter<"AlertRule"> | Date | string | null
    fechaCreacion?: DateTimeFilter<"AlertRule"> | Date | string
    fechaModificacion?: DateTimeFilter<"AlertRule"> | Date | string
  }

  export type AlertRuleOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    entidadTipo?: SortOrder
    entidadId?: SortOrderInput | SortOrder
    metricaNombre?: SortOrder
    operador?: SortOrder
    valorUmbral?: SortOrder
    tipoAgregacion?: SortOrder
    periodoEvaluacion?: SortOrderInput | SortOrder
    activo?: SortOrder
    rolesDestino?: SortOrderInput | SortOrder
    usuariosDestino?: SortOrderInput | SortOrder
    enviarInApp?: SortOrder
    enviarEmail?: SortOrder
    severidad?: SortOrder
    cooldownMinutos?: SortOrder
    ultimaEjecucion?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type AlertRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertRuleWhereInput | AlertRuleWhereInput[]
    OR?: AlertRuleWhereInput[]
    NOT?: AlertRuleWhereInput | AlertRuleWhereInput[]
    nombre?: StringFilter<"AlertRule"> | string
    descripcion?: StringNullableFilter<"AlertRule"> | string | null
    entidadTipo?: StringFilter<"AlertRule"> | string
    entidadId?: StringNullableFilter<"AlertRule"> | string | null
    metricaNombre?: StringFilter<"AlertRule"> | string
    operador?: StringFilter<"AlertRule"> | string
    valorUmbral?: FloatFilter<"AlertRule"> | number
    tipoAgregacion?: StringFilter<"AlertRule"> | string
    periodoEvaluacion?: StringNullableFilter<"AlertRule"> | string | null
    activo?: BoolFilter<"AlertRule"> | boolean
    rolesDestino?: StringNullableFilter<"AlertRule"> | string | null
    usuariosDestino?: StringNullableFilter<"AlertRule"> | string | null
    enviarInApp?: BoolFilter<"AlertRule"> | boolean
    enviarEmail?: BoolFilter<"AlertRule"> | boolean
    severidad?: StringFilter<"AlertRule"> | string
    cooldownMinutos?: IntFilter<"AlertRule"> | number
    ultimaEjecucion?: DateTimeNullableFilter<"AlertRule"> | Date | string | null
    fechaCreacion?: DateTimeFilter<"AlertRule"> | Date | string
    fechaModificacion?: DateTimeFilter<"AlertRule"> | Date | string
  }, "id">

  export type AlertRuleOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    entidadTipo?: SortOrder
    entidadId?: SortOrderInput | SortOrder
    metricaNombre?: SortOrder
    operador?: SortOrder
    valorUmbral?: SortOrder
    tipoAgregacion?: SortOrder
    periodoEvaluacion?: SortOrderInput | SortOrder
    activo?: SortOrder
    rolesDestino?: SortOrderInput | SortOrder
    usuariosDestino?: SortOrderInput | SortOrder
    enviarInApp?: SortOrder
    enviarEmail?: SortOrder
    severidad?: SortOrder
    cooldownMinutos?: SortOrder
    ultimaEjecucion?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
    _count?: AlertRuleCountOrderByAggregateInput
    _avg?: AlertRuleAvgOrderByAggregateInput
    _max?: AlertRuleMaxOrderByAggregateInput
    _min?: AlertRuleMinOrderByAggregateInput
    _sum?: AlertRuleSumOrderByAggregateInput
  }

  export type AlertRuleScalarWhereWithAggregatesInput = {
    AND?: AlertRuleScalarWhereWithAggregatesInput | AlertRuleScalarWhereWithAggregatesInput[]
    OR?: AlertRuleScalarWhereWithAggregatesInput[]
    NOT?: AlertRuleScalarWhereWithAggregatesInput | AlertRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AlertRule"> | string
    nombre?: StringWithAggregatesFilter<"AlertRule"> | string
    descripcion?: StringNullableWithAggregatesFilter<"AlertRule"> | string | null
    entidadTipo?: StringWithAggregatesFilter<"AlertRule"> | string
    entidadId?: StringNullableWithAggregatesFilter<"AlertRule"> | string | null
    metricaNombre?: StringWithAggregatesFilter<"AlertRule"> | string
    operador?: StringWithAggregatesFilter<"AlertRule"> | string
    valorUmbral?: FloatWithAggregatesFilter<"AlertRule"> | number
    tipoAgregacion?: StringWithAggregatesFilter<"AlertRule"> | string
    periodoEvaluacion?: StringNullableWithAggregatesFilter<"AlertRule"> | string | null
    activo?: BoolWithAggregatesFilter<"AlertRule"> | boolean
    rolesDestino?: StringNullableWithAggregatesFilter<"AlertRule"> | string | null
    usuariosDestino?: StringNullableWithAggregatesFilter<"AlertRule"> | string | null
    enviarInApp?: BoolWithAggregatesFilter<"AlertRule"> | boolean
    enviarEmail?: BoolWithAggregatesFilter<"AlertRule"> | boolean
    severidad?: StringWithAggregatesFilter<"AlertRule"> | string
    cooldownMinutos?: IntWithAggregatesFilter<"AlertRule"> | number
    ultimaEjecucion?: DateTimeNullableWithAggregatesFilter<"AlertRule"> | Date | string | null
    fechaCreacion?: DateTimeWithAggregatesFilter<"AlertRule"> | Date | string
    fechaModificacion?: DateTimeWithAggregatesFilter<"AlertRule"> | Date | string
  }

  export type ExpirationRuleWhereInput = {
    AND?: ExpirationRuleWhereInput | ExpirationRuleWhereInput[]
    OR?: ExpirationRuleWhereInput[]
    NOT?: ExpirationRuleWhereInput | ExpirationRuleWhereInput[]
    id?: StringFilter<"ExpirationRule"> | string
    nombre?: StringFilter<"ExpirationRule"> | string
    descripcion?: StringNullableFilter<"ExpirationRule"> | string | null
    entidadTipo?: StringFilter<"ExpirationRule"> | string
    diasAnticipacion?: StringFilter<"ExpirationRule"> | string
    diasDespuesVencido?: StringNullableFilter<"ExpirationRule"> | string | null
    activo?: BoolFilter<"ExpirationRule"> | boolean
    notificarResponsable?: BoolFilter<"ExpirationRule"> | boolean
    notificarSupervisor?: BoolFilter<"ExpirationRule"> | boolean
    rolesDestino?: StringNullableFilter<"ExpirationRule"> | string | null
    enviarInApp?: BoolFilter<"ExpirationRule"> | boolean
    enviarEmail?: BoolFilter<"ExpirationRule"> | boolean
    fechaCreacion?: DateTimeFilter<"ExpirationRule"> | Date | string
    fechaModificacion?: DateTimeFilter<"ExpirationRule"> | Date | string
  }

  export type ExpirationRuleOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    entidadTipo?: SortOrder
    diasAnticipacion?: SortOrder
    diasDespuesVencido?: SortOrderInput | SortOrder
    activo?: SortOrder
    notificarResponsable?: SortOrder
    notificarSupervisor?: SortOrder
    rolesDestino?: SortOrderInput | SortOrder
    enviarInApp?: SortOrder
    enviarEmail?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type ExpirationRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpirationRuleWhereInput | ExpirationRuleWhereInput[]
    OR?: ExpirationRuleWhereInput[]
    NOT?: ExpirationRuleWhereInput | ExpirationRuleWhereInput[]
    nombre?: StringFilter<"ExpirationRule"> | string
    descripcion?: StringNullableFilter<"ExpirationRule"> | string | null
    entidadTipo?: StringFilter<"ExpirationRule"> | string
    diasAnticipacion?: StringFilter<"ExpirationRule"> | string
    diasDespuesVencido?: StringNullableFilter<"ExpirationRule"> | string | null
    activo?: BoolFilter<"ExpirationRule"> | boolean
    notificarResponsable?: BoolFilter<"ExpirationRule"> | boolean
    notificarSupervisor?: BoolFilter<"ExpirationRule"> | boolean
    rolesDestino?: StringNullableFilter<"ExpirationRule"> | string | null
    enviarInApp?: BoolFilter<"ExpirationRule"> | boolean
    enviarEmail?: BoolFilter<"ExpirationRule"> | boolean
    fechaCreacion?: DateTimeFilter<"ExpirationRule"> | Date | string
    fechaModificacion?: DateTimeFilter<"ExpirationRule"> | Date | string
  }, "id">

  export type ExpirationRuleOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    entidadTipo?: SortOrder
    diasAnticipacion?: SortOrder
    diasDespuesVencido?: SortOrderInput | SortOrder
    activo?: SortOrder
    notificarResponsable?: SortOrder
    notificarSupervisor?: SortOrder
    rolesDestino?: SortOrderInput | SortOrder
    enviarInApp?: SortOrder
    enviarEmail?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
    _count?: ExpirationRuleCountOrderByAggregateInput
    _max?: ExpirationRuleMaxOrderByAggregateInput
    _min?: ExpirationRuleMinOrderByAggregateInput
  }

  export type ExpirationRuleScalarWhereWithAggregatesInput = {
    AND?: ExpirationRuleScalarWhereWithAggregatesInput | ExpirationRuleScalarWhereWithAggregatesInput[]
    OR?: ExpirationRuleScalarWhereWithAggregatesInput[]
    NOT?: ExpirationRuleScalarWhereWithAggregatesInput | ExpirationRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExpirationRule"> | string
    nombre?: StringWithAggregatesFilter<"ExpirationRule"> | string
    descripcion?: StringNullableWithAggregatesFilter<"ExpirationRule"> | string | null
    entidadTipo?: StringWithAggregatesFilter<"ExpirationRule"> | string
    diasAnticipacion?: StringWithAggregatesFilter<"ExpirationRule"> | string
    diasDespuesVencido?: StringNullableWithAggregatesFilter<"ExpirationRule"> | string | null
    activo?: BoolWithAggregatesFilter<"ExpirationRule"> | boolean
    notificarResponsable?: BoolWithAggregatesFilter<"ExpirationRule"> | boolean
    notificarSupervisor?: BoolWithAggregatesFilter<"ExpirationRule"> | boolean
    rolesDestino?: StringNullableWithAggregatesFilter<"ExpirationRule"> | string | null
    enviarInApp?: BoolWithAggregatesFilter<"ExpirationRule"> | boolean
    enviarEmail?: BoolWithAggregatesFilter<"ExpirationRule"> | boolean
    fechaCreacion?: DateTimeWithAggregatesFilter<"ExpirationRule"> | Date | string
    fechaModificacion?: DateTimeWithAggregatesFilter<"ExpirationRule"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    usuarioId?: StringFilter<"Notification"> | string
    tipo?: StringFilter<"Notification"> | string
    titulo?: StringFilter<"Notification"> | string
    mensaje?: StringFilter<"Notification"> | string
    severidad?: StringFilter<"Notification"> | string
    entidadTipo?: StringNullableFilter<"Notification"> | string | null
    entidadId?: StringNullableFilter<"Notification"> | string | null
    entidadNombre?: StringNullableFilter<"Notification"> | string | null
    leida?: BoolFilter<"Notification"> | boolean
    archivada?: BoolFilter<"Notification"> | boolean
    enSeguimiento?: BoolFilter<"Notification"> | boolean
    acciones?: StringNullableFilter<"Notification"> | string | null
    attachmentTipo?: StringNullableFilter<"Notification"> | string | null
    attachmentUrl?: StringNullableFilter<"Notification"> | string | null
    attachmentTitulo?: StringNullableFilter<"Notification"> | string | null
    attachmentSubtitulo?: StringNullableFilter<"Notification"> | string | null
    metadata?: StringNullableFilter<"Notification"> | string | null
    reglaId?: StringNullableFilter<"Notification"> | string | null
    reglaTipo?: StringNullableFilter<"Notification"> | string | null
    fechaCreacion?: DateTimeFilter<"Notification"> | Date | string
    fechaLeida?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    severidad?: SortOrder
    entidadTipo?: SortOrderInput | SortOrder
    entidadId?: SortOrderInput | SortOrder
    entidadNombre?: SortOrderInput | SortOrder
    leida?: SortOrder
    archivada?: SortOrder
    enSeguimiento?: SortOrder
    acciones?: SortOrderInput | SortOrder
    attachmentTipo?: SortOrderInput | SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    attachmentTitulo?: SortOrderInput | SortOrder
    attachmentSubtitulo?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    reglaId?: SortOrderInput | SortOrder
    reglaTipo?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    fechaLeida?: SortOrderInput | SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    usuarioId?: StringFilter<"Notification"> | string
    tipo?: StringFilter<"Notification"> | string
    titulo?: StringFilter<"Notification"> | string
    mensaje?: StringFilter<"Notification"> | string
    severidad?: StringFilter<"Notification"> | string
    entidadTipo?: StringNullableFilter<"Notification"> | string | null
    entidadId?: StringNullableFilter<"Notification"> | string | null
    entidadNombre?: StringNullableFilter<"Notification"> | string | null
    leida?: BoolFilter<"Notification"> | boolean
    archivada?: BoolFilter<"Notification"> | boolean
    enSeguimiento?: BoolFilter<"Notification"> | boolean
    acciones?: StringNullableFilter<"Notification"> | string | null
    attachmentTipo?: StringNullableFilter<"Notification"> | string | null
    attachmentUrl?: StringNullableFilter<"Notification"> | string | null
    attachmentTitulo?: StringNullableFilter<"Notification"> | string | null
    attachmentSubtitulo?: StringNullableFilter<"Notification"> | string | null
    metadata?: StringNullableFilter<"Notification"> | string | null
    reglaId?: StringNullableFilter<"Notification"> | string | null
    reglaTipo?: StringNullableFilter<"Notification"> | string | null
    fechaCreacion?: DateTimeFilter<"Notification"> | Date | string
    fechaLeida?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    severidad?: SortOrder
    entidadTipo?: SortOrderInput | SortOrder
    entidadId?: SortOrderInput | SortOrder
    entidadNombre?: SortOrderInput | SortOrder
    leida?: SortOrder
    archivada?: SortOrder
    enSeguimiento?: SortOrder
    acciones?: SortOrderInput | SortOrder
    attachmentTipo?: SortOrderInput | SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    attachmentTitulo?: SortOrderInput | SortOrder
    attachmentSubtitulo?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    reglaId?: SortOrderInput | SortOrder
    reglaTipo?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    fechaLeida?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    usuarioId?: StringWithAggregatesFilter<"Notification"> | string
    tipo?: StringWithAggregatesFilter<"Notification"> | string
    titulo?: StringWithAggregatesFilter<"Notification"> | string
    mensaje?: StringWithAggregatesFilter<"Notification"> | string
    severidad?: StringWithAggregatesFilter<"Notification"> | string
    entidadTipo?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    entidadId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    entidadNombre?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    leida?: BoolWithAggregatesFilter<"Notification"> | boolean
    archivada?: BoolWithAggregatesFilter<"Notification"> | boolean
    enSeguimiento?: BoolWithAggregatesFilter<"Notification"> | boolean
    acciones?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    attachmentTipo?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    attachmentUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    attachmentTitulo?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    attachmentSubtitulo?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    reglaId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    reglaTipo?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    fechaCreacion?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    fechaLeida?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type UserNotificationPreferencesWhereInput = {
    AND?: UserNotificationPreferencesWhereInput | UserNotificationPreferencesWhereInput[]
    OR?: UserNotificationPreferencesWhereInput[]
    NOT?: UserNotificationPreferencesWhereInput | UserNotificationPreferencesWhereInput[]
    id?: StringFilter<"UserNotificationPreferences"> | string
    usuarioId?: StringFilter<"UserNotificationPreferences"> | string
    habilitado?: BoolFilter<"UserNotificationPreferences"> | boolean
    emailHabilitado?: BoolFilter<"UserNotificationPreferences"> | boolean
    inAppHabilitado?: BoolFilter<"UserNotificationPreferences"> | boolean
    preferenciasPorEntidad?: StringNullableFilter<"UserNotificationPreferences"> | string | null
    notificarInfo?: BoolFilter<"UserNotificationPreferences"> | boolean
    notificarWarning?: BoolFilter<"UserNotificationPreferences"> | boolean
    notificarCritical?: BoolFilter<"UserNotificationPreferences"> | boolean
    frecuenciaEmail?: StringFilter<"UserNotificationPreferences"> | string
    horaResumen?: StringFilter<"UserNotificationPreferences"> | string
    horarioNoMolestarHabilitado?: BoolFilter<"UserNotificationPreferences"> | boolean
    horarioNoMolestarInicio?: StringNullableFilter<"UserNotificationPreferences"> | string | null
    horarioNoMolestarFin?: StringNullableFilter<"UserNotificationPreferences"> | string | null
    horarioNoMolestarDias?: StringNullableFilter<"UserNotificationPreferences"> | string | null
    rateLimitHabilitado?: BoolFilter<"UserNotificationPreferences"> | boolean
    rateLimitMaxPorHora?: IntFilter<"UserNotificationPreferences"> | number
    preferenciasPorModulo?: StringNullableFilter<"UserNotificationPreferences"> | string | null
    fechaCreacion?: DateTimeFilter<"UserNotificationPreferences"> | Date | string
    fechaModificacion?: DateTimeFilter<"UserNotificationPreferences"> | Date | string
  }

  export type UserNotificationPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    habilitado?: SortOrder
    emailHabilitado?: SortOrder
    inAppHabilitado?: SortOrder
    preferenciasPorEntidad?: SortOrderInput | SortOrder
    notificarInfo?: SortOrder
    notificarWarning?: SortOrder
    notificarCritical?: SortOrder
    frecuenciaEmail?: SortOrder
    horaResumen?: SortOrder
    horarioNoMolestarHabilitado?: SortOrder
    horarioNoMolestarInicio?: SortOrderInput | SortOrder
    horarioNoMolestarFin?: SortOrderInput | SortOrder
    horarioNoMolestarDias?: SortOrderInput | SortOrder
    rateLimitHabilitado?: SortOrder
    rateLimitMaxPorHora?: SortOrder
    preferenciasPorModulo?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type UserNotificationPreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    usuarioId?: string
    AND?: UserNotificationPreferencesWhereInput | UserNotificationPreferencesWhereInput[]
    OR?: UserNotificationPreferencesWhereInput[]
    NOT?: UserNotificationPreferencesWhereInput | UserNotificationPreferencesWhereInput[]
    habilitado?: BoolFilter<"UserNotificationPreferences"> | boolean
    emailHabilitado?: BoolFilter<"UserNotificationPreferences"> | boolean
    inAppHabilitado?: BoolFilter<"UserNotificationPreferences"> | boolean
    preferenciasPorEntidad?: StringNullableFilter<"UserNotificationPreferences"> | string | null
    notificarInfo?: BoolFilter<"UserNotificationPreferences"> | boolean
    notificarWarning?: BoolFilter<"UserNotificationPreferences"> | boolean
    notificarCritical?: BoolFilter<"UserNotificationPreferences"> | boolean
    frecuenciaEmail?: StringFilter<"UserNotificationPreferences"> | string
    horaResumen?: StringFilter<"UserNotificationPreferences"> | string
    horarioNoMolestarHabilitado?: BoolFilter<"UserNotificationPreferences"> | boolean
    horarioNoMolestarInicio?: StringNullableFilter<"UserNotificationPreferences"> | string | null
    horarioNoMolestarFin?: StringNullableFilter<"UserNotificationPreferences"> | string | null
    horarioNoMolestarDias?: StringNullableFilter<"UserNotificationPreferences"> | string | null
    rateLimitHabilitado?: BoolFilter<"UserNotificationPreferences"> | boolean
    rateLimitMaxPorHora?: IntFilter<"UserNotificationPreferences"> | number
    preferenciasPorModulo?: StringNullableFilter<"UserNotificationPreferences"> | string | null
    fechaCreacion?: DateTimeFilter<"UserNotificationPreferences"> | Date | string
    fechaModificacion?: DateTimeFilter<"UserNotificationPreferences"> | Date | string
  }, "id" | "usuarioId">

  export type UserNotificationPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    habilitado?: SortOrder
    emailHabilitado?: SortOrder
    inAppHabilitado?: SortOrder
    preferenciasPorEntidad?: SortOrderInput | SortOrder
    notificarInfo?: SortOrder
    notificarWarning?: SortOrder
    notificarCritical?: SortOrder
    frecuenciaEmail?: SortOrder
    horaResumen?: SortOrder
    horarioNoMolestarHabilitado?: SortOrder
    horarioNoMolestarInicio?: SortOrderInput | SortOrder
    horarioNoMolestarFin?: SortOrderInput | SortOrder
    horarioNoMolestarDias?: SortOrderInput | SortOrder
    rateLimitHabilitado?: SortOrder
    rateLimitMaxPorHora?: SortOrder
    preferenciasPorModulo?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
    _count?: UserNotificationPreferencesCountOrderByAggregateInput
    _avg?: UserNotificationPreferencesAvgOrderByAggregateInput
    _max?: UserNotificationPreferencesMaxOrderByAggregateInput
    _min?: UserNotificationPreferencesMinOrderByAggregateInput
    _sum?: UserNotificationPreferencesSumOrderByAggregateInput
  }

  export type UserNotificationPreferencesScalarWhereWithAggregatesInput = {
    AND?: UserNotificationPreferencesScalarWhereWithAggregatesInput | UserNotificationPreferencesScalarWhereWithAggregatesInput[]
    OR?: UserNotificationPreferencesScalarWhereWithAggregatesInput[]
    NOT?: UserNotificationPreferencesScalarWhereWithAggregatesInput | UserNotificationPreferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserNotificationPreferences"> | string
    usuarioId?: StringWithAggregatesFilter<"UserNotificationPreferences"> | string
    habilitado?: BoolWithAggregatesFilter<"UserNotificationPreferences"> | boolean
    emailHabilitado?: BoolWithAggregatesFilter<"UserNotificationPreferences"> | boolean
    inAppHabilitado?: BoolWithAggregatesFilter<"UserNotificationPreferences"> | boolean
    preferenciasPorEntidad?: StringNullableWithAggregatesFilter<"UserNotificationPreferences"> | string | null
    notificarInfo?: BoolWithAggregatesFilter<"UserNotificationPreferences"> | boolean
    notificarWarning?: BoolWithAggregatesFilter<"UserNotificationPreferences"> | boolean
    notificarCritical?: BoolWithAggregatesFilter<"UserNotificationPreferences"> | boolean
    frecuenciaEmail?: StringWithAggregatesFilter<"UserNotificationPreferences"> | string
    horaResumen?: StringWithAggregatesFilter<"UserNotificationPreferences"> | string
    horarioNoMolestarHabilitado?: BoolWithAggregatesFilter<"UserNotificationPreferences"> | boolean
    horarioNoMolestarInicio?: StringNullableWithAggregatesFilter<"UserNotificationPreferences"> | string | null
    horarioNoMolestarFin?: StringNullableWithAggregatesFilter<"UserNotificationPreferences"> | string | null
    horarioNoMolestarDias?: StringNullableWithAggregatesFilter<"UserNotificationPreferences"> | string | null
    rateLimitHabilitado?: BoolWithAggregatesFilter<"UserNotificationPreferences"> | boolean
    rateLimitMaxPorHora?: IntWithAggregatesFilter<"UserNotificationPreferences"> | number
    preferenciasPorModulo?: StringNullableWithAggregatesFilter<"UserNotificationPreferences"> | string | null
    fechaCreacion?: DateTimeWithAggregatesFilter<"UserNotificationPreferences"> | Date | string
    fechaModificacion?: DateTimeWithAggregatesFilter<"UserNotificationPreferences"> | Date | string
  }

  export type NotificationLogWhereInput = {
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    notificationId?: StringNullableFilter<"NotificationLog"> | string | null
    usuarioId?: StringFilter<"NotificationLog"> | string
    canal?: StringFilter<"NotificationLog"> | string
    estado?: StringFilter<"NotificationLog"> | string
    errorMensaje?: StringNullableFilter<"NotificationLog"> | string | null
    reglaId?: StringNullableFilter<"NotificationLog"> | string | null
    reglaTipo?: StringNullableFilter<"NotificationLog"> | string | null
    metadata?: StringNullableFilter<"NotificationLog"> | string | null
    fechaEnvio?: DateTimeFilter<"NotificationLog"> | Date | string
  }

  export type NotificationLogOrderByWithRelationInput = {
    id?: SortOrder
    notificationId?: SortOrderInput | SortOrder
    usuarioId?: SortOrder
    canal?: SortOrder
    estado?: SortOrder
    errorMensaje?: SortOrderInput | SortOrder
    reglaId?: SortOrderInput | SortOrder
    reglaTipo?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    fechaEnvio?: SortOrder
  }

  export type NotificationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    notificationId?: StringNullableFilter<"NotificationLog"> | string | null
    usuarioId?: StringFilter<"NotificationLog"> | string
    canal?: StringFilter<"NotificationLog"> | string
    estado?: StringFilter<"NotificationLog"> | string
    errorMensaje?: StringNullableFilter<"NotificationLog"> | string | null
    reglaId?: StringNullableFilter<"NotificationLog"> | string | null
    reglaTipo?: StringNullableFilter<"NotificationLog"> | string | null
    metadata?: StringNullableFilter<"NotificationLog"> | string | null
    fechaEnvio?: DateTimeFilter<"NotificationLog"> | Date | string
  }, "id">

  export type NotificationLogOrderByWithAggregationInput = {
    id?: SortOrder
    notificationId?: SortOrderInput | SortOrder
    usuarioId?: SortOrder
    canal?: SortOrder
    estado?: SortOrder
    errorMensaje?: SortOrderInput | SortOrder
    reglaId?: SortOrderInput | SortOrder
    reglaTipo?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    fechaEnvio?: SortOrder
    _count?: NotificationLogCountOrderByAggregateInput
    _max?: NotificationLogMaxOrderByAggregateInput
    _min?: NotificationLogMinOrderByAggregateInput
  }

  export type NotificationLogScalarWhereWithAggregatesInput = {
    AND?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    OR?: NotificationLogScalarWhereWithAggregatesInput[]
    NOT?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationLog"> | string
    notificationId?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    usuarioId?: StringWithAggregatesFilter<"NotificationLog"> | string
    canal?: StringWithAggregatesFilter<"NotificationLog"> | string
    estado?: StringWithAggregatesFilter<"NotificationLog"> | string
    errorMensaje?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    reglaId?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    reglaTipo?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    fechaEnvio?: DateTimeWithAggregatesFilter<"NotificationLog"> | Date | string
  }

  export type NotificationProfileWhereInput = {
    AND?: NotificationProfileWhereInput | NotificationProfileWhereInput[]
    OR?: NotificationProfileWhereInput[]
    NOT?: NotificationProfileWhereInput | NotificationProfileWhereInput[]
    id?: StringFilter<"NotificationProfile"> | string
    nombre?: StringFilter<"NotificationProfile"> | string
    descripcion?: StringNullableFilter<"NotificationProfile"> | string | null
    eventos?: StringFilter<"NotificationProfile"> | string
    seleccionEntidades?: StringFilter<"NotificationProfile"> | string
    filtrosEntidad?: StringNullableFilter<"NotificationProfile"> | string | null
    destinatarios?: StringFilter<"NotificationProfile"> | string
    canales?: StringFilter<"NotificationProfile"> | string
    plantillaTitulo?: StringNullableFilter<"NotificationProfile"> | string | null
    plantillaMensaje?: StringNullableFilter<"NotificationProfile"> | string | null
    severidad?: StringFilter<"NotificationProfile"> | string
    estado?: StringFilter<"NotificationProfile"> | string
    horarioNoMolestar?: StringNullableFilter<"NotificationProfile"> | string | null
    fechaCreacion?: DateTimeFilter<"NotificationProfile"> | Date | string
    fechaModificacion?: DateTimeFilter<"NotificationProfile"> | Date | string
    creadoPorId?: StringNullableFilter<"NotificationProfile"> | string | null
  }

  export type NotificationProfileOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    eventos?: SortOrder
    seleccionEntidades?: SortOrder
    filtrosEntidad?: SortOrderInput | SortOrder
    destinatarios?: SortOrder
    canales?: SortOrder
    plantillaTitulo?: SortOrderInput | SortOrder
    plantillaMensaje?: SortOrderInput | SortOrder
    severidad?: SortOrder
    estado?: SortOrder
    horarioNoMolestar?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
    creadoPorId?: SortOrderInput | SortOrder
  }

  export type NotificationProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationProfileWhereInput | NotificationProfileWhereInput[]
    OR?: NotificationProfileWhereInput[]
    NOT?: NotificationProfileWhereInput | NotificationProfileWhereInput[]
    nombre?: StringFilter<"NotificationProfile"> | string
    descripcion?: StringNullableFilter<"NotificationProfile"> | string | null
    eventos?: StringFilter<"NotificationProfile"> | string
    seleccionEntidades?: StringFilter<"NotificationProfile"> | string
    filtrosEntidad?: StringNullableFilter<"NotificationProfile"> | string | null
    destinatarios?: StringFilter<"NotificationProfile"> | string
    canales?: StringFilter<"NotificationProfile"> | string
    plantillaTitulo?: StringNullableFilter<"NotificationProfile"> | string | null
    plantillaMensaje?: StringNullableFilter<"NotificationProfile"> | string | null
    severidad?: StringFilter<"NotificationProfile"> | string
    estado?: StringFilter<"NotificationProfile"> | string
    horarioNoMolestar?: StringNullableFilter<"NotificationProfile"> | string | null
    fechaCreacion?: DateTimeFilter<"NotificationProfile"> | Date | string
    fechaModificacion?: DateTimeFilter<"NotificationProfile"> | Date | string
    creadoPorId?: StringNullableFilter<"NotificationProfile"> | string | null
  }, "id">

  export type NotificationProfileOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    eventos?: SortOrder
    seleccionEntidades?: SortOrder
    filtrosEntidad?: SortOrderInput | SortOrder
    destinatarios?: SortOrder
    canales?: SortOrder
    plantillaTitulo?: SortOrderInput | SortOrder
    plantillaMensaje?: SortOrderInput | SortOrder
    severidad?: SortOrder
    estado?: SortOrder
    horarioNoMolestar?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
    creadoPorId?: SortOrderInput | SortOrder
    _count?: NotificationProfileCountOrderByAggregateInput
    _max?: NotificationProfileMaxOrderByAggregateInput
    _min?: NotificationProfileMinOrderByAggregateInput
  }

  export type NotificationProfileScalarWhereWithAggregatesInput = {
    AND?: NotificationProfileScalarWhereWithAggregatesInput | NotificationProfileScalarWhereWithAggregatesInput[]
    OR?: NotificationProfileScalarWhereWithAggregatesInput[]
    NOT?: NotificationProfileScalarWhereWithAggregatesInput | NotificationProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationProfile"> | string
    nombre?: StringWithAggregatesFilter<"NotificationProfile"> | string
    descripcion?: StringNullableWithAggregatesFilter<"NotificationProfile"> | string | null
    eventos?: StringWithAggregatesFilter<"NotificationProfile"> | string
    seleccionEntidades?: StringWithAggregatesFilter<"NotificationProfile"> | string
    filtrosEntidad?: StringNullableWithAggregatesFilter<"NotificationProfile"> | string | null
    destinatarios?: StringWithAggregatesFilter<"NotificationProfile"> | string
    canales?: StringWithAggregatesFilter<"NotificationProfile"> | string
    plantillaTitulo?: StringNullableWithAggregatesFilter<"NotificationProfile"> | string | null
    plantillaMensaje?: StringNullableWithAggregatesFilter<"NotificationProfile"> | string | null
    severidad?: StringWithAggregatesFilter<"NotificationProfile"> | string
    estado?: StringWithAggregatesFilter<"NotificationProfile"> | string
    horarioNoMolestar?: StringNullableWithAggregatesFilter<"NotificationProfile"> | string | null
    fechaCreacion?: DateTimeWithAggregatesFilter<"NotificationProfile"> | Date | string
    fechaModificacion?: DateTimeWithAggregatesFilter<"NotificationProfile"> | Date | string
    creadoPorId?: StringNullableWithAggregatesFilter<"NotificationProfile"> | string | null
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeFilter<"Project"> | Date | string
    responsibleUserId?: StringFilter<"Project"> | string
    orgUnitId?: StringNullableFilter<"Project"> | string | null
    priority?: StringFilter<"Project"> | string
    status?: StringFilter<"Project"> | string
    progress?: IntFilter<"Project"> | number
    reminderDays?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    createdBy?: StringFilter<"Project"> | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    objectives?: ProjectObjectiveListRelationFilter
    kpis?: ProjectKPIListRelationFilter
    phases?: ProjectPhaseListRelationFilter
    tasks?: TaskListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    responsibleUserId?: SortOrder
    orgUnitId?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    reminderDays?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    objectives?: ProjectObjectiveOrderByRelationAggregateInput
    kpis?: ProjectKPIOrderByRelationAggregateInput
    phases?: ProjectPhaseOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeFilter<"Project"> | Date | string
    responsibleUserId?: StringFilter<"Project"> | string
    orgUnitId?: StringNullableFilter<"Project"> | string | null
    priority?: StringFilter<"Project"> | string
    status?: StringFilter<"Project"> | string
    progress?: IntFilter<"Project"> | number
    reminderDays?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    createdBy?: StringFilter<"Project"> | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    objectives?: ProjectObjectiveListRelationFilter
    kpis?: ProjectKPIListRelationFilter
    phases?: ProjectPhaseListRelationFilter
    tasks?: TaskListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    responsibleUserId?: SortOrder
    orgUnitId?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    reminderDays?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    responsibleUserId?: StringWithAggregatesFilter<"Project"> | string
    orgUnitId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    priority?: StringWithAggregatesFilter<"Project"> | string
    status?: StringWithAggregatesFilter<"Project"> | string
    progress?: IntWithAggregatesFilter<"Project"> | number
    reminderDays?: StringWithAggregatesFilter<"Project"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Project"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ProjectObjectiveWhereInput = {
    AND?: ProjectObjectiveWhereInput | ProjectObjectiveWhereInput[]
    OR?: ProjectObjectiveWhereInput[]
    NOT?: ProjectObjectiveWhereInput | ProjectObjectiveWhereInput[]
    id?: StringFilter<"ProjectObjective"> | string
    projectId?: StringFilter<"ProjectObjective"> | string
    description?: StringFilter<"ProjectObjective"> | string
    category?: StringFilter<"ProjectObjective"> | string
    status?: StringFilter<"ProjectObjective"> | string
    targetDate?: DateTimeNullableFilter<"ProjectObjective"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"ProjectObjective"> | Date | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ProjectObjectiveOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectObjectiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectObjectiveWhereInput | ProjectObjectiveWhereInput[]
    OR?: ProjectObjectiveWhereInput[]
    NOT?: ProjectObjectiveWhereInput | ProjectObjectiveWhereInput[]
    projectId?: StringFilter<"ProjectObjective"> | string
    description?: StringFilter<"ProjectObjective"> | string
    category?: StringFilter<"ProjectObjective"> | string
    status?: StringFilter<"ProjectObjective"> | string
    targetDate?: DateTimeNullableFilter<"ProjectObjective"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"ProjectObjective"> | Date | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectObjectiveOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    _count?: ProjectObjectiveCountOrderByAggregateInput
    _max?: ProjectObjectiveMaxOrderByAggregateInput
    _min?: ProjectObjectiveMinOrderByAggregateInput
  }

  export type ProjectObjectiveScalarWhereWithAggregatesInput = {
    AND?: ProjectObjectiveScalarWhereWithAggregatesInput | ProjectObjectiveScalarWhereWithAggregatesInput[]
    OR?: ProjectObjectiveScalarWhereWithAggregatesInput[]
    NOT?: ProjectObjectiveScalarWhereWithAggregatesInput | ProjectObjectiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectObjective"> | string
    projectId?: StringWithAggregatesFilter<"ProjectObjective"> | string
    description?: StringWithAggregatesFilter<"ProjectObjective"> | string
    category?: StringWithAggregatesFilter<"ProjectObjective"> | string
    status?: StringWithAggregatesFilter<"ProjectObjective"> | string
    targetDate?: DateTimeNullableWithAggregatesFilter<"ProjectObjective"> | Date | string | null
    completedDate?: DateTimeNullableWithAggregatesFilter<"ProjectObjective"> | Date | string | null
  }

  export type ProjectKPIWhereInput = {
    AND?: ProjectKPIWhereInput | ProjectKPIWhereInput[]
    OR?: ProjectKPIWhereInput[]
    NOT?: ProjectKPIWhereInput | ProjectKPIWhereInput[]
    id?: StringFilter<"ProjectKPI"> | string
    projectId?: StringFilter<"ProjectKPI"> | string
    name?: StringFilter<"ProjectKPI"> | string
    description?: StringNullableFilter<"ProjectKPI"> | string | null
    targetValue?: FloatFilter<"ProjectKPI"> | number
    currentValue?: FloatFilter<"ProjectKPI"> | number
    unit?: StringFilter<"ProjectKPI"> | string
    formulaType?: StringFilter<"ProjectKPI"> | string
    formula?: StringNullableFilter<"ProjectKPI"> | string | null
    status?: StringFilter<"ProjectKPI"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ProjectKPIOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    unit?: SortOrder
    formulaType?: SortOrder
    formula?: SortOrderInput | SortOrder
    status?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectKPIWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectKPIWhereInput | ProjectKPIWhereInput[]
    OR?: ProjectKPIWhereInput[]
    NOT?: ProjectKPIWhereInput | ProjectKPIWhereInput[]
    projectId?: StringFilter<"ProjectKPI"> | string
    name?: StringFilter<"ProjectKPI"> | string
    description?: StringNullableFilter<"ProjectKPI"> | string | null
    targetValue?: FloatFilter<"ProjectKPI"> | number
    currentValue?: FloatFilter<"ProjectKPI"> | number
    unit?: StringFilter<"ProjectKPI"> | string
    formulaType?: StringFilter<"ProjectKPI"> | string
    formula?: StringNullableFilter<"ProjectKPI"> | string | null
    status?: StringFilter<"ProjectKPI"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectKPIOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    unit?: SortOrder
    formulaType?: SortOrder
    formula?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: ProjectKPICountOrderByAggregateInput
    _avg?: ProjectKPIAvgOrderByAggregateInput
    _max?: ProjectKPIMaxOrderByAggregateInput
    _min?: ProjectKPIMinOrderByAggregateInput
    _sum?: ProjectKPISumOrderByAggregateInput
  }

  export type ProjectKPIScalarWhereWithAggregatesInput = {
    AND?: ProjectKPIScalarWhereWithAggregatesInput | ProjectKPIScalarWhereWithAggregatesInput[]
    OR?: ProjectKPIScalarWhereWithAggregatesInput[]
    NOT?: ProjectKPIScalarWhereWithAggregatesInput | ProjectKPIScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectKPI"> | string
    projectId?: StringWithAggregatesFilter<"ProjectKPI"> | string
    name?: StringWithAggregatesFilter<"ProjectKPI"> | string
    description?: StringNullableWithAggregatesFilter<"ProjectKPI"> | string | null
    targetValue?: FloatWithAggregatesFilter<"ProjectKPI"> | number
    currentValue?: FloatWithAggregatesFilter<"ProjectKPI"> | number
    unit?: StringWithAggregatesFilter<"ProjectKPI"> | string
    formulaType?: StringWithAggregatesFilter<"ProjectKPI"> | string
    formula?: StringNullableWithAggregatesFilter<"ProjectKPI"> | string | null
    status?: StringWithAggregatesFilter<"ProjectKPI"> | string
  }

  export type ProjectPhaseWhereInput = {
    AND?: ProjectPhaseWhereInput | ProjectPhaseWhereInput[]
    OR?: ProjectPhaseWhereInput[]
    NOT?: ProjectPhaseWhereInput | ProjectPhaseWhereInput[]
    id?: StringFilter<"ProjectPhase"> | string
    projectId?: StringFilter<"ProjectPhase"> | string
    name?: StringFilter<"ProjectPhase"> | string
    description?: StringNullableFilter<"ProjectPhase"> | string | null
    orderNum?: IntFilter<"ProjectPhase"> | number
    startDate?: DateTimeFilter<"ProjectPhase"> | Date | string
    endDate?: DateTimeFilter<"ProjectPhase"> | Date | string
    actualStartDate?: DateTimeNullableFilter<"ProjectPhase"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"ProjectPhase"> | Date | string | null
    status?: StringFilter<"ProjectPhase"> | string
    weight?: IntFilter<"ProjectPhase"> | number
    dependsOnPhaseId?: StringNullableFilter<"ProjectPhase"> | string | null
    progress?: IntFilter<"ProjectPhase"> | number
    createdAt?: DateTimeFilter<"ProjectPhase"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectPhase"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    dependsOn?: XOR<ProjectPhaseNullableRelationFilter, ProjectPhaseWhereInput> | null
    dependents?: ProjectPhaseListRelationFilter
    tasks?: TaskListRelationFilter
  }

  export type ProjectPhaseOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    orderNum?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    actualStartDate?: SortOrderInput | SortOrder
    actualEndDate?: SortOrderInput | SortOrder
    status?: SortOrder
    weight?: SortOrder
    dependsOnPhaseId?: SortOrderInput | SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    dependsOn?: ProjectPhaseOrderByWithRelationInput
    dependents?: ProjectPhaseOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type ProjectPhaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectPhaseWhereInput | ProjectPhaseWhereInput[]
    OR?: ProjectPhaseWhereInput[]
    NOT?: ProjectPhaseWhereInput | ProjectPhaseWhereInput[]
    projectId?: StringFilter<"ProjectPhase"> | string
    name?: StringFilter<"ProjectPhase"> | string
    description?: StringNullableFilter<"ProjectPhase"> | string | null
    orderNum?: IntFilter<"ProjectPhase"> | number
    startDate?: DateTimeFilter<"ProjectPhase"> | Date | string
    endDate?: DateTimeFilter<"ProjectPhase"> | Date | string
    actualStartDate?: DateTimeNullableFilter<"ProjectPhase"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"ProjectPhase"> | Date | string | null
    status?: StringFilter<"ProjectPhase"> | string
    weight?: IntFilter<"ProjectPhase"> | number
    dependsOnPhaseId?: StringNullableFilter<"ProjectPhase"> | string | null
    progress?: IntFilter<"ProjectPhase"> | number
    createdAt?: DateTimeFilter<"ProjectPhase"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectPhase"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    dependsOn?: XOR<ProjectPhaseNullableRelationFilter, ProjectPhaseWhereInput> | null
    dependents?: ProjectPhaseListRelationFilter
    tasks?: TaskListRelationFilter
  }, "id">

  export type ProjectPhaseOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    orderNum?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    actualStartDate?: SortOrderInput | SortOrder
    actualEndDate?: SortOrderInput | SortOrder
    status?: SortOrder
    weight?: SortOrder
    dependsOnPhaseId?: SortOrderInput | SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectPhaseCountOrderByAggregateInput
    _avg?: ProjectPhaseAvgOrderByAggregateInput
    _max?: ProjectPhaseMaxOrderByAggregateInput
    _min?: ProjectPhaseMinOrderByAggregateInput
    _sum?: ProjectPhaseSumOrderByAggregateInput
  }

  export type ProjectPhaseScalarWhereWithAggregatesInput = {
    AND?: ProjectPhaseScalarWhereWithAggregatesInput | ProjectPhaseScalarWhereWithAggregatesInput[]
    OR?: ProjectPhaseScalarWhereWithAggregatesInput[]
    NOT?: ProjectPhaseScalarWhereWithAggregatesInput | ProjectPhaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectPhase"> | string
    projectId?: StringWithAggregatesFilter<"ProjectPhase"> | string
    name?: StringWithAggregatesFilter<"ProjectPhase"> | string
    description?: StringNullableWithAggregatesFilter<"ProjectPhase"> | string | null
    orderNum?: IntWithAggregatesFilter<"ProjectPhase"> | number
    startDate?: DateTimeWithAggregatesFilter<"ProjectPhase"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"ProjectPhase"> | Date | string
    actualStartDate?: DateTimeNullableWithAggregatesFilter<"ProjectPhase"> | Date | string | null
    actualEndDate?: DateTimeNullableWithAggregatesFilter<"ProjectPhase"> | Date | string | null
    status?: StringWithAggregatesFilter<"ProjectPhase"> | string
    weight?: IntWithAggregatesFilter<"ProjectPhase"> | number
    dependsOnPhaseId?: StringNullableWithAggregatesFilter<"ProjectPhase"> | string | null
    progress?: IntWithAggregatesFilter<"ProjectPhase"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProjectPhase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectPhase"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    projectId?: StringFilter<"Task"> | string
    phaseId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    assignedTo?: StringFilter<"Task"> | string
    assignedBy?: StringFilter<"Task"> | string
    assignedAt?: DateTimeFilter<"Task"> | Date | string
    startDate?: DateTimeFilter<"Task"> | Date | string
    dueDate?: DateTimeFilter<"Task"> | Date | string
    completedDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    progress?: IntFilter<"Task"> | number
    status?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    estimatedHours?: FloatNullableFilter<"Task"> | number | null
    actualHours?: FloatNullableFilter<"Task"> | number | null
    taskType?: StringFilter<"Task"> | string
    linkedEntityType?: StringNullableFilter<"Task"> | string | null
    linkedEntityId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    createdBy?: StringFilter<"Task"> | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    phase?: XOR<ProjectPhaseRelationFilter, ProjectPhaseWhereInput>
    evidences?: TaskEvidenceListRelationFilter
    history?: TaskHistoryListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    assignedTo?: SortOrder
    assignedBy?: SortOrder
    assignedAt?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrderInput | SortOrder
    progress?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    estimatedHours?: SortOrderInput | SortOrder
    actualHours?: SortOrderInput | SortOrder
    taskType?: SortOrder
    linkedEntityType?: SortOrderInput | SortOrder
    linkedEntityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    phase?: ProjectPhaseOrderByWithRelationInput
    evidences?: TaskEvidenceOrderByRelationAggregateInput
    history?: TaskHistoryOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    projectId?: StringFilter<"Task"> | string
    phaseId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    assignedTo?: StringFilter<"Task"> | string
    assignedBy?: StringFilter<"Task"> | string
    assignedAt?: DateTimeFilter<"Task"> | Date | string
    startDate?: DateTimeFilter<"Task"> | Date | string
    dueDate?: DateTimeFilter<"Task"> | Date | string
    completedDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    progress?: IntFilter<"Task"> | number
    status?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    estimatedHours?: FloatNullableFilter<"Task"> | number | null
    actualHours?: FloatNullableFilter<"Task"> | number | null
    taskType?: StringFilter<"Task"> | string
    linkedEntityType?: StringNullableFilter<"Task"> | string | null
    linkedEntityId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    createdBy?: StringFilter<"Task"> | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    phase?: XOR<ProjectPhaseRelationFilter, ProjectPhaseWhereInput>
    evidences?: TaskEvidenceListRelationFilter
    history?: TaskHistoryListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    assignedTo?: SortOrder
    assignedBy?: SortOrder
    assignedAt?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrderInput | SortOrder
    progress?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    estimatedHours?: SortOrderInput | SortOrder
    actualHours?: SortOrderInput | SortOrder
    taskType?: SortOrder
    linkedEntityType?: SortOrderInput | SortOrder
    linkedEntityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    projectId?: StringWithAggregatesFilter<"Task"> | string
    phaseId?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    assignedTo?: StringWithAggregatesFilter<"Task"> | string
    assignedBy?: StringWithAggregatesFilter<"Task"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    startDate?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    completedDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    progress?: IntWithAggregatesFilter<"Task"> | number
    status?: StringWithAggregatesFilter<"Task"> | string
    priority?: StringWithAggregatesFilter<"Task"> | string
    estimatedHours?: FloatNullableWithAggregatesFilter<"Task"> | number | null
    actualHours?: FloatNullableWithAggregatesFilter<"Task"> | number | null
    taskType?: StringWithAggregatesFilter<"Task"> | string
    linkedEntityType?: StringNullableWithAggregatesFilter<"Task"> | string | null
    linkedEntityId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Task"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type TaskEvidenceWhereInput = {
    AND?: TaskEvidenceWhereInput | TaskEvidenceWhereInput[]
    OR?: TaskEvidenceWhereInput[]
    NOT?: TaskEvidenceWhereInput | TaskEvidenceWhereInput[]
    id?: StringFilter<"TaskEvidence"> | string
    taskId?: StringFilter<"TaskEvidence"> | string
    fileName?: StringFilter<"TaskEvidence"> | string
    fileType?: StringFilter<"TaskEvidence"> | string
    fileSize?: IntFilter<"TaskEvidence"> | number
    storageUrl?: StringFilter<"TaskEvidence"> | string
    evidenceType?: StringFilter<"TaskEvidence"> | string
    description?: StringNullableFilter<"TaskEvidence"> | string | null
    documentDate?: DateTimeNullableFilter<"TaskEvidence"> | Date | string | null
    uploadedBy?: StringFilter<"TaskEvidence"> | string
    uploadedAt?: DateTimeFilter<"TaskEvidence"> | Date | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
  }

  export type TaskEvidenceOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    storageUrl?: SortOrder
    evidenceType?: SortOrder
    description?: SortOrderInput | SortOrder
    documentDate?: SortOrderInput | SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    task?: TaskOrderByWithRelationInput
  }

  export type TaskEvidenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskEvidenceWhereInput | TaskEvidenceWhereInput[]
    OR?: TaskEvidenceWhereInput[]
    NOT?: TaskEvidenceWhereInput | TaskEvidenceWhereInput[]
    taskId?: StringFilter<"TaskEvidence"> | string
    fileName?: StringFilter<"TaskEvidence"> | string
    fileType?: StringFilter<"TaskEvidence"> | string
    fileSize?: IntFilter<"TaskEvidence"> | number
    storageUrl?: StringFilter<"TaskEvidence"> | string
    evidenceType?: StringFilter<"TaskEvidence"> | string
    description?: StringNullableFilter<"TaskEvidence"> | string | null
    documentDate?: DateTimeNullableFilter<"TaskEvidence"> | Date | string | null
    uploadedBy?: StringFilter<"TaskEvidence"> | string
    uploadedAt?: DateTimeFilter<"TaskEvidence"> | Date | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
  }, "id">

  export type TaskEvidenceOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    storageUrl?: SortOrder
    evidenceType?: SortOrder
    description?: SortOrderInput | SortOrder
    documentDate?: SortOrderInput | SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    _count?: TaskEvidenceCountOrderByAggregateInput
    _avg?: TaskEvidenceAvgOrderByAggregateInput
    _max?: TaskEvidenceMaxOrderByAggregateInput
    _min?: TaskEvidenceMinOrderByAggregateInput
    _sum?: TaskEvidenceSumOrderByAggregateInput
  }

  export type TaskEvidenceScalarWhereWithAggregatesInput = {
    AND?: TaskEvidenceScalarWhereWithAggregatesInput | TaskEvidenceScalarWhereWithAggregatesInput[]
    OR?: TaskEvidenceScalarWhereWithAggregatesInput[]
    NOT?: TaskEvidenceScalarWhereWithAggregatesInput | TaskEvidenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskEvidence"> | string
    taskId?: StringWithAggregatesFilter<"TaskEvidence"> | string
    fileName?: StringWithAggregatesFilter<"TaskEvidence"> | string
    fileType?: StringWithAggregatesFilter<"TaskEvidence"> | string
    fileSize?: IntWithAggregatesFilter<"TaskEvidence"> | number
    storageUrl?: StringWithAggregatesFilter<"TaskEvidence"> | string
    evidenceType?: StringWithAggregatesFilter<"TaskEvidence"> | string
    description?: StringNullableWithAggregatesFilter<"TaskEvidence"> | string | null
    documentDate?: DateTimeNullableWithAggregatesFilter<"TaskEvidence"> | Date | string | null
    uploadedBy?: StringWithAggregatesFilter<"TaskEvidence"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"TaskEvidence"> | Date | string
  }

  export type TaskHistoryWhereInput = {
    AND?: TaskHistoryWhereInput | TaskHistoryWhereInput[]
    OR?: TaskHistoryWhereInput[]
    NOT?: TaskHistoryWhereInput | TaskHistoryWhereInput[]
    id?: StringFilter<"TaskHistory"> | string
    taskId?: StringFilter<"TaskHistory"> | string
    userId?: StringFilter<"TaskHistory"> | string
    action?: StringFilter<"TaskHistory"> | string
    changes?: StringNullableFilter<"TaskHistory"> | string | null
    comment?: StringNullableFilter<"TaskHistory"> | string | null
    timestamp?: DateTimeFilter<"TaskHistory"> | Date | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
  }

  export type TaskHistoryOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    changes?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    task?: TaskOrderByWithRelationInput
  }

  export type TaskHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskHistoryWhereInput | TaskHistoryWhereInput[]
    OR?: TaskHistoryWhereInput[]
    NOT?: TaskHistoryWhereInput | TaskHistoryWhereInput[]
    taskId?: StringFilter<"TaskHistory"> | string
    userId?: StringFilter<"TaskHistory"> | string
    action?: StringFilter<"TaskHistory"> | string
    changes?: StringNullableFilter<"TaskHistory"> | string | null
    comment?: StringNullableFilter<"TaskHistory"> | string | null
    timestamp?: DateTimeFilter<"TaskHistory"> | Date | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
  }, "id">

  export type TaskHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    changes?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: TaskHistoryCountOrderByAggregateInput
    _max?: TaskHistoryMaxOrderByAggregateInput
    _min?: TaskHistoryMinOrderByAggregateInput
  }

  export type TaskHistoryScalarWhereWithAggregatesInput = {
    AND?: TaskHistoryScalarWhereWithAggregatesInput | TaskHistoryScalarWhereWithAggregatesInput[]
    OR?: TaskHistoryScalarWhereWithAggregatesInput[]
    NOT?: TaskHistoryScalarWhereWithAggregatesInput | TaskHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskHistory"> | string
    taskId?: StringWithAggregatesFilter<"TaskHistory"> | string
    userId?: StringWithAggregatesFilter<"TaskHistory"> | string
    action?: StringWithAggregatesFilter<"TaskHistory"> | string
    changes?: StringNullableWithAggregatesFilter<"TaskHistory"> | string | null
    comment?: StringNullableWithAggregatesFilter<"TaskHistory"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"TaskHistory"> | Date | string
  }

  export type UsuarioCreateInput = {
    id?: string
    nombre: string
    apellido: string
    email: string
    password?: string | null
    telefono?: string | null
    avatar?: string | null
    estado?: string
    departamento?: string | null
    cargo?: string | null
    region?: string
    autenticacionDosFactor?: boolean
    cambioPasswordRequerido?: boolean
    sesionesActivas?: number
    maxSesionesPermitidas?: number
    ultimoCambioPassword?: Date | string | null
    intentosFallidos?: number
    fechaCreacion?: Date | string
    fechaExpiracion?: Date | string | null
    ultimoAcceso?: Date | string | null
    updatedAt?: Date | string
    roles?: UsuarioRolCreateNestedManyWithoutUsuarioInput
    activosAcceso?: UsuarioActivoCreateNestedManyWithoutUsuarioInput
    logsAuditoria?: LogAuditoriaCreateNestedManyWithoutUsuarioInput
    respuestasCuestionario?: RespuestaCuestionarioCreateNestedManyWithoutRespondidoPorInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: string
    nombre: string
    apellido: string
    email: string
    password?: string | null
    telefono?: string | null
    avatar?: string | null
    estado?: string
    departamento?: string | null
    cargo?: string | null
    region?: string
    autenticacionDosFactor?: boolean
    cambioPasswordRequerido?: boolean
    sesionesActivas?: number
    maxSesionesPermitidas?: number
    ultimoCambioPassword?: Date | string | null
    intentosFallidos?: number
    fechaCreacion?: Date | string
    fechaExpiracion?: Date | string | null
    ultimoAcceso?: Date | string | null
    updatedAt?: Date | string
    roles?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput
    activosAcceso?: UsuarioActivoUncheckedCreateNestedManyWithoutUsuarioInput
    logsAuditoria?: LogAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    respuestasCuestionario?: RespuestaCuestionarioUncheckedCreateNestedManyWithoutRespondidoPorInput
  }

  export type UsuarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    region?: StringFieldUpdateOperationsInput | string
    autenticacionDosFactor?: BoolFieldUpdateOperationsInput | boolean
    cambioPasswordRequerido?: BoolFieldUpdateOperationsInput | boolean
    sesionesActivas?: IntFieldUpdateOperationsInput | number
    maxSesionesPermitidas?: IntFieldUpdateOperationsInput | number
    ultimoCambioPassword?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UsuarioRolUpdateManyWithoutUsuarioNestedInput
    activosAcceso?: UsuarioActivoUpdateManyWithoutUsuarioNestedInput
    logsAuditoria?: LogAuditoriaUpdateManyWithoutUsuarioNestedInput
    respuestasCuestionario?: RespuestaCuestionarioUpdateManyWithoutRespondidoPorNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    region?: StringFieldUpdateOperationsInput | string
    autenticacionDosFactor?: BoolFieldUpdateOperationsInput | boolean
    cambioPasswordRequerido?: BoolFieldUpdateOperationsInput | boolean
    sesionesActivas?: IntFieldUpdateOperationsInput | number
    maxSesionesPermitidas?: IntFieldUpdateOperationsInput | number
    ultimoCambioPassword?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput
    activosAcceso?: UsuarioActivoUncheckedUpdateManyWithoutUsuarioNestedInput
    logsAuditoria?: LogAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    respuestasCuestionario?: RespuestaCuestionarioUncheckedUpdateManyWithoutRespondidoPorNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: string
    nombre: string
    apellido: string
    email: string
    password?: string | null
    telefono?: string | null
    avatar?: string | null
    estado?: string
    departamento?: string | null
    cargo?: string | null
    region?: string
    autenticacionDosFactor?: boolean
    cambioPasswordRequerido?: boolean
    sesionesActivas?: number
    maxSesionesPermitidas?: number
    ultimoCambioPassword?: Date | string | null
    intentosFallidos?: number
    fechaCreacion?: Date | string
    fechaExpiracion?: Date | string | null
    ultimoAcceso?: Date | string | null
    updatedAt?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    region?: StringFieldUpdateOperationsInput | string
    autenticacionDosFactor?: BoolFieldUpdateOperationsInput | boolean
    cambioPasswordRequerido?: BoolFieldUpdateOperationsInput | boolean
    sesionesActivas?: IntFieldUpdateOperationsInput | number
    maxSesionesPermitidas?: IntFieldUpdateOperationsInput | number
    ultimoCambioPassword?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    region?: StringFieldUpdateOperationsInput | string
    autenticacionDosFactor?: BoolFieldUpdateOperationsInput | boolean
    cambioPasswordRequerido?: BoolFieldUpdateOperationsInput | boolean
    sesionesActivas?: IntFieldUpdateOperationsInput | number
    maxSesionesPermitidas?: IntFieldUpdateOperationsInput | number
    ultimoCambioPassword?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolCreateInput = {
    id?: string
    nombre: string
    descripcion: string
    nivelAcceso?: string
    region?: string
    tipoArbol?: string
    color?: string | null
    icono?: string | null
    activo?: boolean
    esRolSistema?: boolean
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    usuarios?: UsuarioRolCreateNestedManyWithoutRolInput
    permisos?: RolPermisoCreateNestedManyWithoutRolInput
  }

  export type RolUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion: string
    nivelAcceso?: string
    region?: string
    tipoArbol?: string
    color?: string | null
    icono?: string | null
    activo?: boolean
    esRolSistema?: boolean
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    usuarios?: UsuarioRolUncheckedCreateNestedManyWithoutRolInput
    permisos?: RolPermisoUncheckedCreateNestedManyWithoutRolInput
  }

  export type RolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    nivelAcceso?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    tipoArbol?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    esRolSistema?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarios?: UsuarioRolUpdateManyWithoutRolNestedInput
    permisos?: RolPermisoUpdateManyWithoutRolNestedInput
  }

  export type RolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    nivelAcceso?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    tipoArbol?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    esRolSistema?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarios?: UsuarioRolUncheckedUpdateManyWithoutRolNestedInput
    permisos?: RolPermisoUncheckedUpdateManyWithoutRolNestedInput
  }

  export type RolCreateManyInput = {
    id?: string
    nombre: string
    descripcion: string
    nivelAcceso?: string
    region?: string
    tipoArbol?: string
    color?: string | null
    icono?: string | null
    activo?: boolean
    esRolSistema?: boolean
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
  }

  export type RolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    nivelAcceso?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    tipoArbol?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    esRolSistema?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    nivelAcceso?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    tipoArbol?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    esRolSistema?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermisoCreateInput = {
    id?: string
    codigo: string
    nombre: string
    descripcion: string
    modulo: string
    categoria: string
    activo?: boolean
    padre?: PermisoCreateNestedOneWithoutHijosInput
    hijos?: PermisoCreateNestedManyWithoutPadreInput
    roles?: RolPermisoCreateNestedManyWithoutPermisoInput
  }

  export type PermisoUncheckedCreateInput = {
    id?: string
    codigo: string
    nombre: string
    descripcion: string
    modulo: string
    categoria: string
    activo?: boolean
    padreId?: string | null
    hijos?: PermisoUncheckedCreateNestedManyWithoutPadreInput
    roles?: RolPermisoUncheckedCreateNestedManyWithoutPermisoInput
  }

  export type PermisoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    padre?: PermisoUpdateOneWithoutHijosNestedInput
    hijos?: PermisoUpdateManyWithoutPadreNestedInput
    roles?: RolPermisoUpdateManyWithoutPermisoNestedInput
  }

  export type PermisoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    padreId?: NullableStringFieldUpdateOperationsInput | string | null
    hijos?: PermisoUncheckedUpdateManyWithoutPadreNestedInput
    roles?: RolPermisoUncheckedUpdateManyWithoutPermisoNestedInput
  }

  export type PermisoCreateManyInput = {
    id?: string
    codigo: string
    nombre: string
    descripcion: string
    modulo: string
    categoria: string
    activo?: boolean
    padreId?: string | null
  }

  export type PermisoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermisoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    padreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModuloCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    icono?: string | null
    orden?: number
    activo?: boolean
    permisoCreacion?: boolean
    permisoEdicion?: boolean
    permisoVisualizacion?: boolean
    permisoEliminacion?: boolean
  }

  export type ModuloUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    icono?: string | null
    orden?: number
    activo?: boolean
    permisoCreacion?: boolean
    permisoEdicion?: boolean
    permisoVisualizacion?: boolean
    permisoEliminacion?: boolean
  }

  export type ModuloUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    permisoCreacion?: BoolFieldUpdateOperationsInput | boolean
    permisoEdicion?: BoolFieldUpdateOperationsInput | boolean
    permisoVisualizacion?: BoolFieldUpdateOperationsInput | boolean
    permisoEliminacion?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuloUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    permisoCreacion?: BoolFieldUpdateOperationsInput | boolean
    permisoEdicion?: BoolFieldUpdateOperationsInput | boolean
    permisoVisualizacion?: BoolFieldUpdateOperationsInput | boolean
    permisoEliminacion?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuloCreateManyInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    icono?: string | null
    orden?: number
    activo?: boolean
    permisoCreacion?: boolean
    permisoEdicion?: boolean
    permisoVisualizacion?: boolean
    permisoEliminacion?: boolean
  }

  export type ModuloUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    permisoCreacion?: BoolFieldUpdateOperationsInput | boolean
    permisoEdicion?: BoolFieldUpdateOperationsInput | boolean
    permisoVisualizacion?: BoolFieldUpdateOperationsInput | boolean
    permisoEliminacion?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuloUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    permisoCreacion?: BoolFieldUpdateOperationsInput | boolean
    permisoEdicion?: BoolFieldUpdateOperationsInput | boolean
    permisoVisualizacion?: BoolFieldUpdateOperationsInput | boolean
    permisoEliminacion?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioRolCreateInput = {
    fechaAsignacion?: Date | string
    usuario: UsuarioCreateNestedOneWithoutRolesInput
    rol: RolCreateNestedOneWithoutUsuariosInput
  }

  export type UsuarioRolUncheckedCreateInput = {
    usuarioId: string
    rolId: string
    fechaAsignacion?: Date | string
  }

  export type UsuarioRolUpdateInput = {
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutRolesNestedInput
    rol?: RolUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type UsuarioRolUncheckedUpdateInput = {
    usuarioId?: StringFieldUpdateOperationsInput | string
    rolId?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioRolCreateManyInput = {
    usuarioId: string
    rolId: string
    fechaAsignacion?: Date | string
  }

  export type UsuarioRolUpdateManyMutationInput = {
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioRolUncheckedUpdateManyInput = {
    usuarioId?: StringFieldUpdateOperationsInput | string
    rolId?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolPermisoCreateInput = {
    rol: RolCreateNestedOneWithoutPermisosInput
    permiso: PermisoCreateNestedOneWithoutRolesInput
  }

  export type RolPermisoUncheckedCreateInput = {
    rolId: string
    permisoId: string
  }

  export type RolPermisoUpdateInput = {
    rol?: RolUpdateOneRequiredWithoutPermisosNestedInput
    permiso?: PermisoUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolPermisoUncheckedUpdateInput = {
    rolId?: StringFieldUpdateOperationsInput | string
    permisoId?: StringFieldUpdateOperationsInput | string
  }

  export type RolPermisoCreateManyInput = {
    rolId: string
    permisoId: string
  }

  export type RolPermisoUpdateManyMutationInput = {

  }

  export type RolPermisoUncheckedUpdateManyInput = {
    rolId?: StringFieldUpdateOperationsInput | string
    permisoId?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioActivoCreateInput = {
    nivelAcceso?: string
    usuario: UsuarioCreateNestedOneWithoutActivosAccesoInput
    activo: ActivoAccesoCreateNestedOneWithoutUsuariosInput
  }

  export type UsuarioActivoUncheckedCreateInput = {
    usuarioId: string
    activoId: string
    nivelAcceso?: string
  }

  export type UsuarioActivoUpdateInput = {
    nivelAcceso?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateOneRequiredWithoutActivosAccesoNestedInput
    activo?: ActivoAccesoUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type UsuarioActivoUncheckedUpdateInput = {
    usuarioId?: StringFieldUpdateOperationsInput | string
    activoId?: StringFieldUpdateOperationsInput | string
    nivelAcceso?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioActivoCreateManyInput = {
    usuarioId: string
    activoId: string
    nivelAcceso?: string
  }

  export type UsuarioActivoUpdateManyMutationInput = {
    nivelAcceso?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioActivoUncheckedUpdateManyInput = {
    usuarioId?: StringFieldUpdateOperationsInput | string
    activoId?: StringFieldUpdateOperationsInput | string
    nivelAcceso?: StringFieldUpdateOperationsInput | string
  }

  export type LogAuditoriaCreateInput = {
    id?: string
    accion: string
    entidad: string
    entidadId: string
    entidadNombre: string
    detalles?: string | null
    ip?: string | null
    userAgent?: string | null
    fecha?: Date | string
    usuario: UsuarioCreateNestedOneWithoutLogsAuditoriaInput
  }

  export type LogAuditoriaUncheckedCreateInput = {
    id?: string
    accion: string
    entidad: string
    entidadId: string
    entidadNombre: string
    detalles?: string | null
    ip?: string | null
    userAgent?: string | null
    fecha?: Date | string
    usuarioId: string
  }

  export type LogAuditoriaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: StringFieldUpdateOperationsInput | string
    entidadNombre?: StringFieldUpdateOperationsInput | string
    detalles?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutLogsAuditoriaNestedInput
  }

  export type LogAuditoriaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: StringFieldUpdateOperationsInput | string
    entidadNombre?: StringFieldUpdateOperationsInput | string
    detalles?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: StringFieldUpdateOperationsInput | string
  }

  export type LogAuditoriaCreateManyInput = {
    id?: string
    accion: string
    entidad: string
    entidadId: string
    entidadNombre: string
    detalles?: string | null
    ip?: string | null
    userAgent?: string | null
    fecha?: Date | string
    usuarioId: string
  }

  export type LogAuditoriaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: StringFieldUpdateOperationsInput | string
    entidadNombre?: StringFieldUpdateOperationsInput | string
    detalles?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogAuditoriaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: StringFieldUpdateOperationsInput | string
    entidadNombre?: StringFieldUpdateOperationsInput | string
    detalles?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: StringFieldUpdateOperationsInput | string
  }

  export type ActivoAccesoCreateInput = {
    id?: string
    nombre: string
    tipo: string
    icono?: string | null
    nivelAcceso?: string | null
    expanded?: boolean
    padre?: ActivoAccesoCreateNestedOneWithoutHijosInput
    hijos?: ActivoAccesoCreateNestedManyWithoutPadreInput
    usuarios?: UsuarioActivoCreateNestedManyWithoutActivoInput
  }

  export type ActivoAccesoUncheckedCreateInput = {
    id?: string
    nombre: string
    tipo: string
    icono?: string | null
    nivelAcceso?: string | null
    expanded?: boolean
    padreId?: string | null
    hijos?: ActivoAccesoUncheckedCreateNestedManyWithoutPadreInput
    usuarios?: UsuarioActivoUncheckedCreateNestedManyWithoutActivoInput
  }

  export type ActivoAccesoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    expanded?: BoolFieldUpdateOperationsInput | boolean
    padre?: ActivoAccesoUpdateOneWithoutHijosNestedInput
    hijos?: ActivoAccesoUpdateManyWithoutPadreNestedInput
    usuarios?: UsuarioActivoUpdateManyWithoutActivoNestedInput
  }

  export type ActivoAccesoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    expanded?: BoolFieldUpdateOperationsInput | boolean
    padreId?: NullableStringFieldUpdateOperationsInput | string | null
    hijos?: ActivoAccesoUncheckedUpdateManyWithoutPadreNestedInput
    usuarios?: UsuarioActivoUncheckedUpdateManyWithoutActivoNestedInput
  }

  export type ActivoAccesoCreateManyInput = {
    id?: string
    nombre: string
    tipo: string
    icono?: string | null
    nivelAcceso?: string | null
    expanded?: boolean
    padreId?: string | null
  }

  export type ActivoAccesoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    expanded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActivoAccesoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    expanded?: BoolFieldUpdateOperationsInput | boolean
    padreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantillaActivoCreateInput = {
    id?: string
    nombre: string
    tipoActivo: string
    descripcion: string
    icono?: string | null
    color?: string | null
    propiedades: string
    activo?: boolean
    fechaCreacion?: Date | string
    activos?: ActivoCreateNestedManyWithoutPlantillaInput
  }

  export type PlantillaActivoUncheckedCreateInput = {
    id?: string
    nombre: string
    tipoActivo: string
    descripcion: string
    icono?: string | null
    color?: string | null
    propiedades: string
    activo?: boolean
    fechaCreacion?: Date | string
    activos?: ActivoUncheckedCreateNestedManyWithoutPlantillaInput
  }

  export type PlantillaActivoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipoActivo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    propiedades?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    activos?: ActivoUpdateManyWithoutPlantillaNestedInput
  }

  export type PlantillaActivoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipoActivo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    propiedades?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    activos?: ActivoUncheckedUpdateManyWithoutPlantillaNestedInput
  }

  export type PlantillaActivoCreateManyInput = {
    id?: string
    nombre: string
    tipoActivo: string
    descripcion: string
    icono?: string | null
    color?: string | null
    propiedades: string
    activo?: boolean
    fechaCreacion?: Date | string
  }

  export type PlantillaActivoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipoActivo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    propiedades?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantillaActivoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipoActivo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    propiedades?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivoCreateInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    criticidad: string
    responsable: string
    departamento: string
    fechaRegistro?: Date | string
    updatedAt?: Date | string
    propiedadesCustom?: string | null
    plantilla?: PlantillaActivoCreateNestedOneWithoutActivosInput
    riesgos?: RiesgoCreateNestedManyWithoutActivoInput
    incidentes?: IncidenteCreateNestedManyWithoutActivoInput
    defectos?: DefectoCreateNestedManyWithoutActivoInput
  }

  export type ActivoUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    criticidad: string
    responsable: string
    departamento: string
    fechaRegistro?: Date | string
    updatedAt?: Date | string
    plantillaId?: string | null
    propiedadesCustom?: string | null
    riesgos?: RiesgoUncheckedCreateNestedManyWithoutActivoInput
    incidentes?: IncidenteUncheckedCreateNestedManyWithoutActivoInput
    defectos?: DefectoUncheckedCreateNestedManyWithoutActivoInput
  }

  export type ActivoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    criticidad?: StringFieldUpdateOperationsInput | string
    responsable?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propiedadesCustom?: NullableStringFieldUpdateOperationsInput | string | null
    plantilla?: PlantillaActivoUpdateOneWithoutActivosNestedInput
    riesgos?: RiesgoUpdateManyWithoutActivoNestedInput
    incidentes?: IncidenteUpdateManyWithoutActivoNestedInput
    defectos?: DefectoUpdateManyWithoutActivoNestedInput
  }

  export type ActivoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    criticidad?: StringFieldUpdateOperationsInput | string
    responsable?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plantillaId?: NullableStringFieldUpdateOperationsInput | string | null
    propiedadesCustom?: NullableStringFieldUpdateOperationsInput | string | null
    riesgos?: RiesgoUncheckedUpdateManyWithoutActivoNestedInput
    incidentes?: IncidenteUncheckedUpdateManyWithoutActivoNestedInput
    defectos?: DefectoUncheckedUpdateManyWithoutActivoNestedInput
  }

  export type ActivoCreateManyInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    criticidad: string
    responsable: string
    departamento: string
    fechaRegistro?: Date | string
    updatedAt?: Date | string
    plantillaId?: string | null
    propiedadesCustom?: string | null
  }

  export type ActivoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    criticidad?: StringFieldUpdateOperationsInput | string
    responsable?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propiedadesCustom?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    criticidad?: StringFieldUpdateOperationsInput | string
    responsable?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plantillaId?: NullableStringFieldUpdateOperationsInput | string | null
    propiedadesCustom?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RiesgoCreateInput = {
    id?: string
    descripcion: string
    probabilidad: number
    impacto: number
    estado: string
    fechaIdentificacion?: Date | string
    responsable: string
    updatedAt?: Date | string
    activo: ActivoCreateNestedOneWithoutRiesgosInput
  }

  export type RiesgoUncheckedCreateInput = {
    id?: string
    activoId: string
    descripcion: string
    probabilidad: number
    impacto: number
    estado: string
    fechaIdentificacion?: Date | string
    responsable: string
    updatedAt?: Date | string
  }

  export type RiesgoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    probabilidad?: IntFieldUpdateOperationsInput | number
    impacto?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    fechaIdentificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    responsable?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: ActivoUpdateOneRequiredWithoutRiesgosNestedInput
  }

  export type RiesgoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activoId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    probabilidad?: IntFieldUpdateOperationsInput | number
    impacto?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    fechaIdentificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    responsable?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiesgoCreateManyInput = {
    id?: string
    activoId: string
    descripcion: string
    probabilidad: number
    impacto: number
    estado: string
    fechaIdentificacion?: Date | string
    responsable: string
    updatedAt?: Date | string
  }

  export type RiesgoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    probabilidad?: IntFieldUpdateOperationsInput | number
    impacto?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    fechaIdentificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    responsable?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiesgoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    activoId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    probabilidad?: IntFieldUpdateOperationsInput | number
    impacto?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    fechaIdentificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    responsable?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidenteCreateInput = {
    id?: string
    titulo: string
    descripcion: string
    severidad: string
    estado: string
    fechaReporte?: Date | string
    reportadoPor: string
    updatedAt?: Date | string
    activo: ActivoCreateNestedOneWithoutIncidentesInput
  }

  export type IncidenteUncheckedCreateInput = {
    id?: string
    activoId: string
    titulo: string
    descripcion: string
    severidad: string
    estado: string
    fechaReporte?: Date | string
    reportadoPor: string
    updatedAt?: Date | string
  }

  export type IncidenteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    severidad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
    reportadoPor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: ActivoUpdateOneRequiredWithoutIncidentesNestedInput
  }

  export type IncidenteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activoId?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    severidad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
    reportadoPor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidenteCreateManyInput = {
    id?: string
    activoId: string
    titulo: string
    descripcion: string
    severidad: string
    estado: string
    fechaReporte?: Date | string
    reportadoPor: string
    updatedAt?: Date | string
  }

  export type IncidenteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    severidad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
    reportadoPor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidenteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    activoId?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    severidad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
    reportadoPor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectoCreateInput = {
    id?: string
    titulo: string
    descripcion: string
    tipo: string
    prioridad: string
    estado: string
    fechaDeteccion?: Date | string
    detectadoPor: string
    updatedAt?: Date | string
    activo: ActivoCreateNestedOneWithoutDefectosInput
  }

  export type DefectoUncheckedCreateInput = {
    id?: string
    activoId: string
    titulo: string
    descripcion: string
    tipo: string
    prioridad: string
    estado: string
    fechaDeteccion?: Date | string
    detectadoPor: string
    updatedAt?: Date | string
  }

  export type DefectoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    prioridad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaDeteccion?: DateTimeFieldUpdateOperationsInput | Date | string
    detectadoPor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: ActivoUpdateOneRequiredWithoutDefectosNestedInput
  }

  export type DefectoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activoId?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    prioridad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaDeteccion?: DateTimeFieldUpdateOperationsInput | Date | string
    detectadoPor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectoCreateManyInput = {
    id?: string
    activoId: string
    titulo: string
    descripcion: string
    tipo: string
    prioridad: string
    estado: string
    fechaDeteccion?: Date | string
    detectadoPor: string
    updatedAt?: Date | string
  }

  export type DefectoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    prioridad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaDeteccion?: DateTimeFieldUpdateOperationsInput | Date | string
    detectadoPor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    activoId?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    prioridad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaDeteccion?: DateTimeFieldUpdateOperationsInput | Date | string
    detectadoPor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganigramaCreateInput = {
    id?: string
    nombre: string
    descripcion: string
    fechaCreacion?: Date | string
    updatedAt?: Date | string
    nodos?: NodoOrganigramaCreateNestedManyWithoutOrganigramaInput
  }

  export type OrganigramaUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion: string
    fechaCreacion?: Date | string
    updatedAt?: Date | string
    nodos?: NodoOrganigramaUncheckedCreateNestedManyWithoutOrganigramaInput
  }

  export type OrganigramaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodos?: NodoOrganigramaUpdateManyWithoutOrganigramaNestedInput
  }

  export type OrganigramaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodos?: NodoOrganigramaUncheckedUpdateManyWithoutOrganigramaNestedInput
  }

  export type OrganigramaCreateManyInput = {
    id?: string
    nombre: string
    descripcion: string
    fechaCreacion?: Date | string
    updatedAt?: Date | string
  }

  export type OrganigramaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganigramaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodoOrganigramaCreateInput = {
    id?: string
    nombre: string
    cargo: string
    departamento: string
    email: string
    telefono?: string | null
    foto?: string | null
    organigrama: OrganigramaCreateNestedOneWithoutNodosInput
    padre?: NodoOrganigramaCreateNestedOneWithoutSubordinadosInput
    subordinados?: NodoOrganigramaCreateNestedManyWithoutPadreInput
  }

  export type NodoOrganigramaUncheckedCreateInput = {
    id?: string
    organigramaId: string
    nombre: string
    cargo: string
    departamento: string
    email: string
    telefono?: string | null
    foto?: string | null
    padreId?: string | null
    subordinados?: NodoOrganigramaUncheckedCreateNestedManyWithoutPadreInput
  }

  export type NodoOrganigramaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    organigrama?: OrganigramaUpdateOneRequiredWithoutNodosNestedInput
    padre?: NodoOrganigramaUpdateOneWithoutSubordinadosNestedInput
    subordinados?: NodoOrganigramaUpdateManyWithoutPadreNestedInput
  }

  export type NodoOrganigramaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organigramaId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    padreId?: NullableStringFieldUpdateOperationsInput | string | null
    subordinados?: NodoOrganigramaUncheckedUpdateManyWithoutPadreNestedInput
  }

  export type NodoOrganigramaCreateManyInput = {
    id?: string
    organigramaId: string
    nombre: string
    cargo: string
    departamento: string
    email: string
    telefono?: string | null
    foto?: string | null
    padreId?: string | null
  }

  export type NodoOrganigramaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NodoOrganigramaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organigramaId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    padreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarcoNormativoCreateInput = {
    id?: string
    nombre: string
    acronimo: string
    version: string
    fechaVigencia: Date | string
    descripcion: string
    activo?: boolean
    fechaCreacion?: Date | string
    requisitos?: RequisitoNormativoCreateNestedManyWithoutMarcoInput
    cuestionarios?: CuestionarioCreateNestedManyWithoutMarcoNormativoInput
  }

  export type MarcoNormativoUncheckedCreateInput = {
    id?: string
    nombre: string
    acronimo: string
    version: string
    fechaVigencia: Date | string
    descripcion: string
    activo?: boolean
    fechaCreacion?: Date | string
    requisitos?: RequisitoNormativoUncheckedCreateNestedManyWithoutMarcoInput
    cuestionarios?: CuestionarioUncheckedCreateNestedManyWithoutMarcoNormativoInput
  }

  export type MarcoNormativoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    acronimo?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    fechaVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    requisitos?: RequisitoNormativoUpdateManyWithoutMarcoNestedInput
    cuestionarios?: CuestionarioUpdateManyWithoutMarcoNormativoNestedInput
  }

  export type MarcoNormativoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    acronimo?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    fechaVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    requisitos?: RequisitoNormativoUncheckedUpdateManyWithoutMarcoNestedInput
    cuestionarios?: CuestionarioUncheckedUpdateManyWithoutMarcoNormativoNestedInput
  }

  export type MarcoNormativoCreateManyInput = {
    id?: string
    nombre: string
    acronimo: string
    version: string
    fechaVigencia: Date | string
    descripcion: string
    activo?: boolean
    fechaCreacion?: Date | string
  }

  export type MarcoNormativoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    acronimo?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    fechaVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarcoNormativoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    acronimo?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    fechaVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequisitoNormativoCreateInput = {
    id?: string
    codigo: string
    nombre: string
    descripcion: string
    controlesAsociados: string
    marco: MarcoNormativoCreateNestedOneWithoutRequisitosInput
  }

  export type RequisitoNormativoUncheckedCreateInput = {
    id?: string
    codigo: string
    nombre: string
    descripcion: string
    marcoId: string
    controlesAsociados: string
  }

  export type RequisitoNormativoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    controlesAsociados?: StringFieldUpdateOperationsInput | string
    marco?: MarcoNormativoUpdateOneRequiredWithoutRequisitosNestedInput
  }

  export type RequisitoNormativoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    marcoId?: StringFieldUpdateOperationsInput | string
    controlesAsociados?: StringFieldUpdateOperationsInput | string
  }

  export type RequisitoNormativoCreateManyInput = {
    id?: string
    codigo: string
    nombre: string
    descripcion: string
    marcoId: string
    controlesAsociados: string
  }

  export type RequisitoNormativoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    controlesAsociados?: StringFieldUpdateOperationsInput | string
  }

  export type RequisitoNormativoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    marcoId?: StringFieldUpdateOperationsInput | string
    controlesAsociados?: StringFieldUpdateOperationsInput | string
  }

  export type CuestionarioCreateInput = {
    id?: string
    nombre: string
    descripcion: string
    categoria: string
    tipo: string
    tipoEvaluacion: string
    estado?: string
    periodicidad: string
    tasaCompletado?: number
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    umbrales: string
    areasObjetivo: string
    responsables: string
    marcoNormativo?: MarcoNormativoCreateNestedOneWithoutCuestionariosInput
    secciones?: SeccionCreateNestedManyWithoutCuestionarioInput
    asignaciones?: AsignacionCuestionarioCreateNestedManyWithoutCuestionarioInput
  }

  export type CuestionarioUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion: string
    categoria: string
    tipo: string
    tipoEvaluacion: string
    estado?: string
    marcoNormativoId?: string | null
    periodicidad: string
    tasaCompletado?: number
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    umbrales: string
    areasObjetivo: string
    responsables: string
    secciones?: SeccionUncheckedCreateNestedManyWithoutCuestionarioInput
    asignaciones?: AsignacionCuestionarioUncheckedCreateNestedManyWithoutCuestionarioInput
  }

  export type CuestionarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tipoEvaluacion?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    periodicidad?: StringFieldUpdateOperationsInput | string
    tasaCompletado?: FloatFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    umbrales?: StringFieldUpdateOperationsInput | string
    areasObjetivo?: StringFieldUpdateOperationsInput | string
    responsables?: StringFieldUpdateOperationsInput | string
    marcoNormativo?: MarcoNormativoUpdateOneWithoutCuestionariosNestedInput
    secciones?: SeccionUpdateManyWithoutCuestionarioNestedInput
    asignaciones?: AsignacionCuestionarioUpdateManyWithoutCuestionarioNestedInput
  }

  export type CuestionarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tipoEvaluacion?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    marcoNormativoId?: NullableStringFieldUpdateOperationsInput | string | null
    periodicidad?: StringFieldUpdateOperationsInput | string
    tasaCompletado?: FloatFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    umbrales?: StringFieldUpdateOperationsInput | string
    areasObjetivo?: StringFieldUpdateOperationsInput | string
    responsables?: StringFieldUpdateOperationsInput | string
    secciones?: SeccionUncheckedUpdateManyWithoutCuestionarioNestedInput
    asignaciones?: AsignacionCuestionarioUncheckedUpdateManyWithoutCuestionarioNestedInput
  }

  export type CuestionarioCreateManyInput = {
    id?: string
    nombre: string
    descripcion: string
    categoria: string
    tipo: string
    tipoEvaluacion: string
    estado?: string
    marcoNormativoId?: string | null
    periodicidad: string
    tasaCompletado?: number
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    umbrales: string
    areasObjetivo: string
    responsables: string
  }

  export type CuestionarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tipoEvaluacion?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    periodicidad?: StringFieldUpdateOperationsInput | string
    tasaCompletado?: FloatFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    umbrales?: StringFieldUpdateOperationsInput | string
    areasObjetivo?: StringFieldUpdateOperationsInput | string
    responsables?: StringFieldUpdateOperationsInput | string
  }

  export type CuestionarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tipoEvaluacion?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    marcoNormativoId?: NullableStringFieldUpdateOperationsInput | string | null
    periodicidad?: StringFieldUpdateOperationsInput | string
    tasaCompletado?: FloatFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    umbrales?: StringFieldUpdateOperationsInput | string
    areasObjetivo?: StringFieldUpdateOperationsInput | string
    responsables?: StringFieldUpdateOperationsInput | string
  }

  export type SeccionCreateInput = {
    id?: string
    nombre: string
    descripcion: string
    peso?: number
    requerida?: boolean
    orden?: number
    cuestionario: CuestionarioCreateNestedOneWithoutSeccionesInput
    preguntas?: PreguntaCreateNestedManyWithoutSeccionInput
  }

  export type SeccionUncheckedCreateInput = {
    id?: string
    cuestionarioId: string
    nombre: string
    descripcion: string
    peso?: number
    requerida?: boolean
    orden?: number
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutSeccionInput
  }

  export type SeccionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    peso?: FloatFieldUpdateOperationsInput | number
    requerida?: BoolFieldUpdateOperationsInput | boolean
    orden?: IntFieldUpdateOperationsInput | number
    cuestionario?: CuestionarioUpdateOneRequiredWithoutSeccionesNestedInput
    preguntas?: PreguntaUpdateManyWithoutSeccionNestedInput
  }

  export type SeccionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    peso?: FloatFieldUpdateOperationsInput | number
    requerida?: BoolFieldUpdateOperationsInput | boolean
    orden?: IntFieldUpdateOperationsInput | number
    preguntas?: PreguntaUncheckedUpdateManyWithoutSeccionNestedInput
  }

  export type SeccionCreateManyInput = {
    id?: string
    cuestionarioId: string
    nombre: string
    descripcion: string
    peso?: number
    requerida?: boolean
    orden?: number
  }

  export type SeccionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    peso?: FloatFieldUpdateOperationsInput | number
    requerida?: BoolFieldUpdateOperationsInput | boolean
    orden?: IntFieldUpdateOperationsInput | number
  }

  export type SeccionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    peso?: FloatFieldUpdateOperationsInput | number
    requerida?: BoolFieldUpdateOperationsInput | boolean
    orden?: IntFieldUpdateOperationsInput | number
  }

  export type PreguntaCreateInput = {
    id?: string
    texto: string
    tipo: string
    requerida?: boolean
    peso?: number
    opciones?: string | null
    escalaMin?: number | null
    escalaMax?: number | null
    ayuda?: string | null
    placeholder?: string | null
    requisitoNormativoId?: string | null
    controlAsociado?: string | null
    requiereEvidencia?: boolean
    maxStars?: number | null
    leftAnchor?: string | null
    rightAnchor?: string | null
    likertLabels?: string | null
    displayConditionQuestionId?: string | null
    displayConditionAnswer?: string | null
    logicaCondicional?: string | null
    isCalculated?: boolean
    formula?: string | null
    orden?: number
    seccion: SeccionCreateNestedOneWithoutPreguntasInput
    respuestas?: RespuestaPreguntaCreateNestedManyWithoutPreguntaInput
    hallazgos?: HallazgoCreateNestedManyWithoutPreguntaInput
  }

  export type PreguntaUncheckedCreateInput = {
    id?: string
    seccionId: string
    texto: string
    tipo: string
    requerida?: boolean
    peso?: number
    opciones?: string | null
    escalaMin?: number | null
    escalaMax?: number | null
    ayuda?: string | null
    placeholder?: string | null
    requisitoNormativoId?: string | null
    controlAsociado?: string | null
    requiereEvidencia?: boolean
    maxStars?: number | null
    leftAnchor?: string | null
    rightAnchor?: string | null
    likertLabels?: string | null
    displayConditionQuestionId?: string | null
    displayConditionAnswer?: string | null
    logicaCondicional?: string | null
    isCalculated?: boolean
    formula?: string | null
    orden?: number
    respuestas?: RespuestaPreguntaUncheckedCreateNestedManyWithoutPreguntaInput
    hallazgos?: HallazgoUncheckedCreateNestedManyWithoutPreguntaInput
  }

  export type PreguntaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    requerida?: BoolFieldUpdateOperationsInput | boolean
    peso?: FloatFieldUpdateOperationsInput | number
    opciones?: NullableStringFieldUpdateOperationsInput | string | null
    escalaMin?: NullableIntFieldUpdateOperationsInput | number | null
    escalaMax?: NullableIntFieldUpdateOperationsInput | number | null
    ayuda?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    requisitoNormativoId?: NullableStringFieldUpdateOperationsInput | string | null
    controlAsociado?: NullableStringFieldUpdateOperationsInput | string | null
    requiereEvidencia?: BoolFieldUpdateOperationsInput | boolean
    maxStars?: NullableIntFieldUpdateOperationsInput | number | null
    leftAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    rightAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    likertLabels?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    logicaCondicional?: NullableStringFieldUpdateOperationsInput | string | null
    isCalculated?: BoolFieldUpdateOperationsInput | boolean
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    seccion?: SeccionUpdateOneRequiredWithoutPreguntasNestedInput
    respuestas?: RespuestaPreguntaUpdateManyWithoutPreguntaNestedInput
    hallazgos?: HallazgoUpdateManyWithoutPreguntaNestedInput
  }

  export type PreguntaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seccionId?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    requerida?: BoolFieldUpdateOperationsInput | boolean
    peso?: FloatFieldUpdateOperationsInput | number
    opciones?: NullableStringFieldUpdateOperationsInput | string | null
    escalaMin?: NullableIntFieldUpdateOperationsInput | number | null
    escalaMax?: NullableIntFieldUpdateOperationsInput | number | null
    ayuda?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    requisitoNormativoId?: NullableStringFieldUpdateOperationsInput | string | null
    controlAsociado?: NullableStringFieldUpdateOperationsInput | string | null
    requiereEvidencia?: BoolFieldUpdateOperationsInput | boolean
    maxStars?: NullableIntFieldUpdateOperationsInput | number | null
    leftAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    rightAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    likertLabels?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    logicaCondicional?: NullableStringFieldUpdateOperationsInput | string | null
    isCalculated?: BoolFieldUpdateOperationsInput | boolean
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    respuestas?: RespuestaPreguntaUncheckedUpdateManyWithoutPreguntaNestedInput
    hallazgos?: HallazgoUncheckedUpdateManyWithoutPreguntaNestedInput
  }

  export type PreguntaCreateManyInput = {
    id?: string
    seccionId: string
    texto: string
    tipo: string
    requerida?: boolean
    peso?: number
    opciones?: string | null
    escalaMin?: number | null
    escalaMax?: number | null
    ayuda?: string | null
    placeholder?: string | null
    requisitoNormativoId?: string | null
    controlAsociado?: string | null
    requiereEvidencia?: boolean
    maxStars?: number | null
    leftAnchor?: string | null
    rightAnchor?: string | null
    likertLabels?: string | null
    displayConditionQuestionId?: string | null
    displayConditionAnswer?: string | null
    logicaCondicional?: string | null
    isCalculated?: boolean
    formula?: string | null
    orden?: number
  }

  export type PreguntaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    requerida?: BoolFieldUpdateOperationsInput | boolean
    peso?: FloatFieldUpdateOperationsInput | number
    opciones?: NullableStringFieldUpdateOperationsInput | string | null
    escalaMin?: NullableIntFieldUpdateOperationsInput | number | null
    escalaMax?: NullableIntFieldUpdateOperationsInput | number | null
    ayuda?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    requisitoNormativoId?: NullableStringFieldUpdateOperationsInput | string | null
    controlAsociado?: NullableStringFieldUpdateOperationsInput | string | null
    requiereEvidencia?: BoolFieldUpdateOperationsInput | boolean
    maxStars?: NullableIntFieldUpdateOperationsInput | number | null
    leftAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    rightAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    likertLabels?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    logicaCondicional?: NullableStringFieldUpdateOperationsInput | string | null
    isCalculated?: BoolFieldUpdateOperationsInput | boolean
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
  }

  export type PreguntaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seccionId?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    requerida?: BoolFieldUpdateOperationsInput | boolean
    peso?: FloatFieldUpdateOperationsInput | number
    opciones?: NullableStringFieldUpdateOperationsInput | string | null
    escalaMin?: NullableIntFieldUpdateOperationsInput | number | null
    escalaMax?: NullableIntFieldUpdateOperationsInput | number | null
    ayuda?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    requisitoNormativoId?: NullableStringFieldUpdateOperationsInput | string | null
    controlAsociado?: NullableStringFieldUpdateOperationsInput | string | null
    requiereEvidencia?: BoolFieldUpdateOperationsInput | boolean
    maxStars?: NullableIntFieldUpdateOperationsInput | number | null
    leftAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    rightAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    likertLabels?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    logicaCondicional?: NullableStringFieldUpdateOperationsInput | string | null
    isCalculated?: BoolFieldUpdateOperationsInput | boolean
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
  }

  export type AsignacionCuestionarioCreateInput = {
    id?: string
    cuestionarioIds?: string | null
    titulo: string
    descripcion?: string | null
    tipoRevision: string
    usuariosAsignados: string
    usuariosAsignadosNombres: string
    emailsExternos?: string | null
    contrasenaAcceso?: string | null
    activosObjetivo: string
    activosObjetivoNombres: string
    procesosObjetivo: string
    procesosObjetivoNombres: string
    aprobadores: string
    aprobadoresNombres: string
    evaluadosInternos?: string | null
    evaluadosInternosNombres?: string | null
    areaId: string
    areaNombre: string
    responsableId: string
    responsableNombre: string
    fechaAsignacion?: Date | string
    fechaInicio: Date | string
    fechaVencimiento: Date | string
    estado?: string
    progreso?: number
    instrucciones?: string | null
    recordatorios?: boolean
    tokenAccesoExterno?: string | null
    recurrencia?: string | null
    cuestionario: CuestionarioCreateNestedOneWithoutAsignacionesInput
    evaluadosExternos?: EvaluadoExternoCreateNestedManyWithoutAsignacionInput
    respuestas?: RespuestaCuestionarioCreateNestedManyWithoutAsignacionInput
    mensajesChat?: MensajeChatCreateNestedManyWithoutAsignacionInput
  }

  export type AsignacionCuestionarioUncheckedCreateInput = {
    id?: string
    cuestionarioId: string
    cuestionarioIds?: string | null
    titulo: string
    descripcion?: string | null
    tipoRevision: string
    usuariosAsignados: string
    usuariosAsignadosNombres: string
    emailsExternos?: string | null
    contrasenaAcceso?: string | null
    activosObjetivo: string
    activosObjetivoNombres: string
    procesosObjetivo: string
    procesosObjetivoNombres: string
    aprobadores: string
    aprobadoresNombres: string
    evaluadosInternos?: string | null
    evaluadosInternosNombres?: string | null
    areaId: string
    areaNombre: string
    responsableId: string
    responsableNombre: string
    fechaAsignacion?: Date | string
    fechaInicio: Date | string
    fechaVencimiento: Date | string
    estado?: string
    progreso?: number
    instrucciones?: string | null
    recordatorios?: boolean
    tokenAccesoExterno?: string | null
    recurrencia?: string | null
    evaluadosExternos?: EvaluadoExternoUncheckedCreateNestedManyWithoutAsignacionInput
    respuestas?: RespuestaCuestionarioUncheckedCreateNestedManyWithoutAsignacionInput
    mensajesChat?: MensajeChatUncheckedCreateNestedManyWithoutAsignacionInput
  }

  export type AsignacionCuestionarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioIds?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipoRevision?: StringFieldUpdateOperationsInput | string
    usuariosAsignados?: StringFieldUpdateOperationsInput | string
    usuariosAsignadosNombres?: StringFieldUpdateOperationsInput | string
    emailsExternos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasenaAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activosObjetivo?: StringFieldUpdateOperationsInput | string
    activosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    procesosObjetivo?: StringFieldUpdateOperationsInput | string
    procesosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    aprobadores?: StringFieldUpdateOperationsInput | string
    aprobadoresNombres?: StringFieldUpdateOperationsInput | string
    evaluadosInternos?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosInternosNombres?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: StringFieldUpdateOperationsInput | string
    areaNombre?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    responsableNombre?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    instrucciones?: NullableStringFieldUpdateOperationsInput | string | null
    recordatorios?: BoolFieldUpdateOperationsInput | boolean
    tokenAccesoExterno?: NullableStringFieldUpdateOperationsInput | string | null
    recurrencia?: NullableStringFieldUpdateOperationsInput | string | null
    cuestionario?: CuestionarioUpdateOneRequiredWithoutAsignacionesNestedInput
    evaluadosExternos?: EvaluadoExternoUpdateManyWithoutAsignacionNestedInput
    respuestas?: RespuestaCuestionarioUpdateManyWithoutAsignacionNestedInput
    mensajesChat?: MensajeChatUpdateManyWithoutAsignacionNestedInput
  }

  export type AsignacionCuestionarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    cuestionarioIds?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipoRevision?: StringFieldUpdateOperationsInput | string
    usuariosAsignados?: StringFieldUpdateOperationsInput | string
    usuariosAsignadosNombres?: StringFieldUpdateOperationsInput | string
    emailsExternos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasenaAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activosObjetivo?: StringFieldUpdateOperationsInput | string
    activosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    procesosObjetivo?: StringFieldUpdateOperationsInput | string
    procesosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    aprobadores?: StringFieldUpdateOperationsInput | string
    aprobadoresNombres?: StringFieldUpdateOperationsInput | string
    evaluadosInternos?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosInternosNombres?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: StringFieldUpdateOperationsInput | string
    areaNombre?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    responsableNombre?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    instrucciones?: NullableStringFieldUpdateOperationsInput | string | null
    recordatorios?: BoolFieldUpdateOperationsInput | boolean
    tokenAccesoExterno?: NullableStringFieldUpdateOperationsInput | string | null
    recurrencia?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosExternos?: EvaluadoExternoUncheckedUpdateManyWithoutAsignacionNestedInput
    respuestas?: RespuestaCuestionarioUncheckedUpdateManyWithoutAsignacionNestedInput
    mensajesChat?: MensajeChatUncheckedUpdateManyWithoutAsignacionNestedInput
  }

  export type AsignacionCuestionarioCreateManyInput = {
    id?: string
    cuestionarioId: string
    cuestionarioIds?: string | null
    titulo: string
    descripcion?: string | null
    tipoRevision: string
    usuariosAsignados: string
    usuariosAsignadosNombres: string
    emailsExternos?: string | null
    contrasenaAcceso?: string | null
    activosObjetivo: string
    activosObjetivoNombres: string
    procesosObjetivo: string
    procesosObjetivoNombres: string
    aprobadores: string
    aprobadoresNombres: string
    evaluadosInternos?: string | null
    evaluadosInternosNombres?: string | null
    areaId: string
    areaNombre: string
    responsableId: string
    responsableNombre: string
    fechaAsignacion?: Date | string
    fechaInicio: Date | string
    fechaVencimiento: Date | string
    estado?: string
    progreso?: number
    instrucciones?: string | null
    recordatorios?: boolean
    tokenAccesoExterno?: string | null
    recurrencia?: string | null
  }

  export type AsignacionCuestionarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioIds?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipoRevision?: StringFieldUpdateOperationsInput | string
    usuariosAsignados?: StringFieldUpdateOperationsInput | string
    usuariosAsignadosNombres?: StringFieldUpdateOperationsInput | string
    emailsExternos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasenaAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activosObjetivo?: StringFieldUpdateOperationsInput | string
    activosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    procesosObjetivo?: StringFieldUpdateOperationsInput | string
    procesosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    aprobadores?: StringFieldUpdateOperationsInput | string
    aprobadoresNombres?: StringFieldUpdateOperationsInput | string
    evaluadosInternos?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosInternosNombres?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: StringFieldUpdateOperationsInput | string
    areaNombre?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    responsableNombre?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    instrucciones?: NullableStringFieldUpdateOperationsInput | string | null
    recordatorios?: BoolFieldUpdateOperationsInput | boolean
    tokenAccesoExterno?: NullableStringFieldUpdateOperationsInput | string | null
    recurrencia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AsignacionCuestionarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    cuestionarioIds?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipoRevision?: StringFieldUpdateOperationsInput | string
    usuariosAsignados?: StringFieldUpdateOperationsInput | string
    usuariosAsignadosNombres?: StringFieldUpdateOperationsInput | string
    emailsExternos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasenaAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activosObjetivo?: StringFieldUpdateOperationsInput | string
    activosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    procesosObjetivo?: StringFieldUpdateOperationsInput | string
    procesosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    aprobadores?: StringFieldUpdateOperationsInput | string
    aprobadoresNombres?: StringFieldUpdateOperationsInput | string
    evaluadosInternos?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosInternosNombres?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: StringFieldUpdateOperationsInput | string
    areaNombre?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    responsableNombre?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    instrucciones?: NullableStringFieldUpdateOperationsInput | string | null
    recordatorios?: BoolFieldUpdateOperationsInput | boolean
    tokenAccesoExterno?: NullableStringFieldUpdateOperationsInput | string | null
    recurrencia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvaluadoExternoCreateInput = {
    id?: string
    nombre: string
    email: string
    password?: string | null
    invitacionEnviada?: boolean
    fechaInvitacion?: Date | string | null
    haRespondido?: boolean
    fechaRespuesta?: Date | string | null
    asignacion: AsignacionCuestionarioCreateNestedOneWithoutEvaluadosExternosInput
  }

  export type EvaluadoExternoUncheckedCreateInput = {
    id?: string
    asignacionId: string
    nombre: string
    email: string
    password?: string | null
    invitacionEnviada?: boolean
    fechaInvitacion?: Date | string | null
    haRespondido?: boolean
    fechaRespuesta?: Date | string | null
  }

  export type EvaluadoExternoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    invitacionEnviada?: BoolFieldUpdateOperationsInput | boolean
    fechaInvitacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    haRespondido?: BoolFieldUpdateOperationsInput | boolean
    fechaRespuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    asignacion?: AsignacionCuestionarioUpdateOneRequiredWithoutEvaluadosExternosNestedInput
  }

  export type EvaluadoExternoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    asignacionId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    invitacionEnviada?: BoolFieldUpdateOperationsInput | boolean
    fechaInvitacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    haRespondido?: BoolFieldUpdateOperationsInput | boolean
    fechaRespuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluadoExternoCreateManyInput = {
    id?: string
    asignacionId: string
    nombre: string
    email: string
    password?: string | null
    invitacionEnviada?: boolean
    fechaInvitacion?: Date | string | null
    haRespondido?: boolean
    fechaRespuesta?: Date | string | null
  }

  export type EvaluadoExternoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    invitacionEnviada?: BoolFieldUpdateOperationsInput | boolean
    fechaInvitacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    haRespondido?: BoolFieldUpdateOperationsInput | boolean
    fechaRespuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluadoExternoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    asignacionId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    invitacionEnviada?: BoolFieldUpdateOperationsInput | boolean
    fechaInvitacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    haRespondido?: BoolFieldUpdateOperationsInput | boolean
    fechaRespuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RespuestaCuestionarioCreateInput = {
    id?: string
    cuestionarioId: string
    fechaInicio?: Date | string
    fechaEnvio?: Date | string | null
    estado?: string
    puntuacionTotal?: number
    nivelCumplimiento?: string | null
    comentariosGenerales?: string | null
    asignacion: AsignacionCuestionarioCreateNestedOneWithoutRespuestasInput
    respondidoPor: UsuarioCreateNestedOneWithoutRespuestasCuestionarioInput
    respuestas?: RespuestaPreguntaCreateNestedManyWithoutRespuestaCuestionarioInput
  }

  export type RespuestaCuestionarioUncheckedCreateInput = {
    id?: string
    asignacionId: string
    cuestionarioId: string
    respondidoPorId: string
    fechaInicio?: Date | string
    fechaEnvio?: Date | string | null
    estado?: string
    puntuacionTotal?: number
    nivelCumplimiento?: string | null
    comentariosGenerales?: string | null
    respuestas?: RespuestaPreguntaUncheckedCreateNestedManyWithoutRespuestaCuestionarioInput
  }

  export type RespuestaCuestionarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    puntuacionTotal?: FloatFieldUpdateOperationsInput | number
    nivelCumplimiento?: NullableStringFieldUpdateOperationsInput | string | null
    comentariosGenerales?: NullableStringFieldUpdateOperationsInput | string | null
    asignacion?: AsignacionCuestionarioUpdateOneRequiredWithoutRespuestasNestedInput
    respondidoPor?: UsuarioUpdateOneRequiredWithoutRespuestasCuestionarioNestedInput
    respuestas?: RespuestaPreguntaUpdateManyWithoutRespuestaCuestionarioNestedInput
  }

  export type RespuestaCuestionarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    asignacionId?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    respondidoPorId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    puntuacionTotal?: FloatFieldUpdateOperationsInput | number
    nivelCumplimiento?: NullableStringFieldUpdateOperationsInput | string | null
    comentariosGenerales?: NullableStringFieldUpdateOperationsInput | string | null
    respuestas?: RespuestaPreguntaUncheckedUpdateManyWithoutRespuestaCuestionarioNestedInput
  }

  export type RespuestaCuestionarioCreateManyInput = {
    id?: string
    asignacionId: string
    cuestionarioId: string
    respondidoPorId: string
    fechaInicio?: Date | string
    fechaEnvio?: Date | string | null
    estado?: string
    puntuacionTotal?: number
    nivelCumplimiento?: string | null
    comentariosGenerales?: string | null
  }

  export type RespuestaCuestionarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    puntuacionTotal?: FloatFieldUpdateOperationsInput | number
    nivelCumplimiento?: NullableStringFieldUpdateOperationsInput | string | null
    comentariosGenerales?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RespuestaCuestionarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    asignacionId?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    respondidoPorId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    puntuacionTotal?: FloatFieldUpdateOperationsInput | number
    nivelCumplimiento?: NullableStringFieldUpdateOperationsInput | string | null
    comentariosGenerales?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RespuestaPreguntaCreateInput = {
    id?: string
    valor?: string | null
    comentario?: string | null
    archivosAdjuntos?: string | null
    marcadaParaRevision?: boolean
    estadoRevision?: string
    comentarioRevisor?: string | null
    respuestaCuestionario: RespuestaCuestionarioCreateNestedOneWithoutRespuestasInput
    pregunta: PreguntaCreateNestedOneWithoutRespuestasInput
    evidencias?: EvidenciaCreateNestedManyWithoutRespuestaPreguntaInput
  }

  export type RespuestaPreguntaUncheckedCreateInput = {
    id?: string
    respuestaCuestionarioId: string
    preguntaId: string
    valor?: string | null
    comentario?: string | null
    archivosAdjuntos?: string | null
    marcadaParaRevision?: boolean
    estadoRevision?: string
    comentarioRevisor?: string | null
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutRespuestaPreguntaInput
  }

  export type RespuestaPreguntaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    archivosAdjuntos?: NullableStringFieldUpdateOperationsInput | string | null
    marcadaParaRevision?: BoolFieldUpdateOperationsInput | boolean
    estadoRevision?: StringFieldUpdateOperationsInput | string
    comentarioRevisor?: NullableStringFieldUpdateOperationsInput | string | null
    respuestaCuestionario?: RespuestaCuestionarioUpdateOneRequiredWithoutRespuestasNestedInput
    pregunta?: PreguntaUpdateOneRequiredWithoutRespuestasNestedInput
    evidencias?: EvidenciaUpdateManyWithoutRespuestaPreguntaNestedInput
  }

  export type RespuestaPreguntaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    respuestaCuestionarioId?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    archivosAdjuntos?: NullableStringFieldUpdateOperationsInput | string | null
    marcadaParaRevision?: BoolFieldUpdateOperationsInput | boolean
    estadoRevision?: StringFieldUpdateOperationsInput | string
    comentarioRevisor?: NullableStringFieldUpdateOperationsInput | string | null
    evidencias?: EvidenciaUncheckedUpdateManyWithoutRespuestaPreguntaNestedInput
  }

  export type RespuestaPreguntaCreateManyInput = {
    id?: string
    respuestaCuestionarioId: string
    preguntaId: string
    valor?: string | null
    comentario?: string | null
    archivosAdjuntos?: string | null
    marcadaParaRevision?: boolean
    estadoRevision?: string
    comentarioRevisor?: string | null
  }

  export type RespuestaPreguntaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    archivosAdjuntos?: NullableStringFieldUpdateOperationsInput | string | null
    marcadaParaRevision?: BoolFieldUpdateOperationsInput | boolean
    estadoRevision?: StringFieldUpdateOperationsInput | string
    comentarioRevisor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RespuestaPreguntaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    respuestaCuestionarioId?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    archivosAdjuntos?: NullableStringFieldUpdateOperationsInput | string | null
    marcadaParaRevision?: BoolFieldUpdateOperationsInput | boolean
    estadoRevision?: StringFieldUpdateOperationsInput | string
    comentarioRevisor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvidenciaCreateInput = {
    id?: string
    nombre: string
    tipo: string
    tamano: number
    fechaCarga?: Date | string
    url: string
    descripcion?: string | null
    vigencia?: Date | string | null
    estado?: string
    respuestaPregunta: RespuestaPreguntaCreateNestedOneWithoutEvidenciasInput
  }

  export type EvidenciaUncheckedCreateInput = {
    id?: string
    respuestaPreguntaId: string
    nombre: string
    tipo: string
    tamano: number
    fechaCarga?: Date | string
    url: string
    descripcion?: string | null
    vigencia?: Date | string | null
    estado?: string
  }

  export type EvidenciaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tamano?: IntFieldUpdateOperationsInput | number
    fechaCarga?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    respuestaPregunta?: RespuestaPreguntaUpdateOneRequiredWithoutEvidenciasNestedInput
  }

  export type EvidenciaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    respuestaPreguntaId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tamano?: IntFieldUpdateOperationsInput | number
    fechaCarga?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type EvidenciaCreateManyInput = {
    id?: string
    respuestaPreguntaId: string
    nombre: string
    tipo: string
    tamano: number
    fechaCarga?: Date | string
    url: string
    descripcion?: string | null
    vigencia?: Date | string | null
    estado?: string
  }

  export type EvidenciaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tamano?: IntFieldUpdateOperationsInput | number
    fechaCarga?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type EvidenciaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    respuestaPreguntaId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tamano?: IntFieldUpdateOperationsInput | number
    fechaCarga?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type HallazgoCreateInput = {
    id?: string
    tipo: string
    descripcion: string
    requisitoNormativo?: string | null
    accionCorrectiva?: string | null
    responsable: string
    fechaLimite?: Date | string | null
    estado?: string
    fechaCreacion?: Date | string
    pregunta: PreguntaCreateNestedOneWithoutHallazgosInput
  }

  export type HallazgoUncheckedCreateInput = {
    id?: string
    preguntaId: string
    tipo: string
    descripcion: string
    requisitoNormativo?: string | null
    accionCorrectiva?: string | null
    responsable: string
    fechaLimite?: Date | string | null
    estado?: string
    fechaCreacion?: Date | string
  }

  export type HallazgoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    requisitoNormativo?: NullableStringFieldUpdateOperationsInput | string | null
    accionCorrectiva?: NullableStringFieldUpdateOperationsInput | string | null
    responsable?: StringFieldUpdateOperationsInput | string
    fechaLimite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    pregunta?: PreguntaUpdateOneRequiredWithoutHallazgosNestedInput
  }

  export type HallazgoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    requisitoNormativo?: NullableStringFieldUpdateOperationsInput | string | null
    accionCorrectiva?: NullableStringFieldUpdateOperationsInput | string | null
    responsable?: StringFieldUpdateOperationsInput | string
    fechaLimite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HallazgoCreateManyInput = {
    id?: string
    preguntaId: string
    tipo: string
    descripcion: string
    requisitoNormativo?: string | null
    accionCorrectiva?: string | null
    responsable: string
    fechaLimite?: Date | string | null
    estado?: string
    fechaCreacion?: Date | string
  }

  export type HallazgoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    requisitoNormativo?: NullableStringFieldUpdateOperationsInput | string | null
    accionCorrectiva?: NullableStringFieldUpdateOperationsInput | string | null
    responsable?: StringFieldUpdateOperationsInput | string
    fechaLimite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HallazgoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    requisitoNormativo?: NullableStringFieldUpdateOperationsInput | string | null
    accionCorrectiva?: NullableStringFieldUpdateOperationsInput | string | null
    responsable?: StringFieldUpdateOperationsInput | string
    fechaLimite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensajeChatCreateInput = {
    id?: string
    cuestionarioId?: string | null
    activoProcesoId?: string | null
    usuarioId: string
    usuarioNombre: string
    usuarioRol: string
    mensaje: string
    fecha?: Date | string
    leido?: boolean
    asignacion: AsignacionCuestionarioCreateNestedOneWithoutMensajesChatInput
  }

  export type MensajeChatUncheckedCreateInput = {
    id?: string
    asignacionId: string
    cuestionarioId?: string | null
    activoProcesoId?: string | null
    usuarioId: string
    usuarioNombre: string
    usuarioRol: string
    mensaje: string
    fecha?: Date | string
    leido?: boolean
  }

  export type MensajeChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: NullableStringFieldUpdateOperationsInput | string | null
    activoProcesoId?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    usuarioNombre?: StringFieldUpdateOperationsInput | string
    usuarioRol?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    asignacion?: AsignacionCuestionarioUpdateOneRequiredWithoutMensajesChatNestedInput
  }

  export type MensajeChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    asignacionId?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: NullableStringFieldUpdateOperationsInput | string | null
    activoProcesoId?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    usuarioNombre?: StringFieldUpdateOperationsInput | string
    usuarioRol?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    leido?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MensajeChatCreateManyInput = {
    id?: string
    asignacionId: string
    cuestionarioId?: string | null
    activoProcesoId?: string | null
    usuarioId: string
    usuarioNombre: string
    usuarioRol: string
    mensaje: string
    fecha?: Date | string
    leido?: boolean
  }

  export type MensajeChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: NullableStringFieldUpdateOperationsInput | string | null
    activoProcesoId?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    usuarioNombre?: StringFieldUpdateOperationsInput | string
    usuarioRol?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    leido?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MensajeChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    asignacionId?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: NullableStringFieldUpdateOperationsInput | string | null
    activoProcesoId?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    usuarioNombre?: StringFieldUpdateOperationsInput | string
    usuarioRol?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    leido?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlertaCumplimientoCreateInput = {
    id?: string
    tipo: string
    severidad: string
    titulo: string
    descripcion: string
    entidadId: string
    entidadTipo: string
    fechaGeneracion?: Date | string
    estado?: string
    responsable?: string | null
    marcoNormativo?: string | null
  }

  export type AlertaCumplimientoUncheckedCreateInput = {
    id?: string
    tipo: string
    severidad: string
    titulo: string
    descripcion: string
    entidadId: string
    entidadTipo: string
    fechaGeneracion?: Date | string
    estado?: string
    responsable?: string | null
    marcoNormativo?: string | null
  }

  export type AlertaCumplimientoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    severidad?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    entidadId?: StringFieldUpdateOperationsInput | string
    entidadTipo?: StringFieldUpdateOperationsInput | string
    fechaGeneracion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    marcoNormativo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertaCumplimientoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    severidad?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    entidadId?: StringFieldUpdateOperationsInput | string
    entidadTipo?: StringFieldUpdateOperationsInput | string
    fechaGeneracion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    marcoNormativo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertaCumplimientoCreateManyInput = {
    id?: string
    tipo: string
    severidad: string
    titulo: string
    descripcion: string
    entidadId: string
    entidadTipo: string
    fechaGeneracion?: Date | string
    estado?: string
    responsable?: string | null
    marcoNormativo?: string | null
  }

  export type AlertaCumplimientoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    severidad?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    entidadId?: StringFieldUpdateOperationsInput | string
    entidadTipo?: StringFieldUpdateOperationsInput | string
    fechaGeneracion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    marcoNormativo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertaCumplimientoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    severidad?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    entidadId?: StringFieldUpdateOperationsInput | string
    entidadTipo?: StringFieldUpdateOperationsInput | string
    fechaGeneracion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    marcoNormativo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProcesoCreateInput = {
    id?: string
    nombre: string
    descripcion: string
    version?: string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    nodos?: ProcessNodeCreateNestedManyWithoutProcesoInput
    edges?: ProcessEdgeCreateNestedManyWithoutProcesoInput
    objetivos?: ObjetivoProcesoCreateNestedManyWithoutProcesoInput
    kpis?: KpiProcesoCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion: string
    version?: string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    nodos?: ProcessNodeUncheckedCreateNestedManyWithoutProcesoInput
    edges?: ProcessEdgeUncheckedCreateNestedManyWithoutProcesoInput
    objetivos?: ObjetivoProcesoUncheckedCreateNestedManyWithoutProcesoInput
    kpis?: KpiProcesoUncheckedCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    nodos?: ProcessNodeUpdateManyWithoutProcesoNestedInput
    edges?: ProcessEdgeUpdateManyWithoutProcesoNestedInput
    objetivos?: ObjetivoProcesoUpdateManyWithoutProcesoNestedInput
    kpis?: KpiProcesoUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    nodos?: ProcessNodeUncheckedUpdateManyWithoutProcesoNestedInput
    edges?: ProcessEdgeUncheckedUpdateManyWithoutProcesoNestedInput
    objetivos?: ObjetivoProcesoUncheckedUpdateManyWithoutProcesoNestedInput
    kpis?: KpiProcesoUncheckedUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoCreateManyInput = {
    id?: string
    nombre: string
    descripcion: string
    version?: string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type ProcesoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ProcesoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessNodeCreateInput = {
    id?: string
    type: string
    label: string
    descripcion?: string | null
    config: string
    positionX: number
    positionY: number
    proceso: ProcesoCreateNestedOneWithoutNodosInput
    edgesFrom?: ProcessEdgeCreateNestedManyWithoutSourceNodeInput
    edgesTo?: ProcessEdgeCreateNestedManyWithoutTargetNodeInput
    kpiHistorico?: KpiHistoricoCreateNestedManyWithoutNodoInput
  }

  export type ProcessNodeUncheckedCreateInput = {
    id?: string
    procesoId: string
    type: string
    label: string
    descripcion?: string | null
    config: string
    positionX: number
    positionY: number
    edgesFrom?: ProcessEdgeUncheckedCreateNestedManyWithoutSourceNodeInput
    edgesTo?: ProcessEdgeUncheckedCreateNestedManyWithoutTargetNodeInput
    kpiHistorico?: KpiHistoricoUncheckedCreateNestedManyWithoutNodoInput
  }

  export type ProcessNodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    proceso?: ProcesoUpdateOneRequiredWithoutNodosNestedInput
    edgesFrom?: ProcessEdgeUpdateManyWithoutSourceNodeNestedInput
    edgesTo?: ProcessEdgeUpdateManyWithoutTargetNodeNestedInput
    kpiHistorico?: KpiHistoricoUpdateManyWithoutNodoNestedInput
  }

  export type ProcessNodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    edgesFrom?: ProcessEdgeUncheckedUpdateManyWithoutSourceNodeNestedInput
    edgesTo?: ProcessEdgeUncheckedUpdateManyWithoutTargetNodeNestedInput
    kpiHistorico?: KpiHistoricoUncheckedUpdateManyWithoutNodoNestedInput
  }

  export type ProcessNodeCreateManyInput = {
    id?: string
    procesoId: string
    type: string
    label: string
    descripcion?: string | null
    config: string
    positionX: number
    positionY: number
  }

  export type ProcessNodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
  }

  export type ProcessNodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
  }

  export type ProcessEdgeCreateInput = {
    id?: string
    sourceHandle?: string | null
    targetHandle?: string | null
    label?: string | null
    proceso: ProcesoCreateNestedOneWithoutEdgesInput
    sourceNode: ProcessNodeCreateNestedOneWithoutEdgesFromInput
    targetNode: ProcessNodeCreateNestedOneWithoutEdgesToInput
  }

  export type ProcessEdgeUncheckedCreateInput = {
    id?: string
    procesoId: string
    sourceNodeId: string
    targetNodeId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    label?: string | null
  }

  export type ProcessEdgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    proceso?: ProcesoUpdateOneRequiredWithoutEdgesNestedInput
    sourceNode?: ProcessNodeUpdateOneRequiredWithoutEdgesFromNestedInput
    targetNode?: ProcessNodeUpdateOneRequiredWithoutEdgesToNestedInput
  }

  export type ProcessEdgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    sourceNodeId?: StringFieldUpdateOperationsInput | string
    targetNodeId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProcessEdgeCreateManyInput = {
    id?: string
    procesoId: string
    sourceNodeId: string
    targetNodeId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    label?: string | null
  }

  export type ProcessEdgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProcessEdgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    sourceNodeId?: StringFieldUpdateOperationsInput | string
    targetNodeId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ObjetivoProcesoCreateInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    progreso?: number
    proceso: ProcesoCreateNestedOneWithoutObjetivosInput
    kpis?: KpiProcesoCreateNestedManyWithoutObjetivoInput
  }

  export type ObjetivoProcesoUncheckedCreateInput = {
    id?: string
    procesoId: string
    nombre: string
    descripcion: string
    tipo: string
    progreso?: number
    kpis?: KpiProcesoUncheckedCreateNestedManyWithoutObjetivoInput
  }

  export type ObjetivoProcesoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    proceso?: ProcesoUpdateOneRequiredWithoutObjetivosNestedInput
    kpis?: KpiProcesoUpdateManyWithoutObjetivoNestedInput
  }

  export type ObjetivoProcesoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    kpis?: KpiProcesoUncheckedUpdateManyWithoutObjetivoNestedInput
  }

  export type ObjetivoProcesoCreateManyInput = {
    id?: string
    procesoId: string
    nombre: string
    descripcion: string
    tipo: string
    progreso?: number
  }

  export type ObjetivoProcesoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
  }

  export type ObjetivoProcesoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
  }

  export type KpiProcesoCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    unidad: string
    meta: number
    valorActual?: number
    fechaUltimaActualizacion?: Date | string | null
    alertaAdvertencia?: number | null
    alertaCritico?: number | null
    alertaDireccion?: string
    proceso: ProcesoCreateNestedOneWithoutKpisInput
    objetivo?: ObjetivoProcesoCreateNestedOneWithoutKpisInput
    historico?: KpiHistoricoCreateNestedManyWithoutKpiInput
  }

  export type KpiProcesoUncheckedCreateInput = {
    id?: string
    procesoId: string
    objetivoId?: string | null
    nombre: string
    descripcion?: string | null
    unidad: string
    meta: number
    valorActual?: number
    fechaUltimaActualizacion?: Date | string | null
    alertaAdvertencia?: number | null
    alertaCritico?: number | null
    alertaDireccion?: string
    historico?: KpiHistoricoUncheckedCreateNestedManyWithoutKpiInput
  }

  export type KpiProcesoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    unidad?: StringFieldUpdateOperationsInput | string
    meta?: FloatFieldUpdateOperationsInput | number
    valorActual?: FloatFieldUpdateOperationsInput | number
    fechaUltimaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertaAdvertencia?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaCritico?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaDireccion?: StringFieldUpdateOperationsInput | string
    proceso?: ProcesoUpdateOneRequiredWithoutKpisNestedInput
    objetivo?: ObjetivoProcesoUpdateOneWithoutKpisNestedInput
    historico?: KpiHistoricoUpdateManyWithoutKpiNestedInput
  }

  export type KpiProcesoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    objetivoId?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    unidad?: StringFieldUpdateOperationsInput | string
    meta?: FloatFieldUpdateOperationsInput | number
    valorActual?: FloatFieldUpdateOperationsInput | number
    fechaUltimaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertaAdvertencia?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaCritico?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaDireccion?: StringFieldUpdateOperationsInput | string
    historico?: KpiHistoricoUncheckedUpdateManyWithoutKpiNestedInput
  }

  export type KpiProcesoCreateManyInput = {
    id?: string
    procesoId: string
    objetivoId?: string | null
    nombre: string
    descripcion?: string | null
    unidad: string
    meta: number
    valorActual?: number
    fechaUltimaActualizacion?: Date | string | null
    alertaAdvertencia?: number | null
    alertaCritico?: number | null
    alertaDireccion?: string
  }

  export type KpiProcesoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    unidad?: StringFieldUpdateOperationsInput | string
    meta?: FloatFieldUpdateOperationsInput | number
    valorActual?: FloatFieldUpdateOperationsInput | number
    fechaUltimaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertaAdvertencia?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaCritico?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaDireccion?: StringFieldUpdateOperationsInput | string
  }

  export type KpiProcesoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    objetivoId?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    unidad?: StringFieldUpdateOperationsInput | string
    meta?: FloatFieldUpdateOperationsInput | number
    valorActual?: FloatFieldUpdateOperationsInput | number
    fechaUltimaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertaAdvertencia?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaCritico?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaDireccion?: StringFieldUpdateOperationsInput | string
  }

  export type KpiHistoricoCreateInput = {
    id?: string
    valor: number
    timestamp?: Date | string
    procesoId: string
    metadatos?: string | null
    kpi: KpiProcesoCreateNestedOneWithoutHistoricoInput
    nodo?: ProcessNodeCreateNestedOneWithoutKpiHistoricoInput
  }

  export type KpiHistoricoUncheckedCreateInput = {
    id?: string
    kpiId: string
    valor: number
    timestamp?: Date | string
    procesoId: string
    nodoId?: string | null
    metadatos?: string | null
  }

  export type KpiHistoricoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    procesoId?: StringFieldUpdateOperationsInput | string
    metadatos?: NullableStringFieldUpdateOperationsInput | string | null
    kpi?: KpiProcesoUpdateOneRequiredWithoutHistoricoNestedInput
    nodo?: ProcessNodeUpdateOneWithoutKpiHistoricoNestedInput
  }

  export type KpiHistoricoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiId?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    procesoId?: StringFieldUpdateOperationsInput | string
    nodoId?: NullableStringFieldUpdateOperationsInput | string | null
    metadatos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KpiHistoricoCreateManyInput = {
    id?: string
    kpiId: string
    valor: number
    timestamp?: Date | string
    procesoId: string
    nodoId?: string | null
    metadatos?: string | null
  }

  export type KpiHistoricoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    procesoId?: StringFieldUpdateOperationsInput | string
    metadatos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KpiHistoricoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiId?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    procesoId?: StringFieldUpdateOperationsInput | string
    nodoId?: NullableStringFieldUpdateOperationsInput | string | null
    metadatos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardConfigCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    isDefault?: boolean
    isLocked?: boolean
    columns?: number
    rowHeight?: number
    gap?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    widgets?: DashboardWidgetCreateNestedManyWithoutDashboardInput
  }

  export type DashboardConfigUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    isDefault?: boolean
    isLocked?: boolean
    columns?: number
    rowHeight?: number
    gap?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    widgets?: DashboardWidgetUncheckedCreateNestedManyWithoutDashboardInput
  }

  export type DashboardConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    columns?: IntFieldUpdateOperationsInput | number
    rowHeight?: IntFieldUpdateOperationsInput | number
    gap?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    widgets?: DashboardWidgetUpdateManyWithoutDashboardNestedInput
  }

  export type DashboardConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    columns?: IntFieldUpdateOperationsInput | number
    rowHeight?: IntFieldUpdateOperationsInput | number
    gap?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    widgets?: DashboardWidgetUncheckedUpdateManyWithoutDashboardNestedInput
  }

  export type DashboardConfigCreateManyInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    isDefault?: boolean
    isLocked?: boolean
    columns?: number
    rowHeight?: number
    gap?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type DashboardConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    columns?: IntFieldUpdateOperationsInput | number
    rowHeight?: IntFieldUpdateOperationsInput | number
    gap?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    columns?: IntFieldUpdateOperationsInput | number
    rowHeight?: IntFieldUpdateOperationsInput | number
    gap?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardWidgetCreateInput = {
    id?: string
    tipo: string
    titulo: string
    subtitulo?: string | null
    icono?: string | null
    config: string
    x: number
    y: number
    cols: number
    rows: number
    canResize?: boolean
    canDrag?: boolean
    canRemove?: boolean
    canEdit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dashboard: DashboardConfigCreateNestedOneWithoutWidgetsInput
  }

  export type DashboardWidgetUncheckedCreateInput = {
    id?: string
    dashboardId: string
    tipo: string
    titulo: string
    subtitulo?: string | null
    icono?: string | null
    config: string
    x: number
    y: number
    cols: number
    rows: number
    canResize?: boolean
    canDrag?: boolean
    canRemove?: boolean
    canEdit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardWidgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    subtitulo?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    canResize?: BoolFieldUpdateOperationsInput | boolean
    canDrag?: BoolFieldUpdateOperationsInput | boolean
    canRemove?: BoolFieldUpdateOperationsInput | boolean
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dashboard?: DashboardConfigUpdateOneRequiredWithoutWidgetsNestedInput
  }

  export type DashboardWidgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dashboardId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    subtitulo?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    canResize?: BoolFieldUpdateOperationsInput | boolean
    canDrag?: BoolFieldUpdateOperationsInput | boolean
    canRemove?: BoolFieldUpdateOperationsInput | boolean
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardWidgetCreateManyInput = {
    id?: string
    dashboardId: string
    tipo: string
    titulo: string
    subtitulo?: string | null
    icono?: string | null
    config: string
    x: number
    y: number
    cols: number
    rows: number
    canResize?: boolean
    canDrag?: boolean
    canRemove?: boolean
    canEdit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardWidgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    subtitulo?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    canResize?: BoolFieldUpdateOperationsInput | boolean
    canDrag?: BoolFieldUpdateOperationsInput | boolean
    canRemove?: BoolFieldUpdateOperationsInput | boolean
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardWidgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dashboardId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    subtitulo?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    canResize?: BoolFieldUpdateOperationsInput | boolean
    canDrag?: BoolFieldUpdateOperationsInput | boolean
    canRemove?: BoolFieldUpdateOperationsInput | boolean
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogoCreateInput = {
    id?: string
    tipo: string
    codigo: string
    nombre: string
    descripcion?: string | null
    orden?: number
    activo?: boolean
    color?: string | null
    icono?: string | null
    metadata?: string | null
  }

  export type CatalogoUncheckedCreateInput = {
    id?: string
    tipo: string
    codigo: string
    nombre: string
    descripcion?: string | null
    orden?: number
    activo?: boolean
    color?: string | null
    icono?: string | null
    metadata?: string | null
  }

  export type CatalogoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogoCreateManyInput = {
    id?: string
    tipo: string
    codigo: string
    nombre: string
    descripcion?: string | null
    orden?: number
    activo?: boolean
    color?: string | null
    icono?: string | null
    metadata?: string | null
  }

  export type CatalogoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationRuleCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    entidadTipo: string
    eventoTipo: string
    activo?: boolean
    notificarCreador?: boolean
    notificarResponsable?: boolean
    notificarAprobadores?: boolean
    rolesDestino?: string | null
    usuariosDestino?: string | null
    enviarInApp?: boolean
    enviarEmail?: boolean
    plantillaMensaje?: string | null
    severidad?: string
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
  }

  export type NotificationRuleUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    entidadTipo: string
    eventoTipo: string
    activo?: boolean
    notificarCreador?: boolean
    notificarResponsable?: boolean
    notificarAprobadores?: boolean
    rolesDestino?: string | null
    usuariosDestino?: string | null
    enviarInApp?: boolean
    enviarEmail?: boolean
    plantillaMensaje?: string | null
    severidad?: string
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
  }

  export type NotificationRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    entidadTipo?: StringFieldUpdateOperationsInput | string
    eventoTipo?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    notificarCreador?: BoolFieldUpdateOperationsInput | boolean
    notificarResponsable?: BoolFieldUpdateOperationsInput | boolean
    notificarAprobadores?: BoolFieldUpdateOperationsInput | boolean
    rolesDestino?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosDestino?: NullableStringFieldUpdateOperationsInput | string | null
    enviarInApp?: BoolFieldUpdateOperationsInput | boolean
    enviarEmail?: BoolFieldUpdateOperationsInput | boolean
    plantillaMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    severidad?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    entidadTipo?: StringFieldUpdateOperationsInput | string
    eventoTipo?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    notificarCreador?: BoolFieldUpdateOperationsInput | boolean
    notificarResponsable?: BoolFieldUpdateOperationsInput | boolean
    notificarAprobadores?: BoolFieldUpdateOperationsInput | boolean
    rolesDestino?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosDestino?: NullableStringFieldUpdateOperationsInput | string | null
    enviarInApp?: BoolFieldUpdateOperationsInput | boolean
    enviarEmail?: BoolFieldUpdateOperationsInput | boolean
    plantillaMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    severidad?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRuleCreateManyInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    entidadTipo: string
    eventoTipo: string
    activo?: boolean
    notificarCreador?: boolean
    notificarResponsable?: boolean
    notificarAprobadores?: boolean
    rolesDestino?: string | null
    usuariosDestino?: string | null
    enviarInApp?: boolean
    enviarEmail?: boolean
    plantillaMensaje?: string | null
    severidad?: string
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
  }

  export type NotificationRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    entidadTipo?: StringFieldUpdateOperationsInput | string
    eventoTipo?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    notificarCreador?: BoolFieldUpdateOperationsInput | boolean
    notificarResponsable?: BoolFieldUpdateOperationsInput | boolean
    notificarAprobadores?: BoolFieldUpdateOperationsInput | boolean
    rolesDestino?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosDestino?: NullableStringFieldUpdateOperationsInput | string | null
    enviarInApp?: BoolFieldUpdateOperationsInput | boolean
    enviarEmail?: BoolFieldUpdateOperationsInput | boolean
    plantillaMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    severidad?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    entidadTipo?: StringFieldUpdateOperationsInput | string
    eventoTipo?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    notificarCreador?: BoolFieldUpdateOperationsInput | boolean
    notificarResponsable?: BoolFieldUpdateOperationsInput | boolean
    notificarAprobadores?: BoolFieldUpdateOperationsInput | boolean
    rolesDestino?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosDestino?: NullableStringFieldUpdateOperationsInput | string | null
    enviarInApp?: BoolFieldUpdateOperationsInput | boolean
    enviarEmail?: BoolFieldUpdateOperationsInput | boolean
    plantillaMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    severidad?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertRuleCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    entidadTipo: string
    entidadId?: string | null
    metricaNombre: string
    operador: string
    valorUmbral: number
    tipoAgregacion?: string
    periodoEvaluacion?: string | null
    activo?: boolean
    rolesDestino?: string | null
    usuariosDestino?: string | null
    enviarInApp?: boolean
    enviarEmail?: boolean
    severidad?: string
    cooldownMinutos?: number
    ultimaEjecucion?: Date | string | null
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
  }

  export type AlertRuleUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    entidadTipo: string
    entidadId?: string | null
    metricaNombre: string
    operador: string
    valorUmbral: number
    tipoAgregacion?: string
    periodoEvaluacion?: string | null
    activo?: boolean
    rolesDestino?: string | null
    usuariosDestino?: string | null
    enviarInApp?: boolean
    enviarEmail?: boolean
    severidad?: string
    cooldownMinutos?: number
    ultimaEjecucion?: Date | string | null
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
  }

  export type AlertRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    entidadTipo?: StringFieldUpdateOperationsInput | string
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    metricaNombre?: StringFieldUpdateOperationsInput | string
    operador?: StringFieldUpdateOperationsInput | string
    valorUmbral?: FloatFieldUpdateOperationsInput | number
    tipoAgregacion?: StringFieldUpdateOperationsInput | string
    periodoEvaluacion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    rolesDestino?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosDestino?: NullableStringFieldUpdateOperationsInput | string | null
    enviarInApp?: BoolFieldUpdateOperationsInput | boolean
    enviarEmail?: BoolFieldUpdateOperationsInput | boolean
    severidad?: StringFieldUpdateOperationsInput | string
    cooldownMinutos?: IntFieldUpdateOperationsInput | number
    ultimaEjecucion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    entidadTipo?: StringFieldUpdateOperationsInput | string
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    metricaNombre?: StringFieldUpdateOperationsInput | string
    operador?: StringFieldUpdateOperationsInput | string
    valorUmbral?: FloatFieldUpdateOperationsInput | number
    tipoAgregacion?: StringFieldUpdateOperationsInput | string
    periodoEvaluacion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    rolesDestino?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosDestino?: NullableStringFieldUpdateOperationsInput | string | null
    enviarInApp?: BoolFieldUpdateOperationsInput | boolean
    enviarEmail?: BoolFieldUpdateOperationsInput | boolean
    severidad?: StringFieldUpdateOperationsInput | string
    cooldownMinutos?: IntFieldUpdateOperationsInput | number
    ultimaEjecucion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertRuleCreateManyInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    entidadTipo: string
    entidadId?: string | null
    metricaNombre: string
    operador: string
    valorUmbral: number
    tipoAgregacion?: string
    periodoEvaluacion?: string | null
    activo?: boolean
    rolesDestino?: string | null
    usuariosDestino?: string | null
    enviarInApp?: boolean
    enviarEmail?: boolean
    severidad?: string
    cooldownMinutos?: number
    ultimaEjecucion?: Date | string | null
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
  }

  export type AlertRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    entidadTipo?: StringFieldUpdateOperationsInput | string
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    metricaNombre?: StringFieldUpdateOperationsInput | string
    operador?: StringFieldUpdateOperationsInput | string
    valorUmbral?: FloatFieldUpdateOperationsInput | number
    tipoAgregacion?: StringFieldUpdateOperationsInput | string
    periodoEvaluacion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    rolesDestino?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosDestino?: NullableStringFieldUpdateOperationsInput | string | null
    enviarInApp?: BoolFieldUpdateOperationsInput | boolean
    enviarEmail?: BoolFieldUpdateOperationsInput | boolean
    severidad?: StringFieldUpdateOperationsInput | string
    cooldownMinutos?: IntFieldUpdateOperationsInput | number
    ultimaEjecucion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    entidadTipo?: StringFieldUpdateOperationsInput | string
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    metricaNombre?: StringFieldUpdateOperationsInput | string
    operador?: StringFieldUpdateOperationsInput | string
    valorUmbral?: FloatFieldUpdateOperationsInput | number
    tipoAgregacion?: StringFieldUpdateOperationsInput | string
    periodoEvaluacion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    rolesDestino?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosDestino?: NullableStringFieldUpdateOperationsInput | string | null
    enviarInApp?: BoolFieldUpdateOperationsInput | boolean
    enviarEmail?: BoolFieldUpdateOperationsInput | boolean
    severidad?: StringFieldUpdateOperationsInput | string
    cooldownMinutos?: IntFieldUpdateOperationsInput | number
    ultimaEjecucion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpirationRuleCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    entidadTipo: string
    diasAnticipacion: string
    diasDespuesVencido?: string | null
    activo?: boolean
    notificarResponsable?: boolean
    notificarSupervisor?: boolean
    rolesDestino?: string | null
    enviarInApp?: boolean
    enviarEmail?: boolean
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
  }

  export type ExpirationRuleUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    entidadTipo: string
    diasAnticipacion: string
    diasDespuesVencido?: string | null
    activo?: boolean
    notificarResponsable?: boolean
    notificarSupervisor?: boolean
    rolesDestino?: string | null
    enviarInApp?: boolean
    enviarEmail?: boolean
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
  }

  export type ExpirationRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    entidadTipo?: StringFieldUpdateOperationsInput | string
    diasAnticipacion?: StringFieldUpdateOperationsInput | string
    diasDespuesVencido?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    notificarResponsable?: BoolFieldUpdateOperationsInput | boolean
    notificarSupervisor?: BoolFieldUpdateOperationsInput | boolean
    rolesDestino?: NullableStringFieldUpdateOperationsInput | string | null
    enviarInApp?: BoolFieldUpdateOperationsInput | boolean
    enviarEmail?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpirationRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    entidadTipo?: StringFieldUpdateOperationsInput | string
    diasAnticipacion?: StringFieldUpdateOperationsInput | string
    diasDespuesVencido?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    notificarResponsable?: BoolFieldUpdateOperationsInput | boolean
    notificarSupervisor?: BoolFieldUpdateOperationsInput | boolean
    rolesDestino?: NullableStringFieldUpdateOperationsInput | string | null
    enviarInApp?: BoolFieldUpdateOperationsInput | boolean
    enviarEmail?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpirationRuleCreateManyInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    entidadTipo: string
    diasAnticipacion: string
    diasDespuesVencido?: string | null
    activo?: boolean
    notificarResponsable?: boolean
    notificarSupervisor?: boolean
    rolesDestino?: string | null
    enviarInApp?: boolean
    enviarEmail?: boolean
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
  }

  export type ExpirationRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    entidadTipo?: StringFieldUpdateOperationsInput | string
    diasAnticipacion?: StringFieldUpdateOperationsInput | string
    diasDespuesVencido?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    notificarResponsable?: BoolFieldUpdateOperationsInput | boolean
    notificarSupervisor?: BoolFieldUpdateOperationsInput | boolean
    rolesDestino?: NullableStringFieldUpdateOperationsInput | string | null
    enviarInApp?: BoolFieldUpdateOperationsInput | boolean
    enviarEmail?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpirationRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    entidadTipo?: StringFieldUpdateOperationsInput | string
    diasAnticipacion?: StringFieldUpdateOperationsInput | string
    diasDespuesVencido?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    notificarResponsable?: BoolFieldUpdateOperationsInput | boolean
    notificarSupervisor?: BoolFieldUpdateOperationsInput | boolean
    rolesDestino?: NullableStringFieldUpdateOperationsInput | string | null
    enviarInApp?: BoolFieldUpdateOperationsInput | boolean
    enviarEmail?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    usuarioId: string
    tipo: string
    titulo: string
    mensaje: string
    severidad?: string
    entidadTipo?: string | null
    entidadId?: string | null
    entidadNombre?: string | null
    leida?: boolean
    archivada?: boolean
    enSeguimiento?: boolean
    acciones?: string | null
    attachmentTipo?: string | null
    attachmentUrl?: string | null
    attachmentTitulo?: string | null
    attachmentSubtitulo?: string | null
    metadata?: string | null
    reglaId?: string | null
    reglaTipo?: string | null
    fechaCreacion?: Date | string
    fechaLeida?: Date | string | null
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    usuarioId: string
    tipo: string
    titulo: string
    mensaje: string
    severidad?: string
    entidadTipo?: string | null
    entidadId?: string | null
    entidadNombre?: string | null
    leida?: boolean
    archivada?: boolean
    enSeguimiento?: boolean
    acciones?: string | null
    attachmentTipo?: string | null
    attachmentUrl?: string | null
    attachmentTitulo?: string | null
    attachmentSubtitulo?: string | null
    metadata?: string | null
    reglaId?: string | null
    reglaTipo?: string | null
    fechaCreacion?: Date | string
    fechaLeida?: Date | string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    severidad?: StringFieldUpdateOperationsInput | string
    entidadTipo?: NullableStringFieldUpdateOperationsInput | string | null
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    entidadNombre?: NullableStringFieldUpdateOperationsInput | string | null
    leida?: BoolFieldUpdateOperationsInput | boolean
    archivada?: BoolFieldUpdateOperationsInput | boolean
    enSeguimiento?: BoolFieldUpdateOperationsInput | boolean
    acciones?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentTipo?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentTitulo?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentSubtitulo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    reglaId?: NullableStringFieldUpdateOperationsInput | string | null
    reglaTipo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLeida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    severidad?: StringFieldUpdateOperationsInput | string
    entidadTipo?: NullableStringFieldUpdateOperationsInput | string | null
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    entidadNombre?: NullableStringFieldUpdateOperationsInput | string | null
    leida?: BoolFieldUpdateOperationsInput | boolean
    archivada?: BoolFieldUpdateOperationsInput | boolean
    enSeguimiento?: BoolFieldUpdateOperationsInput | boolean
    acciones?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentTipo?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentTitulo?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentSubtitulo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    reglaId?: NullableStringFieldUpdateOperationsInput | string | null
    reglaTipo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLeida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    usuarioId: string
    tipo: string
    titulo: string
    mensaje: string
    severidad?: string
    entidadTipo?: string | null
    entidadId?: string | null
    entidadNombre?: string | null
    leida?: boolean
    archivada?: boolean
    enSeguimiento?: boolean
    acciones?: string | null
    attachmentTipo?: string | null
    attachmentUrl?: string | null
    attachmentTitulo?: string | null
    attachmentSubtitulo?: string | null
    metadata?: string | null
    reglaId?: string | null
    reglaTipo?: string | null
    fechaCreacion?: Date | string
    fechaLeida?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    severidad?: StringFieldUpdateOperationsInput | string
    entidadTipo?: NullableStringFieldUpdateOperationsInput | string | null
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    entidadNombre?: NullableStringFieldUpdateOperationsInput | string | null
    leida?: BoolFieldUpdateOperationsInput | boolean
    archivada?: BoolFieldUpdateOperationsInput | boolean
    enSeguimiento?: BoolFieldUpdateOperationsInput | boolean
    acciones?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentTipo?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentTitulo?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentSubtitulo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    reglaId?: NullableStringFieldUpdateOperationsInput | string | null
    reglaTipo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLeida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    severidad?: StringFieldUpdateOperationsInput | string
    entidadTipo?: NullableStringFieldUpdateOperationsInput | string | null
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    entidadNombre?: NullableStringFieldUpdateOperationsInput | string | null
    leida?: BoolFieldUpdateOperationsInput | boolean
    archivada?: BoolFieldUpdateOperationsInput | boolean
    enSeguimiento?: BoolFieldUpdateOperationsInput | boolean
    acciones?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentTipo?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentTitulo?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentSubtitulo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    reglaId?: NullableStringFieldUpdateOperationsInput | string | null
    reglaTipo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLeida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserNotificationPreferencesCreateInput = {
    id?: string
    usuarioId: string
    habilitado?: boolean
    emailHabilitado?: boolean
    inAppHabilitado?: boolean
    preferenciasPorEntidad?: string | null
    notificarInfo?: boolean
    notificarWarning?: boolean
    notificarCritical?: boolean
    frecuenciaEmail?: string
    horaResumen?: string
    horarioNoMolestarHabilitado?: boolean
    horarioNoMolestarInicio?: string | null
    horarioNoMolestarFin?: string | null
    horarioNoMolestarDias?: string | null
    rateLimitHabilitado?: boolean
    rateLimitMaxPorHora?: number
    preferenciasPorModulo?: string | null
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
  }

  export type UserNotificationPreferencesUncheckedCreateInput = {
    id?: string
    usuarioId: string
    habilitado?: boolean
    emailHabilitado?: boolean
    inAppHabilitado?: boolean
    preferenciasPorEntidad?: string | null
    notificarInfo?: boolean
    notificarWarning?: boolean
    notificarCritical?: boolean
    frecuenciaEmail?: string
    horaResumen?: string
    horarioNoMolestarHabilitado?: boolean
    horarioNoMolestarInicio?: string | null
    horarioNoMolestarFin?: string | null
    horarioNoMolestarDias?: string | null
    rateLimitHabilitado?: boolean
    rateLimitMaxPorHora?: number
    preferenciasPorModulo?: string | null
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
  }

  export type UserNotificationPreferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    habilitado?: BoolFieldUpdateOperationsInput | boolean
    emailHabilitado?: BoolFieldUpdateOperationsInput | boolean
    inAppHabilitado?: BoolFieldUpdateOperationsInput | boolean
    preferenciasPorEntidad?: NullableStringFieldUpdateOperationsInput | string | null
    notificarInfo?: BoolFieldUpdateOperationsInput | boolean
    notificarWarning?: BoolFieldUpdateOperationsInput | boolean
    notificarCritical?: BoolFieldUpdateOperationsInput | boolean
    frecuenciaEmail?: StringFieldUpdateOperationsInput | string
    horaResumen?: StringFieldUpdateOperationsInput | string
    horarioNoMolestarHabilitado?: BoolFieldUpdateOperationsInput | boolean
    horarioNoMolestarInicio?: NullableStringFieldUpdateOperationsInput | string | null
    horarioNoMolestarFin?: NullableStringFieldUpdateOperationsInput | string | null
    horarioNoMolestarDias?: NullableStringFieldUpdateOperationsInput | string | null
    rateLimitHabilitado?: BoolFieldUpdateOperationsInput | boolean
    rateLimitMaxPorHora?: IntFieldUpdateOperationsInput | number
    preferenciasPorModulo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationPreferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    habilitado?: BoolFieldUpdateOperationsInput | boolean
    emailHabilitado?: BoolFieldUpdateOperationsInput | boolean
    inAppHabilitado?: BoolFieldUpdateOperationsInput | boolean
    preferenciasPorEntidad?: NullableStringFieldUpdateOperationsInput | string | null
    notificarInfo?: BoolFieldUpdateOperationsInput | boolean
    notificarWarning?: BoolFieldUpdateOperationsInput | boolean
    notificarCritical?: BoolFieldUpdateOperationsInput | boolean
    frecuenciaEmail?: StringFieldUpdateOperationsInput | string
    horaResumen?: StringFieldUpdateOperationsInput | string
    horarioNoMolestarHabilitado?: BoolFieldUpdateOperationsInput | boolean
    horarioNoMolestarInicio?: NullableStringFieldUpdateOperationsInput | string | null
    horarioNoMolestarFin?: NullableStringFieldUpdateOperationsInput | string | null
    horarioNoMolestarDias?: NullableStringFieldUpdateOperationsInput | string | null
    rateLimitHabilitado?: BoolFieldUpdateOperationsInput | boolean
    rateLimitMaxPorHora?: IntFieldUpdateOperationsInput | number
    preferenciasPorModulo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationPreferencesCreateManyInput = {
    id?: string
    usuarioId: string
    habilitado?: boolean
    emailHabilitado?: boolean
    inAppHabilitado?: boolean
    preferenciasPorEntidad?: string | null
    notificarInfo?: boolean
    notificarWarning?: boolean
    notificarCritical?: boolean
    frecuenciaEmail?: string
    horaResumen?: string
    horarioNoMolestarHabilitado?: boolean
    horarioNoMolestarInicio?: string | null
    horarioNoMolestarFin?: string | null
    horarioNoMolestarDias?: string | null
    rateLimitHabilitado?: boolean
    rateLimitMaxPorHora?: number
    preferenciasPorModulo?: string | null
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
  }

  export type UserNotificationPreferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    habilitado?: BoolFieldUpdateOperationsInput | boolean
    emailHabilitado?: BoolFieldUpdateOperationsInput | boolean
    inAppHabilitado?: BoolFieldUpdateOperationsInput | boolean
    preferenciasPorEntidad?: NullableStringFieldUpdateOperationsInput | string | null
    notificarInfo?: BoolFieldUpdateOperationsInput | boolean
    notificarWarning?: BoolFieldUpdateOperationsInput | boolean
    notificarCritical?: BoolFieldUpdateOperationsInput | boolean
    frecuenciaEmail?: StringFieldUpdateOperationsInput | string
    horaResumen?: StringFieldUpdateOperationsInput | string
    horarioNoMolestarHabilitado?: BoolFieldUpdateOperationsInput | boolean
    horarioNoMolestarInicio?: NullableStringFieldUpdateOperationsInput | string | null
    horarioNoMolestarFin?: NullableStringFieldUpdateOperationsInput | string | null
    horarioNoMolestarDias?: NullableStringFieldUpdateOperationsInput | string | null
    rateLimitHabilitado?: BoolFieldUpdateOperationsInput | boolean
    rateLimitMaxPorHora?: IntFieldUpdateOperationsInput | number
    preferenciasPorModulo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationPreferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    habilitado?: BoolFieldUpdateOperationsInput | boolean
    emailHabilitado?: BoolFieldUpdateOperationsInput | boolean
    inAppHabilitado?: BoolFieldUpdateOperationsInput | boolean
    preferenciasPorEntidad?: NullableStringFieldUpdateOperationsInput | string | null
    notificarInfo?: BoolFieldUpdateOperationsInput | boolean
    notificarWarning?: BoolFieldUpdateOperationsInput | boolean
    notificarCritical?: BoolFieldUpdateOperationsInput | boolean
    frecuenciaEmail?: StringFieldUpdateOperationsInput | string
    horaResumen?: StringFieldUpdateOperationsInput | string
    horarioNoMolestarHabilitado?: BoolFieldUpdateOperationsInput | boolean
    horarioNoMolestarInicio?: NullableStringFieldUpdateOperationsInput | string | null
    horarioNoMolestarFin?: NullableStringFieldUpdateOperationsInput | string | null
    horarioNoMolestarDias?: NullableStringFieldUpdateOperationsInput | string | null
    rateLimitHabilitado?: BoolFieldUpdateOperationsInput | boolean
    rateLimitMaxPorHora?: IntFieldUpdateOperationsInput | number
    preferenciasPorModulo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateInput = {
    id?: string
    notificationId?: string | null
    usuarioId: string
    canal: string
    estado: string
    errorMensaje?: string | null
    reglaId?: string | null
    reglaTipo?: string | null
    metadata?: string | null
    fechaEnvio?: Date | string
  }

  export type NotificationLogUncheckedCreateInput = {
    id?: string
    notificationId?: string | null
    usuarioId: string
    canal: string
    estado: string
    errorMensaje?: string | null
    reglaId?: string | null
    reglaTipo?: string | null
    metadata?: string | null
    fechaEnvio?: Date | string
  }

  export type NotificationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    errorMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    reglaId?: NullableStringFieldUpdateOperationsInput | string | null
    reglaTipo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    errorMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    reglaId?: NullableStringFieldUpdateOperationsInput | string | null
    reglaTipo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateManyInput = {
    id?: string
    notificationId?: string | null
    usuarioId: string
    canal: string
    estado: string
    errorMensaje?: string | null
    reglaId?: string | null
    reglaTipo?: string | null
    metadata?: string | null
    fechaEnvio?: Date | string
  }

  export type NotificationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    errorMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    reglaId?: NullableStringFieldUpdateOperationsInput | string | null
    reglaTipo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    errorMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    reglaId?: NullableStringFieldUpdateOperationsInput | string | null
    reglaTipo?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationProfileCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    eventos: string
    seleccionEntidades: string
    filtrosEntidad?: string | null
    destinatarios: string
    canales: string
    plantillaTitulo?: string | null
    plantillaMensaje?: string | null
    severidad?: string
    estado?: string
    horarioNoMolestar?: string | null
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    creadoPorId?: string | null
  }

  export type NotificationProfileUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    eventos: string
    seleccionEntidades: string
    filtrosEntidad?: string | null
    destinatarios: string
    canales: string
    plantillaTitulo?: string | null
    plantillaMensaje?: string | null
    severidad?: string
    estado?: string
    horarioNoMolestar?: string | null
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    creadoPorId?: string | null
  }

  export type NotificationProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    eventos?: StringFieldUpdateOperationsInput | string
    seleccionEntidades?: StringFieldUpdateOperationsInput | string
    filtrosEntidad?: NullableStringFieldUpdateOperationsInput | string | null
    destinatarios?: StringFieldUpdateOperationsInput | string
    canales?: StringFieldUpdateOperationsInput | string
    plantillaTitulo?: NullableStringFieldUpdateOperationsInput | string | null
    plantillaMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    severidad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    horarioNoMolestar?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    eventos?: StringFieldUpdateOperationsInput | string
    seleccionEntidades?: StringFieldUpdateOperationsInput | string
    filtrosEntidad?: NullableStringFieldUpdateOperationsInput | string | null
    destinatarios?: StringFieldUpdateOperationsInput | string
    canales?: StringFieldUpdateOperationsInput | string
    plantillaTitulo?: NullableStringFieldUpdateOperationsInput | string | null
    plantillaMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    severidad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    horarioNoMolestar?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationProfileCreateManyInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    eventos: string
    seleccionEntidades: string
    filtrosEntidad?: string | null
    destinatarios: string
    canales: string
    plantillaTitulo?: string | null
    plantillaMensaje?: string | null
    severidad?: string
    estado?: string
    horarioNoMolestar?: string | null
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    creadoPorId?: string | null
  }

  export type NotificationProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    eventos?: StringFieldUpdateOperationsInput | string
    seleccionEntidades?: StringFieldUpdateOperationsInput | string
    filtrosEntidad?: NullableStringFieldUpdateOperationsInput | string | null
    destinatarios?: StringFieldUpdateOperationsInput | string
    canales?: StringFieldUpdateOperationsInput | string
    plantillaTitulo?: NullableStringFieldUpdateOperationsInput | string | null
    plantillaMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    severidad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    horarioNoMolestar?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    eventos?: StringFieldUpdateOperationsInput | string
    seleccionEntidades?: StringFieldUpdateOperationsInput | string
    filtrosEntidad?: NullableStringFieldUpdateOperationsInput | string | null
    destinatarios?: StringFieldUpdateOperationsInput | string
    canales?: StringFieldUpdateOperationsInput | string
    plantillaTitulo?: NullableStringFieldUpdateOperationsInput | string | null
    plantillaMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    severidad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    horarioNoMolestar?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    responsibleUserId: string
    orgUnitId?: string | null
    priority?: string
    status?: string
    progress?: number
    reminderDays?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    objectives?: ProjectObjectiveCreateNestedManyWithoutProjectInput
    kpis?: ProjectKPICreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    responsibleUserId: string
    orgUnitId?: string | null
    priority?: string
    status?: string
    progress?: number
    reminderDays?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    objectives?: ProjectObjectiveUncheckedCreateNestedManyWithoutProjectInput
    kpis?: ProjectKPIUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUserId?: StringFieldUpdateOperationsInput | string
    orgUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    reminderDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    objectives?: ProjectObjectiveUpdateManyWithoutProjectNestedInput
    kpis?: ProjectKPIUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUserId?: StringFieldUpdateOperationsInput | string
    orgUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    reminderDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    objectives?: ProjectObjectiveUncheckedUpdateManyWithoutProjectNestedInput
    kpis?: ProjectKPIUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    responsibleUserId: string
    orgUnitId?: string | null
    priority?: string
    status?: string
    progress?: number
    reminderDays?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUserId?: StringFieldUpdateOperationsInput | string
    orgUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    reminderDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUserId?: StringFieldUpdateOperationsInput | string
    orgUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    reminderDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectObjectiveCreateInput = {
    id?: string
    description: string
    category: string
    status?: string
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    project: ProjectCreateNestedOneWithoutObjectivesInput
  }

  export type ProjectObjectiveUncheckedCreateInput = {
    id?: string
    projectId: string
    description: string
    category: string
    status?: string
    targetDate?: Date | string | null
    completedDate?: Date | string | null
  }

  export type ProjectObjectiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutObjectivesNestedInput
  }

  export type ProjectObjectiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectObjectiveCreateManyInput = {
    id?: string
    projectId: string
    description: string
    category: string
    status?: string
    targetDate?: Date | string | null
    completedDate?: Date | string | null
  }

  export type ProjectObjectiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectObjectiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectKPICreateInput = {
    id?: string
    name: string
    description?: string | null
    targetValue: number
    currentValue?: number
    unit: string
    formulaType: string
    formula?: string | null
    status?: string
    project: ProjectCreateNestedOneWithoutKpisInput
  }

  export type ProjectKPIUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    targetValue: number
    currentValue?: number
    unit: string
    formulaType: string
    formula?: string | null
    status?: string
  }

  export type ProjectKPIUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    formulaType?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutKpisNestedInput
  }

  export type ProjectKPIUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    formulaType?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectKPICreateManyInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    targetValue: number
    currentValue?: number
    unit: string
    formulaType: string
    formula?: string | null
    status?: string
  }

  export type ProjectKPIUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    formulaType?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectKPIUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    formulaType?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectPhaseCreateInput = {
    id?: string
    name: string
    description?: string | null
    orderNum: number
    startDate: Date | string
    endDate: Date | string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    status?: string
    weight?: number
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPhasesInput
    dependsOn?: ProjectPhaseCreateNestedOneWithoutDependentsInput
    dependents?: ProjectPhaseCreateNestedManyWithoutDependsOnInput
    tasks?: TaskCreateNestedManyWithoutPhaseInput
  }

  export type ProjectPhaseUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    orderNum: number
    startDate: Date | string
    endDate: Date | string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    status?: string
    weight?: number
    dependsOnPhaseId?: string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dependents?: ProjectPhaseUncheckedCreateNestedManyWithoutDependsOnInput
    tasks?: TaskUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type ProjectPhaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPhasesNestedInput
    dependsOn?: ProjectPhaseUpdateOneWithoutDependentsNestedInput
    dependents?: ProjectPhaseUpdateManyWithoutDependsOnNestedInput
    tasks?: TaskUpdateManyWithoutPhaseNestedInput
  }

  export type ProjectPhaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    dependsOnPhaseId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependents?: ProjectPhaseUncheckedUpdateManyWithoutDependsOnNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type ProjectPhaseCreateManyInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    orderNum: number
    startDate: Date | string
    endDate: Date | string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    status?: string
    weight?: number
    dependsOnPhaseId?: string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectPhaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectPhaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    dependsOnPhaseId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    assignedTo: string
    assignedBy: string
    assignedAt?: Date | string
    startDate: Date | string
    dueDate: Date | string
    completedDate?: Date | string | null
    progress?: number
    status?: string
    priority?: string
    estimatedHours?: number | null
    actualHours?: number | null
    taskType?: string
    linkedEntityType?: string | null
    linkedEntityId?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    phase: ProjectPhaseCreateNestedOneWithoutTasksInput
    evidences?: TaskEvidenceCreateNestedManyWithoutTaskInput
    history?: TaskHistoryCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    projectId: string
    phaseId: string
    title: string
    description?: string | null
    assignedTo: string
    assignedBy: string
    assignedAt?: Date | string
    startDate: Date | string
    dueDate: Date | string
    completedDate?: Date | string | null
    progress?: number
    status?: string
    priority?: string
    estimatedHours?: number | null
    actualHours?: number | null
    taskType?: string
    linkedEntityType?: string | null
    linkedEntityId?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    evidences?: TaskEvidenceUncheckedCreateNestedManyWithoutTaskInput
    history?: TaskHistoryUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedBy?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    taskType?: StringFieldUpdateOperationsInput | string
    linkedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    phase?: ProjectPhaseUpdateOneRequiredWithoutTasksNestedInput
    evidences?: TaskEvidenceUpdateManyWithoutTaskNestedInput
    history?: TaskHistoryUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedBy?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    taskType?: StringFieldUpdateOperationsInput | string
    linkedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidences?: TaskEvidenceUncheckedUpdateManyWithoutTaskNestedInput
    history?: TaskHistoryUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    projectId: string
    phaseId: string
    title: string
    description?: string | null
    assignedTo: string
    assignedBy: string
    assignedAt?: Date | string
    startDate: Date | string
    dueDate: Date | string
    completedDate?: Date | string | null
    progress?: number
    status?: string
    priority?: string
    estimatedHours?: number | null
    actualHours?: number | null
    taskType?: string
    linkedEntityType?: string | null
    linkedEntityId?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedBy?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    taskType?: StringFieldUpdateOperationsInput | string
    linkedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedBy?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    taskType?: StringFieldUpdateOperationsInput | string
    linkedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEvidenceCreateInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    storageUrl: string
    evidenceType: string
    description?: string | null
    documentDate?: Date | string | null
    uploadedBy: string
    uploadedAt?: Date | string
    task: TaskCreateNestedOneWithoutEvidencesInput
  }

  export type TaskEvidenceUncheckedCreateInput = {
    id?: string
    taskId: string
    fileName: string
    fileType: string
    fileSize: number
    storageUrl: string
    evidenceType: string
    description?: string | null
    documentDate?: Date | string | null
    uploadedBy: string
    uploadedAt?: Date | string
  }

  export type TaskEvidenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    evidenceType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutEvidencesNestedInput
  }

  export type TaskEvidenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    evidenceType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEvidenceCreateManyInput = {
    id?: string
    taskId: string
    fileName: string
    fileType: string
    fileSize: number
    storageUrl: string
    evidenceType: string
    description?: string | null
    documentDate?: Date | string | null
    uploadedBy: string
    uploadedAt?: Date | string
  }

  export type TaskEvidenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    evidenceType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEvidenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    evidenceType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskHistoryCreateInput = {
    id?: string
    userId: string
    action: string
    changes?: string | null
    comment?: string | null
    timestamp?: Date | string
    task: TaskCreateNestedOneWithoutHistoryInput
  }

  export type TaskHistoryUncheckedCreateInput = {
    id?: string
    taskId: string
    userId: string
    action: string
    changes?: string | null
    comment?: string | null
    timestamp?: Date | string
  }

  export type TaskHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type TaskHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskHistoryCreateManyInput = {
    id?: string
    taskId: string
    userId: string
    action: string
    changes?: string | null
    comment?: string | null
    timestamp?: Date | string
  }

  export type TaskHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UsuarioRolListRelationFilter = {
    every?: UsuarioRolWhereInput
    some?: UsuarioRolWhereInput
    none?: UsuarioRolWhereInput
  }

  export type UsuarioActivoListRelationFilter = {
    every?: UsuarioActivoWhereInput
    some?: UsuarioActivoWhereInput
    none?: UsuarioActivoWhereInput
  }

  export type LogAuditoriaListRelationFilter = {
    every?: LogAuditoriaWhereInput
    some?: LogAuditoriaWhereInput
    none?: LogAuditoriaWhereInput
  }

  export type RespuestaCuestionarioListRelationFilter = {
    every?: RespuestaCuestionarioWhereInput
    some?: RespuestaCuestionarioWhereInput
    none?: RespuestaCuestionarioWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UsuarioRolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioActivoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogAuditoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RespuestaCuestionarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    password?: SortOrder
    telefono?: SortOrder
    avatar?: SortOrder
    estado?: SortOrder
    departamento?: SortOrder
    cargo?: SortOrder
    region?: SortOrder
    autenticacionDosFactor?: SortOrder
    cambioPasswordRequerido?: SortOrder
    sesionesActivas?: SortOrder
    maxSesionesPermitidas?: SortOrder
    ultimoCambioPassword?: SortOrder
    intentosFallidos?: SortOrder
    fechaCreacion?: SortOrder
    fechaExpiracion?: SortOrder
    ultimoAcceso?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    sesionesActivas?: SortOrder
    maxSesionesPermitidas?: SortOrder
    intentosFallidos?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    password?: SortOrder
    telefono?: SortOrder
    avatar?: SortOrder
    estado?: SortOrder
    departamento?: SortOrder
    cargo?: SortOrder
    region?: SortOrder
    autenticacionDosFactor?: SortOrder
    cambioPasswordRequerido?: SortOrder
    sesionesActivas?: SortOrder
    maxSesionesPermitidas?: SortOrder
    ultimoCambioPassword?: SortOrder
    intentosFallidos?: SortOrder
    fechaCreacion?: SortOrder
    fechaExpiracion?: SortOrder
    ultimoAcceso?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    password?: SortOrder
    telefono?: SortOrder
    avatar?: SortOrder
    estado?: SortOrder
    departamento?: SortOrder
    cargo?: SortOrder
    region?: SortOrder
    autenticacionDosFactor?: SortOrder
    cambioPasswordRequerido?: SortOrder
    sesionesActivas?: SortOrder
    maxSesionesPermitidas?: SortOrder
    ultimoCambioPassword?: SortOrder
    intentosFallidos?: SortOrder
    fechaCreacion?: SortOrder
    fechaExpiracion?: SortOrder
    ultimoAcceso?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    sesionesActivas?: SortOrder
    maxSesionesPermitidas?: SortOrder
    intentosFallidos?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type RolPermisoListRelationFilter = {
    every?: RolPermisoWhereInput
    some?: RolPermisoWhereInput
    none?: RolPermisoWhereInput
  }

  export type RolPermisoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    nivelAcceso?: SortOrder
    region?: SortOrder
    tipoArbol?: SortOrder
    color?: SortOrder
    icono?: SortOrder
    activo?: SortOrder
    esRolSistema?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type RolMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    nivelAcceso?: SortOrder
    region?: SortOrder
    tipoArbol?: SortOrder
    color?: SortOrder
    icono?: SortOrder
    activo?: SortOrder
    esRolSistema?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type RolMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    nivelAcceso?: SortOrder
    region?: SortOrder
    tipoArbol?: SortOrder
    color?: SortOrder
    icono?: SortOrder
    activo?: SortOrder
    esRolSistema?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type PermisoNullableRelationFilter = {
    is?: PermisoWhereInput | null
    isNot?: PermisoWhereInput | null
  }

  export type PermisoListRelationFilter = {
    every?: PermisoWhereInput
    some?: PermisoWhereInput
    none?: PermisoWhereInput
  }

  export type PermisoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermisoCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    modulo?: SortOrder
    categoria?: SortOrder
    activo?: SortOrder
    padreId?: SortOrder
  }

  export type PermisoMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    modulo?: SortOrder
    categoria?: SortOrder
    activo?: SortOrder
    padreId?: SortOrder
  }

  export type PermisoMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    modulo?: SortOrder
    categoria?: SortOrder
    activo?: SortOrder
    padreId?: SortOrder
  }

  export type ModuloCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    icono?: SortOrder
    orden?: SortOrder
    activo?: SortOrder
    permisoCreacion?: SortOrder
    permisoEdicion?: SortOrder
    permisoVisualizacion?: SortOrder
    permisoEliminacion?: SortOrder
  }

  export type ModuloAvgOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type ModuloMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    icono?: SortOrder
    orden?: SortOrder
    activo?: SortOrder
    permisoCreacion?: SortOrder
    permisoEdicion?: SortOrder
    permisoVisualizacion?: SortOrder
    permisoEliminacion?: SortOrder
  }

  export type ModuloMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    icono?: SortOrder
    orden?: SortOrder
    activo?: SortOrder
    permisoCreacion?: SortOrder
    permisoEdicion?: SortOrder
    permisoVisualizacion?: SortOrder
    permisoEliminacion?: SortOrder
  }

  export type ModuloSumOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type RolRelationFilter = {
    is?: RolWhereInput
    isNot?: RolWhereInput
  }

  export type UsuarioRolUsuarioIdRolIdCompoundUniqueInput = {
    usuarioId: string
    rolId: string
  }

  export type UsuarioRolCountOrderByAggregateInput = {
    usuarioId?: SortOrder
    rolId?: SortOrder
    fechaAsignacion?: SortOrder
  }

  export type UsuarioRolMaxOrderByAggregateInput = {
    usuarioId?: SortOrder
    rolId?: SortOrder
    fechaAsignacion?: SortOrder
  }

  export type UsuarioRolMinOrderByAggregateInput = {
    usuarioId?: SortOrder
    rolId?: SortOrder
    fechaAsignacion?: SortOrder
  }

  export type PermisoRelationFilter = {
    is?: PermisoWhereInput
    isNot?: PermisoWhereInput
  }

  export type RolPermisoRolIdPermisoIdCompoundUniqueInput = {
    rolId: string
    permisoId: string
  }

  export type RolPermisoCountOrderByAggregateInput = {
    rolId?: SortOrder
    permisoId?: SortOrder
  }

  export type RolPermisoMaxOrderByAggregateInput = {
    rolId?: SortOrder
    permisoId?: SortOrder
  }

  export type RolPermisoMinOrderByAggregateInput = {
    rolId?: SortOrder
    permisoId?: SortOrder
  }

  export type ActivoAccesoRelationFilter = {
    is?: ActivoAccesoWhereInput
    isNot?: ActivoAccesoWhereInput
  }

  export type UsuarioActivoUsuarioIdActivoIdCompoundUniqueInput = {
    usuarioId: string
    activoId: string
  }

  export type UsuarioActivoCountOrderByAggregateInput = {
    usuarioId?: SortOrder
    activoId?: SortOrder
    nivelAcceso?: SortOrder
  }

  export type UsuarioActivoMaxOrderByAggregateInput = {
    usuarioId?: SortOrder
    activoId?: SortOrder
    nivelAcceso?: SortOrder
  }

  export type UsuarioActivoMinOrderByAggregateInput = {
    usuarioId?: SortOrder
    activoId?: SortOrder
    nivelAcceso?: SortOrder
  }

  export type LogAuditoriaCountOrderByAggregateInput = {
    id?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    entidadNombre?: SortOrder
    detalles?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    fecha?: SortOrder
    usuarioId?: SortOrder
  }

  export type LogAuditoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    entidadNombre?: SortOrder
    detalles?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    fecha?: SortOrder
    usuarioId?: SortOrder
  }

  export type LogAuditoriaMinOrderByAggregateInput = {
    id?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    entidadNombre?: SortOrder
    detalles?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    fecha?: SortOrder
    usuarioId?: SortOrder
  }

  export type ActivoAccesoNullableRelationFilter = {
    is?: ActivoAccesoWhereInput | null
    isNot?: ActivoAccesoWhereInput | null
  }

  export type ActivoAccesoListRelationFilter = {
    every?: ActivoAccesoWhereInput
    some?: ActivoAccesoWhereInput
    none?: ActivoAccesoWhereInput
  }

  export type ActivoAccesoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivoAccesoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    icono?: SortOrder
    nivelAcceso?: SortOrder
    expanded?: SortOrder
    padreId?: SortOrder
  }

  export type ActivoAccesoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    icono?: SortOrder
    nivelAcceso?: SortOrder
    expanded?: SortOrder
    padreId?: SortOrder
  }

  export type ActivoAccesoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    icono?: SortOrder
    nivelAcceso?: SortOrder
    expanded?: SortOrder
    padreId?: SortOrder
  }

  export type ActivoListRelationFilter = {
    every?: ActivoWhereInput
    some?: ActivoWhereInput
    none?: ActivoWhereInput
  }

  export type ActivoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlantillaActivoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipoActivo?: SortOrder
    descripcion?: SortOrder
    icono?: SortOrder
    color?: SortOrder
    propiedades?: SortOrder
    activo?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type PlantillaActivoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipoActivo?: SortOrder
    descripcion?: SortOrder
    icono?: SortOrder
    color?: SortOrder
    propiedades?: SortOrder
    activo?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type PlantillaActivoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipoActivo?: SortOrder
    descripcion?: SortOrder
    icono?: SortOrder
    color?: SortOrder
    propiedades?: SortOrder
    activo?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type PlantillaActivoNullableRelationFilter = {
    is?: PlantillaActivoWhereInput | null
    isNot?: PlantillaActivoWhereInput | null
  }

  export type RiesgoListRelationFilter = {
    every?: RiesgoWhereInput
    some?: RiesgoWhereInput
    none?: RiesgoWhereInput
  }

  export type IncidenteListRelationFilter = {
    every?: IncidenteWhereInput
    some?: IncidenteWhereInput
    none?: IncidenteWhereInput
  }

  export type DefectoListRelationFilter = {
    every?: DefectoWhereInput
    some?: DefectoWhereInput
    none?: DefectoWhereInput
  }

  export type RiesgoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidenteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DefectoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    criticidad?: SortOrder
    responsable?: SortOrder
    departamento?: SortOrder
    fechaRegistro?: SortOrder
    updatedAt?: SortOrder
    plantillaId?: SortOrder
    propiedadesCustom?: SortOrder
  }

  export type ActivoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    criticidad?: SortOrder
    responsable?: SortOrder
    departamento?: SortOrder
    fechaRegistro?: SortOrder
    updatedAt?: SortOrder
    plantillaId?: SortOrder
    propiedadesCustom?: SortOrder
  }

  export type ActivoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    criticidad?: SortOrder
    responsable?: SortOrder
    departamento?: SortOrder
    fechaRegistro?: SortOrder
    updatedAt?: SortOrder
    plantillaId?: SortOrder
    propiedadesCustom?: SortOrder
  }

  export type ActivoRelationFilter = {
    is?: ActivoWhereInput
    isNot?: ActivoWhereInput
  }

  export type RiesgoCountOrderByAggregateInput = {
    id?: SortOrder
    activoId?: SortOrder
    descripcion?: SortOrder
    probabilidad?: SortOrder
    impacto?: SortOrder
    estado?: SortOrder
    fechaIdentificacion?: SortOrder
    responsable?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiesgoAvgOrderByAggregateInput = {
    probabilidad?: SortOrder
    impacto?: SortOrder
  }

  export type RiesgoMaxOrderByAggregateInput = {
    id?: SortOrder
    activoId?: SortOrder
    descripcion?: SortOrder
    probabilidad?: SortOrder
    impacto?: SortOrder
    estado?: SortOrder
    fechaIdentificacion?: SortOrder
    responsable?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiesgoMinOrderByAggregateInput = {
    id?: SortOrder
    activoId?: SortOrder
    descripcion?: SortOrder
    probabilidad?: SortOrder
    impacto?: SortOrder
    estado?: SortOrder
    fechaIdentificacion?: SortOrder
    responsable?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiesgoSumOrderByAggregateInput = {
    probabilidad?: SortOrder
    impacto?: SortOrder
  }

  export type IncidenteCountOrderByAggregateInput = {
    id?: SortOrder
    activoId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    severidad?: SortOrder
    estado?: SortOrder
    fechaReporte?: SortOrder
    reportadoPor?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidenteMaxOrderByAggregateInput = {
    id?: SortOrder
    activoId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    severidad?: SortOrder
    estado?: SortOrder
    fechaReporte?: SortOrder
    reportadoPor?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidenteMinOrderByAggregateInput = {
    id?: SortOrder
    activoId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    severidad?: SortOrder
    estado?: SortOrder
    fechaReporte?: SortOrder
    reportadoPor?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefectoCountOrderByAggregateInput = {
    id?: SortOrder
    activoId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    prioridad?: SortOrder
    estado?: SortOrder
    fechaDeteccion?: SortOrder
    detectadoPor?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefectoMaxOrderByAggregateInput = {
    id?: SortOrder
    activoId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    prioridad?: SortOrder
    estado?: SortOrder
    fechaDeteccion?: SortOrder
    detectadoPor?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefectoMinOrderByAggregateInput = {
    id?: SortOrder
    activoId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    prioridad?: SortOrder
    estado?: SortOrder
    fechaDeteccion?: SortOrder
    detectadoPor?: SortOrder
    updatedAt?: SortOrder
  }

  export type NodoOrganigramaListRelationFilter = {
    every?: NodoOrganigramaWhereInput
    some?: NodoOrganigramaWhereInput
    none?: NodoOrganigramaWhereInput
  }

  export type NodoOrganigramaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganigramaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    fechaCreacion?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganigramaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    fechaCreacion?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganigramaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    fechaCreacion?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganigramaRelationFilter = {
    is?: OrganigramaWhereInput
    isNot?: OrganigramaWhereInput
  }

  export type NodoOrganigramaNullableRelationFilter = {
    is?: NodoOrganigramaWhereInput | null
    isNot?: NodoOrganigramaWhereInput | null
  }

  export type NodoOrganigramaCountOrderByAggregateInput = {
    id?: SortOrder
    organigramaId?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    departamento?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    foto?: SortOrder
    padreId?: SortOrder
  }

  export type NodoOrganigramaMaxOrderByAggregateInput = {
    id?: SortOrder
    organigramaId?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    departamento?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    foto?: SortOrder
    padreId?: SortOrder
  }

  export type NodoOrganigramaMinOrderByAggregateInput = {
    id?: SortOrder
    organigramaId?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    departamento?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    foto?: SortOrder
    padreId?: SortOrder
  }

  export type RequisitoNormativoListRelationFilter = {
    every?: RequisitoNormativoWhereInput
    some?: RequisitoNormativoWhereInput
    none?: RequisitoNormativoWhereInput
  }

  export type CuestionarioListRelationFilter = {
    every?: CuestionarioWhereInput
    some?: CuestionarioWhereInput
    none?: CuestionarioWhereInput
  }

  export type RequisitoNormativoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CuestionarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarcoNormativoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    acronimo?: SortOrder
    version?: SortOrder
    fechaVigencia?: SortOrder
    descripcion?: SortOrder
    activo?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type MarcoNormativoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    acronimo?: SortOrder
    version?: SortOrder
    fechaVigencia?: SortOrder
    descripcion?: SortOrder
    activo?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type MarcoNormativoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    acronimo?: SortOrder
    version?: SortOrder
    fechaVigencia?: SortOrder
    descripcion?: SortOrder
    activo?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type MarcoNormativoRelationFilter = {
    is?: MarcoNormativoWhereInput
    isNot?: MarcoNormativoWhereInput
  }

  export type RequisitoNormativoCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    marcoId?: SortOrder
    controlesAsociados?: SortOrder
  }

  export type RequisitoNormativoMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    marcoId?: SortOrder
    controlesAsociados?: SortOrder
  }

  export type RequisitoNormativoMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    marcoId?: SortOrder
    controlesAsociados?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MarcoNormativoNullableRelationFilter = {
    is?: MarcoNormativoWhereInput | null
    isNot?: MarcoNormativoWhereInput | null
  }

  export type SeccionListRelationFilter = {
    every?: SeccionWhereInput
    some?: SeccionWhereInput
    none?: SeccionWhereInput
  }

  export type AsignacionCuestionarioListRelationFilter = {
    every?: AsignacionCuestionarioWhereInput
    some?: AsignacionCuestionarioWhereInput
    none?: AsignacionCuestionarioWhereInput
  }

  export type SeccionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AsignacionCuestionarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CuestionarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    categoria?: SortOrder
    tipo?: SortOrder
    tipoEvaluacion?: SortOrder
    estado?: SortOrder
    marcoNormativoId?: SortOrder
    periodicidad?: SortOrder
    tasaCompletado?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
    umbrales?: SortOrder
    areasObjetivo?: SortOrder
    responsables?: SortOrder
  }

  export type CuestionarioAvgOrderByAggregateInput = {
    tasaCompletado?: SortOrder
  }

  export type CuestionarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    categoria?: SortOrder
    tipo?: SortOrder
    tipoEvaluacion?: SortOrder
    estado?: SortOrder
    marcoNormativoId?: SortOrder
    periodicidad?: SortOrder
    tasaCompletado?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
    umbrales?: SortOrder
    areasObjetivo?: SortOrder
    responsables?: SortOrder
  }

  export type CuestionarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    categoria?: SortOrder
    tipo?: SortOrder
    tipoEvaluacion?: SortOrder
    estado?: SortOrder
    marcoNormativoId?: SortOrder
    periodicidad?: SortOrder
    tasaCompletado?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
    umbrales?: SortOrder
    areasObjetivo?: SortOrder
    responsables?: SortOrder
  }

  export type CuestionarioSumOrderByAggregateInput = {
    tasaCompletado?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CuestionarioRelationFilter = {
    is?: CuestionarioWhereInput
    isNot?: CuestionarioWhereInput
  }

  export type PreguntaListRelationFilter = {
    every?: PreguntaWhereInput
    some?: PreguntaWhereInput
    none?: PreguntaWhereInput
  }

  export type PreguntaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeccionCountOrderByAggregateInput = {
    id?: SortOrder
    cuestionarioId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    peso?: SortOrder
    requerida?: SortOrder
    orden?: SortOrder
  }

  export type SeccionAvgOrderByAggregateInput = {
    peso?: SortOrder
    orden?: SortOrder
  }

  export type SeccionMaxOrderByAggregateInput = {
    id?: SortOrder
    cuestionarioId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    peso?: SortOrder
    requerida?: SortOrder
    orden?: SortOrder
  }

  export type SeccionMinOrderByAggregateInput = {
    id?: SortOrder
    cuestionarioId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    peso?: SortOrder
    requerida?: SortOrder
    orden?: SortOrder
  }

  export type SeccionSumOrderByAggregateInput = {
    peso?: SortOrder
    orden?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SeccionRelationFilter = {
    is?: SeccionWhereInput
    isNot?: SeccionWhereInput
  }

  export type RespuestaPreguntaListRelationFilter = {
    every?: RespuestaPreguntaWhereInput
    some?: RespuestaPreguntaWhereInput
    none?: RespuestaPreguntaWhereInput
  }

  export type HallazgoListRelationFilter = {
    every?: HallazgoWhereInput
    some?: HallazgoWhereInput
    none?: HallazgoWhereInput
  }

  export type RespuestaPreguntaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HallazgoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PreguntaCountOrderByAggregateInput = {
    id?: SortOrder
    seccionId?: SortOrder
    texto?: SortOrder
    tipo?: SortOrder
    requerida?: SortOrder
    peso?: SortOrder
    opciones?: SortOrder
    escalaMin?: SortOrder
    escalaMax?: SortOrder
    ayuda?: SortOrder
    placeholder?: SortOrder
    requisitoNormativoId?: SortOrder
    controlAsociado?: SortOrder
    requiereEvidencia?: SortOrder
    maxStars?: SortOrder
    leftAnchor?: SortOrder
    rightAnchor?: SortOrder
    likertLabels?: SortOrder
    displayConditionQuestionId?: SortOrder
    displayConditionAnswer?: SortOrder
    logicaCondicional?: SortOrder
    isCalculated?: SortOrder
    formula?: SortOrder
    orden?: SortOrder
  }

  export type PreguntaAvgOrderByAggregateInput = {
    peso?: SortOrder
    escalaMin?: SortOrder
    escalaMax?: SortOrder
    maxStars?: SortOrder
    orden?: SortOrder
  }

  export type PreguntaMaxOrderByAggregateInput = {
    id?: SortOrder
    seccionId?: SortOrder
    texto?: SortOrder
    tipo?: SortOrder
    requerida?: SortOrder
    peso?: SortOrder
    opciones?: SortOrder
    escalaMin?: SortOrder
    escalaMax?: SortOrder
    ayuda?: SortOrder
    placeholder?: SortOrder
    requisitoNormativoId?: SortOrder
    controlAsociado?: SortOrder
    requiereEvidencia?: SortOrder
    maxStars?: SortOrder
    leftAnchor?: SortOrder
    rightAnchor?: SortOrder
    likertLabels?: SortOrder
    displayConditionQuestionId?: SortOrder
    displayConditionAnswer?: SortOrder
    logicaCondicional?: SortOrder
    isCalculated?: SortOrder
    formula?: SortOrder
    orden?: SortOrder
  }

  export type PreguntaMinOrderByAggregateInput = {
    id?: SortOrder
    seccionId?: SortOrder
    texto?: SortOrder
    tipo?: SortOrder
    requerida?: SortOrder
    peso?: SortOrder
    opciones?: SortOrder
    escalaMin?: SortOrder
    escalaMax?: SortOrder
    ayuda?: SortOrder
    placeholder?: SortOrder
    requisitoNormativoId?: SortOrder
    controlAsociado?: SortOrder
    requiereEvidencia?: SortOrder
    maxStars?: SortOrder
    leftAnchor?: SortOrder
    rightAnchor?: SortOrder
    likertLabels?: SortOrder
    displayConditionQuestionId?: SortOrder
    displayConditionAnswer?: SortOrder
    logicaCondicional?: SortOrder
    isCalculated?: SortOrder
    formula?: SortOrder
    orden?: SortOrder
  }

  export type PreguntaSumOrderByAggregateInput = {
    peso?: SortOrder
    escalaMin?: SortOrder
    escalaMax?: SortOrder
    maxStars?: SortOrder
    orden?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EvaluadoExternoListRelationFilter = {
    every?: EvaluadoExternoWhereInput
    some?: EvaluadoExternoWhereInput
    none?: EvaluadoExternoWhereInput
  }

  export type MensajeChatListRelationFilter = {
    every?: MensajeChatWhereInput
    some?: MensajeChatWhereInput
    none?: MensajeChatWhereInput
  }

  export type EvaluadoExternoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MensajeChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AsignacionCuestionarioCountOrderByAggregateInput = {
    id?: SortOrder
    cuestionarioId?: SortOrder
    cuestionarioIds?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    tipoRevision?: SortOrder
    usuariosAsignados?: SortOrder
    usuariosAsignadosNombres?: SortOrder
    emailsExternos?: SortOrder
    contrasenaAcceso?: SortOrder
    activosObjetivo?: SortOrder
    activosObjetivoNombres?: SortOrder
    procesosObjetivo?: SortOrder
    procesosObjetivoNombres?: SortOrder
    aprobadores?: SortOrder
    aprobadoresNombres?: SortOrder
    evaluadosInternos?: SortOrder
    evaluadosInternosNombres?: SortOrder
    areaId?: SortOrder
    areaNombre?: SortOrder
    responsableId?: SortOrder
    responsableNombre?: SortOrder
    fechaAsignacion?: SortOrder
    fechaInicio?: SortOrder
    fechaVencimiento?: SortOrder
    estado?: SortOrder
    progreso?: SortOrder
    instrucciones?: SortOrder
    recordatorios?: SortOrder
    tokenAccesoExterno?: SortOrder
    recurrencia?: SortOrder
  }

  export type AsignacionCuestionarioAvgOrderByAggregateInput = {
    progreso?: SortOrder
  }

  export type AsignacionCuestionarioMaxOrderByAggregateInput = {
    id?: SortOrder
    cuestionarioId?: SortOrder
    cuestionarioIds?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    tipoRevision?: SortOrder
    usuariosAsignados?: SortOrder
    usuariosAsignadosNombres?: SortOrder
    emailsExternos?: SortOrder
    contrasenaAcceso?: SortOrder
    activosObjetivo?: SortOrder
    activosObjetivoNombres?: SortOrder
    procesosObjetivo?: SortOrder
    procesosObjetivoNombres?: SortOrder
    aprobadores?: SortOrder
    aprobadoresNombres?: SortOrder
    evaluadosInternos?: SortOrder
    evaluadosInternosNombres?: SortOrder
    areaId?: SortOrder
    areaNombre?: SortOrder
    responsableId?: SortOrder
    responsableNombre?: SortOrder
    fechaAsignacion?: SortOrder
    fechaInicio?: SortOrder
    fechaVencimiento?: SortOrder
    estado?: SortOrder
    progreso?: SortOrder
    instrucciones?: SortOrder
    recordatorios?: SortOrder
    tokenAccesoExterno?: SortOrder
    recurrencia?: SortOrder
  }

  export type AsignacionCuestionarioMinOrderByAggregateInput = {
    id?: SortOrder
    cuestionarioId?: SortOrder
    cuestionarioIds?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    tipoRevision?: SortOrder
    usuariosAsignados?: SortOrder
    usuariosAsignadosNombres?: SortOrder
    emailsExternos?: SortOrder
    contrasenaAcceso?: SortOrder
    activosObjetivo?: SortOrder
    activosObjetivoNombres?: SortOrder
    procesosObjetivo?: SortOrder
    procesosObjetivoNombres?: SortOrder
    aprobadores?: SortOrder
    aprobadoresNombres?: SortOrder
    evaluadosInternos?: SortOrder
    evaluadosInternosNombres?: SortOrder
    areaId?: SortOrder
    areaNombre?: SortOrder
    responsableId?: SortOrder
    responsableNombre?: SortOrder
    fechaAsignacion?: SortOrder
    fechaInicio?: SortOrder
    fechaVencimiento?: SortOrder
    estado?: SortOrder
    progreso?: SortOrder
    instrucciones?: SortOrder
    recordatorios?: SortOrder
    tokenAccesoExterno?: SortOrder
    recurrencia?: SortOrder
  }

  export type AsignacionCuestionarioSumOrderByAggregateInput = {
    progreso?: SortOrder
  }

  export type AsignacionCuestionarioRelationFilter = {
    is?: AsignacionCuestionarioWhereInput
    isNot?: AsignacionCuestionarioWhereInput
  }

  export type EvaluadoExternoCountOrderByAggregateInput = {
    id?: SortOrder
    asignacionId?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    password?: SortOrder
    invitacionEnviada?: SortOrder
    fechaInvitacion?: SortOrder
    haRespondido?: SortOrder
    fechaRespuesta?: SortOrder
  }

  export type EvaluadoExternoMaxOrderByAggregateInput = {
    id?: SortOrder
    asignacionId?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    password?: SortOrder
    invitacionEnviada?: SortOrder
    fechaInvitacion?: SortOrder
    haRespondido?: SortOrder
    fechaRespuesta?: SortOrder
  }

  export type EvaluadoExternoMinOrderByAggregateInput = {
    id?: SortOrder
    asignacionId?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    password?: SortOrder
    invitacionEnviada?: SortOrder
    fechaInvitacion?: SortOrder
    haRespondido?: SortOrder
    fechaRespuesta?: SortOrder
  }

  export type RespuestaCuestionarioCountOrderByAggregateInput = {
    id?: SortOrder
    asignacionId?: SortOrder
    cuestionarioId?: SortOrder
    respondidoPorId?: SortOrder
    fechaInicio?: SortOrder
    fechaEnvio?: SortOrder
    estado?: SortOrder
    puntuacionTotal?: SortOrder
    nivelCumplimiento?: SortOrder
    comentariosGenerales?: SortOrder
  }

  export type RespuestaCuestionarioAvgOrderByAggregateInput = {
    puntuacionTotal?: SortOrder
  }

  export type RespuestaCuestionarioMaxOrderByAggregateInput = {
    id?: SortOrder
    asignacionId?: SortOrder
    cuestionarioId?: SortOrder
    respondidoPorId?: SortOrder
    fechaInicio?: SortOrder
    fechaEnvio?: SortOrder
    estado?: SortOrder
    puntuacionTotal?: SortOrder
    nivelCumplimiento?: SortOrder
    comentariosGenerales?: SortOrder
  }

  export type RespuestaCuestionarioMinOrderByAggregateInput = {
    id?: SortOrder
    asignacionId?: SortOrder
    cuestionarioId?: SortOrder
    respondidoPorId?: SortOrder
    fechaInicio?: SortOrder
    fechaEnvio?: SortOrder
    estado?: SortOrder
    puntuacionTotal?: SortOrder
    nivelCumplimiento?: SortOrder
    comentariosGenerales?: SortOrder
  }

  export type RespuestaCuestionarioSumOrderByAggregateInput = {
    puntuacionTotal?: SortOrder
  }

  export type RespuestaCuestionarioRelationFilter = {
    is?: RespuestaCuestionarioWhereInput
    isNot?: RespuestaCuestionarioWhereInput
  }

  export type PreguntaRelationFilter = {
    is?: PreguntaWhereInput
    isNot?: PreguntaWhereInput
  }

  export type EvidenciaListRelationFilter = {
    every?: EvidenciaWhereInput
    some?: EvidenciaWhereInput
    none?: EvidenciaWhereInput
  }

  export type EvidenciaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RespuestaPreguntaCountOrderByAggregateInput = {
    id?: SortOrder
    respuestaCuestionarioId?: SortOrder
    preguntaId?: SortOrder
    valor?: SortOrder
    comentario?: SortOrder
    archivosAdjuntos?: SortOrder
    marcadaParaRevision?: SortOrder
    estadoRevision?: SortOrder
    comentarioRevisor?: SortOrder
  }

  export type RespuestaPreguntaMaxOrderByAggregateInput = {
    id?: SortOrder
    respuestaCuestionarioId?: SortOrder
    preguntaId?: SortOrder
    valor?: SortOrder
    comentario?: SortOrder
    archivosAdjuntos?: SortOrder
    marcadaParaRevision?: SortOrder
    estadoRevision?: SortOrder
    comentarioRevisor?: SortOrder
  }

  export type RespuestaPreguntaMinOrderByAggregateInput = {
    id?: SortOrder
    respuestaCuestionarioId?: SortOrder
    preguntaId?: SortOrder
    valor?: SortOrder
    comentario?: SortOrder
    archivosAdjuntos?: SortOrder
    marcadaParaRevision?: SortOrder
    estadoRevision?: SortOrder
    comentarioRevisor?: SortOrder
  }

  export type RespuestaPreguntaRelationFilter = {
    is?: RespuestaPreguntaWhereInput
    isNot?: RespuestaPreguntaWhereInput
  }

  export type EvidenciaCountOrderByAggregateInput = {
    id?: SortOrder
    respuestaPreguntaId?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    tamano?: SortOrder
    fechaCarga?: SortOrder
    url?: SortOrder
    descripcion?: SortOrder
    vigencia?: SortOrder
    estado?: SortOrder
  }

  export type EvidenciaAvgOrderByAggregateInput = {
    tamano?: SortOrder
  }

  export type EvidenciaMaxOrderByAggregateInput = {
    id?: SortOrder
    respuestaPreguntaId?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    tamano?: SortOrder
    fechaCarga?: SortOrder
    url?: SortOrder
    descripcion?: SortOrder
    vigencia?: SortOrder
    estado?: SortOrder
  }

  export type EvidenciaMinOrderByAggregateInput = {
    id?: SortOrder
    respuestaPreguntaId?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    tamano?: SortOrder
    fechaCarga?: SortOrder
    url?: SortOrder
    descripcion?: SortOrder
    vigencia?: SortOrder
    estado?: SortOrder
  }

  export type EvidenciaSumOrderByAggregateInput = {
    tamano?: SortOrder
  }

  export type HallazgoCountOrderByAggregateInput = {
    id?: SortOrder
    preguntaId?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    requisitoNormativo?: SortOrder
    accionCorrectiva?: SortOrder
    responsable?: SortOrder
    fechaLimite?: SortOrder
    estado?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type HallazgoMaxOrderByAggregateInput = {
    id?: SortOrder
    preguntaId?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    requisitoNormativo?: SortOrder
    accionCorrectiva?: SortOrder
    responsable?: SortOrder
    fechaLimite?: SortOrder
    estado?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type HallazgoMinOrderByAggregateInput = {
    id?: SortOrder
    preguntaId?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    requisitoNormativo?: SortOrder
    accionCorrectiva?: SortOrder
    responsable?: SortOrder
    fechaLimite?: SortOrder
    estado?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type MensajeChatCountOrderByAggregateInput = {
    id?: SortOrder
    asignacionId?: SortOrder
    cuestionarioId?: SortOrder
    activoProcesoId?: SortOrder
    usuarioId?: SortOrder
    usuarioNombre?: SortOrder
    usuarioRol?: SortOrder
    mensaje?: SortOrder
    fecha?: SortOrder
    leido?: SortOrder
  }

  export type MensajeChatMaxOrderByAggregateInput = {
    id?: SortOrder
    asignacionId?: SortOrder
    cuestionarioId?: SortOrder
    activoProcesoId?: SortOrder
    usuarioId?: SortOrder
    usuarioNombre?: SortOrder
    usuarioRol?: SortOrder
    mensaje?: SortOrder
    fecha?: SortOrder
    leido?: SortOrder
  }

  export type MensajeChatMinOrderByAggregateInput = {
    id?: SortOrder
    asignacionId?: SortOrder
    cuestionarioId?: SortOrder
    activoProcesoId?: SortOrder
    usuarioId?: SortOrder
    usuarioNombre?: SortOrder
    usuarioRol?: SortOrder
    mensaje?: SortOrder
    fecha?: SortOrder
    leido?: SortOrder
  }

  export type AlertaCumplimientoCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    severidad?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    entidadId?: SortOrder
    entidadTipo?: SortOrder
    fechaGeneracion?: SortOrder
    estado?: SortOrder
    responsable?: SortOrder
    marcoNormativo?: SortOrder
  }

  export type AlertaCumplimientoMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    severidad?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    entidadId?: SortOrder
    entidadTipo?: SortOrder
    fechaGeneracion?: SortOrder
    estado?: SortOrder
    responsable?: SortOrder
    marcoNormativo?: SortOrder
  }

  export type AlertaCumplimientoMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    severidad?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    entidadId?: SortOrder
    entidadTipo?: SortOrder
    fechaGeneracion?: SortOrder
    estado?: SortOrder
    responsable?: SortOrder
    marcoNormativo?: SortOrder
  }

  export type ProcessNodeListRelationFilter = {
    every?: ProcessNodeWhereInput
    some?: ProcessNodeWhereInput
    none?: ProcessNodeWhereInput
  }

  export type ProcessEdgeListRelationFilter = {
    every?: ProcessEdgeWhereInput
    some?: ProcessEdgeWhereInput
    none?: ProcessEdgeWhereInput
  }

  export type ObjetivoProcesoListRelationFilter = {
    every?: ObjetivoProcesoWhereInput
    some?: ObjetivoProcesoWhereInput
    none?: ObjetivoProcesoWhereInput
  }

  export type KpiProcesoListRelationFilter = {
    every?: KpiProcesoWhereInput
    some?: KpiProcesoWhereInput
    none?: KpiProcesoWhereInput
  }

  export type ProcessNodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessEdgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObjetivoProcesoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KpiProcesoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcesoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    version?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ProcesoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    version?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ProcesoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    version?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ProcesoRelationFilter = {
    is?: ProcesoWhereInput
    isNot?: ProcesoWhereInput
  }

  export type KpiHistoricoListRelationFilter = {
    every?: KpiHistoricoWhereInput
    some?: KpiHistoricoWhereInput
    none?: KpiHistoricoWhereInput
  }

  export type KpiHistoricoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessNodeCountOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    descripcion?: SortOrder
    config?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type ProcessNodeAvgOrderByAggregateInput = {
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type ProcessNodeMaxOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    descripcion?: SortOrder
    config?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type ProcessNodeMinOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    descripcion?: SortOrder
    config?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type ProcessNodeSumOrderByAggregateInput = {
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type ProcessNodeRelationFilter = {
    is?: ProcessNodeWhereInput
    isNot?: ProcessNodeWhereInput
  }

  export type ProcessEdgeCountOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    sourceNodeId?: SortOrder
    targetNodeId?: SortOrder
    sourceHandle?: SortOrder
    targetHandle?: SortOrder
    label?: SortOrder
  }

  export type ProcessEdgeMaxOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    sourceNodeId?: SortOrder
    targetNodeId?: SortOrder
    sourceHandle?: SortOrder
    targetHandle?: SortOrder
    label?: SortOrder
  }

  export type ProcessEdgeMinOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    sourceNodeId?: SortOrder
    targetNodeId?: SortOrder
    sourceHandle?: SortOrder
    targetHandle?: SortOrder
    label?: SortOrder
  }

  export type ObjetivoProcesoCountOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    progreso?: SortOrder
  }

  export type ObjetivoProcesoAvgOrderByAggregateInput = {
    progreso?: SortOrder
  }

  export type ObjetivoProcesoMaxOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    progreso?: SortOrder
  }

  export type ObjetivoProcesoMinOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    progreso?: SortOrder
  }

  export type ObjetivoProcesoSumOrderByAggregateInput = {
    progreso?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ObjetivoProcesoNullableRelationFilter = {
    is?: ObjetivoProcesoWhereInput | null
    isNot?: ObjetivoProcesoWhereInput | null
  }

  export type KpiProcesoCountOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    objetivoId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    unidad?: SortOrder
    meta?: SortOrder
    valorActual?: SortOrder
    fechaUltimaActualizacion?: SortOrder
    alertaAdvertencia?: SortOrder
    alertaCritico?: SortOrder
    alertaDireccion?: SortOrder
  }

  export type KpiProcesoAvgOrderByAggregateInput = {
    meta?: SortOrder
    valorActual?: SortOrder
    alertaAdvertencia?: SortOrder
    alertaCritico?: SortOrder
  }

  export type KpiProcesoMaxOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    objetivoId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    unidad?: SortOrder
    meta?: SortOrder
    valorActual?: SortOrder
    fechaUltimaActualizacion?: SortOrder
    alertaAdvertencia?: SortOrder
    alertaCritico?: SortOrder
    alertaDireccion?: SortOrder
  }

  export type KpiProcesoMinOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    objetivoId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    unidad?: SortOrder
    meta?: SortOrder
    valorActual?: SortOrder
    fechaUltimaActualizacion?: SortOrder
    alertaAdvertencia?: SortOrder
    alertaCritico?: SortOrder
    alertaDireccion?: SortOrder
  }

  export type KpiProcesoSumOrderByAggregateInput = {
    meta?: SortOrder
    valorActual?: SortOrder
    alertaAdvertencia?: SortOrder
    alertaCritico?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type KpiProcesoRelationFilter = {
    is?: KpiProcesoWhereInput
    isNot?: KpiProcesoWhereInput
  }

  export type ProcessNodeNullableRelationFilter = {
    is?: ProcessNodeWhereInput | null
    isNot?: ProcessNodeWhereInput | null
  }

  export type KpiHistoricoCountOrderByAggregateInput = {
    id?: SortOrder
    kpiId?: SortOrder
    valor?: SortOrder
    timestamp?: SortOrder
    procesoId?: SortOrder
    nodoId?: SortOrder
    metadatos?: SortOrder
  }

  export type KpiHistoricoAvgOrderByAggregateInput = {
    valor?: SortOrder
  }

  export type KpiHistoricoMaxOrderByAggregateInput = {
    id?: SortOrder
    kpiId?: SortOrder
    valor?: SortOrder
    timestamp?: SortOrder
    procesoId?: SortOrder
    nodoId?: SortOrder
    metadatos?: SortOrder
  }

  export type KpiHistoricoMinOrderByAggregateInput = {
    id?: SortOrder
    kpiId?: SortOrder
    valor?: SortOrder
    timestamp?: SortOrder
    procesoId?: SortOrder
    nodoId?: SortOrder
    metadatos?: SortOrder
  }

  export type KpiHistoricoSumOrderByAggregateInput = {
    valor?: SortOrder
  }

  export type DashboardWidgetListRelationFilter = {
    every?: DashboardWidgetWhereInput
    some?: DashboardWidgetWhereInput
    none?: DashboardWidgetWhereInput
  }

  export type DashboardWidgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DashboardConfigCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    isDefault?: SortOrder
    isLocked?: SortOrder
    columns?: SortOrder
    rowHeight?: SortOrder
    gap?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DashboardConfigAvgOrderByAggregateInput = {
    columns?: SortOrder
    rowHeight?: SortOrder
    gap?: SortOrder
  }

  export type DashboardConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    isDefault?: SortOrder
    isLocked?: SortOrder
    columns?: SortOrder
    rowHeight?: SortOrder
    gap?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DashboardConfigMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    isDefault?: SortOrder
    isLocked?: SortOrder
    columns?: SortOrder
    rowHeight?: SortOrder
    gap?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DashboardConfigSumOrderByAggregateInput = {
    columns?: SortOrder
    rowHeight?: SortOrder
    gap?: SortOrder
  }

  export type DashboardConfigRelationFilter = {
    is?: DashboardConfigWhereInput
    isNot?: DashboardConfigWhereInput
  }

  export type DashboardWidgetCountOrderByAggregateInput = {
    id?: SortOrder
    dashboardId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    subtitulo?: SortOrder
    icono?: SortOrder
    config?: SortOrder
    x?: SortOrder
    y?: SortOrder
    cols?: SortOrder
    rows?: SortOrder
    canResize?: SortOrder
    canDrag?: SortOrder
    canRemove?: SortOrder
    canEdit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardWidgetAvgOrderByAggregateInput = {
    x?: SortOrder
    y?: SortOrder
    cols?: SortOrder
    rows?: SortOrder
  }

  export type DashboardWidgetMaxOrderByAggregateInput = {
    id?: SortOrder
    dashboardId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    subtitulo?: SortOrder
    icono?: SortOrder
    config?: SortOrder
    x?: SortOrder
    y?: SortOrder
    cols?: SortOrder
    rows?: SortOrder
    canResize?: SortOrder
    canDrag?: SortOrder
    canRemove?: SortOrder
    canEdit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardWidgetMinOrderByAggregateInput = {
    id?: SortOrder
    dashboardId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    subtitulo?: SortOrder
    icono?: SortOrder
    config?: SortOrder
    x?: SortOrder
    y?: SortOrder
    cols?: SortOrder
    rows?: SortOrder
    canResize?: SortOrder
    canDrag?: SortOrder
    canRemove?: SortOrder
    canEdit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardWidgetSumOrderByAggregateInput = {
    x?: SortOrder
    y?: SortOrder
    cols?: SortOrder
    rows?: SortOrder
  }

  export type CatalogoTipoCodigoCompoundUniqueInput = {
    tipo: string
    codigo: string
  }

  export type CatalogoCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    activo?: SortOrder
    color?: SortOrder
    icono?: SortOrder
    metadata?: SortOrder
  }

  export type CatalogoAvgOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type CatalogoMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    activo?: SortOrder
    color?: SortOrder
    icono?: SortOrder
    metadata?: SortOrder
  }

  export type CatalogoMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    activo?: SortOrder
    color?: SortOrder
    icono?: SortOrder
    metadata?: SortOrder
  }

  export type CatalogoSumOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type NotificationRuleCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    entidadTipo?: SortOrder
    eventoTipo?: SortOrder
    activo?: SortOrder
    notificarCreador?: SortOrder
    notificarResponsable?: SortOrder
    notificarAprobadores?: SortOrder
    rolesDestino?: SortOrder
    usuariosDestino?: SortOrder
    enviarInApp?: SortOrder
    enviarEmail?: SortOrder
    plantillaMensaje?: SortOrder
    severidad?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type NotificationRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    entidadTipo?: SortOrder
    eventoTipo?: SortOrder
    activo?: SortOrder
    notificarCreador?: SortOrder
    notificarResponsable?: SortOrder
    notificarAprobadores?: SortOrder
    rolesDestino?: SortOrder
    usuariosDestino?: SortOrder
    enviarInApp?: SortOrder
    enviarEmail?: SortOrder
    plantillaMensaje?: SortOrder
    severidad?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type NotificationRuleMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    entidadTipo?: SortOrder
    eventoTipo?: SortOrder
    activo?: SortOrder
    notificarCreador?: SortOrder
    notificarResponsable?: SortOrder
    notificarAprobadores?: SortOrder
    rolesDestino?: SortOrder
    usuariosDestino?: SortOrder
    enviarInApp?: SortOrder
    enviarEmail?: SortOrder
    plantillaMensaje?: SortOrder
    severidad?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type AlertRuleCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    entidadTipo?: SortOrder
    entidadId?: SortOrder
    metricaNombre?: SortOrder
    operador?: SortOrder
    valorUmbral?: SortOrder
    tipoAgregacion?: SortOrder
    periodoEvaluacion?: SortOrder
    activo?: SortOrder
    rolesDestino?: SortOrder
    usuariosDestino?: SortOrder
    enviarInApp?: SortOrder
    enviarEmail?: SortOrder
    severidad?: SortOrder
    cooldownMinutos?: SortOrder
    ultimaEjecucion?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type AlertRuleAvgOrderByAggregateInput = {
    valorUmbral?: SortOrder
    cooldownMinutos?: SortOrder
  }

  export type AlertRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    entidadTipo?: SortOrder
    entidadId?: SortOrder
    metricaNombre?: SortOrder
    operador?: SortOrder
    valorUmbral?: SortOrder
    tipoAgregacion?: SortOrder
    periodoEvaluacion?: SortOrder
    activo?: SortOrder
    rolesDestino?: SortOrder
    usuariosDestino?: SortOrder
    enviarInApp?: SortOrder
    enviarEmail?: SortOrder
    severidad?: SortOrder
    cooldownMinutos?: SortOrder
    ultimaEjecucion?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type AlertRuleMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    entidadTipo?: SortOrder
    entidadId?: SortOrder
    metricaNombre?: SortOrder
    operador?: SortOrder
    valorUmbral?: SortOrder
    tipoAgregacion?: SortOrder
    periodoEvaluacion?: SortOrder
    activo?: SortOrder
    rolesDestino?: SortOrder
    usuariosDestino?: SortOrder
    enviarInApp?: SortOrder
    enviarEmail?: SortOrder
    severidad?: SortOrder
    cooldownMinutos?: SortOrder
    ultimaEjecucion?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type AlertRuleSumOrderByAggregateInput = {
    valorUmbral?: SortOrder
    cooldownMinutos?: SortOrder
  }

  export type ExpirationRuleCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    entidadTipo?: SortOrder
    diasAnticipacion?: SortOrder
    diasDespuesVencido?: SortOrder
    activo?: SortOrder
    notificarResponsable?: SortOrder
    notificarSupervisor?: SortOrder
    rolesDestino?: SortOrder
    enviarInApp?: SortOrder
    enviarEmail?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type ExpirationRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    entidadTipo?: SortOrder
    diasAnticipacion?: SortOrder
    diasDespuesVencido?: SortOrder
    activo?: SortOrder
    notificarResponsable?: SortOrder
    notificarSupervisor?: SortOrder
    rolesDestino?: SortOrder
    enviarInApp?: SortOrder
    enviarEmail?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type ExpirationRuleMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    entidadTipo?: SortOrder
    diasAnticipacion?: SortOrder
    diasDespuesVencido?: SortOrder
    activo?: SortOrder
    notificarResponsable?: SortOrder
    notificarSupervisor?: SortOrder
    rolesDestino?: SortOrder
    enviarInApp?: SortOrder
    enviarEmail?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    severidad?: SortOrder
    entidadTipo?: SortOrder
    entidadId?: SortOrder
    entidadNombre?: SortOrder
    leida?: SortOrder
    archivada?: SortOrder
    enSeguimiento?: SortOrder
    acciones?: SortOrder
    attachmentTipo?: SortOrder
    attachmentUrl?: SortOrder
    attachmentTitulo?: SortOrder
    attachmentSubtitulo?: SortOrder
    metadata?: SortOrder
    reglaId?: SortOrder
    reglaTipo?: SortOrder
    fechaCreacion?: SortOrder
    fechaLeida?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    severidad?: SortOrder
    entidadTipo?: SortOrder
    entidadId?: SortOrder
    entidadNombre?: SortOrder
    leida?: SortOrder
    archivada?: SortOrder
    enSeguimiento?: SortOrder
    acciones?: SortOrder
    attachmentTipo?: SortOrder
    attachmentUrl?: SortOrder
    attachmentTitulo?: SortOrder
    attachmentSubtitulo?: SortOrder
    metadata?: SortOrder
    reglaId?: SortOrder
    reglaTipo?: SortOrder
    fechaCreacion?: SortOrder
    fechaLeida?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    severidad?: SortOrder
    entidadTipo?: SortOrder
    entidadId?: SortOrder
    entidadNombre?: SortOrder
    leida?: SortOrder
    archivada?: SortOrder
    enSeguimiento?: SortOrder
    acciones?: SortOrder
    attachmentTipo?: SortOrder
    attachmentUrl?: SortOrder
    attachmentTitulo?: SortOrder
    attachmentSubtitulo?: SortOrder
    metadata?: SortOrder
    reglaId?: SortOrder
    reglaTipo?: SortOrder
    fechaCreacion?: SortOrder
    fechaLeida?: SortOrder
  }

  export type UserNotificationPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    habilitado?: SortOrder
    emailHabilitado?: SortOrder
    inAppHabilitado?: SortOrder
    preferenciasPorEntidad?: SortOrder
    notificarInfo?: SortOrder
    notificarWarning?: SortOrder
    notificarCritical?: SortOrder
    frecuenciaEmail?: SortOrder
    horaResumen?: SortOrder
    horarioNoMolestarHabilitado?: SortOrder
    horarioNoMolestarInicio?: SortOrder
    horarioNoMolestarFin?: SortOrder
    horarioNoMolestarDias?: SortOrder
    rateLimitHabilitado?: SortOrder
    rateLimitMaxPorHora?: SortOrder
    preferenciasPorModulo?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type UserNotificationPreferencesAvgOrderByAggregateInput = {
    rateLimitMaxPorHora?: SortOrder
  }

  export type UserNotificationPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    habilitado?: SortOrder
    emailHabilitado?: SortOrder
    inAppHabilitado?: SortOrder
    preferenciasPorEntidad?: SortOrder
    notificarInfo?: SortOrder
    notificarWarning?: SortOrder
    notificarCritical?: SortOrder
    frecuenciaEmail?: SortOrder
    horaResumen?: SortOrder
    horarioNoMolestarHabilitado?: SortOrder
    horarioNoMolestarInicio?: SortOrder
    horarioNoMolestarFin?: SortOrder
    horarioNoMolestarDias?: SortOrder
    rateLimitHabilitado?: SortOrder
    rateLimitMaxPorHora?: SortOrder
    preferenciasPorModulo?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type UserNotificationPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    habilitado?: SortOrder
    emailHabilitado?: SortOrder
    inAppHabilitado?: SortOrder
    preferenciasPorEntidad?: SortOrder
    notificarInfo?: SortOrder
    notificarWarning?: SortOrder
    notificarCritical?: SortOrder
    frecuenciaEmail?: SortOrder
    horaResumen?: SortOrder
    horarioNoMolestarHabilitado?: SortOrder
    horarioNoMolestarInicio?: SortOrder
    horarioNoMolestarFin?: SortOrder
    horarioNoMolestarDias?: SortOrder
    rateLimitHabilitado?: SortOrder
    rateLimitMaxPorHora?: SortOrder
    preferenciasPorModulo?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
  }

  export type UserNotificationPreferencesSumOrderByAggregateInput = {
    rateLimitMaxPorHora?: SortOrder
  }

  export type NotificationLogCountOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    usuarioId?: SortOrder
    canal?: SortOrder
    estado?: SortOrder
    errorMensaje?: SortOrder
    reglaId?: SortOrder
    reglaTipo?: SortOrder
    metadata?: SortOrder
    fechaEnvio?: SortOrder
  }

  export type NotificationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    usuarioId?: SortOrder
    canal?: SortOrder
    estado?: SortOrder
    errorMensaje?: SortOrder
    reglaId?: SortOrder
    reglaTipo?: SortOrder
    metadata?: SortOrder
    fechaEnvio?: SortOrder
  }

  export type NotificationLogMinOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    usuarioId?: SortOrder
    canal?: SortOrder
    estado?: SortOrder
    errorMensaje?: SortOrder
    reglaId?: SortOrder
    reglaTipo?: SortOrder
    metadata?: SortOrder
    fechaEnvio?: SortOrder
  }

  export type NotificationProfileCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    eventos?: SortOrder
    seleccionEntidades?: SortOrder
    filtrosEntidad?: SortOrder
    destinatarios?: SortOrder
    canales?: SortOrder
    plantillaTitulo?: SortOrder
    plantillaMensaje?: SortOrder
    severidad?: SortOrder
    estado?: SortOrder
    horarioNoMolestar?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
    creadoPorId?: SortOrder
  }

  export type NotificationProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    eventos?: SortOrder
    seleccionEntidades?: SortOrder
    filtrosEntidad?: SortOrder
    destinatarios?: SortOrder
    canales?: SortOrder
    plantillaTitulo?: SortOrder
    plantillaMensaje?: SortOrder
    severidad?: SortOrder
    estado?: SortOrder
    horarioNoMolestar?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
    creadoPorId?: SortOrder
  }

  export type NotificationProfileMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    eventos?: SortOrder
    seleccionEntidades?: SortOrder
    filtrosEntidad?: SortOrder
    destinatarios?: SortOrder
    canales?: SortOrder
    plantillaTitulo?: SortOrder
    plantillaMensaje?: SortOrder
    severidad?: SortOrder
    estado?: SortOrder
    horarioNoMolestar?: SortOrder
    fechaCreacion?: SortOrder
    fechaModificacion?: SortOrder
    creadoPorId?: SortOrder
  }

  export type ProjectObjectiveListRelationFilter = {
    every?: ProjectObjectiveWhereInput
    some?: ProjectObjectiveWhereInput
    none?: ProjectObjectiveWhereInput
  }

  export type ProjectKPIListRelationFilter = {
    every?: ProjectKPIWhereInput
    some?: ProjectKPIWhereInput
    none?: ProjectKPIWhereInput
  }

  export type ProjectPhaseListRelationFilter = {
    every?: ProjectPhaseWhereInput
    some?: ProjectPhaseWhereInput
    none?: ProjectPhaseWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type ProjectObjectiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectKPIOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectPhaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    responsibleUserId?: SortOrder
    orgUnitId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    reminderDays?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    responsibleUserId?: SortOrder
    orgUnitId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    reminderDays?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    responsibleUserId?: SortOrder
    orgUnitId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    reminderDays?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectObjectiveCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    targetDate?: SortOrder
    completedDate?: SortOrder
  }

  export type ProjectObjectiveMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    targetDate?: SortOrder
    completedDate?: SortOrder
  }

  export type ProjectObjectiveMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    targetDate?: SortOrder
    completedDate?: SortOrder
  }

  export type ProjectKPICountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    unit?: SortOrder
    formulaType?: SortOrder
    formula?: SortOrder
    status?: SortOrder
  }

  export type ProjectKPIAvgOrderByAggregateInput = {
    targetValue?: SortOrder
    currentValue?: SortOrder
  }

  export type ProjectKPIMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    unit?: SortOrder
    formulaType?: SortOrder
    formula?: SortOrder
    status?: SortOrder
  }

  export type ProjectKPIMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    unit?: SortOrder
    formulaType?: SortOrder
    formula?: SortOrder
    status?: SortOrder
  }

  export type ProjectKPISumOrderByAggregateInput = {
    targetValue?: SortOrder
    currentValue?: SortOrder
  }

  export type ProjectPhaseNullableRelationFilter = {
    is?: ProjectPhaseWhereInput | null
    isNot?: ProjectPhaseWhereInput | null
  }

  export type ProjectPhaseCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    orderNum?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    actualStartDate?: SortOrder
    actualEndDate?: SortOrder
    status?: SortOrder
    weight?: SortOrder
    dependsOnPhaseId?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectPhaseAvgOrderByAggregateInput = {
    orderNum?: SortOrder
    weight?: SortOrder
    progress?: SortOrder
  }

  export type ProjectPhaseMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    orderNum?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    actualStartDate?: SortOrder
    actualEndDate?: SortOrder
    status?: SortOrder
    weight?: SortOrder
    dependsOnPhaseId?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectPhaseMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    orderNum?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    actualStartDate?: SortOrder
    actualEndDate?: SortOrder
    status?: SortOrder
    weight?: SortOrder
    dependsOnPhaseId?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectPhaseSumOrderByAggregateInput = {
    orderNum?: SortOrder
    weight?: SortOrder
    progress?: SortOrder
  }

  export type ProjectPhaseRelationFilter = {
    is?: ProjectPhaseWhereInput
    isNot?: ProjectPhaseWhereInput
  }

  export type TaskEvidenceListRelationFilter = {
    every?: TaskEvidenceWhereInput
    some?: TaskEvidenceWhereInput
    none?: TaskEvidenceWhereInput
  }

  export type TaskHistoryListRelationFilter = {
    every?: TaskHistoryWhereInput
    some?: TaskHistoryWhereInput
    none?: TaskHistoryWhereInput
  }

  export type TaskEvidenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    assignedTo?: SortOrder
    assignedBy?: SortOrder
    assignedAt?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    taskType?: SortOrder
    linkedEntityType?: SortOrder
    linkedEntityId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    progress?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    assignedTo?: SortOrder
    assignedBy?: SortOrder
    assignedAt?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    taskType?: SortOrder
    linkedEntityType?: SortOrder
    linkedEntityId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    assignedTo?: SortOrder
    assignedBy?: SortOrder
    assignedAt?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    taskType?: SortOrder
    linkedEntityType?: SortOrder
    linkedEntityId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    progress?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
  }

  export type TaskRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type TaskEvidenceCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    storageUrl?: SortOrder
    evidenceType?: SortOrder
    description?: SortOrder
    documentDate?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
  }

  export type TaskEvidenceAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type TaskEvidenceMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    storageUrl?: SortOrder
    evidenceType?: SortOrder
    description?: SortOrder
    documentDate?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
  }

  export type TaskEvidenceMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    storageUrl?: SortOrder
    evidenceType?: SortOrder
    description?: SortOrder
    documentDate?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
  }

  export type TaskEvidenceSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type TaskHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    changes?: SortOrder
    comment?: SortOrder
    timestamp?: SortOrder
  }

  export type TaskHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    changes?: SortOrder
    comment?: SortOrder
    timestamp?: SortOrder
  }

  export type TaskHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    changes?: SortOrder
    comment?: SortOrder
    timestamp?: SortOrder
  }

  export type UsuarioRolCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<UsuarioRolCreateWithoutUsuarioInput, UsuarioRolUncheckedCreateWithoutUsuarioInput> | UsuarioRolCreateWithoutUsuarioInput[] | UsuarioRolUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: UsuarioRolCreateOrConnectWithoutUsuarioInput | UsuarioRolCreateOrConnectWithoutUsuarioInput[]
    createMany?: UsuarioRolCreateManyUsuarioInputEnvelope
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
  }

  export type UsuarioActivoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<UsuarioActivoCreateWithoutUsuarioInput, UsuarioActivoUncheckedCreateWithoutUsuarioInput> | UsuarioActivoCreateWithoutUsuarioInput[] | UsuarioActivoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: UsuarioActivoCreateOrConnectWithoutUsuarioInput | UsuarioActivoCreateOrConnectWithoutUsuarioInput[]
    createMany?: UsuarioActivoCreateManyUsuarioInputEnvelope
    connect?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
  }

  export type LogAuditoriaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<LogAuditoriaCreateWithoutUsuarioInput, LogAuditoriaUncheckedCreateWithoutUsuarioInput> | LogAuditoriaCreateWithoutUsuarioInput[] | LogAuditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: LogAuditoriaCreateOrConnectWithoutUsuarioInput | LogAuditoriaCreateOrConnectWithoutUsuarioInput[]
    createMany?: LogAuditoriaCreateManyUsuarioInputEnvelope
    connect?: LogAuditoriaWhereUniqueInput | LogAuditoriaWhereUniqueInput[]
  }

  export type RespuestaCuestionarioCreateNestedManyWithoutRespondidoPorInput = {
    create?: XOR<RespuestaCuestionarioCreateWithoutRespondidoPorInput, RespuestaCuestionarioUncheckedCreateWithoutRespondidoPorInput> | RespuestaCuestionarioCreateWithoutRespondidoPorInput[] | RespuestaCuestionarioUncheckedCreateWithoutRespondidoPorInput[]
    connectOrCreate?: RespuestaCuestionarioCreateOrConnectWithoutRespondidoPorInput | RespuestaCuestionarioCreateOrConnectWithoutRespondidoPorInput[]
    createMany?: RespuestaCuestionarioCreateManyRespondidoPorInputEnvelope
    connect?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
  }

  export type UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<UsuarioRolCreateWithoutUsuarioInput, UsuarioRolUncheckedCreateWithoutUsuarioInput> | UsuarioRolCreateWithoutUsuarioInput[] | UsuarioRolUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: UsuarioRolCreateOrConnectWithoutUsuarioInput | UsuarioRolCreateOrConnectWithoutUsuarioInput[]
    createMany?: UsuarioRolCreateManyUsuarioInputEnvelope
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
  }

  export type UsuarioActivoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<UsuarioActivoCreateWithoutUsuarioInput, UsuarioActivoUncheckedCreateWithoutUsuarioInput> | UsuarioActivoCreateWithoutUsuarioInput[] | UsuarioActivoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: UsuarioActivoCreateOrConnectWithoutUsuarioInput | UsuarioActivoCreateOrConnectWithoutUsuarioInput[]
    createMany?: UsuarioActivoCreateManyUsuarioInputEnvelope
    connect?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
  }

  export type LogAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<LogAuditoriaCreateWithoutUsuarioInput, LogAuditoriaUncheckedCreateWithoutUsuarioInput> | LogAuditoriaCreateWithoutUsuarioInput[] | LogAuditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: LogAuditoriaCreateOrConnectWithoutUsuarioInput | LogAuditoriaCreateOrConnectWithoutUsuarioInput[]
    createMany?: LogAuditoriaCreateManyUsuarioInputEnvelope
    connect?: LogAuditoriaWhereUniqueInput | LogAuditoriaWhereUniqueInput[]
  }

  export type RespuestaCuestionarioUncheckedCreateNestedManyWithoutRespondidoPorInput = {
    create?: XOR<RespuestaCuestionarioCreateWithoutRespondidoPorInput, RespuestaCuestionarioUncheckedCreateWithoutRespondidoPorInput> | RespuestaCuestionarioCreateWithoutRespondidoPorInput[] | RespuestaCuestionarioUncheckedCreateWithoutRespondidoPorInput[]
    connectOrCreate?: RespuestaCuestionarioCreateOrConnectWithoutRespondidoPorInput | RespuestaCuestionarioCreateOrConnectWithoutRespondidoPorInput[]
    createMany?: RespuestaCuestionarioCreateManyRespondidoPorInputEnvelope
    connect?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UsuarioRolUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<UsuarioRolCreateWithoutUsuarioInput, UsuarioRolUncheckedCreateWithoutUsuarioInput> | UsuarioRolCreateWithoutUsuarioInput[] | UsuarioRolUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: UsuarioRolCreateOrConnectWithoutUsuarioInput | UsuarioRolCreateOrConnectWithoutUsuarioInput[]
    upsert?: UsuarioRolUpsertWithWhereUniqueWithoutUsuarioInput | UsuarioRolUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: UsuarioRolCreateManyUsuarioInputEnvelope
    set?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    disconnect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    delete?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    update?: UsuarioRolUpdateWithWhereUniqueWithoutUsuarioInput | UsuarioRolUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: UsuarioRolUpdateManyWithWhereWithoutUsuarioInput | UsuarioRolUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[]
  }

  export type UsuarioActivoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<UsuarioActivoCreateWithoutUsuarioInput, UsuarioActivoUncheckedCreateWithoutUsuarioInput> | UsuarioActivoCreateWithoutUsuarioInput[] | UsuarioActivoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: UsuarioActivoCreateOrConnectWithoutUsuarioInput | UsuarioActivoCreateOrConnectWithoutUsuarioInput[]
    upsert?: UsuarioActivoUpsertWithWhereUniqueWithoutUsuarioInput | UsuarioActivoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: UsuarioActivoCreateManyUsuarioInputEnvelope
    set?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
    disconnect?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
    delete?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
    connect?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
    update?: UsuarioActivoUpdateWithWhereUniqueWithoutUsuarioInput | UsuarioActivoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: UsuarioActivoUpdateManyWithWhereWithoutUsuarioInput | UsuarioActivoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: UsuarioActivoScalarWhereInput | UsuarioActivoScalarWhereInput[]
  }

  export type LogAuditoriaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<LogAuditoriaCreateWithoutUsuarioInput, LogAuditoriaUncheckedCreateWithoutUsuarioInput> | LogAuditoriaCreateWithoutUsuarioInput[] | LogAuditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: LogAuditoriaCreateOrConnectWithoutUsuarioInput | LogAuditoriaCreateOrConnectWithoutUsuarioInput[]
    upsert?: LogAuditoriaUpsertWithWhereUniqueWithoutUsuarioInput | LogAuditoriaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: LogAuditoriaCreateManyUsuarioInputEnvelope
    set?: LogAuditoriaWhereUniqueInput | LogAuditoriaWhereUniqueInput[]
    disconnect?: LogAuditoriaWhereUniqueInput | LogAuditoriaWhereUniqueInput[]
    delete?: LogAuditoriaWhereUniqueInput | LogAuditoriaWhereUniqueInput[]
    connect?: LogAuditoriaWhereUniqueInput | LogAuditoriaWhereUniqueInput[]
    update?: LogAuditoriaUpdateWithWhereUniqueWithoutUsuarioInput | LogAuditoriaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: LogAuditoriaUpdateManyWithWhereWithoutUsuarioInput | LogAuditoriaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: LogAuditoriaScalarWhereInput | LogAuditoriaScalarWhereInput[]
  }

  export type RespuestaCuestionarioUpdateManyWithoutRespondidoPorNestedInput = {
    create?: XOR<RespuestaCuestionarioCreateWithoutRespondidoPorInput, RespuestaCuestionarioUncheckedCreateWithoutRespondidoPorInput> | RespuestaCuestionarioCreateWithoutRespondidoPorInput[] | RespuestaCuestionarioUncheckedCreateWithoutRespondidoPorInput[]
    connectOrCreate?: RespuestaCuestionarioCreateOrConnectWithoutRespondidoPorInput | RespuestaCuestionarioCreateOrConnectWithoutRespondidoPorInput[]
    upsert?: RespuestaCuestionarioUpsertWithWhereUniqueWithoutRespondidoPorInput | RespuestaCuestionarioUpsertWithWhereUniqueWithoutRespondidoPorInput[]
    createMany?: RespuestaCuestionarioCreateManyRespondidoPorInputEnvelope
    set?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
    disconnect?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
    delete?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
    connect?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
    update?: RespuestaCuestionarioUpdateWithWhereUniqueWithoutRespondidoPorInput | RespuestaCuestionarioUpdateWithWhereUniqueWithoutRespondidoPorInput[]
    updateMany?: RespuestaCuestionarioUpdateManyWithWhereWithoutRespondidoPorInput | RespuestaCuestionarioUpdateManyWithWhereWithoutRespondidoPorInput[]
    deleteMany?: RespuestaCuestionarioScalarWhereInput | RespuestaCuestionarioScalarWhereInput[]
  }

  export type UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<UsuarioRolCreateWithoutUsuarioInput, UsuarioRolUncheckedCreateWithoutUsuarioInput> | UsuarioRolCreateWithoutUsuarioInput[] | UsuarioRolUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: UsuarioRolCreateOrConnectWithoutUsuarioInput | UsuarioRolCreateOrConnectWithoutUsuarioInput[]
    upsert?: UsuarioRolUpsertWithWhereUniqueWithoutUsuarioInput | UsuarioRolUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: UsuarioRolCreateManyUsuarioInputEnvelope
    set?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    disconnect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    delete?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    update?: UsuarioRolUpdateWithWhereUniqueWithoutUsuarioInput | UsuarioRolUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: UsuarioRolUpdateManyWithWhereWithoutUsuarioInput | UsuarioRolUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[]
  }

  export type UsuarioActivoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<UsuarioActivoCreateWithoutUsuarioInput, UsuarioActivoUncheckedCreateWithoutUsuarioInput> | UsuarioActivoCreateWithoutUsuarioInput[] | UsuarioActivoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: UsuarioActivoCreateOrConnectWithoutUsuarioInput | UsuarioActivoCreateOrConnectWithoutUsuarioInput[]
    upsert?: UsuarioActivoUpsertWithWhereUniqueWithoutUsuarioInput | UsuarioActivoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: UsuarioActivoCreateManyUsuarioInputEnvelope
    set?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
    disconnect?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
    delete?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
    connect?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
    update?: UsuarioActivoUpdateWithWhereUniqueWithoutUsuarioInput | UsuarioActivoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: UsuarioActivoUpdateManyWithWhereWithoutUsuarioInput | UsuarioActivoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: UsuarioActivoScalarWhereInput | UsuarioActivoScalarWhereInput[]
  }

  export type LogAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<LogAuditoriaCreateWithoutUsuarioInput, LogAuditoriaUncheckedCreateWithoutUsuarioInput> | LogAuditoriaCreateWithoutUsuarioInput[] | LogAuditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: LogAuditoriaCreateOrConnectWithoutUsuarioInput | LogAuditoriaCreateOrConnectWithoutUsuarioInput[]
    upsert?: LogAuditoriaUpsertWithWhereUniqueWithoutUsuarioInput | LogAuditoriaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: LogAuditoriaCreateManyUsuarioInputEnvelope
    set?: LogAuditoriaWhereUniqueInput | LogAuditoriaWhereUniqueInput[]
    disconnect?: LogAuditoriaWhereUniqueInput | LogAuditoriaWhereUniqueInput[]
    delete?: LogAuditoriaWhereUniqueInput | LogAuditoriaWhereUniqueInput[]
    connect?: LogAuditoriaWhereUniqueInput | LogAuditoriaWhereUniqueInput[]
    update?: LogAuditoriaUpdateWithWhereUniqueWithoutUsuarioInput | LogAuditoriaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: LogAuditoriaUpdateManyWithWhereWithoutUsuarioInput | LogAuditoriaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: LogAuditoriaScalarWhereInput | LogAuditoriaScalarWhereInput[]
  }

  export type RespuestaCuestionarioUncheckedUpdateManyWithoutRespondidoPorNestedInput = {
    create?: XOR<RespuestaCuestionarioCreateWithoutRespondidoPorInput, RespuestaCuestionarioUncheckedCreateWithoutRespondidoPorInput> | RespuestaCuestionarioCreateWithoutRespondidoPorInput[] | RespuestaCuestionarioUncheckedCreateWithoutRespondidoPorInput[]
    connectOrCreate?: RespuestaCuestionarioCreateOrConnectWithoutRespondidoPorInput | RespuestaCuestionarioCreateOrConnectWithoutRespondidoPorInput[]
    upsert?: RespuestaCuestionarioUpsertWithWhereUniqueWithoutRespondidoPorInput | RespuestaCuestionarioUpsertWithWhereUniqueWithoutRespondidoPorInput[]
    createMany?: RespuestaCuestionarioCreateManyRespondidoPorInputEnvelope
    set?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
    disconnect?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
    delete?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
    connect?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
    update?: RespuestaCuestionarioUpdateWithWhereUniqueWithoutRespondidoPorInput | RespuestaCuestionarioUpdateWithWhereUniqueWithoutRespondidoPorInput[]
    updateMany?: RespuestaCuestionarioUpdateManyWithWhereWithoutRespondidoPorInput | RespuestaCuestionarioUpdateManyWithWhereWithoutRespondidoPorInput[]
    deleteMany?: RespuestaCuestionarioScalarWhereInput | RespuestaCuestionarioScalarWhereInput[]
  }

  export type UsuarioRolCreateNestedManyWithoutRolInput = {
    create?: XOR<UsuarioRolCreateWithoutRolInput, UsuarioRolUncheckedCreateWithoutRolInput> | UsuarioRolCreateWithoutRolInput[] | UsuarioRolUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuarioRolCreateOrConnectWithoutRolInput | UsuarioRolCreateOrConnectWithoutRolInput[]
    createMany?: UsuarioRolCreateManyRolInputEnvelope
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
  }

  export type RolPermisoCreateNestedManyWithoutRolInput = {
    create?: XOR<RolPermisoCreateWithoutRolInput, RolPermisoUncheckedCreateWithoutRolInput> | RolPermisoCreateWithoutRolInput[] | RolPermisoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolPermisoCreateOrConnectWithoutRolInput | RolPermisoCreateOrConnectWithoutRolInput[]
    createMany?: RolPermisoCreateManyRolInputEnvelope
    connect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
  }

  export type UsuarioRolUncheckedCreateNestedManyWithoutRolInput = {
    create?: XOR<UsuarioRolCreateWithoutRolInput, UsuarioRolUncheckedCreateWithoutRolInput> | UsuarioRolCreateWithoutRolInput[] | UsuarioRolUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuarioRolCreateOrConnectWithoutRolInput | UsuarioRolCreateOrConnectWithoutRolInput[]
    createMany?: UsuarioRolCreateManyRolInputEnvelope
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
  }

  export type RolPermisoUncheckedCreateNestedManyWithoutRolInput = {
    create?: XOR<RolPermisoCreateWithoutRolInput, RolPermisoUncheckedCreateWithoutRolInput> | RolPermisoCreateWithoutRolInput[] | RolPermisoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolPermisoCreateOrConnectWithoutRolInput | RolPermisoCreateOrConnectWithoutRolInput[]
    createMany?: RolPermisoCreateManyRolInputEnvelope
    connect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
  }

  export type UsuarioRolUpdateManyWithoutRolNestedInput = {
    create?: XOR<UsuarioRolCreateWithoutRolInput, UsuarioRolUncheckedCreateWithoutRolInput> | UsuarioRolCreateWithoutRolInput[] | UsuarioRolUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuarioRolCreateOrConnectWithoutRolInput | UsuarioRolCreateOrConnectWithoutRolInput[]
    upsert?: UsuarioRolUpsertWithWhereUniqueWithoutRolInput | UsuarioRolUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: UsuarioRolCreateManyRolInputEnvelope
    set?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    disconnect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    delete?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    update?: UsuarioRolUpdateWithWhereUniqueWithoutRolInput | UsuarioRolUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: UsuarioRolUpdateManyWithWhereWithoutRolInput | UsuarioRolUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[]
  }

  export type RolPermisoUpdateManyWithoutRolNestedInput = {
    create?: XOR<RolPermisoCreateWithoutRolInput, RolPermisoUncheckedCreateWithoutRolInput> | RolPermisoCreateWithoutRolInput[] | RolPermisoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolPermisoCreateOrConnectWithoutRolInput | RolPermisoCreateOrConnectWithoutRolInput[]
    upsert?: RolPermisoUpsertWithWhereUniqueWithoutRolInput | RolPermisoUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: RolPermisoCreateManyRolInputEnvelope
    set?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    disconnect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    delete?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    connect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    update?: RolPermisoUpdateWithWhereUniqueWithoutRolInput | RolPermisoUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: RolPermisoUpdateManyWithWhereWithoutRolInput | RolPermisoUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: RolPermisoScalarWhereInput | RolPermisoScalarWhereInput[]
  }

  export type UsuarioRolUncheckedUpdateManyWithoutRolNestedInput = {
    create?: XOR<UsuarioRolCreateWithoutRolInput, UsuarioRolUncheckedCreateWithoutRolInput> | UsuarioRolCreateWithoutRolInput[] | UsuarioRolUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuarioRolCreateOrConnectWithoutRolInput | UsuarioRolCreateOrConnectWithoutRolInput[]
    upsert?: UsuarioRolUpsertWithWhereUniqueWithoutRolInput | UsuarioRolUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: UsuarioRolCreateManyRolInputEnvelope
    set?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    disconnect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    delete?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    update?: UsuarioRolUpdateWithWhereUniqueWithoutRolInput | UsuarioRolUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: UsuarioRolUpdateManyWithWhereWithoutRolInput | UsuarioRolUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[]
  }

  export type RolPermisoUncheckedUpdateManyWithoutRolNestedInput = {
    create?: XOR<RolPermisoCreateWithoutRolInput, RolPermisoUncheckedCreateWithoutRolInput> | RolPermisoCreateWithoutRolInput[] | RolPermisoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolPermisoCreateOrConnectWithoutRolInput | RolPermisoCreateOrConnectWithoutRolInput[]
    upsert?: RolPermisoUpsertWithWhereUniqueWithoutRolInput | RolPermisoUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: RolPermisoCreateManyRolInputEnvelope
    set?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    disconnect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    delete?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    connect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    update?: RolPermisoUpdateWithWhereUniqueWithoutRolInput | RolPermisoUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: RolPermisoUpdateManyWithWhereWithoutRolInput | RolPermisoUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: RolPermisoScalarWhereInput | RolPermisoScalarWhereInput[]
  }

  export type PermisoCreateNestedOneWithoutHijosInput = {
    create?: XOR<PermisoCreateWithoutHijosInput, PermisoUncheckedCreateWithoutHijosInput>
    connectOrCreate?: PermisoCreateOrConnectWithoutHijosInput
    connect?: PermisoWhereUniqueInput
  }

  export type PermisoCreateNestedManyWithoutPadreInput = {
    create?: XOR<PermisoCreateWithoutPadreInput, PermisoUncheckedCreateWithoutPadreInput> | PermisoCreateWithoutPadreInput[] | PermisoUncheckedCreateWithoutPadreInput[]
    connectOrCreate?: PermisoCreateOrConnectWithoutPadreInput | PermisoCreateOrConnectWithoutPadreInput[]
    createMany?: PermisoCreateManyPadreInputEnvelope
    connect?: PermisoWhereUniqueInput | PermisoWhereUniqueInput[]
  }

  export type RolPermisoCreateNestedManyWithoutPermisoInput = {
    create?: XOR<RolPermisoCreateWithoutPermisoInput, RolPermisoUncheckedCreateWithoutPermisoInput> | RolPermisoCreateWithoutPermisoInput[] | RolPermisoUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: RolPermisoCreateOrConnectWithoutPermisoInput | RolPermisoCreateOrConnectWithoutPermisoInput[]
    createMany?: RolPermisoCreateManyPermisoInputEnvelope
    connect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
  }

  export type PermisoUncheckedCreateNestedManyWithoutPadreInput = {
    create?: XOR<PermisoCreateWithoutPadreInput, PermisoUncheckedCreateWithoutPadreInput> | PermisoCreateWithoutPadreInput[] | PermisoUncheckedCreateWithoutPadreInput[]
    connectOrCreate?: PermisoCreateOrConnectWithoutPadreInput | PermisoCreateOrConnectWithoutPadreInput[]
    createMany?: PermisoCreateManyPadreInputEnvelope
    connect?: PermisoWhereUniqueInput | PermisoWhereUniqueInput[]
  }

  export type RolPermisoUncheckedCreateNestedManyWithoutPermisoInput = {
    create?: XOR<RolPermisoCreateWithoutPermisoInput, RolPermisoUncheckedCreateWithoutPermisoInput> | RolPermisoCreateWithoutPermisoInput[] | RolPermisoUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: RolPermisoCreateOrConnectWithoutPermisoInput | RolPermisoCreateOrConnectWithoutPermisoInput[]
    createMany?: RolPermisoCreateManyPermisoInputEnvelope
    connect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
  }

  export type PermisoUpdateOneWithoutHijosNestedInput = {
    create?: XOR<PermisoCreateWithoutHijosInput, PermisoUncheckedCreateWithoutHijosInput>
    connectOrCreate?: PermisoCreateOrConnectWithoutHijosInput
    upsert?: PermisoUpsertWithoutHijosInput
    disconnect?: PermisoWhereInput | boolean
    delete?: PermisoWhereInput | boolean
    connect?: PermisoWhereUniqueInput
    update?: XOR<XOR<PermisoUpdateToOneWithWhereWithoutHijosInput, PermisoUpdateWithoutHijosInput>, PermisoUncheckedUpdateWithoutHijosInput>
  }

  export type PermisoUpdateManyWithoutPadreNestedInput = {
    create?: XOR<PermisoCreateWithoutPadreInput, PermisoUncheckedCreateWithoutPadreInput> | PermisoCreateWithoutPadreInput[] | PermisoUncheckedCreateWithoutPadreInput[]
    connectOrCreate?: PermisoCreateOrConnectWithoutPadreInput | PermisoCreateOrConnectWithoutPadreInput[]
    upsert?: PermisoUpsertWithWhereUniqueWithoutPadreInput | PermisoUpsertWithWhereUniqueWithoutPadreInput[]
    createMany?: PermisoCreateManyPadreInputEnvelope
    set?: PermisoWhereUniqueInput | PermisoWhereUniqueInput[]
    disconnect?: PermisoWhereUniqueInput | PermisoWhereUniqueInput[]
    delete?: PermisoWhereUniqueInput | PermisoWhereUniqueInput[]
    connect?: PermisoWhereUniqueInput | PermisoWhereUniqueInput[]
    update?: PermisoUpdateWithWhereUniqueWithoutPadreInput | PermisoUpdateWithWhereUniqueWithoutPadreInput[]
    updateMany?: PermisoUpdateManyWithWhereWithoutPadreInput | PermisoUpdateManyWithWhereWithoutPadreInput[]
    deleteMany?: PermisoScalarWhereInput | PermisoScalarWhereInput[]
  }

  export type RolPermisoUpdateManyWithoutPermisoNestedInput = {
    create?: XOR<RolPermisoCreateWithoutPermisoInput, RolPermisoUncheckedCreateWithoutPermisoInput> | RolPermisoCreateWithoutPermisoInput[] | RolPermisoUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: RolPermisoCreateOrConnectWithoutPermisoInput | RolPermisoCreateOrConnectWithoutPermisoInput[]
    upsert?: RolPermisoUpsertWithWhereUniqueWithoutPermisoInput | RolPermisoUpsertWithWhereUniqueWithoutPermisoInput[]
    createMany?: RolPermisoCreateManyPermisoInputEnvelope
    set?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    disconnect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    delete?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    connect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    update?: RolPermisoUpdateWithWhereUniqueWithoutPermisoInput | RolPermisoUpdateWithWhereUniqueWithoutPermisoInput[]
    updateMany?: RolPermisoUpdateManyWithWhereWithoutPermisoInput | RolPermisoUpdateManyWithWhereWithoutPermisoInput[]
    deleteMany?: RolPermisoScalarWhereInput | RolPermisoScalarWhereInput[]
  }

  export type PermisoUncheckedUpdateManyWithoutPadreNestedInput = {
    create?: XOR<PermisoCreateWithoutPadreInput, PermisoUncheckedCreateWithoutPadreInput> | PermisoCreateWithoutPadreInput[] | PermisoUncheckedCreateWithoutPadreInput[]
    connectOrCreate?: PermisoCreateOrConnectWithoutPadreInput | PermisoCreateOrConnectWithoutPadreInput[]
    upsert?: PermisoUpsertWithWhereUniqueWithoutPadreInput | PermisoUpsertWithWhereUniqueWithoutPadreInput[]
    createMany?: PermisoCreateManyPadreInputEnvelope
    set?: PermisoWhereUniqueInput | PermisoWhereUniqueInput[]
    disconnect?: PermisoWhereUniqueInput | PermisoWhereUniqueInput[]
    delete?: PermisoWhereUniqueInput | PermisoWhereUniqueInput[]
    connect?: PermisoWhereUniqueInput | PermisoWhereUniqueInput[]
    update?: PermisoUpdateWithWhereUniqueWithoutPadreInput | PermisoUpdateWithWhereUniqueWithoutPadreInput[]
    updateMany?: PermisoUpdateManyWithWhereWithoutPadreInput | PermisoUpdateManyWithWhereWithoutPadreInput[]
    deleteMany?: PermisoScalarWhereInput | PermisoScalarWhereInput[]
  }

  export type RolPermisoUncheckedUpdateManyWithoutPermisoNestedInput = {
    create?: XOR<RolPermisoCreateWithoutPermisoInput, RolPermisoUncheckedCreateWithoutPermisoInput> | RolPermisoCreateWithoutPermisoInput[] | RolPermisoUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: RolPermisoCreateOrConnectWithoutPermisoInput | RolPermisoCreateOrConnectWithoutPermisoInput[]
    upsert?: RolPermisoUpsertWithWhereUniqueWithoutPermisoInput | RolPermisoUpsertWithWhereUniqueWithoutPermisoInput[]
    createMany?: RolPermisoCreateManyPermisoInputEnvelope
    set?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    disconnect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    delete?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    connect?: RolPermisoWhereUniqueInput | RolPermisoWhereUniqueInput[]
    update?: RolPermisoUpdateWithWhereUniqueWithoutPermisoInput | RolPermisoUpdateWithWhereUniqueWithoutPermisoInput[]
    updateMany?: RolPermisoUpdateManyWithWhereWithoutPermisoInput | RolPermisoUpdateManyWithWhereWithoutPermisoInput[]
    deleteMany?: RolPermisoScalarWhereInput | RolPermisoScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutRolesInput = {
    create?: XOR<UsuarioCreateWithoutRolesInput, UsuarioUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRolesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type RolCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: RolCreateOrConnectWithoutUsuariosInput
    connect?: RolWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UsuarioCreateWithoutRolesInput, UsuarioUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRolesInput
    upsert?: UsuarioUpsertWithoutRolesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutRolesInput, UsuarioUpdateWithoutRolesInput>, UsuarioUncheckedUpdateWithoutRolesInput>
  }

  export type RolUpdateOneRequiredWithoutUsuariosNestedInput = {
    create?: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: RolCreateOrConnectWithoutUsuariosInput
    upsert?: RolUpsertWithoutUsuariosInput
    connect?: RolWhereUniqueInput
    update?: XOR<XOR<RolUpdateToOneWithWhereWithoutUsuariosInput, RolUpdateWithoutUsuariosInput>, RolUncheckedUpdateWithoutUsuariosInput>
  }

  export type RolCreateNestedOneWithoutPermisosInput = {
    create?: XOR<RolCreateWithoutPermisosInput, RolUncheckedCreateWithoutPermisosInput>
    connectOrCreate?: RolCreateOrConnectWithoutPermisosInput
    connect?: RolWhereUniqueInput
  }

  export type PermisoCreateNestedOneWithoutRolesInput = {
    create?: XOR<PermisoCreateWithoutRolesInput, PermisoUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermisoCreateOrConnectWithoutRolesInput
    connect?: PermisoWhereUniqueInput
  }

  export type RolUpdateOneRequiredWithoutPermisosNestedInput = {
    create?: XOR<RolCreateWithoutPermisosInput, RolUncheckedCreateWithoutPermisosInput>
    connectOrCreate?: RolCreateOrConnectWithoutPermisosInput
    upsert?: RolUpsertWithoutPermisosInput
    connect?: RolWhereUniqueInput
    update?: XOR<XOR<RolUpdateToOneWithWhereWithoutPermisosInput, RolUpdateWithoutPermisosInput>, RolUncheckedUpdateWithoutPermisosInput>
  }

  export type PermisoUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PermisoCreateWithoutRolesInput, PermisoUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermisoCreateOrConnectWithoutRolesInput
    upsert?: PermisoUpsertWithoutRolesInput
    connect?: PermisoWhereUniqueInput
    update?: XOR<XOR<PermisoUpdateToOneWithWhereWithoutRolesInput, PermisoUpdateWithoutRolesInput>, PermisoUncheckedUpdateWithoutRolesInput>
  }

  export type UsuarioCreateNestedOneWithoutActivosAccesoInput = {
    create?: XOR<UsuarioCreateWithoutActivosAccesoInput, UsuarioUncheckedCreateWithoutActivosAccesoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutActivosAccesoInput
    connect?: UsuarioWhereUniqueInput
  }

  export type ActivoAccesoCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<ActivoAccesoCreateWithoutUsuariosInput, ActivoAccesoUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: ActivoAccesoCreateOrConnectWithoutUsuariosInput
    connect?: ActivoAccesoWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutActivosAccesoNestedInput = {
    create?: XOR<UsuarioCreateWithoutActivosAccesoInput, UsuarioUncheckedCreateWithoutActivosAccesoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutActivosAccesoInput
    upsert?: UsuarioUpsertWithoutActivosAccesoInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutActivosAccesoInput, UsuarioUpdateWithoutActivosAccesoInput>, UsuarioUncheckedUpdateWithoutActivosAccesoInput>
  }

  export type ActivoAccesoUpdateOneRequiredWithoutUsuariosNestedInput = {
    create?: XOR<ActivoAccesoCreateWithoutUsuariosInput, ActivoAccesoUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: ActivoAccesoCreateOrConnectWithoutUsuariosInput
    upsert?: ActivoAccesoUpsertWithoutUsuariosInput
    connect?: ActivoAccesoWhereUniqueInput
    update?: XOR<XOR<ActivoAccesoUpdateToOneWithWhereWithoutUsuariosInput, ActivoAccesoUpdateWithoutUsuariosInput>, ActivoAccesoUncheckedUpdateWithoutUsuariosInput>
  }

  export type UsuarioCreateNestedOneWithoutLogsAuditoriaInput = {
    create?: XOR<UsuarioCreateWithoutLogsAuditoriaInput, UsuarioUncheckedCreateWithoutLogsAuditoriaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutLogsAuditoriaInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutLogsAuditoriaNestedInput = {
    create?: XOR<UsuarioCreateWithoutLogsAuditoriaInput, UsuarioUncheckedCreateWithoutLogsAuditoriaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutLogsAuditoriaInput
    upsert?: UsuarioUpsertWithoutLogsAuditoriaInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutLogsAuditoriaInput, UsuarioUpdateWithoutLogsAuditoriaInput>, UsuarioUncheckedUpdateWithoutLogsAuditoriaInput>
  }

  export type ActivoAccesoCreateNestedOneWithoutHijosInput = {
    create?: XOR<ActivoAccesoCreateWithoutHijosInput, ActivoAccesoUncheckedCreateWithoutHijosInput>
    connectOrCreate?: ActivoAccesoCreateOrConnectWithoutHijosInput
    connect?: ActivoAccesoWhereUniqueInput
  }

  export type ActivoAccesoCreateNestedManyWithoutPadreInput = {
    create?: XOR<ActivoAccesoCreateWithoutPadreInput, ActivoAccesoUncheckedCreateWithoutPadreInput> | ActivoAccesoCreateWithoutPadreInput[] | ActivoAccesoUncheckedCreateWithoutPadreInput[]
    connectOrCreate?: ActivoAccesoCreateOrConnectWithoutPadreInput | ActivoAccesoCreateOrConnectWithoutPadreInput[]
    createMany?: ActivoAccesoCreateManyPadreInputEnvelope
    connect?: ActivoAccesoWhereUniqueInput | ActivoAccesoWhereUniqueInput[]
  }

  export type UsuarioActivoCreateNestedManyWithoutActivoInput = {
    create?: XOR<UsuarioActivoCreateWithoutActivoInput, UsuarioActivoUncheckedCreateWithoutActivoInput> | UsuarioActivoCreateWithoutActivoInput[] | UsuarioActivoUncheckedCreateWithoutActivoInput[]
    connectOrCreate?: UsuarioActivoCreateOrConnectWithoutActivoInput | UsuarioActivoCreateOrConnectWithoutActivoInput[]
    createMany?: UsuarioActivoCreateManyActivoInputEnvelope
    connect?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
  }

  export type ActivoAccesoUncheckedCreateNestedManyWithoutPadreInput = {
    create?: XOR<ActivoAccesoCreateWithoutPadreInput, ActivoAccesoUncheckedCreateWithoutPadreInput> | ActivoAccesoCreateWithoutPadreInput[] | ActivoAccesoUncheckedCreateWithoutPadreInput[]
    connectOrCreate?: ActivoAccesoCreateOrConnectWithoutPadreInput | ActivoAccesoCreateOrConnectWithoutPadreInput[]
    createMany?: ActivoAccesoCreateManyPadreInputEnvelope
    connect?: ActivoAccesoWhereUniqueInput | ActivoAccesoWhereUniqueInput[]
  }

  export type UsuarioActivoUncheckedCreateNestedManyWithoutActivoInput = {
    create?: XOR<UsuarioActivoCreateWithoutActivoInput, UsuarioActivoUncheckedCreateWithoutActivoInput> | UsuarioActivoCreateWithoutActivoInput[] | UsuarioActivoUncheckedCreateWithoutActivoInput[]
    connectOrCreate?: UsuarioActivoCreateOrConnectWithoutActivoInput | UsuarioActivoCreateOrConnectWithoutActivoInput[]
    createMany?: UsuarioActivoCreateManyActivoInputEnvelope
    connect?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
  }

  export type ActivoAccesoUpdateOneWithoutHijosNestedInput = {
    create?: XOR<ActivoAccesoCreateWithoutHijosInput, ActivoAccesoUncheckedCreateWithoutHijosInput>
    connectOrCreate?: ActivoAccesoCreateOrConnectWithoutHijosInput
    upsert?: ActivoAccesoUpsertWithoutHijosInput
    disconnect?: ActivoAccesoWhereInput | boolean
    delete?: ActivoAccesoWhereInput | boolean
    connect?: ActivoAccesoWhereUniqueInput
    update?: XOR<XOR<ActivoAccesoUpdateToOneWithWhereWithoutHijosInput, ActivoAccesoUpdateWithoutHijosInput>, ActivoAccesoUncheckedUpdateWithoutHijosInput>
  }

  export type ActivoAccesoUpdateManyWithoutPadreNestedInput = {
    create?: XOR<ActivoAccesoCreateWithoutPadreInput, ActivoAccesoUncheckedCreateWithoutPadreInput> | ActivoAccesoCreateWithoutPadreInput[] | ActivoAccesoUncheckedCreateWithoutPadreInput[]
    connectOrCreate?: ActivoAccesoCreateOrConnectWithoutPadreInput | ActivoAccesoCreateOrConnectWithoutPadreInput[]
    upsert?: ActivoAccesoUpsertWithWhereUniqueWithoutPadreInput | ActivoAccesoUpsertWithWhereUniqueWithoutPadreInput[]
    createMany?: ActivoAccesoCreateManyPadreInputEnvelope
    set?: ActivoAccesoWhereUniqueInput | ActivoAccesoWhereUniqueInput[]
    disconnect?: ActivoAccesoWhereUniqueInput | ActivoAccesoWhereUniqueInput[]
    delete?: ActivoAccesoWhereUniqueInput | ActivoAccesoWhereUniqueInput[]
    connect?: ActivoAccesoWhereUniqueInput | ActivoAccesoWhereUniqueInput[]
    update?: ActivoAccesoUpdateWithWhereUniqueWithoutPadreInput | ActivoAccesoUpdateWithWhereUniqueWithoutPadreInput[]
    updateMany?: ActivoAccesoUpdateManyWithWhereWithoutPadreInput | ActivoAccesoUpdateManyWithWhereWithoutPadreInput[]
    deleteMany?: ActivoAccesoScalarWhereInput | ActivoAccesoScalarWhereInput[]
  }

  export type UsuarioActivoUpdateManyWithoutActivoNestedInput = {
    create?: XOR<UsuarioActivoCreateWithoutActivoInput, UsuarioActivoUncheckedCreateWithoutActivoInput> | UsuarioActivoCreateWithoutActivoInput[] | UsuarioActivoUncheckedCreateWithoutActivoInput[]
    connectOrCreate?: UsuarioActivoCreateOrConnectWithoutActivoInput | UsuarioActivoCreateOrConnectWithoutActivoInput[]
    upsert?: UsuarioActivoUpsertWithWhereUniqueWithoutActivoInput | UsuarioActivoUpsertWithWhereUniqueWithoutActivoInput[]
    createMany?: UsuarioActivoCreateManyActivoInputEnvelope
    set?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
    disconnect?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
    delete?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
    connect?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
    update?: UsuarioActivoUpdateWithWhereUniqueWithoutActivoInput | UsuarioActivoUpdateWithWhereUniqueWithoutActivoInput[]
    updateMany?: UsuarioActivoUpdateManyWithWhereWithoutActivoInput | UsuarioActivoUpdateManyWithWhereWithoutActivoInput[]
    deleteMany?: UsuarioActivoScalarWhereInput | UsuarioActivoScalarWhereInput[]
  }

  export type ActivoAccesoUncheckedUpdateManyWithoutPadreNestedInput = {
    create?: XOR<ActivoAccesoCreateWithoutPadreInput, ActivoAccesoUncheckedCreateWithoutPadreInput> | ActivoAccesoCreateWithoutPadreInput[] | ActivoAccesoUncheckedCreateWithoutPadreInput[]
    connectOrCreate?: ActivoAccesoCreateOrConnectWithoutPadreInput | ActivoAccesoCreateOrConnectWithoutPadreInput[]
    upsert?: ActivoAccesoUpsertWithWhereUniqueWithoutPadreInput | ActivoAccesoUpsertWithWhereUniqueWithoutPadreInput[]
    createMany?: ActivoAccesoCreateManyPadreInputEnvelope
    set?: ActivoAccesoWhereUniqueInput | ActivoAccesoWhereUniqueInput[]
    disconnect?: ActivoAccesoWhereUniqueInput | ActivoAccesoWhereUniqueInput[]
    delete?: ActivoAccesoWhereUniqueInput | ActivoAccesoWhereUniqueInput[]
    connect?: ActivoAccesoWhereUniqueInput | ActivoAccesoWhereUniqueInput[]
    update?: ActivoAccesoUpdateWithWhereUniqueWithoutPadreInput | ActivoAccesoUpdateWithWhereUniqueWithoutPadreInput[]
    updateMany?: ActivoAccesoUpdateManyWithWhereWithoutPadreInput | ActivoAccesoUpdateManyWithWhereWithoutPadreInput[]
    deleteMany?: ActivoAccesoScalarWhereInput | ActivoAccesoScalarWhereInput[]
  }

  export type UsuarioActivoUncheckedUpdateManyWithoutActivoNestedInput = {
    create?: XOR<UsuarioActivoCreateWithoutActivoInput, UsuarioActivoUncheckedCreateWithoutActivoInput> | UsuarioActivoCreateWithoutActivoInput[] | UsuarioActivoUncheckedCreateWithoutActivoInput[]
    connectOrCreate?: UsuarioActivoCreateOrConnectWithoutActivoInput | UsuarioActivoCreateOrConnectWithoutActivoInput[]
    upsert?: UsuarioActivoUpsertWithWhereUniqueWithoutActivoInput | UsuarioActivoUpsertWithWhereUniqueWithoutActivoInput[]
    createMany?: UsuarioActivoCreateManyActivoInputEnvelope
    set?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
    disconnect?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
    delete?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
    connect?: UsuarioActivoWhereUniqueInput | UsuarioActivoWhereUniqueInput[]
    update?: UsuarioActivoUpdateWithWhereUniqueWithoutActivoInput | UsuarioActivoUpdateWithWhereUniqueWithoutActivoInput[]
    updateMany?: UsuarioActivoUpdateManyWithWhereWithoutActivoInput | UsuarioActivoUpdateManyWithWhereWithoutActivoInput[]
    deleteMany?: UsuarioActivoScalarWhereInput | UsuarioActivoScalarWhereInput[]
  }

  export type ActivoCreateNestedManyWithoutPlantillaInput = {
    create?: XOR<ActivoCreateWithoutPlantillaInput, ActivoUncheckedCreateWithoutPlantillaInput> | ActivoCreateWithoutPlantillaInput[] | ActivoUncheckedCreateWithoutPlantillaInput[]
    connectOrCreate?: ActivoCreateOrConnectWithoutPlantillaInput | ActivoCreateOrConnectWithoutPlantillaInput[]
    createMany?: ActivoCreateManyPlantillaInputEnvelope
    connect?: ActivoWhereUniqueInput | ActivoWhereUniqueInput[]
  }

  export type ActivoUncheckedCreateNestedManyWithoutPlantillaInput = {
    create?: XOR<ActivoCreateWithoutPlantillaInput, ActivoUncheckedCreateWithoutPlantillaInput> | ActivoCreateWithoutPlantillaInput[] | ActivoUncheckedCreateWithoutPlantillaInput[]
    connectOrCreate?: ActivoCreateOrConnectWithoutPlantillaInput | ActivoCreateOrConnectWithoutPlantillaInput[]
    createMany?: ActivoCreateManyPlantillaInputEnvelope
    connect?: ActivoWhereUniqueInput | ActivoWhereUniqueInput[]
  }

  export type ActivoUpdateManyWithoutPlantillaNestedInput = {
    create?: XOR<ActivoCreateWithoutPlantillaInput, ActivoUncheckedCreateWithoutPlantillaInput> | ActivoCreateWithoutPlantillaInput[] | ActivoUncheckedCreateWithoutPlantillaInput[]
    connectOrCreate?: ActivoCreateOrConnectWithoutPlantillaInput | ActivoCreateOrConnectWithoutPlantillaInput[]
    upsert?: ActivoUpsertWithWhereUniqueWithoutPlantillaInput | ActivoUpsertWithWhereUniqueWithoutPlantillaInput[]
    createMany?: ActivoCreateManyPlantillaInputEnvelope
    set?: ActivoWhereUniqueInput | ActivoWhereUniqueInput[]
    disconnect?: ActivoWhereUniqueInput | ActivoWhereUniqueInput[]
    delete?: ActivoWhereUniqueInput | ActivoWhereUniqueInput[]
    connect?: ActivoWhereUniqueInput | ActivoWhereUniqueInput[]
    update?: ActivoUpdateWithWhereUniqueWithoutPlantillaInput | ActivoUpdateWithWhereUniqueWithoutPlantillaInput[]
    updateMany?: ActivoUpdateManyWithWhereWithoutPlantillaInput | ActivoUpdateManyWithWhereWithoutPlantillaInput[]
    deleteMany?: ActivoScalarWhereInput | ActivoScalarWhereInput[]
  }

  export type ActivoUncheckedUpdateManyWithoutPlantillaNestedInput = {
    create?: XOR<ActivoCreateWithoutPlantillaInput, ActivoUncheckedCreateWithoutPlantillaInput> | ActivoCreateWithoutPlantillaInput[] | ActivoUncheckedCreateWithoutPlantillaInput[]
    connectOrCreate?: ActivoCreateOrConnectWithoutPlantillaInput | ActivoCreateOrConnectWithoutPlantillaInput[]
    upsert?: ActivoUpsertWithWhereUniqueWithoutPlantillaInput | ActivoUpsertWithWhereUniqueWithoutPlantillaInput[]
    createMany?: ActivoCreateManyPlantillaInputEnvelope
    set?: ActivoWhereUniqueInput | ActivoWhereUniqueInput[]
    disconnect?: ActivoWhereUniqueInput | ActivoWhereUniqueInput[]
    delete?: ActivoWhereUniqueInput | ActivoWhereUniqueInput[]
    connect?: ActivoWhereUniqueInput | ActivoWhereUniqueInput[]
    update?: ActivoUpdateWithWhereUniqueWithoutPlantillaInput | ActivoUpdateWithWhereUniqueWithoutPlantillaInput[]
    updateMany?: ActivoUpdateManyWithWhereWithoutPlantillaInput | ActivoUpdateManyWithWhereWithoutPlantillaInput[]
    deleteMany?: ActivoScalarWhereInput | ActivoScalarWhereInput[]
  }

  export type PlantillaActivoCreateNestedOneWithoutActivosInput = {
    create?: XOR<PlantillaActivoCreateWithoutActivosInput, PlantillaActivoUncheckedCreateWithoutActivosInput>
    connectOrCreate?: PlantillaActivoCreateOrConnectWithoutActivosInput
    connect?: PlantillaActivoWhereUniqueInput
  }

  export type RiesgoCreateNestedManyWithoutActivoInput = {
    create?: XOR<RiesgoCreateWithoutActivoInput, RiesgoUncheckedCreateWithoutActivoInput> | RiesgoCreateWithoutActivoInput[] | RiesgoUncheckedCreateWithoutActivoInput[]
    connectOrCreate?: RiesgoCreateOrConnectWithoutActivoInput | RiesgoCreateOrConnectWithoutActivoInput[]
    createMany?: RiesgoCreateManyActivoInputEnvelope
    connect?: RiesgoWhereUniqueInput | RiesgoWhereUniqueInput[]
  }

  export type IncidenteCreateNestedManyWithoutActivoInput = {
    create?: XOR<IncidenteCreateWithoutActivoInput, IncidenteUncheckedCreateWithoutActivoInput> | IncidenteCreateWithoutActivoInput[] | IncidenteUncheckedCreateWithoutActivoInput[]
    connectOrCreate?: IncidenteCreateOrConnectWithoutActivoInput | IncidenteCreateOrConnectWithoutActivoInput[]
    createMany?: IncidenteCreateManyActivoInputEnvelope
    connect?: IncidenteWhereUniqueInput | IncidenteWhereUniqueInput[]
  }

  export type DefectoCreateNestedManyWithoutActivoInput = {
    create?: XOR<DefectoCreateWithoutActivoInput, DefectoUncheckedCreateWithoutActivoInput> | DefectoCreateWithoutActivoInput[] | DefectoUncheckedCreateWithoutActivoInput[]
    connectOrCreate?: DefectoCreateOrConnectWithoutActivoInput | DefectoCreateOrConnectWithoutActivoInput[]
    createMany?: DefectoCreateManyActivoInputEnvelope
    connect?: DefectoWhereUniqueInput | DefectoWhereUniqueInput[]
  }

  export type RiesgoUncheckedCreateNestedManyWithoutActivoInput = {
    create?: XOR<RiesgoCreateWithoutActivoInput, RiesgoUncheckedCreateWithoutActivoInput> | RiesgoCreateWithoutActivoInput[] | RiesgoUncheckedCreateWithoutActivoInput[]
    connectOrCreate?: RiesgoCreateOrConnectWithoutActivoInput | RiesgoCreateOrConnectWithoutActivoInput[]
    createMany?: RiesgoCreateManyActivoInputEnvelope
    connect?: RiesgoWhereUniqueInput | RiesgoWhereUniqueInput[]
  }

  export type IncidenteUncheckedCreateNestedManyWithoutActivoInput = {
    create?: XOR<IncidenteCreateWithoutActivoInput, IncidenteUncheckedCreateWithoutActivoInput> | IncidenteCreateWithoutActivoInput[] | IncidenteUncheckedCreateWithoutActivoInput[]
    connectOrCreate?: IncidenteCreateOrConnectWithoutActivoInput | IncidenteCreateOrConnectWithoutActivoInput[]
    createMany?: IncidenteCreateManyActivoInputEnvelope
    connect?: IncidenteWhereUniqueInput | IncidenteWhereUniqueInput[]
  }

  export type DefectoUncheckedCreateNestedManyWithoutActivoInput = {
    create?: XOR<DefectoCreateWithoutActivoInput, DefectoUncheckedCreateWithoutActivoInput> | DefectoCreateWithoutActivoInput[] | DefectoUncheckedCreateWithoutActivoInput[]
    connectOrCreate?: DefectoCreateOrConnectWithoutActivoInput | DefectoCreateOrConnectWithoutActivoInput[]
    createMany?: DefectoCreateManyActivoInputEnvelope
    connect?: DefectoWhereUniqueInput | DefectoWhereUniqueInput[]
  }

  export type PlantillaActivoUpdateOneWithoutActivosNestedInput = {
    create?: XOR<PlantillaActivoCreateWithoutActivosInput, PlantillaActivoUncheckedCreateWithoutActivosInput>
    connectOrCreate?: PlantillaActivoCreateOrConnectWithoutActivosInput
    upsert?: PlantillaActivoUpsertWithoutActivosInput
    disconnect?: PlantillaActivoWhereInput | boolean
    delete?: PlantillaActivoWhereInput | boolean
    connect?: PlantillaActivoWhereUniqueInput
    update?: XOR<XOR<PlantillaActivoUpdateToOneWithWhereWithoutActivosInput, PlantillaActivoUpdateWithoutActivosInput>, PlantillaActivoUncheckedUpdateWithoutActivosInput>
  }

  export type RiesgoUpdateManyWithoutActivoNestedInput = {
    create?: XOR<RiesgoCreateWithoutActivoInput, RiesgoUncheckedCreateWithoutActivoInput> | RiesgoCreateWithoutActivoInput[] | RiesgoUncheckedCreateWithoutActivoInput[]
    connectOrCreate?: RiesgoCreateOrConnectWithoutActivoInput | RiesgoCreateOrConnectWithoutActivoInput[]
    upsert?: RiesgoUpsertWithWhereUniqueWithoutActivoInput | RiesgoUpsertWithWhereUniqueWithoutActivoInput[]
    createMany?: RiesgoCreateManyActivoInputEnvelope
    set?: RiesgoWhereUniqueInput | RiesgoWhereUniqueInput[]
    disconnect?: RiesgoWhereUniqueInput | RiesgoWhereUniqueInput[]
    delete?: RiesgoWhereUniqueInput | RiesgoWhereUniqueInput[]
    connect?: RiesgoWhereUniqueInput | RiesgoWhereUniqueInput[]
    update?: RiesgoUpdateWithWhereUniqueWithoutActivoInput | RiesgoUpdateWithWhereUniqueWithoutActivoInput[]
    updateMany?: RiesgoUpdateManyWithWhereWithoutActivoInput | RiesgoUpdateManyWithWhereWithoutActivoInput[]
    deleteMany?: RiesgoScalarWhereInput | RiesgoScalarWhereInput[]
  }

  export type IncidenteUpdateManyWithoutActivoNestedInput = {
    create?: XOR<IncidenteCreateWithoutActivoInput, IncidenteUncheckedCreateWithoutActivoInput> | IncidenteCreateWithoutActivoInput[] | IncidenteUncheckedCreateWithoutActivoInput[]
    connectOrCreate?: IncidenteCreateOrConnectWithoutActivoInput | IncidenteCreateOrConnectWithoutActivoInput[]
    upsert?: IncidenteUpsertWithWhereUniqueWithoutActivoInput | IncidenteUpsertWithWhereUniqueWithoutActivoInput[]
    createMany?: IncidenteCreateManyActivoInputEnvelope
    set?: IncidenteWhereUniqueInput | IncidenteWhereUniqueInput[]
    disconnect?: IncidenteWhereUniqueInput | IncidenteWhereUniqueInput[]
    delete?: IncidenteWhereUniqueInput | IncidenteWhereUniqueInput[]
    connect?: IncidenteWhereUniqueInput | IncidenteWhereUniqueInput[]
    update?: IncidenteUpdateWithWhereUniqueWithoutActivoInput | IncidenteUpdateWithWhereUniqueWithoutActivoInput[]
    updateMany?: IncidenteUpdateManyWithWhereWithoutActivoInput | IncidenteUpdateManyWithWhereWithoutActivoInput[]
    deleteMany?: IncidenteScalarWhereInput | IncidenteScalarWhereInput[]
  }

  export type DefectoUpdateManyWithoutActivoNestedInput = {
    create?: XOR<DefectoCreateWithoutActivoInput, DefectoUncheckedCreateWithoutActivoInput> | DefectoCreateWithoutActivoInput[] | DefectoUncheckedCreateWithoutActivoInput[]
    connectOrCreate?: DefectoCreateOrConnectWithoutActivoInput | DefectoCreateOrConnectWithoutActivoInput[]
    upsert?: DefectoUpsertWithWhereUniqueWithoutActivoInput | DefectoUpsertWithWhereUniqueWithoutActivoInput[]
    createMany?: DefectoCreateManyActivoInputEnvelope
    set?: DefectoWhereUniqueInput | DefectoWhereUniqueInput[]
    disconnect?: DefectoWhereUniqueInput | DefectoWhereUniqueInput[]
    delete?: DefectoWhereUniqueInput | DefectoWhereUniqueInput[]
    connect?: DefectoWhereUniqueInput | DefectoWhereUniqueInput[]
    update?: DefectoUpdateWithWhereUniqueWithoutActivoInput | DefectoUpdateWithWhereUniqueWithoutActivoInput[]
    updateMany?: DefectoUpdateManyWithWhereWithoutActivoInput | DefectoUpdateManyWithWhereWithoutActivoInput[]
    deleteMany?: DefectoScalarWhereInput | DefectoScalarWhereInput[]
  }

  export type RiesgoUncheckedUpdateManyWithoutActivoNestedInput = {
    create?: XOR<RiesgoCreateWithoutActivoInput, RiesgoUncheckedCreateWithoutActivoInput> | RiesgoCreateWithoutActivoInput[] | RiesgoUncheckedCreateWithoutActivoInput[]
    connectOrCreate?: RiesgoCreateOrConnectWithoutActivoInput | RiesgoCreateOrConnectWithoutActivoInput[]
    upsert?: RiesgoUpsertWithWhereUniqueWithoutActivoInput | RiesgoUpsertWithWhereUniqueWithoutActivoInput[]
    createMany?: RiesgoCreateManyActivoInputEnvelope
    set?: RiesgoWhereUniqueInput | RiesgoWhereUniqueInput[]
    disconnect?: RiesgoWhereUniqueInput | RiesgoWhereUniqueInput[]
    delete?: RiesgoWhereUniqueInput | RiesgoWhereUniqueInput[]
    connect?: RiesgoWhereUniqueInput | RiesgoWhereUniqueInput[]
    update?: RiesgoUpdateWithWhereUniqueWithoutActivoInput | RiesgoUpdateWithWhereUniqueWithoutActivoInput[]
    updateMany?: RiesgoUpdateManyWithWhereWithoutActivoInput | RiesgoUpdateManyWithWhereWithoutActivoInput[]
    deleteMany?: RiesgoScalarWhereInput | RiesgoScalarWhereInput[]
  }

  export type IncidenteUncheckedUpdateManyWithoutActivoNestedInput = {
    create?: XOR<IncidenteCreateWithoutActivoInput, IncidenteUncheckedCreateWithoutActivoInput> | IncidenteCreateWithoutActivoInput[] | IncidenteUncheckedCreateWithoutActivoInput[]
    connectOrCreate?: IncidenteCreateOrConnectWithoutActivoInput | IncidenteCreateOrConnectWithoutActivoInput[]
    upsert?: IncidenteUpsertWithWhereUniqueWithoutActivoInput | IncidenteUpsertWithWhereUniqueWithoutActivoInput[]
    createMany?: IncidenteCreateManyActivoInputEnvelope
    set?: IncidenteWhereUniqueInput | IncidenteWhereUniqueInput[]
    disconnect?: IncidenteWhereUniqueInput | IncidenteWhereUniqueInput[]
    delete?: IncidenteWhereUniqueInput | IncidenteWhereUniqueInput[]
    connect?: IncidenteWhereUniqueInput | IncidenteWhereUniqueInput[]
    update?: IncidenteUpdateWithWhereUniqueWithoutActivoInput | IncidenteUpdateWithWhereUniqueWithoutActivoInput[]
    updateMany?: IncidenteUpdateManyWithWhereWithoutActivoInput | IncidenteUpdateManyWithWhereWithoutActivoInput[]
    deleteMany?: IncidenteScalarWhereInput | IncidenteScalarWhereInput[]
  }

  export type DefectoUncheckedUpdateManyWithoutActivoNestedInput = {
    create?: XOR<DefectoCreateWithoutActivoInput, DefectoUncheckedCreateWithoutActivoInput> | DefectoCreateWithoutActivoInput[] | DefectoUncheckedCreateWithoutActivoInput[]
    connectOrCreate?: DefectoCreateOrConnectWithoutActivoInput | DefectoCreateOrConnectWithoutActivoInput[]
    upsert?: DefectoUpsertWithWhereUniqueWithoutActivoInput | DefectoUpsertWithWhereUniqueWithoutActivoInput[]
    createMany?: DefectoCreateManyActivoInputEnvelope
    set?: DefectoWhereUniqueInput | DefectoWhereUniqueInput[]
    disconnect?: DefectoWhereUniqueInput | DefectoWhereUniqueInput[]
    delete?: DefectoWhereUniqueInput | DefectoWhereUniqueInput[]
    connect?: DefectoWhereUniqueInput | DefectoWhereUniqueInput[]
    update?: DefectoUpdateWithWhereUniqueWithoutActivoInput | DefectoUpdateWithWhereUniqueWithoutActivoInput[]
    updateMany?: DefectoUpdateManyWithWhereWithoutActivoInput | DefectoUpdateManyWithWhereWithoutActivoInput[]
    deleteMany?: DefectoScalarWhereInput | DefectoScalarWhereInput[]
  }

  export type ActivoCreateNestedOneWithoutRiesgosInput = {
    create?: XOR<ActivoCreateWithoutRiesgosInput, ActivoUncheckedCreateWithoutRiesgosInput>
    connectOrCreate?: ActivoCreateOrConnectWithoutRiesgosInput
    connect?: ActivoWhereUniqueInput
  }

  export type ActivoUpdateOneRequiredWithoutRiesgosNestedInput = {
    create?: XOR<ActivoCreateWithoutRiesgosInput, ActivoUncheckedCreateWithoutRiesgosInput>
    connectOrCreate?: ActivoCreateOrConnectWithoutRiesgosInput
    upsert?: ActivoUpsertWithoutRiesgosInput
    connect?: ActivoWhereUniqueInput
    update?: XOR<XOR<ActivoUpdateToOneWithWhereWithoutRiesgosInput, ActivoUpdateWithoutRiesgosInput>, ActivoUncheckedUpdateWithoutRiesgosInput>
  }

  export type ActivoCreateNestedOneWithoutIncidentesInput = {
    create?: XOR<ActivoCreateWithoutIncidentesInput, ActivoUncheckedCreateWithoutIncidentesInput>
    connectOrCreate?: ActivoCreateOrConnectWithoutIncidentesInput
    connect?: ActivoWhereUniqueInput
  }

  export type ActivoUpdateOneRequiredWithoutIncidentesNestedInput = {
    create?: XOR<ActivoCreateWithoutIncidentesInput, ActivoUncheckedCreateWithoutIncidentesInput>
    connectOrCreate?: ActivoCreateOrConnectWithoutIncidentesInput
    upsert?: ActivoUpsertWithoutIncidentesInput
    connect?: ActivoWhereUniqueInput
    update?: XOR<XOR<ActivoUpdateToOneWithWhereWithoutIncidentesInput, ActivoUpdateWithoutIncidentesInput>, ActivoUncheckedUpdateWithoutIncidentesInput>
  }

  export type ActivoCreateNestedOneWithoutDefectosInput = {
    create?: XOR<ActivoCreateWithoutDefectosInput, ActivoUncheckedCreateWithoutDefectosInput>
    connectOrCreate?: ActivoCreateOrConnectWithoutDefectosInput
    connect?: ActivoWhereUniqueInput
  }

  export type ActivoUpdateOneRequiredWithoutDefectosNestedInput = {
    create?: XOR<ActivoCreateWithoutDefectosInput, ActivoUncheckedCreateWithoutDefectosInput>
    connectOrCreate?: ActivoCreateOrConnectWithoutDefectosInput
    upsert?: ActivoUpsertWithoutDefectosInput
    connect?: ActivoWhereUniqueInput
    update?: XOR<XOR<ActivoUpdateToOneWithWhereWithoutDefectosInput, ActivoUpdateWithoutDefectosInput>, ActivoUncheckedUpdateWithoutDefectosInput>
  }

  export type NodoOrganigramaCreateNestedManyWithoutOrganigramaInput = {
    create?: XOR<NodoOrganigramaCreateWithoutOrganigramaInput, NodoOrganigramaUncheckedCreateWithoutOrganigramaInput> | NodoOrganigramaCreateWithoutOrganigramaInput[] | NodoOrganigramaUncheckedCreateWithoutOrganigramaInput[]
    connectOrCreate?: NodoOrganigramaCreateOrConnectWithoutOrganigramaInput | NodoOrganigramaCreateOrConnectWithoutOrganigramaInput[]
    createMany?: NodoOrganigramaCreateManyOrganigramaInputEnvelope
    connect?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
  }

  export type NodoOrganigramaUncheckedCreateNestedManyWithoutOrganigramaInput = {
    create?: XOR<NodoOrganigramaCreateWithoutOrganigramaInput, NodoOrganigramaUncheckedCreateWithoutOrganigramaInput> | NodoOrganigramaCreateWithoutOrganigramaInput[] | NodoOrganigramaUncheckedCreateWithoutOrganigramaInput[]
    connectOrCreate?: NodoOrganigramaCreateOrConnectWithoutOrganigramaInput | NodoOrganigramaCreateOrConnectWithoutOrganigramaInput[]
    createMany?: NodoOrganigramaCreateManyOrganigramaInputEnvelope
    connect?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
  }

  export type NodoOrganigramaUpdateManyWithoutOrganigramaNestedInput = {
    create?: XOR<NodoOrganigramaCreateWithoutOrganigramaInput, NodoOrganigramaUncheckedCreateWithoutOrganigramaInput> | NodoOrganigramaCreateWithoutOrganigramaInput[] | NodoOrganigramaUncheckedCreateWithoutOrganigramaInput[]
    connectOrCreate?: NodoOrganigramaCreateOrConnectWithoutOrganigramaInput | NodoOrganigramaCreateOrConnectWithoutOrganigramaInput[]
    upsert?: NodoOrganigramaUpsertWithWhereUniqueWithoutOrganigramaInput | NodoOrganigramaUpsertWithWhereUniqueWithoutOrganigramaInput[]
    createMany?: NodoOrganigramaCreateManyOrganigramaInputEnvelope
    set?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
    disconnect?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
    delete?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
    connect?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
    update?: NodoOrganigramaUpdateWithWhereUniqueWithoutOrganigramaInput | NodoOrganigramaUpdateWithWhereUniqueWithoutOrganigramaInput[]
    updateMany?: NodoOrganigramaUpdateManyWithWhereWithoutOrganigramaInput | NodoOrganigramaUpdateManyWithWhereWithoutOrganigramaInput[]
    deleteMany?: NodoOrganigramaScalarWhereInput | NodoOrganigramaScalarWhereInput[]
  }

  export type NodoOrganigramaUncheckedUpdateManyWithoutOrganigramaNestedInput = {
    create?: XOR<NodoOrganigramaCreateWithoutOrganigramaInput, NodoOrganigramaUncheckedCreateWithoutOrganigramaInput> | NodoOrganigramaCreateWithoutOrganigramaInput[] | NodoOrganigramaUncheckedCreateWithoutOrganigramaInput[]
    connectOrCreate?: NodoOrganigramaCreateOrConnectWithoutOrganigramaInput | NodoOrganigramaCreateOrConnectWithoutOrganigramaInput[]
    upsert?: NodoOrganigramaUpsertWithWhereUniqueWithoutOrganigramaInput | NodoOrganigramaUpsertWithWhereUniqueWithoutOrganigramaInput[]
    createMany?: NodoOrganigramaCreateManyOrganigramaInputEnvelope
    set?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
    disconnect?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
    delete?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
    connect?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
    update?: NodoOrganigramaUpdateWithWhereUniqueWithoutOrganigramaInput | NodoOrganigramaUpdateWithWhereUniqueWithoutOrganigramaInput[]
    updateMany?: NodoOrganigramaUpdateManyWithWhereWithoutOrganigramaInput | NodoOrganigramaUpdateManyWithWhereWithoutOrganigramaInput[]
    deleteMany?: NodoOrganigramaScalarWhereInput | NodoOrganigramaScalarWhereInput[]
  }

  export type OrganigramaCreateNestedOneWithoutNodosInput = {
    create?: XOR<OrganigramaCreateWithoutNodosInput, OrganigramaUncheckedCreateWithoutNodosInput>
    connectOrCreate?: OrganigramaCreateOrConnectWithoutNodosInput
    connect?: OrganigramaWhereUniqueInput
  }

  export type NodoOrganigramaCreateNestedOneWithoutSubordinadosInput = {
    create?: XOR<NodoOrganigramaCreateWithoutSubordinadosInput, NodoOrganigramaUncheckedCreateWithoutSubordinadosInput>
    connectOrCreate?: NodoOrganigramaCreateOrConnectWithoutSubordinadosInput
    connect?: NodoOrganigramaWhereUniqueInput
  }

  export type NodoOrganigramaCreateNestedManyWithoutPadreInput = {
    create?: XOR<NodoOrganigramaCreateWithoutPadreInput, NodoOrganigramaUncheckedCreateWithoutPadreInput> | NodoOrganigramaCreateWithoutPadreInput[] | NodoOrganigramaUncheckedCreateWithoutPadreInput[]
    connectOrCreate?: NodoOrganigramaCreateOrConnectWithoutPadreInput | NodoOrganigramaCreateOrConnectWithoutPadreInput[]
    createMany?: NodoOrganigramaCreateManyPadreInputEnvelope
    connect?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
  }

  export type NodoOrganigramaUncheckedCreateNestedManyWithoutPadreInput = {
    create?: XOR<NodoOrganigramaCreateWithoutPadreInput, NodoOrganigramaUncheckedCreateWithoutPadreInput> | NodoOrganigramaCreateWithoutPadreInput[] | NodoOrganigramaUncheckedCreateWithoutPadreInput[]
    connectOrCreate?: NodoOrganigramaCreateOrConnectWithoutPadreInput | NodoOrganigramaCreateOrConnectWithoutPadreInput[]
    createMany?: NodoOrganigramaCreateManyPadreInputEnvelope
    connect?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
  }

  export type OrganigramaUpdateOneRequiredWithoutNodosNestedInput = {
    create?: XOR<OrganigramaCreateWithoutNodosInput, OrganigramaUncheckedCreateWithoutNodosInput>
    connectOrCreate?: OrganigramaCreateOrConnectWithoutNodosInput
    upsert?: OrganigramaUpsertWithoutNodosInput
    connect?: OrganigramaWhereUniqueInput
    update?: XOR<XOR<OrganigramaUpdateToOneWithWhereWithoutNodosInput, OrganigramaUpdateWithoutNodosInput>, OrganigramaUncheckedUpdateWithoutNodosInput>
  }

  export type NodoOrganigramaUpdateOneWithoutSubordinadosNestedInput = {
    create?: XOR<NodoOrganigramaCreateWithoutSubordinadosInput, NodoOrganigramaUncheckedCreateWithoutSubordinadosInput>
    connectOrCreate?: NodoOrganigramaCreateOrConnectWithoutSubordinadosInput
    upsert?: NodoOrganigramaUpsertWithoutSubordinadosInput
    disconnect?: NodoOrganigramaWhereInput | boolean
    delete?: NodoOrganigramaWhereInput | boolean
    connect?: NodoOrganigramaWhereUniqueInput
    update?: XOR<XOR<NodoOrganigramaUpdateToOneWithWhereWithoutSubordinadosInput, NodoOrganigramaUpdateWithoutSubordinadosInput>, NodoOrganigramaUncheckedUpdateWithoutSubordinadosInput>
  }

  export type NodoOrganigramaUpdateManyWithoutPadreNestedInput = {
    create?: XOR<NodoOrganigramaCreateWithoutPadreInput, NodoOrganigramaUncheckedCreateWithoutPadreInput> | NodoOrganigramaCreateWithoutPadreInput[] | NodoOrganigramaUncheckedCreateWithoutPadreInput[]
    connectOrCreate?: NodoOrganigramaCreateOrConnectWithoutPadreInput | NodoOrganigramaCreateOrConnectWithoutPadreInput[]
    upsert?: NodoOrganigramaUpsertWithWhereUniqueWithoutPadreInput | NodoOrganigramaUpsertWithWhereUniqueWithoutPadreInput[]
    createMany?: NodoOrganigramaCreateManyPadreInputEnvelope
    set?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
    disconnect?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
    delete?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
    connect?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
    update?: NodoOrganigramaUpdateWithWhereUniqueWithoutPadreInput | NodoOrganigramaUpdateWithWhereUniqueWithoutPadreInput[]
    updateMany?: NodoOrganigramaUpdateManyWithWhereWithoutPadreInput | NodoOrganigramaUpdateManyWithWhereWithoutPadreInput[]
    deleteMany?: NodoOrganigramaScalarWhereInput | NodoOrganigramaScalarWhereInput[]
  }

  export type NodoOrganigramaUncheckedUpdateManyWithoutPadreNestedInput = {
    create?: XOR<NodoOrganigramaCreateWithoutPadreInput, NodoOrganigramaUncheckedCreateWithoutPadreInput> | NodoOrganigramaCreateWithoutPadreInput[] | NodoOrganigramaUncheckedCreateWithoutPadreInput[]
    connectOrCreate?: NodoOrganigramaCreateOrConnectWithoutPadreInput | NodoOrganigramaCreateOrConnectWithoutPadreInput[]
    upsert?: NodoOrganigramaUpsertWithWhereUniqueWithoutPadreInput | NodoOrganigramaUpsertWithWhereUniqueWithoutPadreInput[]
    createMany?: NodoOrganigramaCreateManyPadreInputEnvelope
    set?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
    disconnect?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
    delete?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
    connect?: NodoOrganigramaWhereUniqueInput | NodoOrganigramaWhereUniqueInput[]
    update?: NodoOrganigramaUpdateWithWhereUniqueWithoutPadreInput | NodoOrganigramaUpdateWithWhereUniqueWithoutPadreInput[]
    updateMany?: NodoOrganigramaUpdateManyWithWhereWithoutPadreInput | NodoOrganigramaUpdateManyWithWhereWithoutPadreInput[]
    deleteMany?: NodoOrganigramaScalarWhereInput | NodoOrganigramaScalarWhereInput[]
  }

  export type RequisitoNormativoCreateNestedManyWithoutMarcoInput = {
    create?: XOR<RequisitoNormativoCreateWithoutMarcoInput, RequisitoNormativoUncheckedCreateWithoutMarcoInput> | RequisitoNormativoCreateWithoutMarcoInput[] | RequisitoNormativoUncheckedCreateWithoutMarcoInput[]
    connectOrCreate?: RequisitoNormativoCreateOrConnectWithoutMarcoInput | RequisitoNormativoCreateOrConnectWithoutMarcoInput[]
    createMany?: RequisitoNormativoCreateManyMarcoInputEnvelope
    connect?: RequisitoNormativoWhereUniqueInput | RequisitoNormativoWhereUniqueInput[]
  }

  export type CuestionarioCreateNestedManyWithoutMarcoNormativoInput = {
    create?: XOR<CuestionarioCreateWithoutMarcoNormativoInput, CuestionarioUncheckedCreateWithoutMarcoNormativoInput> | CuestionarioCreateWithoutMarcoNormativoInput[] | CuestionarioUncheckedCreateWithoutMarcoNormativoInput[]
    connectOrCreate?: CuestionarioCreateOrConnectWithoutMarcoNormativoInput | CuestionarioCreateOrConnectWithoutMarcoNormativoInput[]
    createMany?: CuestionarioCreateManyMarcoNormativoInputEnvelope
    connect?: CuestionarioWhereUniqueInput | CuestionarioWhereUniqueInput[]
  }

  export type RequisitoNormativoUncheckedCreateNestedManyWithoutMarcoInput = {
    create?: XOR<RequisitoNormativoCreateWithoutMarcoInput, RequisitoNormativoUncheckedCreateWithoutMarcoInput> | RequisitoNormativoCreateWithoutMarcoInput[] | RequisitoNormativoUncheckedCreateWithoutMarcoInput[]
    connectOrCreate?: RequisitoNormativoCreateOrConnectWithoutMarcoInput | RequisitoNormativoCreateOrConnectWithoutMarcoInput[]
    createMany?: RequisitoNormativoCreateManyMarcoInputEnvelope
    connect?: RequisitoNormativoWhereUniqueInput | RequisitoNormativoWhereUniqueInput[]
  }

  export type CuestionarioUncheckedCreateNestedManyWithoutMarcoNormativoInput = {
    create?: XOR<CuestionarioCreateWithoutMarcoNormativoInput, CuestionarioUncheckedCreateWithoutMarcoNormativoInput> | CuestionarioCreateWithoutMarcoNormativoInput[] | CuestionarioUncheckedCreateWithoutMarcoNormativoInput[]
    connectOrCreate?: CuestionarioCreateOrConnectWithoutMarcoNormativoInput | CuestionarioCreateOrConnectWithoutMarcoNormativoInput[]
    createMany?: CuestionarioCreateManyMarcoNormativoInputEnvelope
    connect?: CuestionarioWhereUniqueInput | CuestionarioWhereUniqueInput[]
  }

  export type RequisitoNormativoUpdateManyWithoutMarcoNestedInput = {
    create?: XOR<RequisitoNormativoCreateWithoutMarcoInput, RequisitoNormativoUncheckedCreateWithoutMarcoInput> | RequisitoNormativoCreateWithoutMarcoInput[] | RequisitoNormativoUncheckedCreateWithoutMarcoInput[]
    connectOrCreate?: RequisitoNormativoCreateOrConnectWithoutMarcoInput | RequisitoNormativoCreateOrConnectWithoutMarcoInput[]
    upsert?: RequisitoNormativoUpsertWithWhereUniqueWithoutMarcoInput | RequisitoNormativoUpsertWithWhereUniqueWithoutMarcoInput[]
    createMany?: RequisitoNormativoCreateManyMarcoInputEnvelope
    set?: RequisitoNormativoWhereUniqueInput | RequisitoNormativoWhereUniqueInput[]
    disconnect?: RequisitoNormativoWhereUniqueInput | RequisitoNormativoWhereUniqueInput[]
    delete?: RequisitoNormativoWhereUniqueInput | RequisitoNormativoWhereUniqueInput[]
    connect?: RequisitoNormativoWhereUniqueInput | RequisitoNormativoWhereUniqueInput[]
    update?: RequisitoNormativoUpdateWithWhereUniqueWithoutMarcoInput | RequisitoNormativoUpdateWithWhereUniqueWithoutMarcoInput[]
    updateMany?: RequisitoNormativoUpdateManyWithWhereWithoutMarcoInput | RequisitoNormativoUpdateManyWithWhereWithoutMarcoInput[]
    deleteMany?: RequisitoNormativoScalarWhereInput | RequisitoNormativoScalarWhereInput[]
  }

  export type CuestionarioUpdateManyWithoutMarcoNormativoNestedInput = {
    create?: XOR<CuestionarioCreateWithoutMarcoNormativoInput, CuestionarioUncheckedCreateWithoutMarcoNormativoInput> | CuestionarioCreateWithoutMarcoNormativoInput[] | CuestionarioUncheckedCreateWithoutMarcoNormativoInput[]
    connectOrCreate?: CuestionarioCreateOrConnectWithoutMarcoNormativoInput | CuestionarioCreateOrConnectWithoutMarcoNormativoInput[]
    upsert?: CuestionarioUpsertWithWhereUniqueWithoutMarcoNormativoInput | CuestionarioUpsertWithWhereUniqueWithoutMarcoNormativoInput[]
    createMany?: CuestionarioCreateManyMarcoNormativoInputEnvelope
    set?: CuestionarioWhereUniqueInput | CuestionarioWhereUniqueInput[]
    disconnect?: CuestionarioWhereUniqueInput | CuestionarioWhereUniqueInput[]
    delete?: CuestionarioWhereUniqueInput | CuestionarioWhereUniqueInput[]
    connect?: CuestionarioWhereUniqueInput | CuestionarioWhereUniqueInput[]
    update?: CuestionarioUpdateWithWhereUniqueWithoutMarcoNormativoInput | CuestionarioUpdateWithWhereUniqueWithoutMarcoNormativoInput[]
    updateMany?: CuestionarioUpdateManyWithWhereWithoutMarcoNormativoInput | CuestionarioUpdateManyWithWhereWithoutMarcoNormativoInput[]
    deleteMany?: CuestionarioScalarWhereInput | CuestionarioScalarWhereInput[]
  }

  export type RequisitoNormativoUncheckedUpdateManyWithoutMarcoNestedInput = {
    create?: XOR<RequisitoNormativoCreateWithoutMarcoInput, RequisitoNormativoUncheckedCreateWithoutMarcoInput> | RequisitoNormativoCreateWithoutMarcoInput[] | RequisitoNormativoUncheckedCreateWithoutMarcoInput[]
    connectOrCreate?: RequisitoNormativoCreateOrConnectWithoutMarcoInput | RequisitoNormativoCreateOrConnectWithoutMarcoInput[]
    upsert?: RequisitoNormativoUpsertWithWhereUniqueWithoutMarcoInput | RequisitoNormativoUpsertWithWhereUniqueWithoutMarcoInput[]
    createMany?: RequisitoNormativoCreateManyMarcoInputEnvelope
    set?: RequisitoNormativoWhereUniqueInput | RequisitoNormativoWhereUniqueInput[]
    disconnect?: RequisitoNormativoWhereUniqueInput | RequisitoNormativoWhereUniqueInput[]
    delete?: RequisitoNormativoWhereUniqueInput | RequisitoNormativoWhereUniqueInput[]
    connect?: RequisitoNormativoWhereUniqueInput | RequisitoNormativoWhereUniqueInput[]
    update?: RequisitoNormativoUpdateWithWhereUniqueWithoutMarcoInput | RequisitoNormativoUpdateWithWhereUniqueWithoutMarcoInput[]
    updateMany?: RequisitoNormativoUpdateManyWithWhereWithoutMarcoInput | RequisitoNormativoUpdateManyWithWhereWithoutMarcoInput[]
    deleteMany?: RequisitoNormativoScalarWhereInput | RequisitoNormativoScalarWhereInput[]
  }

  export type CuestionarioUncheckedUpdateManyWithoutMarcoNormativoNestedInput = {
    create?: XOR<CuestionarioCreateWithoutMarcoNormativoInput, CuestionarioUncheckedCreateWithoutMarcoNormativoInput> | CuestionarioCreateWithoutMarcoNormativoInput[] | CuestionarioUncheckedCreateWithoutMarcoNormativoInput[]
    connectOrCreate?: CuestionarioCreateOrConnectWithoutMarcoNormativoInput | CuestionarioCreateOrConnectWithoutMarcoNormativoInput[]
    upsert?: CuestionarioUpsertWithWhereUniqueWithoutMarcoNormativoInput | CuestionarioUpsertWithWhereUniqueWithoutMarcoNormativoInput[]
    createMany?: CuestionarioCreateManyMarcoNormativoInputEnvelope
    set?: CuestionarioWhereUniqueInput | CuestionarioWhereUniqueInput[]
    disconnect?: CuestionarioWhereUniqueInput | CuestionarioWhereUniqueInput[]
    delete?: CuestionarioWhereUniqueInput | CuestionarioWhereUniqueInput[]
    connect?: CuestionarioWhereUniqueInput | CuestionarioWhereUniqueInput[]
    update?: CuestionarioUpdateWithWhereUniqueWithoutMarcoNormativoInput | CuestionarioUpdateWithWhereUniqueWithoutMarcoNormativoInput[]
    updateMany?: CuestionarioUpdateManyWithWhereWithoutMarcoNormativoInput | CuestionarioUpdateManyWithWhereWithoutMarcoNormativoInput[]
    deleteMany?: CuestionarioScalarWhereInput | CuestionarioScalarWhereInput[]
  }

  export type MarcoNormativoCreateNestedOneWithoutRequisitosInput = {
    create?: XOR<MarcoNormativoCreateWithoutRequisitosInput, MarcoNormativoUncheckedCreateWithoutRequisitosInput>
    connectOrCreate?: MarcoNormativoCreateOrConnectWithoutRequisitosInput
    connect?: MarcoNormativoWhereUniqueInput
  }

  export type MarcoNormativoUpdateOneRequiredWithoutRequisitosNestedInput = {
    create?: XOR<MarcoNormativoCreateWithoutRequisitosInput, MarcoNormativoUncheckedCreateWithoutRequisitosInput>
    connectOrCreate?: MarcoNormativoCreateOrConnectWithoutRequisitosInput
    upsert?: MarcoNormativoUpsertWithoutRequisitosInput
    connect?: MarcoNormativoWhereUniqueInput
    update?: XOR<XOR<MarcoNormativoUpdateToOneWithWhereWithoutRequisitosInput, MarcoNormativoUpdateWithoutRequisitosInput>, MarcoNormativoUncheckedUpdateWithoutRequisitosInput>
  }

  export type MarcoNormativoCreateNestedOneWithoutCuestionariosInput = {
    create?: XOR<MarcoNormativoCreateWithoutCuestionariosInput, MarcoNormativoUncheckedCreateWithoutCuestionariosInput>
    connectOrCreate?: MarcoNormativoCreateOrConnectWithoutCuestionariosInput
    connect?: MarcoNormativoWhereUniqueInput
  }

  export type SeccionCreateNestedManyWithoutCuestionarioInput = {
    create?: XOR<SeccionCreateWithoutCuestionarioInput, SeccionUncheckedCreateWithoutCuestionarioInput> | SeccionCreateWithoutCuestionarioInput[] | SeccionUncheckedCreateWithoutCuestionarioInput[]
    connectOrCreate?: SeccionCreateOrConnectWithoutCuestionarioInput | SeccionCreateOrConnectWithoutCuestionarioInput[]
    createMany?: SeccionCreateManyCuestionarioInputEnvelope
    connect?: SeccionWhereUniqueInput | SeccionWhereUniqueInput[]
  }

  export type AsignacionCuestionarioCreateNestedManyWithoutCuestionarioInput = {
    create?: XOR<AsignacionCuestionarioCreateWithoutCuestionarioInput, AsignacionCuestionarioUncheckedCreateWithoutCuestionarioInput> | AsignacionCuestionarioCreateWithoutCuestionarioInput[] | AsignacionCuestionarioUncheckedCreateWithoutCuestionarioInput[]
    connectOrCreate?: AsignacionCuestionarioCreateOrConnectWithoutCuestionarioInput | AsignacionCuestionarioCreateOrConnectWithoutCuestionarioInput[]
    createMany?: AsignacionCuestionarioCreateManyCuestionarioInputEnvelope
    connect?: AsignacionCuestionarioWhereUniqueInput | AsignacionCuestionarioWhereUniqueInput[]
  }

  export type SeccionUncheckedCreateNestedManyWithoutCuestionarioInput = {
    create?: XOR<SeccionCreateWithoutCuestionarioInput, SeccionUncheckedCreateWithoutCuestionarioInput> | SeccionCreateWithoutCuestionarioInput[] | SeccionUncheckedCreateWithoutCuestionarioInput[]
    connectOrCreate?: SeccionCreateOrConnectWithoutCuestionarioInput | SeccionCreateOrConnectWithoutCuestionarioInput[]
    createMany?: SeccionCreateManyCuestionarioInputEnvelope
    connect?: SeccionWhereUniqueInput | SeccionWhereUniqueInput[]
  }

  export type AsignacionCuestionarioUncheckedCreateNestedManyWithoutCuestionarioInput = {
    create?: XOR<AsignacionCuestionarioCreateWithoutCuestionarioInput, AsignacionCuestionarioUncheckedCreateWithoutCuestionarioInput> | AsignacionCuestionarioCreateWithoutCuestionarioInput[] | AsignacionCuestionarioUncheckedCreateWithoutCuestionarioInput[]
    connectOrCreate?: AsignacionCuestionarioCreateOrConnectWithoutCuestionarioInput | AsignacionCuestionarioCreateOrConnectWithoutCuestionarioInput[]
    createMany?: AsignacionCuestionarioCreateManyCuestionarioInputEnvelope
    connect?: AsignacionCuestionarioWhereUniqueInput | AsignacionCuestionarioWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MarcoNormativoUpdateOneWithoutCuestionariosNestedInput = {
    create?: XOR<MarcoNormativoCreateWithoutCuestionariosInput, MarcoNormativoUncheckedCreateWithoutCuestionariosInput>
    connectOrCreate?: MarcoNormativoCreateOrConnectWithoutCuestionariosInput
    upsert?: MarcoNormativoUpsertWithoutCuestionariosInput
    disconnect?: MarcoNormativoWhereInput | boolean
    delete?: MarcoNormativoWhereInput | boolean
    connect?: MarcoNormativoWhereUniqueInput
    update?: XOR<XOR<MarcoNormativoUpdateToOneWithWhereWithoutCuestionariosInput, MarcoNormativoUpdateWithoutCuestionariosInput>, MarcoNormativoUncheckedUpdateWithoutCuestionariosInput>
  }

  export type SeccionUpdateManyWithoutCuestionarioNestedInput = {
    create?: XOR<SeccionCreateWithoutCuestionarioInput, SeccionUncheckedCreateWithoutCuestionarioInput> | SeccionCreateWithoutCuestionarioInput[] | SeccionUncheckedCreateWithoutCuestionarioInput[]
    connectOrCreate?: SeccionCreateOrConnectWithoutCuestionarioInput | SeccionCreateOrConnectWithoutCuestionarioInput[]
    upsert?: SeccionUpsertWithWhereUniqueWithoutCuestionarioInput | SeccionUpsertWithWhereUniqueWithoutCuestionarioInput[]
    createMany?: SeccionCreateManyCuestionarioInputEnvelope
    set?: SeccionWhereUniqueInput | SeccionWhereUniqueInput[]
    disconnect?: SeccionWhereUniqueInput | SeccionWhereUniqueInput[]
    delete?: SeccionWhereUniqueInput | SeccionWhereUniqueInput[]
    connect?: SeccionWhereUniqueInput | SeccionWhereUniqueInput[]
    update?: SeccionUpdateWithWhereUniqueWithoutCuestionarioInput | SeccionUpdateWithWhereUniqueWithoutCuestionarioInput[]
    updateMany?: SeccionUpdateManyWithWhereWithoutCuestionarioInput | SeccionUpdateManyWithWhereWithoutCuestionarioInput[]
    deleteMany?: SeccionScalarWhereInput | SeccionScalarWhereInput[]
  }

  export type AsignacionCuestionarioUpdateManyWithoutCuestionarioNestedInput = {
    create?: XOR<AsignacionCuestionarioCreateWithoutCuestionarioInput, AsignacionCuestionarioUncheckedCreateWithoutCuestionarioInput> | AsignacionCuestionarioCreateWithoutCuestionarioInput[] | AsignacionCuestionarioUncheckedCreateWithoutCuestionarioInput[]
    connectOrCreate?: AsignacionCuestionarioCreateOrConnectWithoutCuestionarioInput | AsignacionCuestionarioCreateOrConnectWithoutCuestionarioInput[]
    upsert?: AsignacionCuestionarioUpsertWithWhereUniqueWithoutCuestionarioInput | AsignacionCuestionarioUpsertWithWhereUniqueWithoutCuestionarioInput[]
    createMany?: AsignacionCuestionarioCreateManyCuestionarioInputEnvelope
    set?: AsignacionCuestionarioWhereUniqueInput | AsignacionCuestionarioWhereUniqueInput[]
    disconnect?: AsignacionCuestionarioWhereUniqueInput | AsignacionCuestionarioWhereUniqueInput[]
    delete?: AsignacionCuestionarioWhereUniqueInput | AsignacionCuestionarioWhereUniqueInput[]
    connect?: AsignacionCuestionarioWhereUniqueInput | AsignacionCuestionarioWhereUniqueInput[]
    update?: AsignacionCuestionarioUpdateWithWhereUniqueWithoutCuestionarioInput | AsignacionCuestionarioUpdateWithWhereUniqueWithoutCuestionarioInput[]
    updateMany?: AsignacionCuestionarioUpdateManyWithWhereWithoutCuestionarioInput | AsignacionCuestionarioUpdateManyWithWhereWithoutCuestionarioInput[]
    deleteMany?: AsignacionCuestionarioScalarWhereInput | AsignacionCuestionarioScalarWhereInput[]
  }

  export type SeccionUncheckedUpdateManyWithoutCuestionarioNestedInput = {
    create?: XOR<SeccionCreateWithoutCuestionarioInput, SeccionUncheckedCreateWithoutCuestionarioInput> | SeccionCreateWithoutCuestionarioInput[] | SeccionUncheckedCreateWithoutCuestionarioInput[]
    connectOrCreate?: SeccionCreateOrConnectWithoutCuestionarioInput | SeccionCreateOrConnectWithoutCuestionarioInput[]
    upsert?: SeccionUpsertWithWhereUniqueWithoutCuestionarioInput | SeccionUpsertWithWhereUniqueWithoutCuestionarioInput[]
    createMany?: SeccionCreateManyCuestionarioInputEnvelope
    set?: SeccionWhereUniqueInput | SeccionWhereUniqueInput[]
    disconnect?: SeccionWhereUniqueInput | SeccionWhereUniqueInput[]
    delete?: SeccionWhereUniqueInput | SeccionWhereUniqueInput[]
    connect?: SeccionWhereUniqueInput | SeccionWhereUniqueInput[]
    update?: SeccionUpdateWithWhereUniqueWithoutCuestionarioInput | SeccionUpdateWithWhereUniqueWithoutCuestionarioInput[]
    updateMany?: SeccionUpdateManyWithWhereWithoutCuestionarioInput | SeccionUpdateManyWithWhereWithoutCuestionarioInput[]
    deleteMany?: SeccionScalarWhereInput | SeccionScalarWhereInput[]
  }

  export type AsignacionCuestionarioUncheckedUpdateManyWithoutCuestionarioNestedInput = {
    create?: XOR<AsignacionCuestionarioCreateWithoutCuestionarioInput, AsignacionCuestionarioUncheckedCreateWithoutCuestionarioInput> | AsignacionCuestionarioCreateWithoutCuestionarioInput[] | AsignacionCuestionarioUncheckedCreateWithoutCuestionarioInput[]
    connectOrCreate?: AsignacionCuestionarioCreateOrConnectWithoutCuestionarioInput | AsignacionCuestionarioCreateOrConnectWithoutCuestionarioInput[]
    upsert?: AsignacionCuestionarioUpsertWithWhereUniqueWithoutCuestionarioInput | AsignacionCuestionarioUpsertWithWhereUniqueWithoutCuestionarioInput[]
    createMany?: AsignacionCuestionarioCreateManyCuestionarioInputEnvelope
    set?: AsignacionCuestionarioWhereUniqueInput | AsignacionCuestionarioWhereUniqueInput[]
    disconnect?: AsignacionCuestionarioWhereUniqueInput | AsignacionCuestionarioWhereUniqueInput[]
    delete?: AsignacionCuestionarioWhereUniqueInput | AsignacionCuestionarioWhereUniqueInput[]
    connect?: AsignacionCuestionarioWhereUniqueInput | AsignacionCuestionarioWhereUniqueInput[]
    update?: AsignacionCuestionarioUpdateWithWhereUniqueWithoutCuestionarioInput | AsignacionCuestionarioUpdateWithWhereUniqueWithoutCuestionarioInput[]
    updateMany?: AsignacionCuestionarioUpdateManyWithWhereWithoutCuestionarioInput | AsignacionCuestionarioUpdateManyWithWhereWithoutCuestionarioInput[]
    deleteMany?: AsignacionCuestionarioScalarWhereInput | AsignacionCuestionarioScalarWhereInput[]
  }

  export type CuestionarioCreateNestedOneWithoutSeccionesInput = {
    create?: XOR<CuestionarioCreateWithoutSeccionesInput, CuestionarioUncheckedCreateWithoutSeccionesInput>
    connectOrCreate?: CuestionarioCreateOrConnectWithoutSeccionesInput
    connect?: CuestionarioWhereUniqueInput
  }

  export type PreguntaCreateNestedManyWithoutSeccionInput = {
    create?: XOR<PreguntaCreateWithoutSeccionInput, PreguntaUncheckedCreateWithoutSeccionInput> | PreguntaCreateWithoutSeccionInput[] | PreguntaUncheckedCreateWithoutSeccionInput[]
    connectOrCreate?: PreguntaCreateOrConnectWithoutSeccionInput | PreguntaCreateOrConnectWithoutSeccionInput[]
    createMany?: PreguntaCreateManySeccionInputEnvelope
    connect?: PreguntaWhereUniqueInput | PreguntaWhereUniqueInput[]
  }

  export type PreguntaUncheckedCreateNestedManyWithoutSeccionInput = {
    create?: XOR<PreguntaCreateWithoutSeccionInput, PreguntaUncheckedCreateWithoutSeccionInput> | PreguntaCreateWithoutSeccionInput[] | PreguntaUncheckedCreateWithoutSeccionInput[]
    connectOrCreate?: PreguntaCreateOrConnectWithoutSeccionInput | PreguntaCreateOrConnectWithoutSeccionInput[]
    createMany?: PreguntaCreateManySeccionInputEnvelope
    connect?: PreguntaWhereUniqueInput | PreguntaWhereUniqueInput[]
  }

  export type CuestionarioUpdateOneRequiredWithoutSeccionesNestedInput = {
    create?: XOR<CuestionarioCreateWithoutSeccionesInput, CuestionarioUncheckedCreateWithoutSeccionesInput>
    connectOrCreate?: CuestionarioCreateOrConnectWithoutSeccionesInput
    upsert?: CuestionarioUpsertWithoutSeccionesInput
    connect?: CuestionarioWhereUniqueInput
    update?: XOR<XOR<CuestionarioUpdateToOneWithWhereWithoutSeccionesInput, CuestionarioUpdateWithoutSeccionesInput>, CuestionarioUncheckedUpdateWithoutSeccionesInput>
  }

  export type PreguntaUpdateManyWithoutSeccionNestedInput = {
    create?: XOR<PreguntaCreateWithoutSeccionInput, PreguntaUncheckedCreateWithoutSeccionInput> | PreguntaCreateWithoutSeccionInput[] | PreguntaUncheckedCreateWithoutSeccionInput[]
    connectOrCreate?: PreguntaCreateOrConnectWithoutSeccionInput | PreguntaCreateOrConnectWithoutSeccionInput[]
    upsert?: PreguntaUpsertWithWhereUniqueWithoutSeccionInput | PreguntaUpsertWithWhereUniqueWithoutSeccionInput[]
    createMany?: PreguntaCreateManySeccionInputEnvelope
    set?: PreguntaWhereUniqueInput | PreguntaWhereUniqueInput[]
    disconnect?: PreguntaWhereUniqueInput | PreguntaWhereUniqueInput[]
    delete?: PreguntaWhereUniqueInput | PreguntaWhereUniqueInput[]
    connect?: PreguntaWhereUniqueInput | PreguntaWhereUniqueInput[]
    update?: PreguntaUpdateWithWhereUniqueWithoutSeccionInput | PreguntaUpdateWithWhereUniqueWithoutSeccionInput[]
    updateMany?: PreguntaUpdateManyWithWhereWithoutSeccionInput | PreguntaUpdateManyWithWhereWithoutSeccionInput[]
    deleteMany?: PreguntaScalarWhereInput | PreguntaScalarWhereInput[]
  }

  export type PreguntaUncheckedUpdateManyWithoutSeccionNestedInput = {
    create?: XOR<PreguntaCreateWithoutSeccionInput, PreguntaUncheckedCreateWithoutSeccionInput> | PreguntaCreateWithoutSeccionInput[] | PreguntaUncheckedCreateWithoutSeccionInput[]
    connectOrCreate?: PreguntaCreateOrConnectWithoutSeccionInput | PreguntaCreateOrConnectWithoutSeccionInput[]
    upsert?: PreguntaUpsertWithWhereUniqueWithoutSeccionInput | PreguntaUpsertWithWhereUniqueWithoutSeccionInput[]
    createMany?: PreguntaCreateManySeccionInputEnvelope
    set?: PreguntaWhereUniqueInput | PreguntaWhereUniqueInput[]
    disconnect?: PreguntaWhereUniqueInput | PreguntaWhereUniqueInput[]
    delete?: PreguntaWhereUniqueInput | PreguntaWhereUniqueInput[]
    connect?: PreguntaWhereUniqueInput | PreguntaWhereUniqueInput[]
    update?: PreguntaUpdateWithWhereUniqueWithoutSeccionInput | PreguntaUpdateWithWhereUniqueWithoutSeccionInput[]
    updateMany?: PreguntaUpdateManyWithWhereWithoutSeccionInput | PreguntaUpdateManyWithWhereWithoutSeccionInput[]
    deleteMany?: PreguntaScalarWhereInput | PreguntaScalarWhereInput[]
  }

  export type SeccionCreateNestedOneWithoutPreguntasInput = {
    create?: XOR<SeccionCreateWithoutPreguntasInput, SeccionUncheckedCreateWithoutPreguntasInput>
    connectOrCreate?: SeccionCreateOrConnectWithoutPreguntasInput
    connect?: SeccionWhereUniqueInput
  }

  export type RespuestaPreguntaCreateNestedManyWithoutPreguntaInput = {
    create?: XOR<RespuestaPreguntaCreateWithoutPreguntaInput, RespuestaPreguntaUncheckedCreateWithoutPreguntaInput> | RespuestaPreguntaCreateWithoutPreguntaInput[] | RespuestaPreguntaUncheckedCreateWithoutPreguntaInput[]
    connectOrCreate?: RespuestaPreguntaCreateOrConnectWithoutPreguntaInput | RespuestaPreguntaCreateOrConnectWithoutPreguntaInput[]
    createMany?: RespuestaPreguntaCreateManyPreguntaInputEnvelope
    connect?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
  }

  export type HallazgoCreateNestedManyWithoutPreguntaInput = {
    create?: XOR<HallazgoCreateWithoutPreguntaInput, HallazgoUncheckedCreateWithoutPreguntaInput> | HallazgoCreateWithoutPreguntaInput[] | HallazgoUncheckedCreateWithoutPreguntaInput[]
    connectOrCreate?: HallazgoCreateOrConnectWithoutPreguntaInput | HallazgoCreateOrConnectWithoutPreguntaInput[]
    createMany?: HallazgoCreateManyPreguntaInputEnvelope
    connect?: HallazgoWhereUniqueInput | HallazgoWhereUniqueInput[]
  }

  export type RespuestaPreguntaUncheckedCreateNestedManyWithoutPreguntaInput = {
    create?: XOR<RespuestaPreguntaCreateWithoutPreguntaInput, RespuestaPreguntaUncheckedCreateWithoutPreguntaInput> | RespuestaPreguntaCreateWithoutPreguntaInput[] | RespuestaPreguntaUncheckedCreateWithoutPreguntaInput[]
    connectOrCreate?: RespuestaPreguntaCreateOrConnectWithoutPreguntaInput | RespuestaPreguntaCreateOrConnectWithoutPreguntaInput[]
    createMany?: RespuestaPreguntaCreateManyPreguntaInputEnvelope
    connect?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
  }

  export type HallazgoUncheckedCreateNestedManyWithoutPreguntaInput = {
    create?: XOR<HallazgoCreateWithoutPreguntaInput, HallazgoUncheckedCreateWithoutPreguntaInput> | HallazgoCreateWithoutPreguntaInput[] | HallazgoUncheckedCreateWithoutPreguntaInput[]
    connectOrCreate?: HallazgoCreateOrConnectWithoutPreguntaInput | HallazgoCreateOrConnectWithoutPreguntaInput[]
    createMany?: HallazgoCreateManyPreguntaInputEnvelope
    connect?: HallazgoWhereUniqueInput | HallazgoWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SeccionUpdateOneRequiredWithoutPreguntasNestedInput = {
    create?: XOR<SeccionCreateWithoutPreguntasInput, SeccionUncheckedCreateWithoutPreguntasInput>
    connectOrCreate?: SeccionCreateOrConnectWithoutPreguntasInput
    upsert?: SeccionUpsertWithoutPreguntasInput
    connect?: SeccionWhereUniqueInput
    update?: XOR<XOR<SeccionUpdateToOneWithWhereWithoutPreguntasInput, SeccionUpdateWithoutPreguntasInput>, SeccionUncheckedUpdateWithoutPreguntasInput>
  }

  export type RespuestaPreguntaUpdateManyWithoutPreguntaNestedInput = {
    create?: XOR<RespuestaPreguntaCreateWithoutPreguntaInput, RespuestaPreguntaUncheckedCreateWithoutPreguntaInput> | RespuestaPreguntaCreateWithoutPreguntaInput[] | RespuestaPreguntaUncheckedCreateWithoutPreguntaInput[]
    connectOrCreate?: RespuestaPreguntaCreateOrConnectWithoutPreguntaInput | RespuestaPreguntaCreateOrConnectWithoutPreguntaInput[]
    upsert?: RespuestaPreguntaUpsertWithWhereUniqueWithoutPreguntaInput | RespuestaPreguntaUpsertWithWhereUniqueWithoutPreguntaInput[]
    createMany?: RespuestaPreguntaCreateManyPreguntaInputEnvelope
    set?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
    disconnect?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
    delete?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
    connect?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
    update?: RespuestaPreguntaUpdateWithWhereUniqueWithoutPreguntaInput | RespuestaPreguntaUpdateWithWhereUniqueWithoutPreguntaInput[]
    updateMany?: RespuestaPreguntaUpdateManyWithWhereWithoutPreguntaInput | RespuestaPreguntaUpdateManyWithWhereWithoutPreguntaInput[]
    deleteMany?: RespuestaPreguntaScalarWhereInput | RespuestaPreguntaScalarWhereInput[]
  }

  export type HallazgoUpdateManyWithoutPreguntaNestedInput = {
    create?: XOR<HallazgoCreateWithoutPreguntaInput, HallazgoUncheckedCreateWithoutPreguntaInput> | HallazgoCreateWithoutPreguntaInput[] | HallazgoUncheckedCreateWithoutPreguntaInput[]
    connectOrCreate?: HallazgoCreateOrConnectWithoutPreguntaInput | HallazgoCreateOrConnectWithoutPreguntaInput[]
    upsert?: HallazgoUpsertWithWhereUniqueWithoutPreguntaInput | HallazgoUpsertWithWhereUniqueWithoutPreguntaInput[]
    createMany?: HallazgoCreateManyPreguntaInputEnvelope
    set?: HallazgoWhereUniqueInput | HallazgoWhereUniqueInput[]
    disconnect?: HallazgoWhereUniqueInput | HallazgoWhereUniqueInput[]
    delete?: HallazgoWhereUniqueInput | HallazgoWhereUniqueInput[]
    connect?: HallazgoWhereUniqueInput | HallazgoWhereUniqueInput[]
    update?: HallazgoUpdateWithWhereUniqueWithoutPreguntaInput | HallazgoUpdateWithWhereUniqueWithoutPreguntaInput[]
    updateMany?: HallazgoUpdateManyWithWhereWithoutPreguntaInput | HallazgoUpdateManyWithWhereWithoutPreguntaInput[]
    deleteMany?: HallazgoScalarWhereInput | HallazgoScalarWhereInput[]
  }

  export type RespuestaPreguntaUncheckedUpdateManyWithoutPreguntaNestedInput = {
    create?: XOR<RespuestaPreguntaCreateWithoutPreguntaInput, RespuestaPreguntaUncheckedCreateWithoutPreguntaInput> | RespuestaPreguntaCreateWithoutPreguntaInput[] | RespuestaPreguntaUncheckedCreateWithoutPreguntaInput[]
    connectOrCreate?: RespuestaPreguntaCreateOrConnectWithoutPreguntaInput | RespuestaPreguntaCreateOrConnectWithoutPreguntaInput[]
    upsert?: RespuestaPreguntaUpsertWithWhereUniqueWithoutPreguntaInput | RespuestaPreguntaUpsertWithWhereUniqueWithoutPreguntaInput[]
    createMany?: RespuestaPreguntaCreateManyPreguntaInputEnvelope
    set?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
    disconnect?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
    delete?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
    connect?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
    update?: RespuestaPreguntaUpdateWithWhereUniqueWithoutPreguntaInput | RespuestaPreguntaUpdateWithWhereUniqueWithoutPreguntaInput[]
    updateMany?: RespuestaPreguntaUpdateManyWithWhereWithoutPreguntaInput | RespuestaPreguntaUpdateManyWithWhereWithoutPreguntaInput[]
    deleteMany?: RespuestaPreguntaScalarWhereInput | RespuestaPreguntaScalarWhereInput[]
  }

  export type HallazgoUncheckedUpdateManyWithoutPreguntaNestedInput = {
    create?: XOR<HallazgoCreateWithoutPreguntaInput, HallazgoUncheckedCreateWithoutPreguntaInput> | HallazgoCreateWithoutPreguntaInput[] | HallazgoUncheckedCreateWithoutPreguntaInput[]
    connectOrCreate?: HallazgoCreateOrConnectWithoutPreguntaInput | HallazgoCreateOrConnectWithoutPreguntaInput[]
    upsert?: HallazgoUpsertWithWhereUniqueWithoutPreguntaInput | HallazgoUpsertWithWhereUniqueWithoutPreguntaInput[]
    createMany?: HallazgoCreateManyPreguntaInputEnvelope
    set?: HallazgoWhereUniqueInput | HallazgoWhereUniqueInput[]
    disconnect?: HallazgoWhereUniqueInput | HallazgoWhereUniqueInput[]
    delete?: HallazgoWhereUniqueInput | HallazgoWhereUniqueInput[]
    connect?: HallazgoWhereUniqueInput | HallazgoWhereUniqueInput[]
    update?: HallazgoUpdateWithWhereUniqueWithoutPreguntaInput | HallazgoUpdateWithWhereUniqueWithoutPreguntaInput[]
    updateMany?: HallazgoUpdateManyWithWhereWithoutPreguntaInput | HallazgoUpdateManyWithWhereWithoutPreguntaInput[]
    deleteMany?: HallazgoScalarWhereInput | HallazgoScalarWhereInput[]
  }

  export type CuestionarioCreateNestedOneWithoutAsignacionesInput = {
    create?: XOR<CuestionarioCreateWithoutAsignacionesInput, CuestionarioUncheckedCreateWithoutAsignacionesInput>
    connectOrCreate?: CuestionarioCreateOrConnectWithoutAsignacionesInput
    connect?: CuestionarioWhereUniqueInput
  }

  export type EvaluadoExternoCreateNestedManyWithoutAsignacionInput = {
    create?: XOR<EvaluadoExternoCreateWithoutAsignacionInput, EvaluadoExternoUncheckedCreateWithoutAsignacionInput> | EvaluadoExternoCreateWithoutAsignacionInput[] | EvaluadoExternoUncheckedCreateWithoutAsignacionInput[]
    connectOrCreate?: EvaluadoExternoCreateOrConnectWithoutAsignacionInput | EvaluadoExternoCreateOrConnectWithoutAsignacionInput[]
    createMany?: EvaluadoExternoCreateManyAsignacionInputEnvelope
    connect?: EvaluadoExternoWhereUniqueInput | EvaluadoExternoWhereUniqueInput[]
  }

  export type RespuestaCuestionarioCreateNestedManyWithoutAsignacionInput = {
    create?: XOR<RespuestaCuestionarioCreateWithoutAsignacionInput, RespuestaCuestionarioUncheckedCreateWithoutAsignacionInput> | RespuestaCuestionarioCreateWithoutAsignacionInput[] | RespuestaCuestionarioUncheckedCreateWithoutAsignacionInput[]
    connectOrCreate?: RespuestaCuestionarioCreateOrConnectWithoutAsignacionInput | RespuestaCuestionarioCreateOrConnectWithoutAsignacionInput[]
    createMany?: RespuestaCuestionarioCreateManyAsignacionInputEnvelope
    connect?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
  }

  export type MensajeChatCreateNestedManyWithoutAsignacionInput = {
    create?: XOR<MensajeChatCreateWithoutAsignacionInput, MensajeChatUncheckedCreateWithoutAsignacionInput> | MensajeChatCreateWithoutAsignacionInput[] | MensajeChatUncheckedCreateWithoutAsignacionInput[]
    connectOrCreate?: MensajeChatCreateOrConnectWithoutAsignacionInput | MensajeChatCreateOrConnectWithoutAsignacionInput[]
    createMany?: MensajeChatCreateManyAsignacionInputEnvelope
    connect?: MensajeChatWhereUniqueInput | MensajeChatWhereUniqueInput[]
  }

  export type EvaluadoExternoUncheckedCreateNestedManyWithoutAsignacionInput = {
    create?: XOR<EvaluadoExternoCreateWithoutAsignacionInput, EvaluadoExternoUncheckedCreateWithoutAsignacionInput> | EvaluadoExternoCreateWithoutAsignacionInput[] | EvaluadoExternoUncheckedCreateWithoutAsignacionInput[]
    connectOrCreate?: EvaluadoExternoCreateOrConnectWithoutAsignacionInput | EvaluadoExternoCreateOrConnectWithoutAsignacionInput[]
    createMany?: EvaluadoExternoCreateManyAsignacionInputEnvelope
    connect?: EvaluadoExternoWhereUniqueInput | EvaluadoExternoWhereUniqueInput[]
  }

  export type RespuestaCuestionarioUncheckedCreateNestedManyWithoutAsignacionInput = {
    create?: XOR<RespuestaCuestionarioCreateWithoutAsignacionInput, RespuestaCuestionarioUncheckedCreateWithoutAsignacionInput> | RespuestaCuestionarioCreateWithoutAsignacionInput[] | RespuestaCuestionarioUncheckedCreateWithoutAsignacionInput[]
    connectOrCreate?: RespuestaCuestionarioCreateOrConnectWithoutAsignacionInput | RespuestaCuestionarioCreateOrConnectWithoutAsignacionInput[]
    createMany?: RespuestaCuestionarioCreateManyAsignacionInputEnvelope
    connect?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
  }

  export type MensajeChatUncheckedCreateNestedManyWithoutAsignacionInput = {
    create?: XOR<MensajeChatCreateWithoutAsignacionInput, MensajeChatUncheckedCreateWithoutAsignacionInput> | MensajeChatCreateWithoutAsignacionInput[] | MensajeChatUncheckedCreateWithoutAsignacionInput[]
    connectOrCreate?: MensajeChatCreateOrConnectWithoutAsignacionInput | MensajeChatCreateOrConnectWithoutAsignacionInput[]
    createMany?: MensajeChatCreateManyAsignacionInputEnvelope
    connect?: MensajeChatWhereUniqueInput | MensajeChatWhereUniqueInput[]
  }

  export type CuestionarioUpdateOneRequiredWithoutAsignacionesNestedInput = {
    create?: XOR<CuestionarioCreateWithoutAsignacionesInput, CuestionarioUncheckedCreateWithoutAsignacionesInput>
    connectOrCreate?: CuestionarioCreateOrConnectWithoutAsignacionesInput
    upsert?: CuestionarioUpsertWithoutAsignacionesInput
    connect?: CuestionarioWhereUniqueInput
    update?: XOR<XOR<CuestionarioUpdateToOneWithWhereWithoutAsignacionesInput, CuestionarioUpdateWithoutAsignacionesInput>, CuestionarioUncheckedUpdateWithoutAsignacionesInput>
  }

  export type EvaluadoExternoUpdateManyWithoutAsignacionNestedInput = {
    create?: XOR<EvaluadoExternoCreateWithoutAsignacionInput, EvaluadoExternoUncheckedCreateWithoutAsignacionInput> | EvaluadoExternoCreateWithoutAsignacionInput[] | EvaluadoExternoUncheckedCreateWithoutAsignacionInput[]
    connectOrCreate?: EvaluadoExternoCreateOrConnectWithoutAsignacionInput | EvaluadoExternoCreateOrConnectWithoutAsignacionInput[]
    upsert?: EvaluadoExternoUpsertWithWhereUniqueWithoutAsignacionInput | EvaluadoExternoUpsertWithWhereUniqueWithoutAsignacionInput[]
    createMany?: EvaluadoExternoCreateManyAsignacionInputEnvelope
    set?: EvaluadoExternoWhereUniqueInput | EvaluadoExternoWhereUniqueInput[]
    disconnect?: EvaluadoExternoWhereUniqueInput | EvaluadoExternoWhereUniqueInput[]
    delete?: EvaluadoExternoWhereUniqueInput | EvaluadoExternoWhereUniqueInput[]
    connect?: EvaluadoExternoWhereUniqueInput | EvaluadoExternoWhereUniqueInput[]
    update?: EvaluadoExternoUpdateWithWhereUniqueWithoutAsignacionInput | EvaluadoExternoUpdateWithWhereUniqueWithoutAsignacionInput[]
    updateMany?: EvaluadoExternoUpdateManyWithWhereWithoutAsignacionInput | EvaluadoExternoUpdateManyWithWhereWithoutAsignacionInput[]
    deleteMany?: EvaluadoExternoScalarWhereInput | EvaluadoExternoScalarWhereInput[]
  }

  export type RespuestaCuestionarioUpdateManyWithoutAsignacionNestedInput = {
    create?: XOR<RespuestaCuestionarioCreateWithoutAsignacionInput, RespuestaCuestionarioUncheckedCreateWithoutAsignacionInput> | RespuestaCuestionarioCreateWithoutAsignacionInput[] | RespuestaCuestionarioUncheckedCreateWithoutAsignacionInput[]
    connectOrCreate?: RespuestaCuestionarioCreateOrConnectWithoutAsignacionInput | RespuestaCuestionarioCreateOrConnectWithoutAsignacionInput[]
    upsert?: RespuestaCuestionarioUpsertWithWhereUniqueWithoutAsignacionInput | RespuestaCuestionarioUpsertWithWhereUniqueWithoutAsignacionInput[]
    createMany?: RespuestaCuestionarioCreateManyAsignacionInputEnvelope
    set?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
    disconnect?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
    delete?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
    connect?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
    update?: RespuestaCuestionarioUpdateWithWhereUniqueWithoutAsignacionInput | RespuestaCuestionarioUpdateWithWhereUniqueWithoutAsignacionInput[]
    updateMany?: RespuestaCuestionarioUpdateManyWithWhereWithoutAsignacionInput | RespuestaCuestionarioUpdateManyWithWhereWithoutAsignacionInput[]
    deleteMany?: RespuestaCuestionarioScalarWhereInput | RespuestaCuestionarioScalarWhereInput[]
  }

  export type MensajeChatUpdateManyWithoutAsignacionNestedInput = {
    create?: XOR<MensajeChatCreateWithoutAsignacionInput, MensajeChatUncheckedCreateWithoutAsignacionInput> | MensajeChatCreateWithoutAsignacionInput[] | MensajeChatUncheckedCreateWithoutAsignacionInput[]
    connectOrCreate?: MensajeChatCreateOrConnectWithoutAsignacionInput | MensajeChatCreateOrConnectWithoutAsignacionInput[]
    upsert?: MensajeChatUpsertWithWhereUniqueWithoutAsignacionInput | MensajeChatUpsertWithWhereUniqueWithoutAsignacionInput[]
    createMany?: MensajeChatCreateManyAsignacionInputEnvelope
    set?: MensajeChatWhereUniqueInput | MensajeChatWhereUniqueInput[]
    disconnect?: MensajeChatWhereUniqueInput | MensajeChatWhereUniqueInput[]
    delete?: MensajeChatWhereUniqueInput | MensajeChatWhereUniqueInput[]
    connect?: MensajeChatWhereUniqueInput | MensajeChatWhereUniqueInput[]
    update?: MensajeChatUpdateWithWhereUniqueWithoutAsignacionInput | MensajeChatUpdateWithWhereUniqueWithoutAsignacionInput[]
    updateMany?: MensajeChatUpdateManyWithWhereWithoutAsignacionInput | MensajeChatUpdateManyWithWhereWithoutAsignacionInput[]
    deleteMany?: MensajeChatScalarWhereInput | MensajeChatScalarWhereInput[]
  }

  export type EvaluadoExternoUncheckedUpdateManyWithoutAsignacionNestedInput = {
    create?: XOR<EvaluadoExternoCreateWithoutAsignacionInput, EvaluadoExternoUncheckedCreateWithoutAsignacionInput> | EvaluadoExternoCreateWithoutAsignacionInput[] | EvaluadoExternoUncheckedCreateWithoutAsignacionInput[]
    connectOrCreate?: EvaluadoExternoCreateOrConnectWithoutAsignacionInput | EvaluadoExternoCreateOrConnectWithoutAsignacionInput[]
    upsert?: EvaluadoExternoUpsertWithWhereUniqueWithoutAsignacionInput | EvaluadoExternoUpsertWithWhereUniqueWithoutAsignacionInput[]
    createMany?: EvaluadoExternoCreateManyAsignacionInputEnvelope
    set?: EvaluadoExternoWhereUniqueInput | EvaluadoExternoWhereUniqueInput[]
    disconnect?: EvaluadoExternoWhereUniqueInput | EvaluadoExternoWhereUniqueInput[]
    delete?: EvaluadoExternoWhereUniqueInput | EvaluadoExternoWhereUniqueInput[]
    connect?: EvaluadoExternoWhereUniqueInput | EvaluadoExternoWhereUniqueInput[]
    update?: EvaluadoExternoUpdateWithWhereUniqueWithoutAsignacionInput | EvaluadoExternoUpdateWithWhereUniqueWithoutAsignacionInput[]
    updateMany?: EvaluadoExternoUpdateManyWithWhereWithoutAsignacionInput | EvaluadoExternoUpdateManyWithWhereWithoutAsignacionInput[]
    deleteMany?: EvaluadoExternoScalarWhereInput | EvaluadoExternoScalarWhereInput[]
  }

  export type RespuestaCuestionarioUncheckedUpdateManyWithoutAsignacionNestedInput = {
    create?: XOR<RespuestaCuestionarioCreateWithoutAsignacionInput, RespuestaCuestionarioUncheckedCreateWithoutAsignacionInput> | RespuestaCuestionarioCreateWithoutAsignacionInput[] | RespuestaCuestionarioUncheckedCreateWithoutAsignacionInput[]
    connectOrCreate?: RespuestaCuestionarioCreateOrConnectWithoutAsignacionInput | RespuestaCuestionarioCreateOrConnectWithoutAsignacionInput[]
    upsert?: RespuestaCuestionarioUpsertWithWhereUniqueWithoutAsignacionInput | RespuestaCuestionarioUpsertWithWhereUniqueWithoutAsignacionInput[]
    createMany?: RespuestaCuestionarioCreateManyAsignacionInputEnvelope
    set?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
    disconnect?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
    delete?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
    connect?: RespuestaCuestionarioWhereUniqueInput | RespuestaCuestionarioWhereUniqueInput[]
    update?: RespuestaCuestionarioUpdateWithWhereUniqueWithoutAsignacionInput | RespuestaCuestionarioUpdateWithWhereUniqueWithoutAsignacionInput[]
    updateMany?: RespuestaCuestionarioUpdateManyWithWhereWithoutAsignacionInput | RespuestaCuestionarioUpdateManyWithWhereWithoutAsignacionInput[]
    deleteMany?: RespuestaCuestionarioScalarWhereInput | RespuestaCuestionarioScalarWhereInput[]
  }

  export type MensajeChatUncheckedUpdateManyWithoutAsignacionNestedInput = {
    create?: XOR<MensajeChatCreateWithoutAsignacionInput, MensajeChatUncheckedCreateWithoutAsignacionInput> | MensajeChatCreateWithoutAsignacionInput[] | MensajeChatUncheckedCreateWithoutAsignacionInput[]
    connectOrCreate?: MensajeChatCreateOrConnectWithoutAsignacionInput | MensajeChatCreateOrConnectWithoutAsignacionInput[]
    upsert?: MensajeChatUpsertWithWhereUniqueWithoutAsignacionInput | MensajeChatUpsertWithWhereUniqueWithoutAsignacionInput[]
    createMany?: MensajeChatCreateManyAsignacionInputEnvelope
    set?: MensajeChatWhereUniqueInput | MensajeChatWhereUniqueInput[]
    disconnect?: MensajeChatWhereUniqueInput | MensajeChatWhereUniqueInput[]
    delete?: MensajeChatWhereUniqueInput | MensajeChatWhereUniqueInput[]
    connect?: MensajeChatWhereUniqueInput | MensajeChatWhereUniqueInput[]
    update?: MensajeChatUpdateWithWhereUniqueWithoutAsignacionInput | MensajeChatUpdateWithWhereUniqueWithoutAsignacionInput[]
    updateMany?: MensajeChatUpdateManyWithWhereWithoutAsignacionInput | MensajeChatUpdateManyWithWhereWithoutAsignacionInput[]
    deleteMany?: MensajeChatScalarWhereInput | MensajeChatScalarWhereInput[]
  }

  export type AsignacionCuestionarioCreateNestedOneWithoutEvaluadosExternosInput = {
    create?: XOR<AsignacionCuestionarioCreateWithoutEvaluadosExternosInput, AsignacionCuestionarioUncheckedCreateWithoutEvaluadosExternosInput>
    connectOrCreate?: AsignacionCuestionarioCreateOrConnectWithoutEvaluadosExternosInput
    connect?: AsignacionCuestionarioWhereUniqueInput
  }

  export type AsignacionCuestionarioUpdateOneRequiredWithoutEvaluadosExternosNestedInput = {
    create?: XOR<AsignacionCuestionarioCreateWithoutEvaluadosExternosInput, AsignacionCuestionarioUncheckedCreateWithoutEvaluadosExternosInput>
    connectOrCreate?: AsignacionCuestionarioCreateOrConnectWithoutEvaluadosExternosInput
    upsert?: AsignacionCuestionarioUpsertWithoutEvaluadosExternosInput
    connect?: AsignacionCuestionarioWhereUniqueInput
    update?: XOR<XOR<AsignacionCuestionarioUpdateToOneWithWhereWithoutEvaluadosExternosInput, AsignacionCuestionarioUpdateWithoutEvaluadosExternosInput>, AsignacionCuestionarioUncheckedUpdateWithoutEvaluadosExternosInput>
  }

  export type AsignacionCuestionarioCreateNestedOneWithoutRespuestasInput = {
    create?: XOR<AsignacionCuestionarioCreateWithoutRespuestasInput, AsignacionCuestionarioUncheckedCreateWithoutRespuestasInput>
    connectOrCreate?: AsignacionCuestionarioCreateOrConnectWithoutRespuestasInput
    connect?: AsignacionCuestionarioWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutRespuestasCuestionarioInput = {
    create?: XOR<UsuarioCreateWithoutRespuestasCuestionarioInput, UsuarioUncheckedCreateWithoutRespuestasCuestionarioInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRespuestasCuestionarioInput
    connect?: UsuarioWhereUniqueInput
  }

  export type RespuestaPreguntaCreateNestedManyWithoutRespuestaCuestionarioInput = {
    create?: XOR<RespuestaPreguntaCreateWithoutRespuestaCuestionarioInput, RespuestaPreguntaUncheckedCreateWithoutRespuestaCuestionarioInput> | RespuestaPreguntaCreateWithoutRespuestaCuestionarioInput[] | RespuestaPreguntaUncheckedCreateWithoutRespuestaCuestionarioInput[]
    connectOrCreate?: RespuestaPreguntaCreateOrConnectWithoutRespuestaCuestionarioInput | RespuestaPreguntaCreateOrConnectWithoutRespuestaCuestionarioInput[]
    createMany?: RespuestaPreguntaCreateManyRespuestaCuestionarioInputEnvelope
    connect?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
  }

  export type RespuestaPreguntaUncheckedCreateNestedManyWithoutRespuestaCuestionarioInput = {
    create?: XOR<RespuestaPreguntaCreateWithoutRespuestaCuestionarioInput, RespuestaPreguntaUncheckedCreateWithoutRespuestaCuestionarioInput> | RespuestaPreguntaCreateWithoutRespuestaCuestionarioInput[] | RespuestaPreguntaUncheckedCreateWithoutRespuestaCuestionarioInput[]
    connectOrCreate?: RespuestaPreguntaCreateOrConnectWithoutRespuestaCuestionarioInput | RespuestaPreguntaCreateOrConnectWithoutRespuestaCuestionarioInput[]
    createMany?: RespuestaPreguntaCreateManyRespuestaCuestionarioInputEnvelope
    connect?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
  }

  export type AsignacionCuestionarioUpdateOneRequiredWithoutRespuestasNestedInput = {
    create?: XOR<AsignacionCuestionarioCreateWithoutRespuestasInput, AsignacionCuestionarioUncheckedCreateWithoutRespuestasInput>
    connectOrCreate?: AsignacionCuestionarioCreateOrConnectWithoutRespuestasInput
    upsert?: AsignacionCuestionarioUpsertWithoutRespuestasInput
    connect?: AsignacionCuestionarioWhereUniqueInput
    update?: XOR<XOR<AsignacionCuestionarioUpdateToOneWithWhereWithoutRespuestasInput, AsignacionCuestionarioUpdateWithoutRespuestasInput>, AsignacionCuestionarioUncheckedUpdateWithoutRespuestasInput>
  }

  export type UsuarioUpdateOneRequiredWithoutRespuestasCuestionarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutRespuestasCuestionarioInput, UsuarioUncheckedCreateWithoutRespuestasCuestionarioInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRespuestasCuestionarioInput
    upsert?: UsuarioUpsertWithoutRespuestasCuestionarioInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutRespuestasCuestionarioInput, UsuarioUpdateWithoutRespuestasCuestionarioInput>, UsuarioUncheckedUpdateWithoutRespuestasCuestionarioInput>
  }

  export type RespuestaPreguntaUpdateManyWithoutRespuestaCuestionarioNestedInput = {
    create?: XOR<RespuestaPreguntaCreateWithoutRespuestaCuestionarioInput, RespuestaPreguntaUncheckedCreateWithoutRespuestaCuestionarioInput> | RespuestaPreguntaCreateWithoutRespuestaCuestionarioInput[] | RespuestaPreguntaUncheckedCreateWithoutRespuestaCuestionarioInput[]
    connectOrCreate?: RespuestaPreguntaCreateOrConnectWithoutRespuestaCuestionarioInput | RespuestaPreguntaCreateOrConnectWithoutRespuestaCuestionarioInput[]
    upsert?: RespuestaPreguntaUpsertWithWhereUniqueWithoutRespuestaCuestionarioInput | RespuestaPreguntaUpsertWithWhereUniqueWithoutRespuestaCuestionarioInput[]
    createMany?: RespuestaPreguntaCreateManyRespuestaCuestionarioInputEnvelope
    set?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
    disconnect?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
    delete?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
    connect?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
    update?: RespuestaPreguntaUpdateWithWhereUniqueWithoutRespuestaCuestionarioInput | RespuestaPreguntaUpdateWithWhereUniqueWithoutRespuestaCuestionarioInput[]
    updateMany?: RespuestaPreguntaUpdateManyWithWhereWithoutRespuestaCuestionarioInput | RespuestaPreguntaUpdateManyWithWhereWithoutRespuestaCuestionarioInput[]
    deleteMany?: RespuestaPreguntaScalarWhereInput | RespuestaPreguntaScalarWhereInput[]
  }

  export type RespuestaPreguntaUncheckedUpdateManyWithoutRespuestaCuestionarioNestedInput = {
    create?: XOR<RespuestaPreguntaCreateWithoutRespuestaCuestionarioInput, RespuestaPreguntaUncheckedCreateWithoutRespuestaCuestionarioInput> | RespuestaPreguntaCreateWithoutRespuestaCuestionarioInput[] | RespuestaPreguntaUncheckedCreateWithoutRespuestaCuestionarioInput[]
    connectOrCreate?: RespuestaPreguntaCreateOrConnectWithoutRespuestaCuestionarioInput | RespuestaPreguntaCreateOrConnectWithoutRespuestaCuestionarioInput[]
    upsert?: RespuestaPreguntaUpsertWithWhereUniqueWithoutRespuestaCuestionarioInput | RespuestaPreguntaUpsertWithWhereUniqueWithoutRespuestaCuestionarioInput[]
    createMany?: RespuestaPreguntaCreateManyRespuestaCuestionarioInputEnvelope
    set?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
    disconnect?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
    delete?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
    connect?: RespuestaPreguntaWhereUniqueInput | RespuestaPreguntaWhereUniqueInput[]
    update?: RespuestaPreguntaUpdateWithWhereUniqueWithoutRespuestaCuestionarioInput | RespuestaPreguntaUpdateWithWhereUniqueWithoutRespuestaCuestionarioInput[]
    updateMany?: RespuestaPreguntaUpdateManyWithWhereWithoutRespuestaCuestionarioInput | RespuestaPreguntaUpdateManyWithWhereWithoutRespuestaCuestionarioInput[]
    deleteMany?: RespuestaPreguntaScalarWhereInput | RespuestaPreguntaScalarWhereInput[]
  }

  export type RespuestaCuestionarioCreateNestedOneWithoutRespuestasInput = {
    create?: XOR<RespuestaCuestionarioCreateWithoutRespuestasInput, RespuestaCuestionarioUncheckedCreateWithoutRespuestasInput>
    connectOrCreate?: RespuestaCuestionarioCreateOrConnectWithoutRespuestasInput
    connect?: RespuestaCuestionarioWhereUniqueInput
  }

  export type PreguntaCreateNestedOneWithoutRespuestasInput = {
    create?: XOR<PreguntaCreateWithoutRespuestasInput, PreguntaUncheckedCreateWithoutRespuestasInput>
    connectOrCreate?: PreguntaCreateOrConnectWithoutRespuestasInput
    connect?: PreguntaWhereUniqueInput
  }

  export type EvidenciaCreateNestedManyWithoutRespuestaPreguntaInput = {
    create?: XOR<EvidenciaCreateWithoutRespuestaPreguntaInput, EvidenciaUncheckedCreateWithoutRespuestaPreguntaInput> | EvidenciaCreateWithoutRespuestaPreguntaInput[] | EvidenciaUncheckedCreateWithoutRespuestaPreguntaInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutRespuestaPreguntaInput | EvidenciaCreateOrConnectWithoutRespuestaPreguntaInput[]
    createMany?: EvidenciaCreateManyRespuestaPreguntaInputEnvelope
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
  }

  export type EvidenciaUncheckedCreateNestedManyWithoutRespuestaPreguntaInput = {
    create?: XOR<EvidenciaCreateWithoutRespuestaPreguntaInput, EvidenciaUncheckedCreateWithoutRespuestaPreguntaInput> | EvidenciaCreateWithoutRespuestaPreguntaInput[] | EvidenciaUncheckedCreateWithoutRespuestaPreguntaInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutRespuestaPreguntaInput | EvidenciaCreateOrConnectWithoutRespuestaPreguntaInput[]
    createMany?: EvidenciaCreateManyRespuestaPreguntaInputEnvelope
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
  }

  export type RespuestaCuestionarioUpdateOneRequiredWithoutRespuestasNestedInput = {
    create?: XOR<RespuestaCuestionarioCreateWithoutRespuestasInput, RespuestaCuestionarioUncheckedCreateWithoutRespuestasInput>
    connectOrCreate?: RespuestaCuestionarioCreateOrConnectWithoutRespuestasInput
    upsert?: RespuestaCuestionarioUpsertWithoutRespuestasInput
    connect?: RespuestaCuestionarioWhereUniqueInput
    update?: XOR<XOR<RespuestaCuestionarioUpdateToOneWithWhereWithoutRespuestasInput, RespuestaCuestionarioUpdateWithoutRespuestasInput>, RespuestaCuestionarioUncheckedUpdateWithoutRespuestasInput>
  }

  export type PreguntaUpdateOneRequiredWithoutRespuestasNestedInput = {
    create?: XOR<PreguntaCreateWithoutRespuestasInput, PreguntaUncheckedCreateWithoutRespuestasInput>
    connectOrCreate?: PreguntaCreateOrConnectWithoutRespuestasInput
    upsert?: PreguntaUpsertWithoutRespuestasInput
    connect?: PreguntaWhereUniqueInput
    update?: XOR<XOR<PreguntaUpdateToOneWithWhereWithoutRespuestasInput, PreguntaUpdateWithoutRespuestasInput>, PreguntaUncheckedUpdateWithoutRespuestasInput>
  }

  export type EvidenciaUpdateManyWithoutRespuestaPreguntaNestedInput = {
    create?: XOR<EvidenciaCreateWithoutRespuestaPreguntaInput, EvidenciaUncheckedCreateWithoutRespuestaPreguntaInput> | EvidenciaCreateWithoutRespuestaPreguntaInput[] | EvidenciaUncheckedCreateWithoutRespuestaPreguntaInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutRespuestaPreguntaInput | EvidenciaCreateOrConnectWithoutRespuestaPreguntaInput[]
    upsert?: EvidenciaUpsertWithWhereUniqueWithoutRespuestaPreguntaInput | EvidenciaUpsertWithWhereUniqueWithoutRespuestaPreguntaInput[]
    createMany?: EvidenciaCreateManyRespuestaPreguntaInputEnvelope
    set?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    disconnect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    delete?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    update?: EvidenciaUpdateWithWhereUniqueWithoutRespuestaPreguntaInput | EvidenciaUpdateWithWhereUniqueWithoutRespuestaPreguntaInput[]
    updateMany?: EvidenciaUpdateManyWithWhereWithoutRespuestaPreguntaInput | EvidenciaUpdateManyWithWhereWithoutRespuestaPreguntaInput[]
    deleteMany?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
  }

  export type EvidenciaUncheckedUpdateManyWithoutRespuestaPreguntaNestedInput = {
    create?: XOR<EvidenciaCreateWithoutRespuestaPreguntaInput, EvidenciaUncheckedCreateWithoutRespuestaPreguntaInput> | EvidenciaCreateWithoutRespuestaPreguntaInput[] | EvidenciaUncheckedCreateWithoutRespuestaPreguntaInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutRespuestaPreguntaInput | EvidenciaCreateOrConnectWithoutRespuestaPreguntaInput[]
    upsert?: EvidenciaUpsertWithWhereUniqueWithoutRespuestaPreguntaInput | EvidenciaUpsertWithWhereUniqueWithoutRespuestaPreguntaInput[]
    createMany?: EvidenciaCreateManyRespuestaPreguntaInputEnvelope
    set?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    disconnect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    delete?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    update?: EvidenciaUpdateWithWhereUniqueWithoutRespuestaPreguntaInput | EvidenciaUpdateWithWhereUniqueWithoutRespuestaPreguntaInput[]
    updateMany?: EvidenciaUpdateManyWithWhereWithoutRespuestaPreguntaInput | EvidenciaUpdateManyWithWhereWithoutRespuestaPreguntaInput[]
    deleteMany?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
  }

  export type RespuestaPreguntaCreateNestedOneWithoutEvidenciasInput = {
    create?: XOR<RespuestaPreguntaCreateWithoutEvidenciasInput, RespuestaPreguntaUncheckedCreateWithoutEvidenciasInput>
    connectOrCreate?: RespuestaPreguntaCreateOrConnectWithoutEvidenciasInput
    connect?: RespuestaPreguntaWhereUniqueInput
  }

  export type RespuestaPreguntaUpdateOneRequiredWithoutEvidenciasNestedInput = {
    create?: XOR<RespuestaPreguntaCreateWithoutEvidenciasInput, RespuestaPreguntaUncheckedCreateWithoutEvidenciasInput>
    connectOrCreate?: RespuestaPreguntaCreateOrConnectWithoutEvidenciasInput
    upsert?: RespuestaPreguntaUpsertWithoutEvidenciasInput
    connect?: RespuestaPreguntaWhereUniqueInput
    update?: XOR<XOR<RespuestaPreguntaUpdateToOneWithWhereWithoutEvidenciasInput, RespuestaPreguntaUpdateWithoutEvidenciasInput>, RespuestaPreguntaUncheckedUpdateWithoutEvidenciasInput>
  }

  export type PreguntaCreateNestedOneWithoutHallazgosInput = {
    create?: XOR<PreguntaCreateWithoutHallazgosInput, PreguntaUncheckedCreateWithoutHallazgosInput>
    connectOrCreate?: PreguntaCreateOrConnectWithoutHallazgosInput
    connect?: PreguntaWhereUniqueInput
  }

  export type PreguntaUpdateOneRequiredWithoutHallazgosNestedInput = {
    create?: XOR<PreguntaCreateWithoutHallazgosInput, PreguntaUncheckedCreateWithoutHallazgosInput>
    connectOrCreate?: PreguntaCreateOrConnectWithoutHallazgosInput
    upsert?: PreguntaUpsertWithoutHallazgosInput
    connect?: PreguntaWhereUniqueInput
    update?: XOR<XOR<PreguntaUpdateToOneWithWhereWithoutHallazgosInput, PreguntaUpdateWithoutHallazgosInput>, PreguntaUncheckedUpdateWithoutHallazgosInput>
  }

  export type AsignacionCuestionarioCreateNestedOneWithoutMensajesChatInput = {
    create?: XOR<AsignacionCuestionarioCreateWithoutMensajesChatInput, AsignacionCuestionarioUncheckedCreateWithoutMensajesChatInput>
    connectOrCreate?: AsignacionCuestionarioCreateOrConnectWithoutMensajesChatInput
    connect?: AsignacionCuestionarioWhereUniqueInput
  }

  export type AsignacionCuestionarioUpdateOneRequiredWithoutMensajesChatNestedInput = {
    create?: XOR<AsignacionCuestionarioCreateWithoutMensajesChatInput, AsignacionCuestionarioUncheckedCreateWithoutMensajesChatInput>
    connectOrCreate?: AsignacionCuestionarioCreateOrConnectWithoutMensajesChatInput
    upsert?: AsignacionCuestionarioUpsertWithoutMensajesChatInput
    connect?: AsignacionCuestionarioWhereUniqueInput
    update?: XOR<XOR<AsignacionCuestionarioUpdateToOneWithWhereWithoutMensajesChatInput, AsignacionCuestionarioUpdateWithoutMensajesChatInput>, AsignacionCuestionarioUncheckedUpdateWithoutMensajesChatInput>
  }

  export type ProcessNodeCreateNestedManyWithoutProcesoInput = {
    create?: XOR<ProcessNodeCreateWithoutProcesoInput, ProcessNodeUncheckedCreateWithoutProcesoInput> | ProcessNodeCreateWithoutProcesoInput[] | ProcessNodeUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: ProcessNodeCreateOrConnectWithoutProcesoInput | ProcessNodeCreateOrConnectWithoutProcesoInput[]
    createMany?: ProcessNodeCreateManyProcesoInputEnvelope
    connect?: ProcessNodeWhereUniqueInput | ProcessNodeWhereUniqueInput[]
  }

  export type ProcessEdgeCreateNestedManyWithoutProcesoInput = {
    create?: XOR<ProcessEdgeCreateWithoutProcesoInput, ProcessEdgeUncheckedCreateWithoutProcesoInput> | ProcessEdgeCreateWithoutProcesoInput[] | ProcessEdgeUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: ProcessEdgeCreateOrConnectWithoutProcesoInput | ProcessEdgeCreateOrConnectWithoutProcesoInput[]
    createMany?: ProcessEdgeCreateManyProcesoInputEnvelope
    connect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
  }

  export type ObjetivoProcesoCreateNestedManyWithoutProcesoInput = {
    create?: XOR<ObjetivoProcesoCreateWithoutProcesoInput, ObjetivoProcesoUncheckedCreateWithoutProcesoInput> | ObjetivoProcesoCreateWithoutProcesoInput[] | ObjetivoProcesoUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: ObjetivoProcesoCreateOrConnectWithoutProcesoInput | ObjetivoProcesoCreateOrConnectWithoutProcesoInput[]
    createMany?: ObjetivoProcesoCreateManyProcesoInputEnvelope
    connect?: ObjetivoProcesoWhereUniqueInput | ObjetivoProcesoWhereUniqueInput[]
  }

  export type KpiProcesoCreateNestedManyWithoutProcesoInput = {
    create?: XOR<KpiProcesoCreateWithoutProcesoInput, KpiProcesoUncheckedCreateWithoutProcesoInput> | KpiProcesoCreateWithoutProcesoInput[] | KpiProcesoUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: KpiProcesoCreateOrConnectWithoutProcesoInput | KpiProcesoCreateOrConnectWithoutProcesoInput[]
    createMany?: KpiProcesoCreateManyProcesoInputEnvelope
    connect?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
  }

  export type ProcessNodeUncheckedCreateNestedManyWithoutProcesoInput = {
    create?: XOR<ProcessNodeCreateWithoutProcesoInput, ProcessNodeUncheckedCreateWithoutProcesoInput> | ProcessNodeCreateWithoutProcesoInput[] | ProcessNodeUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: ProcessNodeCreateOrConnectWithoutProcesoInput | ProcessNodeCreateOrConnectWithoutProcesoInput[]
    createMany?: ProcessNodeCreateManyProcesoInputEnvelope
    connect?: ProcessNodeWhereUniqueInput | ProcessNodeWhereUniqueInput[]
  }

  export type ProcessEdgeUncheckedCreateNestedManyWithoutProcesoInput = {
    create?: XOR<ProcessEdgeCreateWithoutProcesoInput, ProcessEdgeUncheckedCreateWithoutProcesoInput> | ProcessEdgeCreateWithoutProcesoInput[] | ProcessEdgeUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: ProcessEdgeCreateOrConnectWithoutProcesoInput | ProcessEdgeCreateOrConnectWithoutProcesoInput[]
    createMany?: ProcessEdgeCreateManyProcesoInputEnvelope
    connect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
  }

  export type ObjetivoProcesoUncheckedCreateNestedManyWithoutProcesoInput = {
    create?: XOR<ObjetivoProcesoCreateWithoutProcesoInput, ObjetivoProcesoUncheckedCreateWithoutProcesoInput> | ObjetivoProcesoCreateWithoutProcesoInput[] | ObjetivoProcesoUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: ObjetivoProcesoCreateOrConnectWithoutProcesoInput | ObjetivoProcesoCreateOrConnectWithoutProcesoInput[]
    createMany?: ObjetivoProcesoCreateManyProcesoInputEnvelope
    connect?: ObjetivoProcesoWhereUniqueInput | ObjetivoProcesoWhereUniqueInput[]
  }

  export type KpiProcesoUncheckedCreateNestedManyWithoutProcesoInput = {
    create?: XOR<KpiProcesoCreateWithoutProcesoInput, KpiProcesoUncheckedCreateWithoutProcesoInput> | KpiProcesoCreateWithoutProcesoInput[] | KpiProcesoUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: KpiProcesoCreateOrConnectWithoutProcesoInput | KpiProcesoCreateOrConnectWithoutProcesoInput[]
    createMany?: KpiProcesoCreateManyProcesoInputEnvelope
    connect?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
  }

  export type ProcessNodeUpdateManyWithoutProcesoNestedInput = {
    create?: XOR<ProcessNodeCreateWithoutProcesoInput, ProcessNodeUncheckedCreateWithoutProcesoInput> | ProcessNodeCreateWithoutProcesoInput[] | ProcessNodeUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: ProcessNodeCreateOrConnectWithoutProcesoInput | ProcessNodeCreateOrConnectWithoutProcesoInput[]
    upsert?: ProcessNodeUpsertWithWhereUniqueWithoutProcesoInput | ProcessNodeUpsertWithWhereUniqueWithoutProcesoInput[]
    createMany?: ProcessNodeCreateManyProcesoInputEnvelope
    set?: ProcessNodeWhereUniqueInput | ProcessNodeWhereUniqueInput[]
    disconnect?: ProcessNodeWhereUniqueInput | ProcessNodeWhereUniqueInput[]
    delete?: ProcessNodeWhereUniqueInput | ProcessNodeWhereUniqueInput[]
    connect?: ProcessNodeWhereUniqueInput | ProcessNodeWhereUniqueInput[]
    update?: ProcessNodeUpdateWithWhereUniqueWithoutProcesoInput | ProcessNodeUpdateWithWhereUniqueWithoutProcesoInput[]
    updateMany?: ProcessNodeUpdateManyWithWhereWithoutProcesoInput | ProcessNodeUpdateManyWithWhereWithoutProcesoInput[]
    deleteMany?: ProcessNodeScalarWhereInput | ProcessNodeScalarWhereInput[]
  }

  export type ProcessEdgeUpdateManyWithoutProcesoNestedInput = {
    create?: XOR<ProcessEdgeCreateWithoutProcesoInput, ProcessEdgeUncheckedCreateWithoutProcesoInput> | ProcessEdgeCreateWithoutProcesoInput[] | ProcessEdgeUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: ProcessEdgeCreateOrConnectWithoutProcesoInput | ProcessEdgeCreateOrConnectWithoutProcesoInput[]
    upsert?: ProcessEdgeUpsertWithWhereUniqueWithoutProcesoInput | ProcessEdgeUpsertWithWhereUniqueWithoutProcesoInput[]
    createMany?: ProcessEdgeCreateManyProcesoInputEnvelope
    set?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    disconnect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    delete?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    connect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    update?: ProcessEdgeUpdateWithWhereUniqueWithoutProcesoInput | ProcessEdgeUpdateWithWhereUniqueWithoutProcesoInput[]
    updateMany?: ProcessEdgeUpdateManyWithWhereWithoutProcesoInput | ProcessEdgeUpdateManyWithWhereWithoutProcesoInput[]
    deleteMany?: ProcessEdgeScalarWhereInput | ProcessEdgeScalarWhereInput[]
  }

  export type ObjetivoProcesoUpdateManyWithoutProcesoNestedInput = {
    create?: XOR<ObjetivoProcesoCreateWithoutProcesoInput, ObjetivoProcesoUncheckedCreateWithoutProcesoInput> | ObjetivoProcesoCreateWithoutProcesoInput[] | ObjetivoProcesoUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: ObjetivoProcesoCreateOrConnectWithoutProcesoInput | ObjetivoProcesoCreateOrConnectWithoutProcesoInput[]
    upsert?: ObjetivoProcesoUpsertWithWhereUniqueWithoutProcesoInput | ObjetivoProcesoUpsertWithWhereUniqueWithoutProcesoInput[]
    createMany?: ObjetivoProcesoCreateManyProcesoInputEnvelope
    set?: ObjetivoProcesoWhereUniqueInput | ObjetivoProcesoWhereUniqueInput[]
    disconnect?: ObjetivoProcesoWhereUniqueInput | ObjetivoProcesoWhereUniqueInput[]
    delete?: ObjetivoProcesoWhereUniqueInput | ObjetivoProcesoWhereUniqueInput[]
    connect?: ObjetivoProcesoWhereUniqueInput | ObjetivoProcesoWhereUniqueInput[]
    update?: ObjetivoProcesoUpdateWithWhereUniqueWithoutProcesoInput | ObjetivoProcesoUpdateWithWhereUniqueWithoutProcesoInput[]
    updateMany?: ObjetivoProcesoUpdateManyWithWhereWithoutProcesoInput | ObjetivoProcesoUpdateManyWithWhereWithoutProcesoInput[]
    deleteMany?: ObjetivoProcesoScalarWhereInput | ObjetivoProcesoScalarWhereInput[]
  }

  export type KpiProcesoUpdateManyWithoutProcesoNestedInput = {
    create?: XOR<KpiProcesoCreateWithoutProcesoInput, KpiProcesoUncheckedCreateWithoutProcesoInput> | KpiProcesoCreateWithoutProcesoInput[] | KpiProcesoUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: KpiProcesoCreateOrConnectWithoutProcesoInput | KpiProcesoCreateOrConnectWithoutProcesoInput[]
    upsert?: KpiProcesoUpsertWithWhereUniqueWithoutProcesoInput | KpiProcesoUpsertWithWhereUniqueWithoutProcesoInput[]
    createMany?: KpiProcesoCreateManyProcesoInputEnvelope
    set?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
    disconnect?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
    delete?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
    connect?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
    update?: KpiProcesoUpdateWithWhereUniqueWithoutProcesoInput | KpiProcesoUpdateWithWhereUniqueWithoutProcesoInput[]
    updateMany?: KpiProcesoUpdateManyWithWhereWithoutProcesoInput | KpiProcesoUpdateManyWithWhereWithoutProcesoInput[]
    deleteMany?: KpiProcesoScalarWhereInput | KpiProcesoScalarWhereInput[]
  }

  export type ProcessNodeUncheckedUpdateManyWithoutProcesoNestedInput = {
    create?: XOR<ProcessNodeCreateWithoutProcesoInput, ProcessNodeUncheckedCreateWithoutProcesoInput> | ProcessNodeCreateWithoutProcesoInput[] | ProcessNodeUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: ProcessNodeCreateOrConnectWithoutProcesoInput | ProcessNodeCreateOrConnectWithoutProcesoInput[]
    upsert?: ProcessNodeUpsertWithWhereUniqueWithoutProcesoInput | ProcessNodeUpsertWithWhereUniqueWithoutProcesoInput[]
    createMany?: ProcessNodeCreateManyProcesoInputEnvelope
    set?: ProcessNodeWhereUniqueInput | ProcessNodeWhereUniqueInput[]
    disconnect?: ProcessNodeWhereUniqueInput | ProcessNodeWhereUniqueInput[]
    delete?: ProcessNodeWhereUniqueInput | ProcessNodeWhereUniqueInput[]
    connect?: ProcessNodeWhereUniqueInput | ProcessNodeWhereUniqueInput[]
    update?: ProcessNodeUpdateWithWhereUniqueWithoutProcesoInput | ProcessNodeUpdateWithWhereUniqueWithoutProcesoInput[]
    updateMany?: ProcessNodeUpdateManyWithWhereWithoutProcesoInput | ProcessNodeUpdateManyWithWhereWithoutProcesoInput[]
    deleteMany?: ProcessNodeScalarWhereInput | ProcessNodeScalarWhereInput[]
  }

  export type ProcessEdgeUncheckedUpdateManyWithoutProcesoNestedInput = {
    create?: XOR<ProcessEdgeCreateWithoutProcesoInput, ProcessEdgeUncheckedCreateWithoutProcesoInput> | ProcessEdgeCreateWithoutProcesoInput[] | ProcessEdgeUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: ProcessEdgeCreateOrConnectWithoutProcesoInput | ProcessEdgeCreateOrConnectWithoutProcesoInput[]
    upsert?: ProcessEdgeUpsertWithWhereUniqueWithoutProcesoInput | ProcessEdgeUpsertWithWhereUniqueWithoutProcesoInput[]
    createMany?: ProcessEdgeCreateManyProcesoInputEnvelope
    set?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    disconnect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    delete?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    connect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    update?: ProcessEdgeUpdateWithWhereUniqueWithoutProcesoInput | ProcessEdgeUpdateWithWhereUniqueWithoutProcesoInput[]
    updateMany?: ProcessEdgeUpdateManyWithWhereWithoutProcesoInput | ProcessEdgeUpdateManyWithWhereWithoutProcesoInput[]
    deleteMany?: ProcessEdgeScalarWhereInput | ProcessEdgeScalarWhereInput[]
  }

  export type ObjetivoProcesoUncheckedUpdateManyWithoutProcesoNestedInput = {
    create?: XOR<ObjetivoProcesoCreateWithoutProcesoInput, ObjetivoProcesoUncheckedCreateWithoutProcesoInput> | ObjetivoProcesoCreateWithoutProcesoInput[] | ObjetivoProcesoUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: ObjetivoProcesoCreateOrConnectWithoutProcesoInput | ObjetivoProcesoCreateOrConnectWithoutProcesoInput[]
    upsert?: ObjetivoProcesoUpsertWithWhereUniqueWithoutProcesoInput | ObjetivoProcesoUpsertWithWhereUniqueWithoutProcesoInput[]
    createMany?: ObjetivoProcesoCreateManyProcesoInputEnvelope
    set?: ObjetivoProcesoWhereUniqueInput | ObjetivoProcesoWhereUniqueInput[]
    disconnect?: ObjetivoProcesoWhereUniqueInput | ObjetivoProcesoWhereUniqueInput[]
    delete?: ObjetivoProcesoWhereUniqueInput | ObjetivoProcesoWhereUniqueInput[]
    connect?: ObjetivoProcesoWhereUniqueInput | ObjetivoProcesoWhereUniqueInput[]
    update?: ObjetivoProcesoUpdateWithWhereUniqueWithoutProcesoInput | ObjetivoProcesoUpdateWithWhereUniqueWithoutProcesoInput[]
    updateMany?: ObjetivoProcesoUpdateManyWithWhereWithoutProcesoInput | ObjetivoProcesoUpdateManyWithWhereWithoutProcesoInput[]
    deleteMany?: ObjetivoProcesoScalarWhereInput | ObjetivoProcesoScalarWhereInput[]
  }

  export type KpiProcesoUncheckedUpdateManyWithoutProcesoNestedInput = {
    create?: XOR<KpiProcesoCreateWithoutProcesoInput, KpiProcesoUncheckedCreateWithoutProcesoInput> | KpiProcesoCreateWithoutProcesoInput[] | KpiProcesoUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: KpiProcesoCreateOrConnectWithoutProcesoInput | KpiProcesoCreateOrConnectWithoutProcesoInput[]
    upsert?: KpiProcesoUpsertWithWhereUniqueWithoutProcesoInput | KpiProcesoUpsertWithWhereUniqueWithoutProcesoInput[]
    createMany?: KpiProcesoCreateManyProcesoInputEnvelope
    set?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
    disconnect?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
    delete?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
    connect?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
    update?: KpiProcesoUpdateWithWhereUniqueWithoutProcesoInput | KpiProcesoUpdateWithWhereUniqueWithoutProcesoInput[]
    updateMany?: KpiProcesoUpdateManyWithWhereWithoutProcesoInput | KpiProcesoUpdateManyWithWhereWithoutProcesoInput[]
    deleteMany?: KpiProcesoScalarWhereInput | KpiProcesoScalarWhereInput[]
  }

  export type ProcesoCreateNestedOneWithoutNodosInput = {
    create?: XOR<ProcesoCreateWithoutNodosInput, ProcesoUncheckedCreateWithoutNodosInput>
    connectOrCreate?: ProcesoCreateOrConnectWithoutNodosInput
    connect?: ProcesoWhereUniqueInput
  }

  export type ProcessEdgeCreateNestedManyWithoutSourceNodeInput = {
    create?: XOR<ProcessEdgeCreateWithoutSourceNodeInput, ProcessEdgeUncheckedCreateWithoutSourceNodeInput> | ProcessEdgeCreateWithoutSourceNodeInput[] | ProcessEdgeUncheckedCreateWithoutSourceNodeInput[]
    connectOrCreate?: ProcessEdgeCreateOrConnectWithoutSourceNodeInput | ProcessEdgeCreateOrConnectWithoutSourceNodeInput[]
    createMany?: ProcessEdgeCreateManySourceNodeInputEnvelope
    connect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
  }

  export type ProcessEdgeCreateNestedManyWithoutTargetNodeInput = {
    create?: XOR<ProcessEdgeCreateWithoutTargetNodeInput, ProcessEdgeUncheckedCreateWithoutTargetNodeInput> | ProcessEdgeCreateWithoutTargetNodeInput[] | ProcessEdgeUncheckedCreateWithoutTargetNodeInput[]
    connectOrCreate?: ProcessEdgeCreateOrConnectWithoutTargetNodeInput | ProcessEdgeCreateOrConnectWithoutTargetNodeInput[]
    createMany?: ProcessEdgeCreateManyTargetNodeInputEnvelope
    connect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
  }

  export type KpiHistoricoCreateNestedManyWithoutNodoInput = {
    create?: XOR<KpiHistoricoCreateWithoutNodoInput, KpiHistoricoUncheckedCreateWithoutNodoInput> | KpiHistoricoCreateWithoutNodoInput[] | KpiHistoricoUncheckedCreateWithoutNodoInput[]
    connectOrCreate?: KpiHistoricoCreateOrConnectWithoutNodoInput | KpiHistoricoCreateOrConnectWithoutNodoInput[]
    createMany?: KpiHistoricoCreateManyNodoInputEnvelope
    connect?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
  }

  export type ProcessEdgeUncheckedCreateNestedManyWithoutSourceNodeInput = {
    create?: XOR<ProcessEdgeCreateWithoutSourceNodeInput, ProcessEdgeUncheckedCreateWithoutSourceNodeInput> | ProcessEdgeCreateWithoutSourceNodeInput[] | ProcessEdgeUncheckedCreateWithoutSourceNodeInput[]
    connectOrCreate?: ProcessEdgeCreateOrConnectWithoutSourceNodeInput | ProcessEdgeCreateOrConnectWithoutSourceNodeInput[]
    createMany?: ProcessEdgeCreateManySourceNodeInputEnvelope
    connect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
  }

  export type ProcessEdgeUncheckedCreateNestedManyWithoutTargetNodeInput = {
    create?: XOR<ProcessEdgeCreateWithoutTargetNodeInput, ProcessEdgeUncheckedCreateWithoutTargetNodeInput> | ProcessEdgeCreateWithoutTargetNodeInput[] | ProcessEdgeUncheckedCreateWithoutTargetNodeInput[]
    connectOrCreate?: ProcessEdgeCreateOrConnectWithoutTargetNodeInput | ProcessEdgeCreateOrConnectWithoutTargetNodeInput[]
    createMany?: ProcessEdgeCreateManyTargetNodeInputEnvelope
    connect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
  }

  export type KpiHistoricoUncheckedCreateNestedManyWithoutNodoInput = {
    create?: XOR<KpiHistoricoCreateWithoutNodoInput, KpiHistoricoUncheckedCreateWithoutNodoInput> | KpiHistoricoCreateWithoutNodoInput[] | KpiHistoricoUncheckedCreateWithoutNodoInput[]
    connectOrCreate?: KpiHistoricoCreateOrConnectWithoutNodoInput | KpiHistoricoCreateOrConnectWithoutNodoInput[]
    createMany?: KpiHistoricoCreateManyNodoInputEnvelope
    connect?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
  }

  export type ProcesoUpdateOneRequiredWithoutNodosNestedInput = {
    create?: XOR<ProcesoCreateWithoutNodosInput, ProcesoUncheckedCreateWithoutNodosInput>
    connectOrCreate?: ProcesoCreateOrConnectWithoutNodosInput
    upsert?: ProcesoUpsertWithoutNodosInput
    connect?: ProcesoWhereUniqueInput
    update?: XOR<XOR<ProcesoUpdateToOneWithWhereWithoutNodosInput, ProcesoUpdateWithoutNodosInput>, ProcesoUncheckedUpdateWithoutNodosInput>
  }

  export type ProcessEdgeUpdateManyWithoutSourceNodeNestedInput = {
    create?: XOR<ProcessEdgeCreateWithoutSourceNodeInput, ProcessEdgeUncheckedCreateWithoutSourceNodeInput> | ProcessEdgeCreateWithoutSourceNodeInput[] | ProcessEdgeUncheckedCreateWithoutSourceNodeInput[]
    connectOrCreate?: ProcessEdgeCreateOrConnectWithoutSourceNodeInput | ProcessEdgeCreateOrConnectWithoutSourceNodeInput[]
    upsert?: ProcessEdgeUpsertWithWhereUniqueWithoutSourceNodeInput | ProcessEdgeUpsertWithWhereUniqueWithoutSourceNodeInput[]
    createMany?: ProcessEdgeCreateManySourceNodeInputEnvelope
    set?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    disconnect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    delete?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    connect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    update?: ProcessEdgeUpdateWithWhereUniqueWithoutSourceNodeInput | ProcessEdgeUpdateWithWhereUniqueWithoutSourceNodeInput[]
    updateMany?: ProcessEdgeUpdateManyWithWhereWithoutSourceNodeInput | ProcessEdgeUpdateManyWithWhereWithoutSourceNodeInput[]
    deleteMany?: ProcessEdgeScalarWhereInput | ProcessEdgeScalarWhereInput[]
  }

  export type ProcessEdgeUpdateManyWithoutTargetNodeNestedInput = {
    create?: XOR<ProcessEdgeCreateWithoutTargetNodeInput, ProcessEdgeUncheckedCreateWithoutTargetNodeInput> | ProcessEdgeCreateWithoutTargetNodeInput[] | ProcessEdgeUncheckedCreateWithoutTargetNodeInput[]
    connectOrCreate?: ProcessEdgeCreateOrConnectWithoutTargetNodeInput | ProcessEdgeCreateOrConnectWithoutTargetNodeInput[]
    upsert?: ProcessEdgeUpsertWithWhereUniqueWithoutTargetNodeInput | ProcessEdgeUpsertWithWhereUniqueWithoutTargetNodeInput[]
    createMany?: ProcessEdgeCreateManyTargetNodeInputEnvelope
    set?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    disconnect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    delete?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    connect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    update?: ProcessEdgeUpdateWithWhereUniqueWithoutTargetNodeInput | ProcessEdgeUpdateWithWhereUniqueWithoutTargetNodeInput[]
    updateMany?: ProcessEdgeUpdateManyWithWhereWithoutTargetNodeInput | ProcessEdgeUpdateManyWithWhereWithoutTargetNodeInput[]
    deleteMany?: ProcessEdgeScalarWhereInput | ProcessEdgeScalarWhereInput[]
  }

  export type KpiHistoricoUpdateManyWithoutNodoNestedInput = {
    create?: XOR<KpiHistoricoCreateWithoutNodoInput, KpiHistoricoUncheckedCreateWithoutNodoInput> | KpiHistoricoCreateWithoutNodoInput[] | KpiHistoricoUncheckedCreateWithoutNodoInput[]
    connectOrCreate?: KpiHistoricoCreateOrConnectWithoutNodoInput | KpiHistoricoCreateOrConnectWithoutNodoInput[]
    upsert?: KpiHistoricoUpsertWithWhereUniqueWithoutNodoInput | KpiHistoricoUpsertWithWhereUniqueWithoutNodoInput[]
    createMany?: KpiHistoricoCreateManyNodoInputEnvelope
    set?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
    disconnect?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
    delete?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
    connect?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
    update?: KpiHistoricoUpdateWithWhereUniqueWithoutNodoInput | KpiHistoricoUpdateWithWhereUniqueWithoutNodoInput[]
    updateMany?: KpiHistoricoUpdateManyWithWhereWithoutNodoInput | KpiHistoricoUpdateManyWithWhereWithoutNodoInput[]
    deleteMany?: KpiHistoricoScalarWhereInput | KpiHistoricoScalarWhereInput[]
  }

  export type ProcessEdgeUncheckedUpdateManyWithoutSourceNodeNestedInput = {
    create?: XOR<ProcessEdgeCreateWithoutSourceNodeInput, ProcessEdgeUncheckedCreateWithoutSourceNodeInput> | ProcessEdgeCreateWithoutSourceNodeInput[] | ProcessEdgeUncheckedCreateWithoutSourceNodeInput[]
    connectOrCreate?: ProcessEdgeCreateOrConnectWithoutSourceNodeInput | ProcessEdgeCreateOrConnectWithoutSourceNodeInput[]
    upsert?: ProcessEdgeUpsertWithWhereUniqueWithoutSourceNodeInput | ProcessEdgeUpsertWithWhereUniqueWithoutSourceNodeInput[]
    createMany?: ProcessEdgeCreateManySourceNodeInputEnvelope
    set?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    disconnect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    delete?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    connect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    update?: ProcessEdgeUpdateWithWhereUniqueWithoutSourceNodeInput | ProcessEdgeUpdateWithWhereUniqueWithoutSourceNodeInput[]
    updateMany?: ProcessEdgeUpdateManyWithWhereWithoutSourceNodeInput | ProcessEdgeUpdateManyWithWhereWithoutSourceNodeInput[]
    deleteMany?: ProcessEdgeScalarWhereInput | ProcessEdgeScalarWhereInput[]
  }

  export type ProcessEdgeUncheckedUpdateManyWithoutTargetNodeNestedInput = {
    create?: XOR<ProcessEdgeCreateWithoutTargetNodeInput, ProcessEdgeUncheckedCreateWithoutTargetNodeInput> | ProcessEdgeCreateWithoutTargetNodeInput[] | ProcessEdgeUncheckedCreateWithoutTargetNodeInput[]
    connectOrCreate?: ProcessEdgeCreateOrConnectWithoutTargetNodeInput | ProcessEdgeCreateOrConnectWithoutTargetNodeInput[]
    upsert?: ProcessEdgeUpsertWithWhereUniqueWithoutTargetNodeInput | ProcessEdgeUpsertWithWhereUniqueWithoutTargetNodeInput[]
    createMany?: ProcessEdgeCreateManyTargetNodeInputEnvelope
    set?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    disconnect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    delete?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    connect?: ProcessEdgeWhereUniqueInput | ProcessEdgeWhereUniqueInput[]
    update?: ProcessEdgeUpdateWithWhereUniqueWithoutTargetNodeInput | ProcessEdgeUpdateWithWhereUniqueWithoutTargetNodeInput[]
    updateMany?: ProcessEdgeUpdateManyWithWhereWithoutTargetNodeInput | ProcessEdgeUpdateManyWithWhereWithoutTargetNodeInput[]
    deleteMany?: ProcessEdgeScalarWhereInput | ProcessEdgeScalarWhereInput[]
  }

  export type KpiHistoricoUncheckedUpdateManyWithoutNodoNestedInput = {
    create?: XOR<KpiHistoricoCreateWithoutNodoInput, KpiHistoricoUncheckedCreateWithoutNodoInput> | KpiHistoricoCreateWithoutNodoInput[] | KpiHistoricoUncheckedCreateWithoutNodoInput[]
    connectOrCreate?: KpiHistoricoCreateOrConnectWithoutNodoInput | KpiHistoricoCreateOrConnectWithoutNodoInput[]
    upsert?: KpiHistoricoUpsertWithWhereUniqueWithoutNodoInput | KpiHistoricoUpsertWithWhereUniqueWithoutNodoInput[]
    createMany?: KpiHistoricoCreateManyNodoInputEnvelope
    set?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
    disconnect?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
    delete?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
    connect?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
    update?: KpiHistoricoUpdateWithWhereUniqueWithoutNodoInput | KpiHistoricoUpdateWithWhereUniqueWithoutNodoInput[]
    updateMany?: KpiHistoricoUpdateManyWithWhereWithoutNodoInput | KpiHistoricoUpdateManyWithWhereWithoutNodoInput[]
    deleteMany?: KpiHistoricoScalarWhereInput | KpiHistoricoScalarWhereInput[]
  }

  export type ProcesoCreateNestedOneWithoutEdgesInput = {
    create?: XOR<ProcesoCreateWithoutEdgesInput, ProcesoUncheckedCreateWithoutEdgesInput>
    connectOrCreate?: ProcesoCreateOrConnectWithoutEdgesInput
    connect?: ProcesoWhereUniqueInput
  }

  export type ProcessNodeCreateNestedOneWithoutEdgesFromInput = {
    create?: XOR<ProcessNodeCreateWithoutEdgesFromInput, ProcessNodeUncheckedCreateWithoutEdgesFromInput>
    connectOrCreate?: ProcessNodeCreateOrConnectWithoutEdgesFromInput
    connect?: ProcessNodeWhereUniqueInput
  }

  export type ProcessNodeCreateNestedOneWithoutEdgesToInput = {
    create?: XOR<ProcessNodeCreateWithoutEdgesToInput, ProcessNodeUncheckedCreateWithoutEdgesToInput>
    connectOrCreate?: ProcessNodeCreateOrConnectWithoutEdgesToInput
    connect?: ProcessNodeWhereUniqueInput
  }

  export type ProcesoUpdateOneRequiredWithoutEdgesNestedInput = {
    create?: XOR<ProcesoCreateWithoutEdgesInput, ProcesoUncheckedCreateWithoutEdgesInput>
    connectOrCreate?: ProcesoCreateOrConnectWithoutEdgesInput
    upsert?: ProcesoUpsertWithoutEdgesInput
    connect?: ProcesoWhereUniqueInput
    update?: XOR<XOR<ProcesoUpdateToOneWithWhereWithoutEdgesInput, ProcesoUpdateWithoutEdgesInput>, ProcesoUncheckedUpdateWithoutEdgesInput>
  }

  export type ProcessNodeUpdateOneRequiredWithoutEdgesFromNestedInput = {
    create?: XOR<ProcessNodeCreateWithoutEdgesFromInput, ProcessNodeUncheckedCreateWithoutEdgesFromInput>
    connectOrCreate?: ProcessNodeCreateOrConnectWithoutEdgesFromInput
    upsert?: ProcessNodeUpsertWithoutEdgesFromInput
    connect?: ProcessNodeWhereUniqueInput
    update?: XOR<XOR<ProcessNodeUpdateToOneWithWhereWithoutEdgesFromInput, ProcessNodeUpdateWithoutEdgesFromInput>, ProcessNodeUncheckedUpdateWithoutEdgesFromInput>
  }

  export type ProcessNodeUpdateOneRequiredWithoutEdgesToNestedInput = {
    create?: XOR<ProcessNodeCreateWithoutEdgesToInput, ProcessNodeUncheckedCreateWithoutEdgesToInput>
    connectOrCreate?: ProcessNodeCreateOrConnectWithoutEdgesToInput
    upsert?: ProcessNodeUpsertWithoutEdgesToInput
    connect?: ProcessNodeWhereUniqueInput
    update?: XOR<XOR<ProcessNodeUpdateToOneWithWhereWithoutEdgesToInput, ProcessNodeUpdateWithoutEdgesToInput>, ProcessNodeUncheckedUpdateWithoutEdgesToInput>
  }

  export type ProcesoCreateNestedOneWithoutObjetivosInput = {
    create?: XOR<ProcesoCreateWithoutObjetivosInput, ProcesoUncheckedCreateWithoutObjetivosInput>
    connectOrCreate?: ProcesoCreateOrConnectWithoutObjetivosInput
    connect?: ProcesoWhereUniqueInput
  }

  export type KpiProcesoCreateNestedManyWithoutObjetivoInput = {
    create?: XOR<KpiProcesoCreateWithoutObjetivoInput, KpiProcesoUncheckedCreateWithoutObjetivoInput> | KpiProcesoCreateWithoutObjetivoInput[] | KpiProcesoUncheckedCreateWithoutObjetivoInput[]
    connectOrCreate?: KpiProcesoCreateOrConnectWithoutObjetivoInput | KpiProcesoCreateOrConnectWithoutObjetivoInput[]
    createMany?: KpiProcesoCreateManyObjetivoInputEnvelope
    connect?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
  }

  export type KpiProcesoUncheckedCreateNestedManyWithoutObjetivoInput = {
    create?: XOR<KpiProcesoCreateWithoutObjetivoInput, KpiProcesoUncheckedCreateWithoutObjetivoInput> | KpiProcesoCreateWithoutObjetivoInput[] | KpiProcesoUncheckedCreateWithoutObjetivoInput[]
    connectOrCreate?: KpiProcesoCreateOrConnectWithoutObjetivoInput | KpiProcesoCreateOrConnectWithoutObjetivoInput[]
    createMany?: KpiProcesoCreateManyObjetivoInputEnvelope
    connect?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
  }

  export type ProcesoUpdateOneRequiredWithoutObjetivosNestedInput = {
    create?: XOR<ProcesoCreateWithoutObjetivosInput, ProcesoUncheckedCreateWithoutObjetivosInput>
    connectOrCreate?: ProcesoCreateOrConnectWithoutObjetivosInput
    upsert?: ProcesoUpsertWithoutObjetivosInput
    connect?: ProcesoWhereUniqueInput
    update?: XOR<XOR<ProcesoUpdateToOneWithWhereWithoutObjetivosInput, ProcesoUpdateWithoutObjetivosInput>, ProcesoUncheckedUpdateWithoutObjetivosInput>
  }

  export type KpiProcesoUpdateManyWithoutObjetivoNestedInput = {
    create?: XOR<KpiProcesoCreateWithoutObjetivoInput, KpiProcesoUncheckedCreateWithoutObjetivoInput> | KpiProcesoCreateWithoutObjetivoInput[] | KpiProcesoUncheckedCreateWithoutObjetivoInput[]
    connectOrCreate?: KpiProcesoCreateOrConnectWithoutObjetivoInput | KpiProcesoCreateOrConnectWithoutObjetivoInput[]
    upsert?: KpiProcesoUpsertWithWhereUniqueWithoutObjetivoInput | KpiProcesoUpsertWithWhereUniqueWithoutObjetivoInput[]
    createMany?: KpiProcesoCreateManyObjetivoInputEnvelope
    set?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
    disconnect?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
    delete?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
    connect?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
    update?: KpiProcesoUpdateWithWhereUniqueWithoutObjetivoInput | KpiProcesoUpdateWithWhereUniqueWithoutObjetivoInput[]
    updateMany?: KpiProcesoUpdateManyWithWhereWithoutObjetivoInput | KpiProcesoUpdateManyWithWhereWithoutObjetivoInput[]
    deleteMany?: KpiProcesoScalarWhereInput | KpiProcesoScalarWhereInput[]
  }

  export type KpiProcesoUncheckedUpdateManyWithoutObjetivoNestedInput = {
    create?: XOR<KpiProcesoCreateWithoutObjetivoInput, KpiProcesoUncheckedCreateWithoutObjetivoInput> | KpiProcesoCreateWithoutObjetivoInput[] | KpiProcesoUncheckedCreateWithoutObjetivoInput[]
    connectOrCreate?: KpiProcesoCreateOrConnectWithoutObjetivoInput | KpiProcesoCreateOrConnectWithoutObjetivoInput[]
    upsert?: KpiProcesoUpsertWithWhereUniqueWithoutObjetivoInput | KpiProcesoUpsertWithWhereUniqueWithoutObjetivoInput[]
    createMany?: KpiProcesoCreateManyObjetivoInputEnvelope
    set?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
    disconnect?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
    delete?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
    connect?: KpiProcesoWhereUniqueInput | KpiProcesoWhereUniqueInput[]
    update?: KpiProcesoUpdateWithWhereUniqueWithoutObjetivoInput | KpiProcesoUpdateWithWhereUniqueWithoutObjetivoInput[]
    updateMany?: KpiProcesoUpdateManyWithWhereWithoutObjetivoInput | KpiProcesoUpdateManyWithWhereWithoutObjetivoInput[]
    deleteMany?: KpiProcesoScalarWhereInput | KpiProcesoScalarWhereInput[]
  }

  export type ProcesoCreateNestedOneWithoutKpisInput = {
    create?: XOR<ProcesoCreateWithoutKpisInput, ProcesoUncheckedCreateWithoutKpisInput>
    connectOrCreate?: ProcesoCreateOrConnectWithoutKpisInput
    connect?: ProcesoWhereUniqueInput
  }

  export type ObjetivoProcesoCreateNestedOneWithoutKpisInput = {
    create?: XOR<ObjetivoProcesoCreateWithoutKpisInput, ObjetivoProcesoUncheckedCreateWithoutKpisInput>
    connectOrCreate?: ObjetivoProcesoCreateOrConnectWithoutKpisInput
    connect?: ObjetivoProcesoWhereUniqueInput
  }

  export type KpiHistoricoCreateNestedManyWithoutKpiInput = {
    create?: XOR<KpiHistoricoCreateWithoutKpiInput, KpiHistoricoUncheckedCreateWithoutKpiInput> | KpiHistoricoCreateWithoutKpiInput[] | KpiHistoricoUncheckedCreateWithoutKpiInput[]
    connectOrCreate?: KpiHistoricoCreateOrConnectWithoutKpiInput | KpiHistoricoCreateOrConnectWithoutKpiInput[]
    createMany?: KpiHistoricoCreateManyKpiInputEnvelope
    connect?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
  }

  export type KpiHistoricoUncheckedCreateNestedManyWithoutKpiInput = {
    create?: XOR<KpiHistoricoCreateWithoutKpiInput, KpiHistoricoUncheckedCreateWithoutKpiInput> | KpiHistoricoCreateWithoutKpiInput[] | KpiHistoricoUncheckedCreateWithoutKpiInput[]
    connectOrCreate?: KpiHistoricoCreateOrConnectWithoutKpiInput | KpiHistoricoCreateOrConnectWithoutKpiInput[]
    createMany?: KpiHistoricoCreateManyKpiInputEnvelope
    connect?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProcesoUpdateOneRequiredWithoutKpisNestedInput = {
    create?: XOR<ProcesoCreateWithoutKpisInput, ProcesoUncheckedCreateWithoutKpisInput>
    connectOrCreate?: ProcesoCreateOrConnectWithoutKpisInput
    upsert?: ProcesoUpsertWithoutKpisInput
    connect?: ProcesoWhereUniqueInput
    update?: XOR<XOR<ProcesoUpdateToOneWithWhereWithoutKpisInput, ProcesoUpdateWithoutKpisInput>, ProcesoUncheckedUpdateWithoutKpisInput>
  }

  export type ObjetivoProcesoUpdateOneWithoutKpisNestedInput = {
    create?: XOR<ObjetivoProcesoCreateWithoutKpisInput, ObjetivoProcesoUncheckedCreateWithoutKpisInput>
    connectOrCreate?: ObjetivoProcesoCreateOrConnectWithoutKpisInput
    upsert?: ObjetivoProcesoUpsertWithoutKpisInput
    disconnect?: ObjetivoProcesoWhereInput | boolean
    delete?: ObjetivoProcesoWhereInput | boolean
    connect?: ObjetivoProcesoWhereUniqueInput
    update?: XOR<XOR<ObjetivoProcesoUpdateToOneWithWhereWithoutKpisInput, ObjetivoProcesoUpdateWithoutKpisInput>, ObjetivoProcesoUncheckedUpdateWithoutKpisInput>
  }

  export type KpiHistoricoUpdateManyWithoutKpiNestedInput = {
    create?: XOR<KpiHistoricoCreateWithoutKpiInput, KpiHistoricoUncheckedCreateWithoutKpiInput> | KpiHistoricoCreateWithoutKpiInput[] | KpiHistoricoUncheckedCreateWithoutKpiInput[]
    connectOrCreate?: KpiHistoricoCreateOrConnectWithoutKpiInput | KpiHistoricoCreateOrConnectWithoutKpiInput[]
    upsert?: KpiHistoricoUpsertWithWhereUniqueWithoutKpiInput | KpiHistoricoUpsertWithWhereUniqueWithoutKpiInput[]
    createMany?: KpiHistoricoCreateManyKpiInputEnvelope
    set?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
    disconnect?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
    delete?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
    connect?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
    update?: KpiHistoricoUpdateWithWhereUniqueWithoutKpiInput | KpiHistoricoUpdateWithWhereUniqueWithoutKpiInput[]
    updateMany?: KpiHistoricoUpdateManyWithWhereWithoutKpiInput | KpiHistoricoUpdateManyWithWhereWithoutKpiInput[]
    deleteMany?: KpiHistoricoScalarWhereInput | KpiHistoricoScalarWhereInput[]
  }

  export type KpiHistoricoUncheckedUpdateManyWithoutKpiNestedInput = {
    create?: XOR<KpiHistoricoCreateWithoutKpiInput, KpiHistoricoUncheckedCreateWithoutKpiInput> | KpiHistoricoCreateWithoutKpiInput[] | KpiHistoricoUncheckedCreateWithoutKpiInput[]
    connectOrCreate?: KpiHistoricoCreateOrConnectWithoutKpiInput | KpiHistoricoCreateOrConnectWithoutKpiInput[]
    upsert?: KpiHistoricoUpsertWithWhereUniqueWithoutKpiInput | KpiHistoricoUpsertWithWhereUniqueWithoutKpiInput[]
    createMany?: KpiHistoricoCreateManyKpiInputEnvelope
    set?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
    disconnect?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
    delete?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
    connect?: KpiHistoricoWhereUniqueInput | KpiHistoricoWhereUniqueInput[]
    update?: KpiHistoricoUpdateWithWhereUniqueWithoutKpiInput | KpiHistoricoUpdateWithWhereUniqueWithoutKpiInput[]
    updateMany?: KpiHistoricoUpdateManyWithWhereWithoutKpiInput | KpiHistoricoUpdateManyWithWhereWithoutKpiInput[]
    deleteMany?: KpiHistoricoScalarWhereInput | KpiHistoricoScalarWhereInput[]
  }

  export type KpiProcesoCreateNestedOneWithoutHistoricoInput = {
    create?: XOR<KpiProcesoCreateWithoutHistoricoInput, KpiProcesoUncheckedCreateWithoutHistoricoInput>
    connectOrCreate?: KpiProcesoCreateOrConnectWithoutHistoricoInput
    connect?: KpiProcesoWhereUniqueInput
  }

  export type ProcessNodeCreateNestedOneWithoutKpiHistoricoInput = {
    create?: XOR<ProcessNodeCreateWithoutKpiHistoricoInput, ProcessNodeUncheckedCreateWithoutKpiHistoricoInput>
    connectOrCreate?: ProcessNodeCreateOrConnectWithoutKpiHistoricoInput
    connect?: ProcessNodeWhereUniqueInput
  }

  export type KpiProcesoUpdateOneRequiredWithoutHistoricoNestedInput = {
    create?: XOR<KpiProcesoCreateWithoutHistoricoInput, KpiProcesoUncheckedCreateWithoutHistoricoInput>
    connectOrCreate?: KpiProcesoCreateOrConnectWithoutHistoricoInput
    upsert?: KpiProcesoUpsertWithoutHistoricoInput
    connect?: KpiProcesoWhereUniqueInput
    update?: XOR<XOR<KpiProcesoUpdateToOneWithWhereWithoutHistoricoInput, KpiProcesoUpdateWithoutHistoricoInput>, KpiProcesoUncheckedUpdateWithoutHistoricoInput>
  }

  export type ProcessNodeUpdateOneWithoutKpiHistoricoNestedInput = {
    create?: XOR<ProcessNodeCreateWithoutKpiHistoricoInput, ProcessNodeUncheckedCreateWithoutKpiHistoricoInput>
    connectOrCreate?: ProcessNodeCreateOrConnectWithoutKpiHistoricoInput
    upsert?: ProcessNodeUpsertWithoutKpiHistoricoInput
    disconnect?: ProcessNodeWhereInput | boolean
    delete?: ProcessNodeWhereInput | boolean
    connect?: ProcessNodeWhereUniqueInput
    update?: XOR<XOR<ProcessNodeUpdateToOneWithWhereWithoutKpiHistoricoInput, ProcessNodeUpdateWithoutKpiHistoricoInput>, ProcessNodeUncheckedUpdateWithoutKpiHistoricoInput>
  }

  export type DashboardWidgetCreateNestedManyWithoutDashboardInput = {
    create?: XOR<DashboardWidgetCreateWithoutDashboardInput, DashboardWidgetUncheckedCreateWithoutDashboardInput> | DashboardWidgetCreateWithoutDashboardInput[] | DashboardWidgetUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: DashboardWidgetCreateOrConnectWithoutDashboardInput | DashboardWidgetCreateOrConnectWithoutDashboardInput[]
    createMany?: DashboardWidgetCreateManyDashboardInputEnvelope
    connect?: DashboardWidgetWhereUniqueInput | DashboardWidgetWhereUniqueInput[]
  }

  export type DashboardWidgetUncheckedCreateNestedManyWithoutDashboardInput = {
    create?: XOR<DashboardWidgetCreateWithoutDashboardInput, DashboardWidgetUncheckedCreateWithoutDashboardInput> | DashboardWidgetCreateWithoutDashboardInput[] | DashboardWidgetUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: DashboardWidgetCreateOrConnectWithoutDashboardInput | DashboardWidgetCreateOrConnectWithoutDashboardInput[]
    createMany?: DashboardWidgetCreateManyDashboardInputEnvelope
    connect?: DashboardWidgetWhereUniqueInput | DashboardWidgetWhereUniqueInput[]
  }

  export type DashboardWidgetUpdateManyWithoutDashboardNestedInput = {
    create?: XOR<DashboardWidgetCreateWithoutDashboardInput, DashboardWidgetUncheckedCreateWithoutDashboardInput> | DashboardWidgetCreateWithoutDashboardInput[] | DashboardWidgetUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: DashboardWidgetCreateOrConnectWithoutDashboardInput | DashboardWidgetCreateOrConnectWithoutDashboardInput[]
    upsert?: DashboardWidgetUpsertWithWhereUniqueWithoutDashboardInput | DashboardWidgetUpsertWithWhereUniqueWithoutDashboardInput[]
    createMany?: DashboardWidgetCreateManyDashboardInputEnvelope
    set?: DashboardWidgetWhereUniqueInput | DashboardWidgetWhereUniqueInput[]
    disconnect?: DashboardWidgetWhereUniqueInput | DashboardWidgetWhereUniqueInput[]
    delete?: DashboardWidgetWhereUniqueInput | DashboardWidgetWhereUniqueInput[]
    connect?: DashboardWidgetWhereUniqueInput | DashboardWidgetWhereUniqueInput[]
    update?: DashboardWidgetUpdateWithWhereUniqueWithoutDashboardInput | DashboardWidgetUpdateWithWhereUniqueWithoutDashboardInput[]
    updateMany?: DashboardWidgetUpdateManyWithWhereWithoutDashboardInput | DashboardWidgetUpdateManyWithWhereWithoutDashboardInput[]
    deleteMany?: DashboardWidgetScalarWhereInput | DashboardWidgetScalarWhereInput[]
  }

  export type DashboardWidgetUncheckedUpdateManyWithoutDashboardNestedInput = {
    create?: XOR<DashboardWidgetCreateWithoutDashboardInput, DashboardWidgetUncheckedCreateWithoutDashboardInput> | DashboardWidgetCreateWithoutDashboardInput[] | DashboardWidgetUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: DashboardWidgetCreateOrConnectWithoutDashboardInput | DashboardWidgetCreateOrConnectWithoutDashboardInput[]
    upsert?: DashboardWidgetUpsertWithWhereUniqueWithoutDashboardInput | DashboardWidgetUpsertWithWhereUniqueWithoutDashboardInput[]
    createMany?: DashboardWidgetCreateManyDashboardInputEnvelope
    set?: DashboardWidgetWhereUniqueInput | DashboardWidgetWhereUniqueInput[]
    disconnect?: DashboardWidgetWhereUniqueInput | DashboardWidgetWhereUniqueInput[]
    delete?: DashboardWidgetWhereUniqueInput | DashboardWidgetWhereUniqueInput[]
    connect?: DashboardWidgetWhereUniqueInput | DashboardWidgetWhereUniqueInput[]
    update?: DashboardWidgetUpdateWithWhereUniqueWithoutDashboardInput | DashboardWidgetUpdateWithWhereUniqueWithoutDashboardInput[]
    updateMany?: DashboardWidgetUpdateManyWithWhereWithoutDashboardInput | DashboardWidgetUpdateManyWithWhereWithoutDashboardInput[]
    deleteMany?: DashboardWidgetScalarWhereInput | DashboardWidgetScalarWhereInput[]
  }

  export type DashboardConfigCreateNestedOneWithoutWidgetsInput = {
    create?: XOR<DashboardConfigCreateWithoutWidgetsInput, DashboardConfigUncheckedCreateWithoutWidgetsInput>
    connectOrCreate?: DashboardConfigCreateOrConnectWithoutWidgetsInput
    connect?: DashboardConfigWhereUniqueInput
  }

  export type DashboardConfigUpdateOneRequiredWithoutWidgetsNestedInput = {
    create?: XOR<DashboardConfigCreateWithoutWidgetsInput, DashboardConfigUncheckedCreateWithoutWidgetsInput>
    connectOrCreate?: DashboardConfigCreateOrConnectWithoutWidgetsInput
    upsert?: DashboardConfigUpsertWithoutWidgetsInput
    connect?: DashboardConfigWhereUniqueInput
    update?: XOR<XOR<DashboardConfigUpdateToOneWithWhereWithoutWidgetsInput, DashboardConfigUpdateWithoutWidgetsInput>, DashboardConfigUncheckedUpdateWithoutWidgetsInput>
  }

  export type ProjectObjectiveCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectObjectiveCreateWithoutProjectInput, ProjectObjectiveUncheckedCreateWithoutProjectInput> | ProjectObjectiveCreateWithoutProjectInput[] | ProjectObjectiveUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectObjectiveCreateOrConnectWithoutProjectInput | ProjectObjectiveCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectObjectiveCreateManyProjectInputEnvelope
    connect?: ProjectObjectiveWhereUniqueInput | ProjectObjectiveWhereUniqueInput[]
  }

  export type ProjectKPICreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectKPICreateWithoutProjectInput, ProjectKPIUncheckedCreateWithoutProjectInput> | ProjectKPICreateWithoutProjectInput[] | ProjectKPIUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectKPICreateOrConnectWithoutProjectInput | ProjectKPICreateOrConnectWithoutProjectInput[]
    createMany?: ProjectKPICreateManyProjectInputEnvelope
    connect?: ProjectKPIWhereUniqueInput | ProjectKPIWhereUniqueInput[]
  }

  export type ProjectPhaseCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectPhaseCreateWithoutProjectInput, ProjectPhaseUncheckedCreateWithoutProjectInput> | ProjectPhaseCreateWithoutProjectInput[] | ProjectPhaseUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectPhaseCreateOrConnectWithoutProjectInput | ProjectPhaseCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectPhaseCreateManyProjectInputEnvelope
    connect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectObjectiveUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectObjectiveCreateWithoutProjectInput, ProjectObjectiveUncheckedCreateWithoutProjectInput> | ProjectObjectiveCreateWithoutProjectInput[] | ProjectObjectiveUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectObjectiveCreateOrConnectWithoutProjectInput | ProjectObjectiveCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectObjectiveCreateManyProjectInputEnvelope
    connect?: ProjectObjectiveWhereUniqueInput | ProjectObjectiveWhereUniqueInput[]
  }

  export type ProjectKPIUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectKPICreateWithoutProjectInput, ProjectKPIUncheckedCreateWithoutProjectInput> | ProjectKPICreateWithoutProjectInput[] | ProjectKPIUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectKPICreateOrConnectWithoutProjectInput | ProjectKPICreateOrConnectWithoutProjectInput[]
    createMany?: ProjectKPICreateManyProjectInputEnvelope
    connect?: ProjectKPIWhereUniqueInput | ProjectKPIWhereUniqueInput[]
  }

  export type ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectPhaseCreateWithoutProjectInput, ProjectPhaseUncheckedCreateWithoutProjectInput> | ProjectPhaseCreateWithoutProjectInput[] | ProjectPhaseUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectPhaseCreateOrConnectWithoutProjectInput | ProjectPhaseCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectPhaseCreateManyProjectInputEnvelope
    connect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectObjectiveUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectObjectiveCreateWithoutProjectInput, ProjectObjectiveUncheckedCreateWithoutProjectInput> | ProjectObjectiveCreateWithoutProjectInput[] | ProjectObjectiveUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectObjectiveCreateOrConnectWithoutProjectInput | ProjectObjectiveCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectObjectiveUpsertWithWhereUniqueWithoutProjectInput | ProjectObjectiveUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectObjectiveCreateManyProjectInputEnvelope
    set?: ProjectObjectiveWhereUniqueInput | ProjectObjectiveWhereUniqueInput[]
    disconnect?: ProjectObjectiveWhereUniqueInput | ProjectObjectiveWhereUniqueInput[]
    delete?: ProjectObjectiveWhereUniqueInput | ProjectObjectiveWhereUniqueInput[]
    connect?: ProjectObjectiveWhereUniqueInput | ProjectObjectiveWhereUniqueInput[]
    update?: ProjectObjectiveUpdateWithWhereUniqueWithoutProjectInput | ProjectObjectiveUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectObjectiveUpdateManyWithWhereWithoutProjectInput | ProjectObjectiveUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectObjectiveScalarWhereInput | ProjectObjectiveScalarWhereInput[]
  }

  export type ProjectKPIUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectKPICreateWithoutProjectInput, ProjectKPIUncheckedCreateWithoutProjectInput> | ProjectKPICreateWithoutProjectInput[] | ProjectKPIUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectKPICreateOrConnectWithoutProjectInput | ProjectKPICreateOrConnectWithoutProjectInput[]
    upsert?: ProjectKPIUpsertWithWhereUniqueWithoutProjectInput | ProjectKPIUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectKPICreateManyProjectInputEnvelope
    set?: ProjectKPIWhereUniqueInput | ProjectKPIWhereUniqueInput[]
    disconnect?: ProjectKPIWhereUniqueInput | ProjectKPIWhereUniqueInput[]
    delete?: ProjectKPIWhereUniqueInput | ProjectKPIWhereUniqueInput[]
    connect?: ProjectKPIWhereUniqueInput | ProjectKPIWhereUniqueInput[]
    update?: ProjectKPIUpdateWithWhereUniqueWithoutProjectInput | ProjectKPIUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectKPIUpdateManyWithWhereWithoutProjectInput | ProjectKPIUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectKPIScalarWhereInput | ProjectKPIScalarWhereInput[]
  }

  export type ProjectPhaseUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectPhaseCreateWithoutProjectInput, ProjectPhaseUncheckedCreateWithoutProjectInput> | ProjectPhaseCreateWithoutProjectInput[] | ProjectPhaseUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectPhaseCreateOrConnectWithoutProjectInput | ProjectPhaseCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectPhaseUpsertWithWhereUniqueWithoutProjectInput | ProjectPhaseUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectPhaseCreateManyProjectInputEnvelope
    set?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    disconnect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    delete?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    connect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    update?: ProjectPhaseUpdateWithWhereUniqueWithoutProjectInput | ProjectPhaseUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectPhaseUpdateManyWithWhereWithoutProjectInput | ProjectPhaseUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectPhaseScalarWhereInput | ProjectPhaseScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectObjectiveUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectObjectiveCreateWithoutProjectInput, ProjectObjectiveUncheckedCreateWithoutProjectInput> | ProjectObjectiveCreateWithoutProjectInput[] | ProjectObjectiveUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectObjectiveCreateOrConnectWithoutProjectInput | ProjectObjectiveCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectObjectiveUpsertWithWhereUniqueWithoutProjectInput | ProjectObjectiveUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectObjectiveCreateManyProjectInputEnvelope
    set?: ProjectObjectiveWhereUniqueInput | ProjectObjectiveWhereUniqueInput[]
    disconnect?: ProjectObjectiveWhereUniqueInput | ProjectObjectiveWhereUniqueInput[]
    delete?: ProjectObjectiveWhereUniqueInput | ProjectObjectiveWhereUniqueInput[]
    connect?: ProjectObjectiveWhereUniqueInput | ProjectObjectiveWhereUniqueInput[]
    update?: ProjectObjectiveUpdateWithWhereUniqueWithoutProjectInput | ProjectObjectiveUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectObjectiveUpdateManyWithWhereWithoutProjectInput | ProjectObjectiveUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectObjectiveScalarWhereInput | ProjectObjectiveScalarWhereInput[]
  }

  export type ProjectKPIUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectKPICreateWithoutProjectInput, ProjectKPIUncheckedCreateWithoutProjectInput> | ProjectKPICreateWithoutProjectInput[] | ProjectKPIUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectKPICreateOrConnectWithoutProjectInput | ProjectKPICreateOrConnectWithoutProjectInput[]
    upsert?: ProjectKPIUpsertWithWhereUniqueWithoutProjectInput | ProjectKPIUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectKPICreateManyProjectInputEnvelope
    set?: ProjectKPIWhereUniqueInput | ProjectKPIWhereUniqueInput[]
    disconnect?: ProjectKPIWhereUniqueInput | ProjectKPIWhereUniqueInput[]
    delete?: ProjectKPIWhereUniqueInput | ProjectKPIWhereUniqueInput[]
    connect?: ProjectKPIWhereUniqueInput | ProjectKPIWhereUniqueInput[]
    update?: ProjectKPIUpdateWithWhereUniqueWithoutProjectInput | ProjectKPIUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectKPIUpdateManyWithWhereWithoutProjectInput | ProjectKPIUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectKPIScalarWhereInput | ProjectKPIScalarWhereInput[]
  }

  export type ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectPhaseCreateWithoutProjectInput, ProjectPhaseUncheckedCreateWithoutProjectInput> | ProjectPhaseCreateWithoutProjectInput[] | ProjectPhaseUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectPhaseCreateOrConnectWithoutProjectInput | ProjectPhaseCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectPhaseUpsertWithWhereUniqueWithoutProjectInput | ProjectPhaseUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectPhaseCreateManyProjectInputEnvelope
    set?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    disconnect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    delete?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    connect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    update?: ProjectPhaseUpdateWithWhereUniqueWithoutProjectInput | ProjectPhaseUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectPhaseUpdateManyWithWhereWithoutProjectInput | ProjectPhaseUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectPhaseScalarWhereInput | ProjectPhaseScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutObjectivesInput = {
    create?: XOR<ProjectCreateWithoutObjectivesInput, ProjectUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutObjectivesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutObjectivesNestedInput = {
    create?: XOR<ProjectCreateWithoutObjectivesInput, ProjectUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutObjectivesInput
    upsert?: ProjectUpsertWithoutObjectivesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutObjectivesInput, ProjectUpdateWithoutObjectivesInput>, ProjectUncheckedUpdateWithoutObjectivesInput>
  }

  export type ProjectCreateNestedOneWithoutKpisInput = {
    create?: XOR<ProjectCreateWithoutKpisInput, ProjectUncheckedCreateWithoutKpisInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutKpisInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutKpisNestedInput = {
    create?: XOR<ProjectCreateWithoutKpisInput, ProjectUncheckedCreateWithoutKpisInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutKpisInput
    upsert?: ProjectUpsertWithoutKpisInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutKpisInput, ProjectUpdateWithoutKpisInput>, ProjectUncheckedUpdateWithoutKpisInput>
  }

  export type ProjectCreateNestedOneWithoutPhasesInput = {
    create?: XOR<ProjectCreateWithoutPhasesInput, ProjectUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPhasesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectPhaseCreateNestedOneWithoutDependentsInput = {
    create?: XOR<ProjectPhaseCreateWithoutDependentsInput, ProjectPhaseUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: ProjectPhaseCreateOrConnectWithoutDependentsInput
    connect?: ProjectPhaseWhereUniqueInput
  }

  export type ProjectPhaseCreateNestedManyWithoutDependsOnInput = {
    create?: XOR<ProjectPhaseCreateWithoutDependsOnInput, ProjectPhaseUncheckedCreateWithoutDependsOnInput> | ProjectPhaseCreateWithoutDependsOnInput[] | ProjectPhaseUncheckedCreateWithoutDependsOnInput[]
    connectOrCreate?: ProjectPhaseCreateOrConnectWithoutDependsOnInput | ProjectPhaseCreateOrConnectWithoutDependsOnInput[]
    createMany?: ProjectPhaseCreateManyDependsOnInputEnvelope
    connect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutPhaseInput = {
    create?: XOR<TaskCreateWithoutPhaseInput, TaskUncheckedCreateWithoutPhaseInput> | TaskCreateWithoutPhaseInput[] | TaskUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutPhaseInput | TaskCreateOrConnectWithoutPhaseInput[]
    createMany?: TaskCreateManyPhaseInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectPhaseUncheckedCreateNestedManyWithoutDependsOnInput = {
    create?: XOR<ProjectPhaseCreateWithoutDependsOnInput, ProjectPhaseUncheckedCreateWithoutDependsOnInput> | ProjectPhaseCreateWithoutDependsOnInput[] | ProjectPhaseUncheckedCreateWithoutDependsOnInput[]
    connectOrCreate?: ProjectPhaseCreateOrConnectWithoutDependsOnInput | ProjectPhaseCreateOrConnectWithoutDependsOnInput[]
    createMany?: ProjectPhaseCreateManyDependsOnInputEnvelope
    connect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutPhaseInput = {
    create?: XOR<TaskCreateWithoutPhaseInput, TaskUncheckedCreateWithoutPhaseInput> | TaskCreateWithoutPhaseInput[] | TaskUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutPhaseInput | TaskCreateOrConnectWithoutPhaseInput[]
    createMany?: TaskCreateManyPhaseInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutPhasesNestedInput = {
    create?: XOR<ProjectCreateWithoutPhasesInput, ProjectUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPhasesInput
    upsert?: ProjectUpsertWithoutPhasesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPhasesInput, ProjectUpdateWithoutPhasesInput>, ProjectUncheckedUpdateWithoutPhasesInput>
  }

  export type ProjectPhaseUpdateOneWithoutDependentsNestedInput = {
    create?: XOR<ProjectPhaseCreateWithoutDependentsInput, ProjectPhaseUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: ProjectPhaseCreateOrConnectWithoutDependentsInput
    upsert?: ProjectPhaseUpsertWithoutDependentsInput
    disconnect?: ProjectPhaseWhereInput | boolean
    delete?: ProjectPhaseWhereInput | boolean
    connect?: ProjectPhaseWhereUniqueInput
    update?: XOR<XOR<ProjectPhaseUpdateToOneWithWhereWithoutDependentsInput, ProjectPhaseUpdateWithoutDependentsInput>, ProjectPhaseUncheckedUpdateWithoutDependentsInput>
  }

  export type ProjectPhaseUpdateManyWithoutDependsOnNestedInput = {
    create?: XOR<ProjectPhaseCreateWithoutDependsOnInput, ProjectPhaseUncheckedCreateWithoutDependsOnInput> | ProjectPhaseCreateWithoutDependsOnInput[] | ProjectPhaseUncheckedCreateWithoutDependsOnInput[]
    connectOrCreate?: ProjectPhaseCreateOrConnectWithoutDependsOnInput | ProjectPhaseCreateOrConnectWithoutDependsOnInput[]
    upsert?: ProjectPhaseUpsertWithWhereUniqueWithoutDependsOnInput | ProjectPhaseUpsertWithWhereUniqueWithoutDependsOnInput[]
    createMany?: ProjectPhaseCreateManyDependsOnInputEnvelope
    set?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    disconnect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    delete?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    connect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    update?: ProjectPhaseUpdateWithWhereUniqueWithoutDependsOnInput | ProjectPhaseUpdateWithWhereUniqueWithoutDependsOnInput[]
    updateMany?: ProjectPhaseUpdateManyWithWhereWithoutDependsOnInput | ProjectPhaseUpdateManyWithWhereWithoutDependsOnInput[]
    deleteMany?: ProjectPhaseScalarWhereInput | ProjectPhaseScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<TaskCreateWithoutPhaseInput, TaskUncheckedCreateWithoutPhaseInput> | TaskCreateWithoutPhaseInput[] | TaskUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutPhaseInput | TaskCreateOrConnectWithoutPhaseInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutPhaseInput | TaskUpsertWithWhereUniqueWithoutPhaseInput[]
    createMany?: TaskCreateManyPhaseInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutPhaseInput | TaskUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutPhaseInput | TaskUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectPhaseUncheckedUpdateManyWithoutDependsOnNestedInput = {
    create?: XOR<ProjectPhaseCreateWithoutDependsOnInput, ProjectPhaseUncheckedCreateWithoutDependsOnInput> | ProjectPhaseCreateWithoutDependsOnInput[] | ProjectPhaseUncheckedCreateWithoutDependsOnInput[]
    connectOrCreate?: ProjectPhaseCreateOrConnectWithoutDependsOnInput | ProjectPhaseCreateOrConnectWithoutDependsOnInput[]
    upsert?: ProjectPhaseUpsertWithWhereUniqueWithoutDependsOnInput | ProjectPhaseUpsertWithWhereUniqueWithoutDependsOnInput[]
    createMany?: ProjectPhaseCreateManyDependsOnInputEnvelope
    set?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    disconnect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    delete?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    connect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    update?: ProjectPhaseUpdateWithWhereUniqueWithoutDependsOnInput | ProjectPhaseUpdateWithWhereUniqueWithoutDependsOnInput[]
    updateMany?: ProjectPhaseUpdateManyWithWhereWithoutDependsOnInput | ProjectPhaseUpdateManyWithWhereWithoutDependsOnInput[]
    deleteMany?: ProjectPhaseScalarWhereInput | ProjectPhaseScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<TaskCreateWithoutPhaseInput, TaskUncheckedCreateWithoutPhaseInput> | TaskCreateWithoutPhaseInput[] | TaskUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutPhaseInput | TaskCreateOrConnectWithoutPhaseInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutPhaseInput | TaskUpsertWithWhereUniqueWithoutPhaseInput[]
    createMany?: TaskCreateManyPhaseInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutPhaseInput | TaskUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutPhaseInput | TaskUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectPhaseCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectPhaseCreateWithoutTasksInput, ProjectPhaseUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectPhaseCreateOrConnectWithoutTasksInput
    connect?: ProjectPhaseWhereUniqueInput
  }

  export type TaskEvidenceCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskEvidenceCreateWithoutTaskInput, TaskEvidenceUncheckedCreateWithoutTaskInput> | TaskEvidenceCreateWithoutTaskInput[] | TaskEvidenceUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskEvidenceCreateOrConnectWithoutTaskInput | TaskEvidenceCreateOrConnectWithoutTaskInput[]
    createMany?: TaskEvidenceCreateManyTaskInputEnvelope
    connect?: TaskEvidenceWhereUniqueInput | TaskEvidenceWhereUniqueInput[]
  }

  export type TaskHistoryCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskHistoryCreateWithoutTaskInput, TaskHistoryUncheckedCreateWithoutTaskInput> | TaskHistoryCreateWithoutTaskInput[] | TaskHistoryUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskHistoryCreateOrConnectWithoutTaskInput | TaskHistoryCreateOrConnectWithoutTaskInput[]
    createMany?: TaskHistoryCreateManyTaskInputEnvelope
    connect?: TaskHistoryWhereUniqueInput | TaskHistoryWhereUniqueInput[]
  }

  export type TaskEvidenceUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskEvidenceCreateWithoutTaskInput, TaskEvidenceUncheckedCreateWithoutTaskInput> | TaskEvidenceCreateWithoutTaskInput[] | TaskEvidenceUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskEvidenceCreateOrConnectWithoutTaskInput | TaskEvidenceCreateOrConnectWithoutTaskInput[]
    createMany?: TaskEvidenceCreateManyTaskInputEnvelope
    connect?: TaskEvidenceWhereUniqueInput | TaskEvidenceWhereUniqueInput[]
  }

  export type TaskHistoryUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskHistoryCreateWithoutTaskInput, TaskHistoryUncheckedCreateWithoutTaskInput> | TaskHistoryCreateWithoutTaskInput[] | TaskHistoryUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskHistoryCreateOrConnectWithoutTaskInput | TaskHistoryCreateOrConnectWithoutTaskInput[]
    createMany?: TaskHistoryCreateManyTaskInputEnvelope
    connect?: TaskHistoryWhereUniqueInput | TaskHistoryWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    upsert?: ProjectUpsertWithoutTasksInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTasksInput, ProjectUpdateWithoutTasksInput>, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectPhaseUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ProjectPhaseCreateWithoutTasksInput, ProjectPhaseUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectPhaseCreateOrConnectWithoutTasksInput
    upsert?: ProjectPhaseUpsertWithoutTasksInput
    connect?: ProjectPhaseWhereUniqueInput
    update?: XOR<XOR<ProjectPhaseUpdateToOneWithWhereWithoutTasksInput, ProjectPhaseUpdateWithoutTasksInput>, ProjectPhaseUncheckedUpdateWithoutTasksInput>
  }

  export type TaskEvidenceUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskEvidenceCreateWithoutTaskInput, TaskEvidenceUncheckedCreateWithoutTaskInput> | TaskEvidenceCreateWithoutTaskInput[] | TaskEvidenceUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskEvidenceCreateOrConnectWithoutTaskInput | TaskEvidenceCreateOrConnectWithoutTaskInput[]
    upsert?: TaskEvidenceUpsertWithWhereUniqueWithoutTaskInput | TaskEvidenceUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskEvidenceCreateManyTaskInputEnvelope
    set?: TaskEvidenceWhereUniqueInput | TaskEvidenceWhereUniqueInput[]
    disconnect?: TaskEvidenceWhereUniqueInput | TaskEvidenceWhereUniqueInput[]
    delete?: TaskEvidenceWhereUniqueInput | TaskEvidenceWhereUniqueInput[]
    connect?: TaskEvidenceWhereUniqueInput | TaskEvidenceWhereUniqueInput[]
    update?: TaskEvidenceUpdateWithWhereUniqueWithoutTaskInput | TaskEvidenceUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskEvidenceUpdateManyWithWhereWithoutTaskInput | TaskEvidenceUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskEvidenceScalarWhereInput | TaskEvidenceScalarWhereInput[]
  }

  export type TaskHistoryUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskHistoryCreateWithoutTaskInput, TaskHistoryUncheckedCreateWithoutTaskInput> | TaskHistoryCreateWithoutTaskInput[] | TaskHistoryUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskHistoryCreateOrConnectWithoutTaskInput | TaskHistoryCreateOrConnectWithoutTaskInput[]
    upsert?: TaskHistoryUpsertWithWhereUniqueWithoutTaskInput | TaskHistoryUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskHistoryCreateManyTaskInputEnvelope
    set?: TaskHistoryWhereUniqueInput | TaskHistoryWhereUniqueInput[]
    disconnect?: TaskHistoryWhereUniqueInput | TaskHistoryWhereUniqueInput[]
    delete?: TaskHistoryWhereUniqueInput | TaskHistoryWhereUniqueInput[]
    connect?: TaskHistoryWhereUniqueInput | TaskHistoryWhereUniqueInput[]
    update?: TaskHistoryUpdateWithWhereUniqueWithoutTaskInput | TaskHistoryUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskHistoryUpdateManyWithWhereWithoutTaskInput | TaskHistoryUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskHistoryScalarWhereInput | TaskHistoryScalarWhereInput[]
  }

  export type TaskEvidenceUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskEvidenceCreateWithoutTaskInput, TaskEvidenceUncheckedCreateWithoutTaskInput> | TaskEvidenceCreateWithoutTaskInput[] | TaskEvidenceUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskEvidenceCreateOrConnectWithoutTaskInput | TaskEvidenceCreateOrConnectWithoutTaskInput[]
    upsert?: TaskEvidenceUpsertWithWhereUniqueWithoutTaskInput | TaskEvidenceUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskEvidenceCreateManyTaskInputEnvelope
    set?: TaskEvidenceWhereUniqueInput | TaskEvidenceWhereUniqueInput[]
    disconnect?: TaskEvidenceWhereUniqueInput | TaskEvidenceWhereUniqueInput[]
    delete?: TaskEvidenceWhereUniqueInput | TaskEvidenceWhereUniqueInput[]
    connect?: TaskEvidenceWhereUniqueInput | TaskEvidenceWhereUniqueInput[]
    update?: TaskEvidenceUpdateWithWhereUniqueWithoutTaskInput | TaskEvidenceUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskEvidenceUpdateManyWithWhereWithoutTaskInput | TaskEvidenceUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskEvidenceScalarWhereInput | TaskEvidenceScalarWhereInput[]
  }

  export type TaskHistoryUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskHistoryCreateWithoutTaskInput, TaskHistoryUncheckedCreateWithoutTaskInput> | TaskHistoryCreateWithoutTaskInput[] | TaskHistoryUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskHistoryCreateOrConnectWithoutTaskInput | TaskHistoryCreateOrConnectWithoutTaskInput[]
    upsert?: TaskHistoryUpsertWithWhereUniqueWithoutTaskInput | TaskHistoryUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskHistoryCreateManyTaskInputEnvelope
    set?: TaskHistoryWhereUniqueInput | TaskHistoryWhereUniqueInput[]
    disconnect?: TaskHistoryWhereUniqueInput | TaskHistoryWhereUniqueInput[]
    delete?: TaskHistoryWhereUniqueInput | TaskHistoryWhereUniqueInput[]
    connect?: TaskHistoryWhereUniqueInput | TaskHistoryWhereUniqueInput[]
    update?: TaskHistoryUpdateWithWhereUniqueWithoutTaskInput | TaskHistoryUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskHistoryUpdateManyWithWhereWithoutTaskInput | TaskHistoryUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskHistoryScalarWhereInput | TaskHistoryScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutEvidencesInput = {
    create?: XOR<TaskCreateWithoutEvidencesInput, TaskUncheckedCreateWithoutEvidencesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutEvidencesInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutEvidencesNestedInput = {
    create?: XOR<TaskCreateWithoutEvidencesInput, TaskUncheckedCreateWithoutEvidencesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutEvidencesInput
    upsert?: TaskUpsertWithoutEvidencesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutEvidencesInput, TaskUpdateWithoutEvidencesInput>, TaskUncheckedUpdateWithoutEvidencesInput>
  }

  export type TaskCreateNestedOneWithoutHistoryInput = {
    create?: XOR<TaskCreateWithoutHistoryInput, TaskUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: TaskCreateOrConnectWithoutHistoryInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<TaskCreateWithoutHistoryInput, TaskUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: TaskCreateOrConnectWithoutHistoryInput
    upsert?: TaskUpsertWithoutHistoryInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutHistoryInput, TaskUpdateWithoutHistoryInput>, TaskUncheckedUpdateWithoutHistoryInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UsuarioRolCreateWithoutUsuarioInput = {
    fechaAsignacion?: Date | string
    rol: RolCreateNestedOneWithoutUsuariosInput
  }

  export type UsuarioRolUncheckedCreateWithoutUsuarioInput = {
    rolId: string
    fechaAsignacion?: Date | string
  }

  export type UsuarioRolCreateOrConnectWithoutUsuarioInput = {
    where: UsuarioRolWhereUniqueInput
    create: XOR<UsuarioRolCreateWithoutUsuarioInput, UsuarioRolUncheckedCreateWithoutUsuarioInput>
  }

  export type UsuarioRolCreateManyUsuarioInputEnvelope = {
    data: UsuarioRolCreateManyUsuarioInput | UsuarioRolCreateManyUsuarioInput[]
  }

  export type UsuarioActivoCreateWithoutUsuarioInput = {
    nivelAcceso?: string
    activo: ActivoAccesoCreateNestedOneWithoutUsuariosInput
  }

  export type UsuarioActivoUncheckedCreateWithoutUsuarioInput = {
    activoId: string
    nivelAcceso?: string
  }

  export type UsuarioActivoCreateOrConnectWithoutUsuarioInput = {
    where: UsuarioActivoWhereUniqueInput
    create: XOR<UsuarioActivoCreateWithoutUsuarioInput, UsuarioActivoUncheckedCreateWithoutUsuarioInput>
  }

  export type UsuarioActivoCreateManyUsuarioInputEnvelope = {
    data: UsuarioActivoCreateManyUsuarioInput | UsuarioActivoCreateManyUsuarioInput[]
  }

  export type LogAuditoriaCreateWithoutUsuarioInput = {
    id?: string
    accion: string
    entidad: string
    entidadId: string
    entidadNombre: string
    detalles?: string | null
    ip?: string | null
    userAgent?: string | null
    fecha?: Date | string
  }

  export type LogAuditoriaUncheckedCreateWithoutUsuarioInput = {
    id?: string
    accion: string
    entidad: string
    entidadId: string
    entidadNombre: string
    detalles?: string | null
    ip?: string | null
    userAgent?: string | null
    fecha?: Date | string
  }

  export type LogAuditoriaCreateOrConnectWithoutUsuarioInput = {
    where: LogAuditoriaWhereUniqueInput
    create: XOR<LogAuditoriaCreateWithoutUsuarioInput, LogAuditoriaUncheckedCreateWithoutUsuarioInput>
  }

  export type LogAuditoriaCreateManyUsuarioInputEnvelope = {
    data: LogAuditoriaCreateManyUsuarioInput | LogAuditoriaCreateManyUsuarioInput[]
  }

  export type RespuestaCuestionarioCreateWithoutRespondidoPorInput = {
    id?: string
    cuestionarioId: string
    fechaInicio?: Date | string
    fechaEnvio?: Date | string | null
    estado?: string
    puntuacionTotal?: number
    nivelCumplimiento?: string | null
    comentariosGenerales?: string | null
    asignacion: AsignacionCuestionarioCreateNestedOneWithoutRespuestasInput
    respuestas?: RespuestaPreguntaCreateNestedManyWithoutRespuestaCuestionarioInput
  }

  export type RespuestaCuestionarioUncheckedCreateWithoutRespondidoPorInput = {
    id?: string
    asignacionId: string
    cuestionarioId: string
    fechaInicio?: Date | string
    fechaEnvio?: Date | string | null
    estado?: string
    puntuacionTotal?: number
    nivelCumplimiento?: string | null
    comentariosGenerales?: string | null
    respuestas?: RespuestaPreguntaUncheckedCreateNestedManyWithoutRespuestaCuestionarioInput
  }

  export type RespuestaCuestionarioCreateOrConnectWithoutRespondidoPorInput = {
    where: RespuestaCuestionarioWhereUniqueInput
    create: XOR<RespuestaCuestionarioCreateWithoutRespondidoPorInput, RespuestaCuestionarioUncheckedCreateWithoutRespondidoPorInput>
  }

  export type RespuestaCuestionarioCreateManyRespondidoPorInputEnvelope = {
    data: RespuestaCuestionarioCreateManyRespondidoPorInput | RespuestaCuestionarioCreateManyRespondidoPorInput[]
  }

  export type UsuarioRolUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: UsuarioRolWhereUniqueInput
    update: XOR<UsuarioRolUpdateWithoutUsuarioInput, UsuarioRolUncheckedUpdateWithoutUsuarioInput>
    create: XOR<UsuarioRolCreateWithoutUsuarioInput, UsuarioRolUncheckedCreateWithoutUsuarioInput>
  }

  export type UsuarioRolUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: UsuarioRolWhereUniqueInput
    data: XOR<UsuarioRolUpdateWithoutUsuarioInput, UsuarioRolUncheckedUpdateWithoutUsuarioInput>
  }

  export type UsuarioRolUpdateManyWithWhereWithoutUsuarioInput = {
    where: UsuarioRolScalarWhereInput
    data: XOR<UsuarioRolUpdateManyMutationInput, UsuarioRolUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type UsuarioRolScalarWhereInput = {
    AND?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[]
    OR?: UsuarioRolScalarWhereInput[]
    NOT?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[]
    usuarioId?: StringFilter<"UsuarioRol"> | string
    rolId?: StringFilter<"UsuarioRol"> | string
    fechaAsignacion?: DateTimeFilter<"UsuarioRol"> | Date | string
  }

  export type UsuarioActivoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: UsuarioActivoWhereUniqueInput
    update: XOR<UsuarioActivoUpdateWithoutUsuarioInput, UsuarioActivoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<UsuarioActivoCreateWithoutUsuarioInput, UsuarioActivoUncheckedCreateWithoutUsuarioInput>
  }

  export type UsuarioActivoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: UsuarioActivoWhereUniqueInput
    data: XOR<UsuarioActivoUpdateWithoutUsuarioInput, UsuarioActivoUncheckedUpdateWithoutUsuarioInput>
  }

  export type UsuarioActivoUpdateManyWithWhereWithoutUsuarioInput = {
    where: UsuarioActivoScalarWhereInput
    data: XOR<UsuarioActivoUpdateManyMutationInput, UsuarioActivoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type UsuarioActivoScalarWhereInput = {
    AND?: UsuarioActivoScalarWhereInput | UsuarioActivoScalarWhereInput[]
    OR?: UsuarioActivoScalarWhereInput[]
    NOT?: UsuarioActivoScalarWhereInput | UsuarioActivoScalarWhereInput[]
    usuarioId?: StringFilter<"UsuarioActivo"> | string
    activoId?: StringFilter<"UsuarioActivo"> | string
    nivelAcceso?: StringFilter<"UsuarioActivo"> | string
  }

  export type LogAuditoriaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: LogAuditoriaWhereUniqueInput
    update: XOR<LogAuditoriaUpdateWithoutUsuarioInput, LogAuditoriaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<LogAuditoriaCreateWithoutUsuarioInput, LogAuditoriaUncheckedCreateWithoutUsuarioInput>
  }

  export type LogAuditoriaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: LogAuditoriaWhereUniqueInput
    data: XOR<LogAuditoriaUpdateWithoutUsuarioInput, LogAuditoriaUncheckedUpdateWithoutUsuarioInput>
  }

  export type LogAuditoriaUpdateManyWithWhereWithoutUsuarioInput = {
    where: LogAuditoriaScalarWhereInput
    data: XOR<LogAuditoriaUpdateManyMutationInput, LogAuditoriaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type LogAuditoriaScalarWhereInput = {
    AND?: LogAuditoriaScalarWhereInput | LogAuditoriaScalarWhereInput[]
    OR?: LogAuditoriaScalarWhereInput[]
    NOT?: LogAuditoriaScalarWhereInput | LogAuditoriaScalarWhereInput[]
    id?: StringFilter<"LogAuditoria"> | string
    accion?: StringFilter<"LogAuditoria"> | string
    entidad?: StringFilter<"LogAuditoria"> | string
    entidadId?: StringFilter<"LogAuditoria"> | string
    entidadNombre?: StringFilter<"LogAuditoria"> | string
    detalles?: StringNullableFilter<"LogAuditoria"> | string | null
    ip?: StringNullableFilter<"LogAuditoria"> | string | null
    userAgent?: StringNullableFilter<"LogAuditoria"> | string | null
    fecha?: DateTimeFilter<"LogAuditoria"> | Date | string
    usuarioId?: StringFilter<"LogAuditoria"> | string
  }

  export type RespuestaCuestionarioUpsertWithWhereUniqueWithoutRespondidoPorInput = {
    where: RespuestaCuestionarioWhereUniqueInput
    update: XOR<RespuestaCuestionarioUpdateWithoutRespondidoPorInput, RespuestaCuestionarioUncheckedUpdateWithoutRespondidoPorInput>
    create: XOR<RespuestaCuestionarioCreateWithoutRespondidoPorInput, RespuestaCuestionarioUncheckedCreateWithoutRespondidoPorInput>
  }

  export type RespuestaCuestionarioUpdateWithWhereUniqueWithoutRespondidoPorInput = {
    where: RespuestaCuestionarioWhereUniqueInput
    data: XOR<RespuestaCuestionarioUpdateWithoutRespondidoPorInput, RespuestaCuestionarioUncheckedUpdateWithoutRespondidoPorInput>
  }

  export type RespuestaCuestionarioUpdateManyWithWhereWithoutRespondidoPorInput = {
    where: RespuestaCuestionarioScalarWhereInput
    data: XOR<RespuestaCuestionarioUpdateManyMutationInput, RespuestaCuestionarioUncheckedUpdateManyWithoutRespondidoPorInput>
  }

  export type RespuestaCuestionarioScalarWhereInput = {
    AND?: RespuestaCuestionarioScalarWhereInput | RespuestaCuestionarioScalarWhereInput[]
    OR?: RespuestaCuestionarioScalarWhereInput[]
    NOT?: RespuestaCuestionarioScalarWhereInput | RespuestaCuestionarioScalarWhereInput[]
    id?: StringFilter<"RespuestaCuestionario"> | string
    asignacionId?: StringFilter<"RespuestaCuestionario"> | string
    cuestionarioId?: StringFilter<"RespuestaCuestionario"> | string
    respondidoPorId?: StringFilter<"RespuestaCuestionario"> | string
    fechaInicio?: DateTimeFilter<"RespuestaCuestionario"> | Date | string
    fechaEnvio?: DateTimeNullableFilter<"RespuestaCuestionario"> | Date | string | null
    estado?: StringFilter<"RespuestaCuestionario"> | string
    puntuacionTotal?: FloatFilter<"RespuestaCuestionario"> | number
    nivelCumplimiento?: StringNullableFilter<"RespuestaCuestionario"> | string | null
    comentariosGenerales?: StringNullableFilter<"RespuestaCuestionario"> | string | null
  }

  export type UsuarioRolCreateWithoutRolInput = {
    fechaAsignacion?: Date | string
    usuario: UsuarioCreateNestedOneWithoutRolesInput
  }

  export type UsuarioRolUncheckedCreateWithoutRolInput = {
    usuarioId: string
    fechaAsignacion?: Date | string
  }

  export type UsuarioRolCreateOrConnectWithoutRolInput = {
    where: UsuarioRolWhereUniqueInput
    create: XOR<UsuarioRolCreateWithoutRolInput, UsuarioRolUncheckedCreateWithoutRolInput>
  }

  export type UsuarioRolCreateManyRolInputEnvelope = {
    data: UsuarioRolCreateManyRolInput | UsuarioRolCreateManyRolInput[]
  }

  export type RolPermisoCreateWithoutRolInput = {
    permiso: PermisoCreateNestedOneWithoutRolesInput
  }

  export type RolPermisoUncheckedCreateWithoutRolInput = {
    permisoId: string
  }

  export type RolPermisoCreateOrConnectWithoutRolInput = {
    where: RolPermisoWhereUniqueInput
    create: XOR<RolPermisoCreateWithoutRolInput, RolPermisoUncheckedCreateWithoutRolInput>
  }

  export type RolPermisoCreateManyRolInputEnvelope = {
    data: RolPermisoCreateManyRolInput | RolPermisoCreateManyRolInput[]
  }

  export type UsuarioRolUpsertWithWhereUniqueWithoutRolInput = {
    where: UsuarioRolWhereUniqueInput
    update: XOR<UsuarioRolUpdateWithoutRolInput, UsuarioRolUncheckedUpdateWithoutRolInput>
    create: XOR<UsuarioRolCreateWithoutRolInput, UsuarioRolUncheckedCreateWithoutRolInput>
  }

  export type UsuarioRolUpdateWithWhereUniqueWithoutRolInput = {
    where: UsuarioRolWhereUniqueInput
    data: XOR<UsuarioRolUpdateWithoutRolInput, UsuarioRolUncheckedUpdateWithoutRolInput>
  }

  export type UsuarioRolUpdateManyWithWhereWithoutRolInput = {
    where: UsuarioRolScalarWhereInput
    data: XOR<UsuarioRolUpdateManyMutationInput, UsuarioRolUncheckedUpdateManyWithoutRolInput>
  }

  export type RolPermisoUpsertWithWhereUniqueWithoutRolInput = {
    where: RolPermisoWhereUniqueInput
    update: XOR<RolPermisoUpdateWithoutRolInput, RolPermisoUncheckedUpdateWithoutRolInput>
    create: XOR<RolPermisoCreateWithoutRolInput, RolPermisoUncheckedCreateWithoutRolInput>
  }

  export type RolPermisoUpdateWithWhereUniqueWithoutRolInput = {
    where: RolPermisoWhereUniqueInput
    data: XOR<RolPermisoUpdateWithoutRolInput, RolPermisoUncheckedUpdateWithoutRolInput>
  }

  export type RolPermisoUpdateManyWithWhereWithoutRolInput = {
    where: RolPermisoScalarWhereInput
    data: XOR<RolPermisoUpdateManyMutationInput, RolPermisoUncheckedUpdateManyWithoutRolInput>
  }

  export type RolPermisoScalarWhereInput = {
    AND?: RolPermisoScalarWhereInput | RolPermisoScalarWhereInput[]
    OR?: RolPermisoScalarWhereInput[]
    NOT?: RolPermisoScalarWhereInput | RolPermisoScalarWhereInput[]
    rolId?: StringFilter<"RolPermiso"> | string
    permisoId?: StringFilter<"RolPermiso"> | string
  }

  export type PermisoCreateWithoutHijosInput = {
    id?: string
    codigo: string
    nombre: string
    descripcion: string
    modulo: string
    categoria: string
    activo?: boolean
    padre?: PermisoCreateNestedOneWithoutHijosInput
    roles?: RolPermisoCreateNestedManyWithoutPermisoInput
  }

  export type PermisoUncheckedCreateWithoutHijosInput = {
    id?: string
    codigo: string
    nombre: string
    descripcion: string
    modulo: string
    categoria: string
    activo?: boolean
    padreId?: string | null
    roles?: RolPermisoUncheckedCreateNestedManyWithoutPermisoInput
  }

  export type PermisoCreateOrConnectWithoutHijosInput = {
    where: PermisoWhereUniqueInput
    create: XOR<PermisoCreateWithoutHijosInput, PermisoUncheckedCreateWithoutHijosInput>
  }

  export type PermisoCreateWithoutPadreInput = {
    id?: string
    codigo: string
    nombre: string
    descripcion: string
    modulo: string
    categoria: string
    activo?: boolean
    hijos?: PermisoCreateNestedManyWithoutPadreInput
    roles?: RolPermisoCreateNestedManyWithoutPermisoInput
  }

  export type PermisoUncheckedCreateWithoutPadreInput = {
    id?: string
    codigo: string
    nombre: string
    descripcion: string
    modulo: string
    categoria: string
    activo?: boolean
    hijos?: PermisoUncheckedCreateNestedManyWithoutPadreInput
    roles?: RolPermisoUncheckedCreateNestedManyWithoutPermisoInput
  }

  export type PermisoCreateOrConnectWithoutPadreInput = {
    where: PermisoWhereUniqueInput
    create: XOR<PermisoCreateWithoutPadreInput, PermisoUncheckedCreateWithoutPadreInput>
  }

  export type PermisoCreateManyPadreInputEnvelope = {
    data: PermisoCreateManyPadreInput | PermisoCreateManyPadreInput[]
  }

  export type RolPermisoCreateWithoutPermisoInput = {
    rol: RolCreateNestedOneWithoutPermisosInput
  }

  export type RolPermisoUncheckedCreateWithoutPermisoInput = {
    rolId: string
  }

  export type RolPermisoCreateOrConnectWithoutPermisoInput = {
    where: RolPermisoWhereUniqueInput
    create: XOR<RolPermisoCreateWithoutPermisoInput, RolPermisoUncheckedCreateWithoutPermisoInput>
  }

  export type RolPermisoCreateManyPermisoInputEnvelope = {
    data: RolPermisoCreateManyPermisoInput | RolPermisoCreateManyPermisoInput[]
  }

  export type PermisoUpsertWithoutHijosInput = {
    update: XOR<PermisoUpdateWithoutHijosInput, PermisoUncheckedUpdateWithoutHijosInput>
    create: XOR<PermisoCreateWithoutHijosInput, PermisoUncheckedCreateWithoutHijosInput>
    where?: PermisoWhereInput
  }

  export type PermisoUpdateToOneWithWhereWithoutHijosInput = {
    where?: PermisoWhereInput
    data: XOR<PermisoUpdateWithoutHijosInput, PermisoUncheckedUpdateWithoutHijosInput>
  }

  export type PermisoUpdateWithoutHijosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    padre?: PermisoUpdateOneWithoutHijosNestedInput
    roles?: RolPermisoUpdateManyWithoutPermisoNestedInput
  }

  export type PermisoUncheckedUpdateWithoutHijosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    padreId?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: RolPermisoUncheckedUpdateManyWithoutPermisoNestedInput
  }

  export type PermisoUpsertWithWhereUniqueWithoutPadreInput = {
    where: PermisoWhereUniqueInput
    update: XOR<PermisoUpdateWithoutPadreInput, PermisoUncheckedUpdateWithoutPadreInput>
    create: XOR<PermisoCreateWithoutPadreInput, PermisoUncheckedCreateWithoutPadreInput>
  }

  export type PermisoUpdateWithWhereUniqueWithoutPadreInput = {
    where: PermisoWhereUniqueInput
    data: XOR<PermisoUpdateWithoutPadreInput, PermisoUncheckedUpdateWithoutPadreInput>
  }

  export type PermisoUpdateManyWithWhereWithoutPadreInput = {
    where: PermisoScalarWhereInput
    data: XOR<PermisoUpdateManyMutationInput, PermisoUncheckedUpdateManyWithoutPadreInput>
  }

  export type PermisoScalarWhereInput = {
    AND?: PermisoScalarWhereInput | PermisoScalarWhereInput[]
    OR?: PermisoScalarWhereInput[]
    NOT?: PermisoScalarWhereInput | PermisoScalarWhereInput[]
    id?: StringFilter<"Permiso"> | string
    codigo?: StringFilter<"Permiso"> | string
    nombre?: StringFilter<"Permiso"> | string
    descripcion?: StringFilter<"Permiso"> | string
    modulo?: StringFilter<"Permiso"> | string
    categoria?: StringFilter<"Permiso"> | string
    activo?: BoolFilter<"Permiso"> | boolean
    padreId?: StringNullableFilter<"Permiso"> | string | null
  }

  export type RolPermisoUpsertWithWhereUniqueWithoutPermisoInput = {
    where: RolPermisoWhereUniqueInput
    update: XOR<RolPermisoUpdateWithoutPermisoInput, RolPermisoUncheckedUpdateWithoutPermisoInput>
    create: XOR<RolPermisoCreateWithoutPermisoInput, RolPermisoUncheckedCreateWithoutPermisoInput>
  }

  export type RolPermisoUpdateWithWhereUniqueWithoutPermisoInput = {
    where: RolPermisoWhereUniqueInput
    data: XOR<RolPermisoUpdateWithoutPermisoInput, RolPermisoUncheckedUpdateWithoutPermisoInput>
  }

  export type RolPermisoUpdateManyWithWhereWithoutPermisoInput = {
    where: RolPermisoScalarWhereInput
    data: XOR<RolPermisoUpdateManyMutationInput, RolPermisoUncheckedUpdateManyWithoutPermisoInput>
  }

  export type UsuarioCreateWithoutRolesInput = {
    id?: string
    nombre: string
    apellido: string
    email: string
    password?: string | null
    telefono?: string | null
    avatar?: string | null
    estado?: string
    departamento?: string | null
    cargo?: string | null
    region?: string
    autenticacionDosFactor?: boolean
    cambioPasswordRequerido?: boolean
    sesionesActivas?: number
    maxSesionesPermitidas?: number
    ultimoCambioPassword?: Date | string | null
    intentosFallidos?: number
    fechaCreacion?: Date | string
    fechaExpiracion?: Date | string | null
    ultimoAcceso?: Date | string | null
    updatedAt?: Date | string
    activosAcceso?: UsuarioActivoCreateNestedManyWithoutUsuarioInput
    logsAuditoria?: LogAuditoriaCreateNestedManyWithoutUsuarioInput
    respuestasCuestionario?: RespuestaCuestionarioCreateNestedManyWithoutRespondidoPorInput
  }

  export type UsuarioUncheckedCreateWithoutRolesInput = {
    id?: string
    nombre: string
    apellido: string
    email: string
    password?: string | null
    telefono?: string | null
    avatar?: string | null
    estado?: string
    departamento?: string | null
    cargo?: string | null
    region?: string
    autenticacionDosFactor?: boolean
    cambioPasswordRequerido?: boolean
    sesionesActivas?: number
    maxSesionesPermitidas?: number
    ultimoCambioPassword?: Date | string | null
    intentosFallidos?: number
    fechaCreacion?: Date | string
    fechaExpiracion?: Date | string | null
    ultimoAcceso?: Date | string | null
    updatedAt?: Date | string
    activosAcceso?: UsuarioActivoUncheckedCreateNestedManyWithoutUsuarioInput
    logsAuditoria?: LogAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    respuestasCuestionario?: RespuestaCuestionarioUncheckedCreateNestedManyWithoutRespondidoPorInput
  }

  export type UsuarioCreateOrConnectWithoutRolesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutRolesInput, UsuarioUncheckedCreateWithoutRolesInput>
  }

  export type RolCreateWithoutUsuariosInput = {
    id?: string
    nombre: string
    descripcion: string
    nivelAcceso?: string
    region?: string
    tipoArbol?: string
    color?: string | null
    icono?: string | null
    activo?: boolean
    esRolSistema?: boolean
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    permisos?: RolPermisoCreateNestedManyWithoutRolInput
  }

  export type RolUncheckedCreateWithoutUsuariosInput = {
    id?: string
    nombre: string
    descripcion: string
    nivelAcceso?: string
    region?: string
    tipoArbol?: string
    color?: string | null
    icono?: string | null
    activo?: boolean
    esRolSistema?: boolean
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    permisos?: RolPermisoUncheckedCreateNestedManyWithoutRolInput
  }

  export type RolCreateOrConnectWithoutUsuariosInput = {
    where: RolWhereUniqueInput
    create: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
  }

  export type UsuarioUpsertWithoutRolesInput = {
    update: XOR<UsuarioUpdateWithoutRolesInput, UsuarioUncheckedUpdateWithoutRolesInput>
    create: XOR<UsuarioCreateWithoutRolesInput, UsuarioUncheckedCreateWithoutRolesInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutRolesInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutRolesInput, UsuarioUncheckedUpdateWithoutRolesInput>
  }

  export type UsuarioUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    region?: StringFieldUpdateOperationsInput | string
    autenticacionDosFactor?: BoolFieldUpdateOperationsInput | boolean
    cambioPasswordRequerido?: BoolFieldUpdateOperationsInput | boolean
    sesionesActivas?: IntFieldUpdateOperationsInput | number
    maxSesionesPermitidas?: IntFieldUpdateOperationsInput | number
    ultimoCambioPassword?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activosAcceso?: UsuarioActivoUpdateManyWithoutUsuarioNestedInput
    logsAuditoria?: LogAuditoriaUpdateManyWithoutUsuarioNestedInput
    respuestasCuestionario?: RespuestaCuestionarioUpdateManyWithoutRespondidoPorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    region?: StringFieldUpdateOperationsInput | string
    autenticacionDosFactor?: BoolFieldUpdateOperationsInput | boolean
    cambioPasswordRequerido?: BoolFieldUpdateOperationsInput | boolean
    sesionesActivas?: IntFieldUpdateOperationsInput | number
    maxSesionesPermitidas?: IntFieldUpdateOperationsInput | number
    ultimoCambioPassword?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activosAcceso?: UsuarioActivoUncheckedUpdateManyWithoutUsuarioNestedInput
    logsAuditoria?: LogAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    respuestasCuestionario?: RespuestaCuestionarioUncheckedUpdateManyWithoutRespondidoPorNestedInput
  }

  export type RolUpsertWithoutUsuariosInput = {
    update: XOR<RolUpdateWithoutUsuariosInput, RolUncheckedUpdateWithoutUsuariosInput>
    create: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
    where?: RolWhereInput
  }

  export type RolUpdateToOneWithWhereWithoutUsuariosInput = {
    where?: RolWhereInput
    data: XOR<RolUpdateWithoutUsuariosInput, RolUncheckedUpdateWithoutUsuariosInput>
  }

  export type RolUpdateWithoutUsuariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    nivelAcceso?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    tipoArbol?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    esRolSistema?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    permisos?: RolPermisoUpdateManyWithoutRolNestedInput
  }

  export type RolUncheckedUpdateWithoutUsuariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    nivelAcceso?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    tipoArbol?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    esRolSistema?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    permisos?: RolPermisoUncheckedUpdateManyWithoutRolNestedInput
  }

  export type RolCreateWithoutPermisosInput = {
    id?: string
    nombre: string
    descripcion: string
    nivelAcceso?: string
    region?: string
    tipoArbol?: string
    color?: string | null
    icono?: string | null
    activo?: boolean
    esRolSistema?: boolean
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    usuarios?: UsuarioRolCreateNestedManyWithoutRolInput
  }

  export type RolUncheckedCreateWithoutPermisosInput = {
    id?: string
    nombre: string
    descripcion: string
    nivelAcceso?: string
    region?: string
    tipoArbol?: string
    color?: string | null
    icono?: string | null
    activo?: boolean
    esRolSistema?: boolean
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    usuarios?: UsuarioRolUncheckedCreateNestedManyWithoutRolInput
  }

  export type RolCreateOrConnectWithoutPermisosInput = {
    where: RolWhereUniqueInput
    create: XOR<RolCreateWithoutPermisosInput, RolUncheckedCreateWithoutPermisosInput>
  }

  export type PermisoCreateWithoutRolesInput = {
    id?: string
    codigo: string
    nombre: string
    descripcion: string
    modulo: string
    categoria: string
    activo?: boolean
    padre?: PermisoCreateNestedOneWithoutHijosInput
    hijos?: PermisoCreateNestedManyWithoutPadreInput
  }

  export type PermisoUncheckedCreateWithoutRolesInput = {
    id?: string
    codigo: string
    nombre: string
    descripcion: string
    modulo: string
    categoria: string
    activo?: boolean
    padreId?: string | null
    hijos?: PermisoUncheckedCreateNestedManyWithoutPadreInput
  }

  export type PermisoCreateOrConnectWithoutRolesInput = {
    where: PermisoWhereUniqueInput
    create: XOR<PermisoCreateWithoutRolesInput, PermisoUncheckedCreateWithoutRolesInput>
  }

  export type RolUpsertWithoutPermisosInput = {
    update: XOR<RolUpdateWithoutPermisosInput, RolUncheckedUpdateWithoutPermisosInput>
    create: XOR<RolCreateWithoutPermisosInput, RolUncheckedCreateWithoutPermisosInput>
    where?: RolWhereInput
  }

  export type RolUpdateToOneWithWhereWithoutPermisosInput = {
    where?: RolWhereInput
    data: XOR<RolUpdateWithoutPermisosInput, RolUncheckedUpdateWithoutPermisosInput>
  }

  export type RolUpdateWithoutPermisosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    nivelAcceso?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    tipoArbol?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    esRolSistema?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarios?: UsuarioRolUpdateManyWithoutRolNestedInput
  }

  export type RolUncheckedUpdateWithoutPermisosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    nivelAcceso?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    tipoArbol?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    esRolSistema?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarios?: UsuarioRolUncheckedUpdateManyWithoutRolNestedInput
  }

  export type PermisoUpsertWithoutRolesInput = {
    update: XOR<PermisoUpdateWithoutRolesInput, PermisoUncheckedUpdateWithoutRolesInput>
    create: XOR<PermisoCreateWithoutRolesInput, PermisoUncheckedCreateWithoutRolesInput>
    where?: PermisoWhereInput
  }

  export type PermisoUpdateToOneWithWhereWithoutRolesInput = {
    where?: PermisoWhereInput
    data: XOR<PermisoUpdateWithoutRolesInput, PermisoUncheckedUpdateWithoutRolesInput>
  }

  export type PermisoUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    padre?: PermisoUpdateOneWithoutHijosNestedInput
    hijos?: PermisoUpdateManyWithoutPadreNestedInput
  }

  export type PermisoUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    padreId?: NullableStringFieldUpdateOperationsInput | string | null
    hijos?: PermisoUncheckedUpdateManyWithoutPadreNestedInput
  }

  export type UsuarioCreateWithoutActivosAccesoInput = {
    id?: string
    nombre: string
    apellido: string
    email: string
    password?: string | null
    telefono?: string | null
    avatar?: string | null
    estado?: string
    departamento?: string | null
    cargo?: string | null
    region?: string
    autenticacionDosFactor?: boolean
    cambioPasswordRequerido?: boolean
    sesionesActivas?: number
    maxSesionesPermitidas?: number
    ultimoCambioPassword?: Date | string | null
    intentosFallidos?: number
    fechaCreacion?: Date | string
    fechaExpiracion?: Date | string | null
    ultimoAcceso?: Date | string | null
    updatedAt?: Date | string
    roles?: UsuarioRolCreateNestedManyWithoutUsuarioInput
    logsAuditoria?: LogAuditoriaCreateNestedManyWithoutUsuarioInput
    respuestasCuestionario?: RespuestaCuestionarioCreateNestedManyWithoutRespondidoPorInput
  }

  export type UsuarioUncheckedCreateWithoutActivosAccesoInput = {
    id?: string
    nombre: string
    apellido: string
    email: string
    password?: string | null
    telefono?: string | null
    avatar?: string | null
    estado?: string
    departamento?: string | null
    cargo?: string | null
    region?: string
    autenticacionDosFactor?: boolean
    cambioPasswordRequerido?: boolean
    sesionesActivas?: number
    maxSesionesPermitidas?: number
    ultimoCambioPassword?: Date | string | null
    intentosFallidos?: number
    fechaCreacion?: Date | string
    fechaExpiracion?: Date | string | null
    ultimoAcceso?: Date | string | null
    updatedAt?: Date | string
    roles?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput
    logsAuditoria?: LogAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    respuestasCuestionario?: RespuestaCuestionarioUncheckedCreateNestedManyWithoutRespondidoPorInput
  }

  export type UsuarioCreateOrConnectWithoutActivosAccesoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutActivosAccesoInput, UsuarioUncheckedCreateWithoutActivosAccesoInput>
  }

  export type ActivoAccesoCreateWithoutUsuariosInput = {
    id?: string
    nombre: string
    tipo: string
    icono?: string | null
    nivelAcceso?: string | null
    expanded?: boolean
    padre?: ActivoAccesoCreateNestedOneWithoutHijosInput
    hijos?: ActivoAccesoCreateNestedManyWithoutPadreInput
  }

  export type ActivoAccesoUncheckedCreateWithoutUsuariosInput = {
    id?: string
    nombre: string
    tipo: string
    icono?: string | null
    nivelAcceso?: string | null
    expanded?: boolean
    padreId?: string | null
    hijos?: ActivoAccesoUncheckedCreateNestedManyWithoutPadreInput
  }

  export type ActivoAccesoCreateOrConnectWithoutUsuariosInput = {
    where: ActivoAccesoWhereUniqueInput
    create: XOR<ActivoAccesoCreateWithoutUsuariosInput, ActivoAccesoUncheckedCreateWithoutUsuariosInput>
  }

  export type UsuarioUpsertWithoutActivosAccesoInput = {
    update: XOR<UsuarioUpdateWithoutActivosAccesoInput, UsuarioUncheckedUpdateWithoutActivosAccesoInput>
    create: XOR<UsuarioCreateWithoutActivosAccesoInput, UsuarioUncheckedCreateWithoutActivosAccesoInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutActivosAccesoInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutActivosAccesoInput, UsuarioUncheckedUpdateWithoutActivosAccesoInput>
  }

  export type UsuarioUpdateWithoutActivosAccesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    region?: StringFieldUpdateOperationsInput | string
    autenticacionDosFactor?: BoolFieldUpdateOperationsInput | boolean
    cambioPasswordRequerido?: BoolFieldUpdateOperationsInput | boolean
    sesionesActivas?: IntFieldUpdateOperationsInput | number
    maxSesionesPermitidas?: IntFieldUpdateOperationsInput | number
    ultimoCambioPassword?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UsuarioRolUpdateManyWithoutUsuarioNestedInput
    logsAuditoria?: LogAuditoriaUpdateManyWithoutUsuarioNestedInput
    respuestasCuestionario?: RespuestaCuestionarioUpdateManyWithoutRespondidoPorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutActivosAccesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    region?: StringFieldUpdateOperationsInput | string
    autenticacionDosFactor?: BoolFieldUpdateOperationsInput | boolean
    cambioPasswordRequerido?: BoolFieldUpdateOperationsInput | boolean
    sesionesActivas?: IntFieldUpdateOperationsInput | number
    maxSesionesPermitidas?: IntFieldUpdateOperationsInput | number
    ultimoCambioPassword?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput
    logsAuditoria?: LogAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    respuestasCuestionario?: RespuestaCuestionarioUncheckedUpdateManyWithoutRespondidoPorNestedInput
  }

  export type ActivoAccesoUpsertWithoutUsuariosInput = {
    update: XOR<ActivoAccesoUpdateWithoutUsuariosInput, ActivoAccesoUncheckedUpdateWithoutUsuariosInput>
    create: XOR<ActivoAccesoCreateWithoutUsuariosInput, ActivoAccesoUncheckedCreateWithoutUsuariosInput>
    where?: ActivoAccesoWhereInput
  }

  export type ActivoAccesoUpdateToOneWithWhereWithoutUsuariosInput = {
    where?: ActivoAccesoWhereInput
    data: XOR<ActivoAccesoUpdateWithoutUsuariosInput, ActivoAccesoUncheckedUpdateWithoutUsuariosInput>
  }

  export type ActivoAccesoUpdateWithoutUsuariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    expanded?: BoolFieldUpdateOperationsInput | boolean
    padre?: ActivoAccesoUpdateOneWithoutHijosNestedInput
    hijos?: ActivoAccesoUpdateManyWithoutPadreNestedInput
  }

  export type ActivoAccesoUncheckedUpdateWithoutUsuariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    expanded?: BoolFieldUpdateOperationsInput | boolean
    padreId?: NullableStringFieldUpdateOperationsInput | string | null
    hijos?: ActivoAccesoUncheckedUpdateManyWithoutPadreNestedInput
  }

  export type UsuarioCreateWithoutLogsAuditoriaInput = {
    id?: string
    nombre: string
    apellido: string
    email: string
    password?: string | null
    telefono?: string | null
    avatar?: string | null
    estado?: string
    departamento?: string | null
    cargo?: string | null
    region?: string
    autenticacionDosFactor?: boolean
    cambioPasswordRequerido?: boolean
    sesionesActivas?: number
    maxSesionesPermitidas?: number
    ultimoCambioPassword?: Date | string | null
    intentosFallidos?: number
    fechaCreacion?: Date | string
    fechaExpiracion?: Date | string | null
    ultimoAcceso?: Date | string | null
    updatedAt?: Date | string
    roles?: UsuarioRolCreateNestedManyWithoutUsuarioInput
    activosAcceso?: UsuarioActivoCreateNestedManyWithoutUsuarioInput
    respuestasCuestionario?: RespuestaCuestionarioCreateNestedManyWithoutRespondidoPorInput
  }

  export type UsuarioUncheckedCreateWithoutLogsAuditoriaInput = {
    id?: string
    nombre: string
    apellido: string
    email: string
    password?: string | null
    telefono?: string | null
    avatar?: string | null
    estado?: string
    departamento?: string | null
    cargo?: string | null
    region?: string
    autenticacionDosFactor?: boolean
    cambioPasswordRequerido?: boolean
    sesionesActivas?: number
    maxSesionesPermitidas?: number
    ultimoCambioPassword?: Date | string | null
    intentosFallidos?: number
    fechaCreacion?: Date | string
    fechaExpiracion?: Date | string | null
    ultimoAcceso?: Date | string | null
    updatedAt?: Date | string
    roles?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput
    activosAcceso?: UsuarioActivoUncheckedCreateNestedManyWithoutUsuarioInput
    respuestasCuestionario?: RespuestaCuestionarioUncheckedCreateNestedManyWithoutRespondidoPorInput
  }

  export type UsuarioCreateOrConnectWithoutLogsAuditoriaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutLogsAuditoriaInput, UsuarioUncheckedCreateWithoutLogsAuditoriaInput>
  }

  export type UsuarioUpsertWithoutLogsAuditoriaInput = {
    update: XOR<UsuarioUpdateWithoutLogsAuditoriaInput, UsuarioUncheckedUpdateWithoutLogsAuditoriaInput>
    create: XOR<UsuarioCreateWithoutLogsAuditoriaInput, UsuarioUncheckedCreateWithoutLogsAuditoriaInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutLogsAuditoriaInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutLogsAuditoriaInput, UsuarioUncheckedUpdateWithoutLogsAuditoriaInput>
  }

  export type UsuarioUpdateWithoutLogsAuditoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    region?: StringFieldUpdateOperationsInput | string
    autenticacionDosFactor?: BoolFieldUpdateOperationsInput | boolean
    cambioPasswordRequerido?: BoolFieldUpdateOperationsInput | boolean
    sesionesActivas?: IntFieldUpdateOperationsInput | number
    maxSesionesPermitidas?: IntFieldUpdateOperationsInput | number
    ultimoCambioPassword?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UsuarioRolUpdateManyWithoutUsuarioNestedInput
    activosAcceso?: UsuarioActivoUpdateManyWithoutUsuarioNestedInput
    respuestasCuestionario?: RespuestaCuestionarioUpdateManyWithoutRespondidoPorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutLogsAuditoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    region?: StringFieldUpdateOperationsInput | string
    autenticacionDosFactor?: BoolFieldUpdateOperationsInput | boolean
    cambioPasswordRequerido?: BoolFieldUpdateOperationsInput | boolean
    sesionesActivas?: IntFieldUpdateOperationsInput | number
    maxSesionesPermitidas?: IntFieldUpdateOperationsInput | number
    ultimoCambioPassword?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput
    activosAcceso?: UsuarioActivoUncheckedUpdateManyWithoutUsuarioNestedInput
    respuestasCuestionario?: RespuestaCuestionarioUncheckedUpdateManyWithoutRespondidoPorNestedInput
  }

  export type ActivoAccesoCreateWithoutHijosInput = {
    id?: string
    nombre: string
    tipo: string
    icono?: string | null
    nivelAcceso?: string | null
    expanded?: boolean
    padre?: ActivoAccesoCreateNestedOneWithoutHijosInput
    usuarios?: UsuarioActivoCreateNestedManyWithoutActivoInput
  }

  export type ActivoAccesoUncheckedCreateWithoutHijosInput = {
    id?: string
    nombre: string
    tipo: string
    icono?: string | null
    nivelAcceso?: string | null
    expanded?: boolean
    padreId?: string | null
    usuarios?: UsuarioActivoUncheckedCreateNestedManyWithoutActivoInput
  }

  export type ActivoAccesoCreateOrConnectWithoutHijosInput = {
    where: ActivoAccesoWhereUniqueInput
    create: XOR<ActivoAccesoCreateWithoutHijosInput, ActivoAccesoUncheckedCreateWithoutHijosInput>
  }

  export type ActivoAccesoCreateWithoutPadreInput = {
    id?: string
    nombre: string
    tipo: string
    icono?: string | null
    nivelAcceso?: string | null
    expanded?: boolean
    hijos?: ActivoAccesoCreateNestedManyWithoutPadreInput
    usuarios?: UsuarioActivoCreateNestedManyWithoutActivoInput
  }

  export type ActivoAccesoUncheckedCreateWithoutPadreInput = {
    id?: string
    nombre: string
    tipo: string
    icono?: string | null
    nivelAcceso?: string | null
    expanded?: boolean
    hijos?: ActivoAccesoUncheckedCreateNestedManyWithoutPadreInput
    usuarios?: UsuarioActivoUncheckedCreateNestedManyWithoutActivoInput
  }

  export type ActivoAccesoCreateOrConnectWithoutPadreInput = {
    where: ActivoAccesoWhereUniqueInput
    create: XOR<ActivoAccesoCreateWithoutPadreInput, ActivoAccesoUncheckedCreateWithoutPadreInput>
  }

  export type ActivoAccesoCreateManyPadreInputEnvelope = {
    data: ActivoAccesoCreateManyPadreInput | ActivoAccesoCreateManyPadreInput[]
  }

  export type UsuarioActivoCreateWithoutActivoInput = {
    nivelAcceso?: string
    usuario: UsuarioCreateNestedOneWithoutActivosAccesoInput
  }

  export type UsuarioActivoUncheckedCreateWithoutActivoInput = {
    usuarioId: string
    nivelAcceso?: string
  }

  export type UsuarioActivoCreateOrConnectWithoutActivoInput = {
    where: UsuarioActivoWhereUniqueInput
    create: XOR<UsuarioActivoCreateWithoutActivoInput, UsuarioActivoUncheckedCreateWithoutActivoInput>
  }

  export type UsuarioActivoCreateManyActivoInputEnvelope = {
    data: UsuarioActivoCreateManyActivoInput | UsuarioActivoCreateManyActivoInput[]
  }

  export type ActivoAccesoUpsertWithoutHijosInput = {
    update: XOR<ActivoAccesoUpdateWithoutHijosInput, ActivoAccesoUncheckedUpdateWithoutHijosInput>
    create: XOR<ActivoAccesoCreateWithoutHijosInput, ActivoAccesoUncheckedCreateWithoutHijosInput>
    where?: ActivoAccesoWhereInput
  }

  export type ActivoAccesoUpdateToOneWithWhereWithoutHijosInput = {
    where?: ActivoAccesoWhereInput
    data: XOR<ActivoAccesoUpdateWithoutHijosInput, ActivoAccesoUncheckedUpdateWithoutHijosInput>
  }

  export type ActivoAccesoUpdateWithoutHijosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    expanded?: BoolFieldUpdateOperationsInput | boolean
    padre?: ActivoAccesoUpdateOneWithoutHijosNestedInput
    usuarios?: UsuarioActivoUpdateManyWithoutActivoNestedInput
  }

  export type ActivoAccesoUncheckedUpdateWithoutHijosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    expanded?: BoolFieldUpdateOperationsInput | boolean
    padreId?: NullableStringFieldUpdateOperationsInput | string | null
    usuarios?: UsuarioActivoUncheckedUpdateManyWithoutActivoNestedInput
  }

  export type ActivoAccesoUpsertWithWhereUniqueWithoutPadreInput = {
    where: ActivoAccesoWhereUniqueInput
    update: XOR<ActivoAccesoUpdateWithoutPadreInput, ActivoAccesoUncheckedUpdateWithoutPadreInput>
    create: XOR<ActivoAccesoCreateWithoutPadreInput, ActivoAccesoUncheckedCreateWithoutPadreInput>
  }

  export type ActivoAccesoUpdateWithWhereUniqueWithoutPadreInput = {
    where: ActivoAccesoWhereUniqueInput
    data: XOR<ActivoAccesoUpdateWithoutPadreInput, ActivoAccesoUncheckedUpdateWithoutPadreInput>
  }

  export type ActivoAccesoUpdateManyWithWhereWithoutPadreInput = {
    where: ActivoAccesoScalarWhereInput
    data: XOR<ActivoAccesoUpdateManyMutationInput, ActivoAccesoUncheckedUpdateManyWithoutPadreInput>
  }

  export type ActivoAccesoScalarWhereInput = {
    AND?: ActivoAccesoScalarWhereInput | ActivoAccesoScalarWhereInput[]
    OR?: ActivoAccesoScalarWhereInput[]
    NOT?: ActivoAccesoScalarWhereInput | ActivoAccesoScalarWhereInput[]
    id?: StringFilter<"ActivoAcceso"> | string
    nombre?: StringFilter<"ActivoAcceso"> | string
    tipo?: StringFilter<"ActivoAcceso"> | string
    icono?: StringNullableFilter<"ActivoAcceso"> | string | null
    nivelAcceso?: StringNullableFilter<"ActivoAcceso"> | string | null
    expanded?: BoolFilter<"ActivoAcceso"> | boolean
    padreId?: StringNullableFilter<"ActivoAcceso"> | string | null
  }

  export type UsuarioActivoUpsertWithWhereUniqueWithoutActivoInput = {
    where: UsuarioActivoWhereUniqueInput
    update: XOR<UsuarioActivoUpdateWithoutActivoInput, UsuarioActivoUncheckedUpdateWithoutActivoInput>
    create: XOR<UsuarioActivoCreateWithoutActivoInput, UsuarioActivoUncheckedCreateWithoutActivoInput>
  }

  export type UsuarioActivoUpdateWithWhereUniqueWithoutActivoInput = {
    where: UsuarioActivoWhereUniqueInput
    data: XOR<UsuarioActivoUpdateWithoutActivoInput, UsuarioActivoUncheckedUpdateWithoutActivoInput>
  }

  export type UsuarioActivoUpdateManyWithWhereWithoutActivoInput = {
    where: UsuarioActivoScalarWhereInput
    data: XOR<UsuarioActivoUpdateManyMutationInput, UsuarioActivoUncheckedUpdateManyWithoutActivoInput>
  }

  export type ActivoCreateWithoutPlantillaInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    criticidad: string
    responsable: string
    departamento: string
    fechaRegistro?: Date | string
    updatedAt?: Date | string
    propiedadesCustom?: string | null
    riesgos?: RiesgoCreateNestedManyWithoutActivoInput
    incidentes?: IncidenteCreateNestedManyWithoutActivoInput
    defectos?: DefectoCreateNestedManyWithoutActivoInput
  }

  export type ActivoUncheckedCreateWithoutPlantillaInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    criticidad: string
    responsable: string
    departamento: string
    fechaRegistro?: Date | string
    updatedAt?: Date | string
    propiedadesCustom?: string | null
    riesgos?: RiesgoUncheckedCreateNestedManyWithoutActivoInput
    incidentes?: IncidenteUncheckedCreateNestedManyWithoutActivoInput
    defectos?: DefectoUncheckedCreateNestedManyWithoutActivoInput
  }

  export type ActivoCreateOrConnectWithoutPlantillaInput = {
    where: ActivoWhereUniqueInput
    create: XOR<ActivoCreateWithoutPlantillaInput, ActivoUncheckedCreateWithoutPlantillaInput>
  }

  export type ActivoCreateManyPlantillaInputEnvelope = {
    data: ActivoCreateManyPlantillaInput | ActivoCreateManyPlantillaInput[]
  }

  export type ActivoUpsertWithWhereUniqueWithoutPlantillaInput = {
    where: ActivoWhereUniqueInput
    update: XOR<ActivoUpdateWithoutPlantillaInput, ActivoUncheckedUpdateWithoutPlantillaInput>
    create: XOR<ActivoCreateWithoutPlantillaInput, ActivoUncheckedCreateWithoutPlantillaInput>
  }

  export type ActivoUpdateWithWhereUniqueWithoutPlantillaInput = {
    where: ActivoWhereUniqueInput
    data: XOR<ActivoUpdateWithoutPlantillaInput, ActivoUncheckedUpdateWithoutPlantillaInput>
  }

  export type ActivoUpdateManyWithWhereWithoutPlantillaInput = {
    where: ActivoScalarWhereInput
    data: XOR<ActivoUpdateManyMutationInput, ActivoUncheckedUpdateManyWithoutPlantillaInput>
  }

  export type ActivoScalarWhereInput = {
    AND?: ActivoScalarWhereInput | ActivoScalarWhereInput[]
    OR?: ActivoScalarWhereInput[]
    NOT?: ActivoScalarWhereInput | ActivoScalarWhereInput[]
    id?: StringFilter<"Activo"> | string
    nombre?: StringFilter<"Activo"> | string
    descripcion?: StringFilter<"Activo"> | string
    tipo?: StringFilter<"Activo"> | string
    criticidad?: StringFilter<"Activo"> | string
    responsable?: StringFilter<"Activo"> | string
    departamento?: StringFilter<"Activo"> | string
    fechaRegistro?: DateTimeFilter<"Activo"> | Date | string
    updatedAt?: DateTimeFilter<"Activo"> | Date | string
    plantillaId?: StringNullableFilter<"Activo"> | string | null
    propiedadesCustom?: StringNullableFilter<"Activo"> | string | null
  }

  export type PlantillaActivoCreateWithoutActivosInput = {
    id?: string
    nombre: string
    tipoActivo: string
    descripcion: string
    icono?: string | null
    color?: string | null
    propiedades: string
    activo?: boolean
    fechaCreacion?: Date | string
  }

  export type PlantillaActivoUncheckedCreateWithoutActivosInput = {
    id?: string
    nombre: string
    tipoActivo: string
    descripcion: string
    icono?: string | null
    color?: string | null
    propiedades: string
    activo?: boolean
    fechaCreacion?: Date | string
  }

  export type PlantillaActivoCreateOrConnectWithoutActivosInput = {
    where: PlantillaActivoWhereUniqueInput
    create: XOR<PlantillaActivoCreateWithoutActivosInput, PlantillaActivoUncheckedCreateWithoutActivosInput>
  }

  export type RiesgoCreateWithoutActivoInput = {
    id?: string
    descripcion: string
    probabilidad: number
    impacto: number
    estado: string
    fechaIdentificacion?: Date | string
    responsable: string
    updatedAt?: Date | string
  }

  export type RiesgoUncheckedCreateWithoutActivoInput = {
    id?: string
    descripcion: string
    probabilidad: number
    impacto: number
    estado: string
    fechaIdentificacion?: Date | string
    responsable: string
    updatedAt?: Date | string
  }

  export type RiesgoCreateOrConnectWithoutActivoInput = {
    where: RiesgoWhereUniqueInput
    create: XOR<RiesgoCreateWithoutActivoInput, RiesgoUncheckedCreateWithoutActivoInput>
  }

  export type RiesgoCreateManyActivoInputEnvelope = {
    data: RiesgoCreateManyActivoInput | RiesgoCreateManyActivoInput[]
  }

  export type IncidenteCreateWithoutActivoInput = {
    id?: string
    titulo: string
    descripcion: string
    severidad: string
    estado: string
    fechaReporte?: Date | string
    reportadoPor: string
    updatedAt?: Date | string
  }

  export type IncidenteUncheckedCreateWithoutActivoInput = {
    id?: string
    titulo: string
    descripcion: string
    severidad: string
    estado: string
    fechaReporte?: Date | string
    reportadoPor: string
    updatedAt?: Date | string
  }

  export type IncidenteCreateOrConnectWithoutActivoInput = {
    where: IncidenteWhereUniqueInput
    create: XOR<IncidenteCreateWithoutActivoInput, IncidenteUncheckedCreateWithoutActivoInput>
  }

  export type IncidenteCreateManyActivoInputEnvelope = {
    data: IncidenteCreateManyActivoInput | IncidenteCreateManyActivoInput[]
  }

  export type DefectoCreateWithoutActivoInput = {
    id?: string
    titulo: string
    descripcion: string
    tipo: string
    prioridad: string
    estado: string
    fechaDeteccion?: Date | string
    detectadoPor: string
    updatedAt?: Date | string
  }

  export type DefectoUncheckedCreateWithoutActivoInput = {
    id?: string
    titulo: string
    descripcion: string
    tipo: string
    prioridad: string
    estado: string
    fechaDeteccion?: Date | string
    detectadoPor: string
    updatedAt?: Date | string
  }

  export type DefectoCreateOrConnectWithoutActivoInput = {
    where: DefectoWhereUniqueInput
    create: XOR<DefectoCreateWithoutActivoInput, DefectoUncheckedCreateWithoutActivoInput>
  }

  export type DefectoCreateManyActivoInputEnvelope = {
    data: DefectoCreateManyActivoInput | DefectoCreateManyActivoInput[]
  }

  export type PlantillaActivoUpsertWithoutActivosInput = {
    update: XOR<PlantillaActivoUpdateWithoutActivosInput, PlantillaActivoUncheckedUpdateWithoutActivosInput>
    create: XOR<PlantillaActivoCreateWithoutActivosInput, PlantillaActivoUncheckedCreateWithoutActivosInput>
    where?: PlantillaActivoWhereInput
  }

  export type PlantillaActivoUpdateToOneWithWhereWithoutActivosInput = {
    where?: PlantillaActivoWhereInput
    data: XOR<PlantillaActivoUpdateWithoutActivosInput, PlantillaActivoUncheckedUpdateWithoutActivosInput>
  }

  export type PlantillaActivoUpdateWithoutActivosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipoActivo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    propiedades?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantillaActivoUncheckedUpdateWithoutActivosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipoActivo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    propiedades?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiesgoUpsertWithWhereUniqueWithoutActivoInput = {
    where: RiesgoWhereUniqueInput
    update: XOR<RiesgoUpdateWithoutActivoInput, RiesgoUncheckedUpdateWithoutActivoInput>
    create: XOR<RiesgoCreateWithoutActivoInput, RiesgoUncheckedCreateWithoutActivoInput>
  }

  export type RiesgoUpdateWithWhereUniqueWithoutActivoInput = {
    where: RiesgoWhereUniqueInput
    data: XOR<RiesgoUpdateWithoutActivoInput, RiesgoUncheckedUpdateWithoutActivoInput>
  }

  export type RiesgoUpdateManyWithWhereWithoutActivoInput = {
    where: RiesgoScalarWhereInput
    data: XOR<RiesgoUpdateManyMutationInput, RiesgoUncheckedUpdateManyWithoutActivoInput>
  }

  export type RiesgoScalarWhereInput = {
    AND?: RiesgoScalarWhereInput | RiesgoScalarWhereInput[]
    OR?: RiesgoScalarWhereInput[]
    NOT?: RiesgoScalarWhereInput | RiesgoScalarWhereInput[]
    id?: StringFilter<"Riesgo"> | string
    activoId?: StringFilter<"Riesgo"> | string
    descripcion?: StringFilter<"Riesgo"> | string
    probabilidad?: IntFilter<"Riesgo"> | number
    impacto?: IntFilter<"Riesgo"> | number
    estado?: StringFilter<"Riesgo"> | string
    fechaIdentificacion?: DateTimeFilter<"Riesgo"> | Date | string
    responsable?: StringFilter<"Riesgo"> | string
    updatedAt?: DateTimeFilter<"Riesgo"> | Date | string
  }

  export type IncidenteUpsertWithWhereUniqueWithoutActivoInput = {
    where: IncidenteWhereUniqueInput
    update: XOR<IncidenteUpdateWithoutActivoInput, IncidenteUncheckedUpdateWithoutActivoInput>
    create: XOR<IncidenteCreateWithoutActivoInput, IncidenteUncheckedCreateWithoutActivoInput>
  }

  export type IncidenteUpdateWithWhereUniqueWithoutActivoInput = {
    where: IncidenteWhereUniqueInput
    data: XOR<IncidenteUpdateWithoutActivoInput, IncidenteUncheckedUpdateWithoutActivoInput>
  }

  export type IncidenteUpdateManyWithWhereWithoutActivoInput = {
    where: IncidenteScalarWhereInput
    data: XOR<IncidenteUpdateManyMutationInput, IncidenteUncheckedUpdateManyWithoutActivoInput>
  }

  export type IncidenteScalarWhereInput = {
    AND?: IncidenteScalarWhereInput | IncidenteScalarWhereInput[]
    OR?: IncidenteScalarWhereInput[]
    NOT?: IncidenteScalarWhereInput | IncidenteScalarWhereInput[]
    id?: StringFilter<"Incidente"> | string
    activoId?: StringFilter<"Incidente"> | string
    titulo?: StringFilter<"Incidente"> | string
    descripcion?: StringFilter<"Incidente"> | string
    severidad?: StringFilter<"Incidente"> | string
    estado?: StringFilter<"Incidente"> | string
    fechaReporte?: DateTimeFilter<"Incidente"> | Date | string
    reportadoPor?: StringFilter<"Incidente"> | string
    updatedAt?: DateTimeFilter<"Incidente"> | Date | string
  }

  export type DefectoUpsertWithWhereUniqueWithoutActivoInput = {
    where: DefectoWhereUniqueInput
    update: XOR<DefectoUpdateWithoutActivoInput, DefectoUncheckedUpdateWithoutActivoInput>
    create: XOR<DefectoCreateWithoutActivoInput, DefectoUncheckedCreateWithoutActivoInput>
  }

  export type DefectoUpdateWithWhereUniqueWithoutActivoInput = {
    where: DefectoWhereUniqueInput
    data: XOR<DefectoUpdateWithoutActivoInput, DefectoUncheckedUpdateWithoutActivoInput>
  }

  export type DefectoUpdateManyWithWhereWithoutActivoInput = {
    where: DefectoScalarWhereInput
    data: XOR<DefectoUpdateManyMutationInput, DefectoUncheckedUpdateManyWithoutActivoInput>
  }

  export type DefectoScalarWhereInput = {
    AND?: DefectoScalarWhereInput | DefectoScalarWhereInput[]
    OR?: DefectoScalarWhereInput[]
    NOT?: DefectoScalarWhereInput | DefectoScalarWhereInput[]
    id?: StringFilter<"Defecto"> | string
    activoId?: StringFilter<"Defecto"> | string
    titulo?: StringFilter<"Defecto"> | string
    descripcion?: StringFilter<"Defecto"> | string
    tipo?: StringFilter<"Defecto"> | string
    prioridad?: StringFilter<"Defecto"> | string
    estado?: StringFilter<"Defecto"> | string
    fechaDeteccion?: DateTimeFilter<"Defecto"> | Date | string
    detectadoPor?: StringFilter<"Defecto"> | string
    updatedAt?: DateTimeFilter<"Defecto"> | Date | string
  }

  export type ActivoCreateWithoutRiesgosInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    criticidad: string
    responsable: string
    departamento: string
    fechaRegistro?: Date | string
    updatedAt?: Date | string
    propiedadesCustom?: string | null
    plantilla?: PlantillaActivoCreateNestedOneWithoutActivosInput
    incidentes?: IncidenteCreateNestedManyWithoutActivoInput
    defectos?: DefectoCreateNestedManyWithoutActivoInput
  }

  export type ActivoUncheckedCreateWithoutRiesgosInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    criticidad: string
    responsable: string
    departamento: string
    fechaRegistro?: Date | string
    updatedAt?: Date | string
    plantillaId?: string | null
    propiedadesCustom?: string | null
    incidentes?: IncidenteUncheckedCreateNestedManyWithoutActivoInput
    defectos?: DefectoUncheckedCreateNestedManyWithoutActivoInput
  }

  export type ActivoCreateOrConnectWithoutRiesgosInput = {
    where: ActivoWhereUniqueInput
    create: XOR<ActivoCreateWithoutRiesgosInput, ActivoUncheckedCreateWithoutRiesgosInput>
  }

  export type ActivoUpsertWithoutRiesgosInput = {
    update: XOR<ActivoUpdateWithoutRiesgosInput, ActivoUncheckedUpdateWithoutRiesgosInput>
    create: XOR<ActivoCreateWithoutRiesgosInput, ActivoUncheckedCreateWithoutRiesgosInput>
    where?: ActivoWhereInput
  }

  export type ActivoUpdateToOneWithWhereWithoutRiesgosInput = {
    where?: ActivoWhereInput
    data: XOR<ActivoUpdateWithoutRiesgosInput, ActivoUncheckedUpdateWithoutRiesgosInput>
  }

  export type ActivoUpdateWithoutRiesgosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    criticidad?: StringFieldUpdateOperationsInput | string
    responsable?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propiedadesCustom?: NullableStringFieldUpdateOperationsInput | string | null
    plantilla?: PlantillaActivoUpdateOneWithoutActivosNestedInput
    incidentes?: IncidenteUpdateManyWithoutActivoNestedInput
    defectos?: DefectoUpdateManyWithoutActivoNestedInput
  }

  export type ActivoUncheckedUpdateWithoutRiesgosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    criticidad?: StringFieldUpdateOperationsInput | string
    responsable?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plantillaId?: NullableStringFieldUpdateOperationsInput | string | null
    propiedadesCustom?: NullableStringFieldUpdateOperationsInput | string | null
    incidentes?: IncidenteUncheckedUpdateManyWithoutActivoNestedInput
    defectos?: DefectoUncheckedUpdateManyWithoutActivoNestedInput
  }

  export type ActivoCreateWithoutIncidentesInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    criticidad: string
    responsable: string
    departamento: string
    fechaRegistro?: Date | string
    updatedAt?: Date | string
    propiedadesCustom?: string | null
    plantilla?: PlantillaActivoCreateNestedOneWithoutActivosInput
    riesgos?: RiesgoCreateNestedManyWithoutActivoInput
    defectos?: DefectoCreateNestedManyWithoutActivoInput
  }

  export type ActivoUncheckedCreateWithoutIncidentesInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    criticidad: string
    responsable: string
    departamento: string
    fechaRegistro?: Date | string
    updatedAt?: Date | string
    plantillaId?: string | null
    propiedadesCustom?: string | null
    riesgos?: RiesgoUncheckedCreateNestedManyWithoutActivoInput
    defectos?: DefectoUncheckedCreateNestedManyWithoutActivoInput
  }

  export type ActivoCreateOrConnectWithoutIncidentesInput = {
    where: ActivoWhereUniqueInput
    create: XOR<ActivoCreateWithoutIncidentesInput, ActivoUncheckedCreateWithoutIncidentesInput>
  }

  export type ActivoUpsertWithoutIncidentesInput = {
    update: XOR<ActivoUpdateWithoutIncidentesInput, ActivoUncheckedUpdateWithoutIncidentesInput>
    create: XOR<ActivoCreateWithoutIncidentesInput, ActivoUncheckedCreateWithoutIncidentesInput>
    where?: ActivoWhereInput
  }

  export type ActivoUpdateToOneWithWhereWithoutIncidentesInput = {
    where?: ActivoWhereInput
    data: XOR<ActivoUpdateWithoutIncidentesInput, ActivoUncheckedUpdateWithoutIncidentesInput>
  }

  export type ActivoUpdateWithoutIncidentesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    criticidad?: StringFieldUpdateOperationsInput | string
    responsable?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propiedadesCustom?: NullableStringFieldUpdateOperationsInput | string | null
    plantilla?: PlantillaActivoUpdateOneWithoutActivosNestedInput
    riesgos?: RiesgoUpdateManyWithoutActivoNestedInput
    defectos?: DefectoUpdateManyWithoutActivoNestedInput
  }

  export type ActivoUncheckedUpdateWithoutIncidentesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    criticidad?: StringFieldUpdateOperationsInput | string
    responsable?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plantillaId?: NullableStringFieldUpdateOperationsInput | string | null
    propiedadesCustom?: NullableStringFieldUpdateOperationsInput | string | null
    riesgos?: RiesgoUncheckedUpdateManyWithoutActivoNestedInput
    defectos?: DefectoUncheckedUpdateManyWithoutActivoNestedInput
  }

  export type ActivoCreateWithoutDefectosInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    criticidad: string
    responsable: string
    departamento: string
    fechaRegistro?: Date | string
    updatedAt?: Date | string
    propiedadesCustom?: string | null
    plantilla?: PlantillaActivoCreateNestedOneWithoutActivosInput
    riesgos?: RiesgoCreateNestedManyWithoutActivoInput
    incidentes?: IncidenteCreateNestedManyWithoutActivoInput
  }

  export type ActivoUncheckedCreateWithoutDefectosInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    criticidad: string
    responsable: string
    departamento: string
    fechaRegistro?: Date | string
    updatedAt?: Date | string
    plantillaId?: string | null
    propiedadesCustom?: string | null
    riesgos?: RiesgoUncheckedCreateNestedManyWithoutActivoInput
    incidentes?: IncidenteUncheckedCreateNestedManyWithoutActivoInput
  }

  export type ActivoCreateOrConnectWithoutDefectosInput = {
    where: ActivoWhereUniqueInput
    create: XOR<ActivoCreateWithoutDefectosInput, ActivoUncheckedCreateWithoutDefectosInput>
  }

  export type ActivoUpsertWithoutDefectosInput = {
    update: XOR<ActivoUpdateWithoutDefectosInput, ActivoUncheckedUpdateWithoutDefectosInput>
    create: XOR<ActivoCreateWithoutDefectosInput, ActivoUncheckedCreateWithoutDefectosInput>
    where?: ActivoWhereInput
  }

  export type ActivoUpdateToOneWithWhereWithoutDefectosInput = {
    where?: ActivoWhereInput
    data: XOR<ActivoUpdateWithoutDefectosInput, ActivoUncheckedUpdateWithoutDefectosInput>
  }

  export type ActivoUpdateWithoutDefectosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    criticidad?: StringFieldUpdateOperationsInput | string
    responsable?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propiedadesCustom?: NullableStringFieldUpdateOperationsInput | string | null
    plantilla?: PlantillaActivoUpdateOneWithoutActivosNestedInput
    riesgos?: RiesgoUpdateManyWithoutActivoNestedInput
    incidentes?: IncidenteUpdateManyWithoutActivoNestedInput
  }

  export type ActivoUncheckedUpdateWithoutDefectosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    criticidad?: StringFieldUpdateOperationsInput | string
    responsable?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plantillaId?: NullableStringFieldUpdateOperationsInput | string | null
    propiedadesCustom?: NullableStringFieldUpdateOperationsInput | string | null
    riesgos?: RiesgoUncheckedUpdateManyWithoutActivoNestedInput
    incidentes?: IncidenteUncheckedUpdateManyWithoutActivoNestedInput
  }

  export type NodoOrganigramaCreateWithoutOrganigramaInput = {
    id?: string
    nombre: string
    cargo: string
    departamento: string
    email: string
    telefono?: string | null
    foto?: string | null
    padre?: NodoOrganigramaCreateNestedOneWithoutSubordinadosInput
    subordinados?: NodoOrganigramaCreateNestedManyWithoutPadreInput
  }

  export type NodoOrganigramaUncheckedCreateWithoutOrganigramaInput = {
    id?: string
    nombre: string
    cargo: string
    departamento: string
    email: string
    telefono?: string | null
    foto?: string | null
    padreId?: string | null
    subordinados?: NodoOrganigramaUncheckedCreateNestedManyWithoutPadreInput
  }

  export type NodoOrganigramaCreateOrConnectWithoutOrganigramaInput = {
    where: NodoOrganigramaWhereUniqueInput
    create: XOR<NodoOrganigramaCreateWithoutOrganigramaInput, NodoOrganigramaUncheckedCreateWithoutOrganigramaInput>
  }

  export type NodoOrganigramaCreateManyOrganigramaInputEnvelope = {
    data: NodoOrganigramaCreateManyOrganigramaInput | NodoOrganigramaCreateManyOrganigramaInput[]
  }

  export type NodoOrganigramaUpsertWithWhereUniqueWithoutOrganigramaInput = {
    where: NodoOrganigramaWhereUniqueInput
    update: XOR<NodoOrganigramaUpdateWithoutOrganigramaInput, NodoOrganigramaUncheckedUpdateWithoutOrganigramaInput>
    create: XOR<NodoOrganigramaCreateWithoutOrganigramaInput, NodoOrganigramaUncheckedCreateWithoutOrganigramaInput>
  }

  export type NodoOrganigramaUpdateWithWhereUniqueWithoutOrganigramaInput = {
    where: NodoOrganigramaWhereUniqueInput
    data: XOR<NodoOrganigramaUpdateWithoutOrganigramaInput, NodoOrganigramaUncheckedUpdateWithoutOrganigramaInput>
  }

  export type NodoOrganigramaUpdateManyWithWhereWithoutOrganigramaInput = {
    where: NodoOrganigramaScalarWhereInput
    data: XOR<NodoOrganigramaUpdateManyMutationInput, NodoOrganigramaUncheckedUpdateManyWithoutOrganigramaInput>
  }

  export type NodoOrganigramaScalarWhereInput = {
    AND?: NodoOrganigramaScalarWhereInput | NodoOrganigramaScalarWhereInput[]
    OR?: NodoOrganigramaScalarWhereInput[]
    NOT?: NodoOrganigramaScalarWhereInput | NodoOrganigramaScalarWhereInput[]
    id?: StringFilter<"NodoOrganigrama"> | string
    organigramaId?: StringFilter<"NodoOrganigrama"> | string
    nombre?: StringFilter<"NodoOrganigrama"> | string
    cargo?: StringFilter<"NodoOrganigrama"> | string
    departamento?: StringFilter<"NodoOrganigrama"> | string
    email?: StringFilter<"NodoOrganigrama"> | string
    telefono?: StringNullableFilter<"NodoOrganigrama"> | string | null
    foto?: StringNullableFilter<"NodoOrganigrama"> | string | null
    padreId?: StringNullableFilter<"NodoOrganigrama"> | string | null
  }

  export type OrganigramaCreateWithoutNodosInput = {
    id?: string
    nombre: string
    descripcion: string
    fechaCreacion?: Date | string
    updatedAt?: Date | string
  }

  export type OrganigramaUncheckedCreateWithoutNodosInput = {
    id?: string
    nombre: string
    descripcion: string
    fechaCreacion?: Date | string
    updatedAt?: Date | string
  }

  export type OrganigramaCreateOrConnectWithoutNodosInput = {
    where: OrganigramaWhereUniqueInput
    create: XOR<OrganigramaCreateWithoutNodosInput, OrganigramaUncheckedCreateWithoutNodosInput>
  }

  export type NodoOrganigramaCreateWithoutSubordinadosInput = {
    id?: string
    nombre: string
    cargo: string
    departamento: string
    email: string
    telefono?: string | null
    foto?: string | null
    organigrama: OrganigramaCreateNestedOneWithoutNodosInput
    padre?: NodoOrganigramaCreateNestedOneWithoutSubordinadosInput
  }

  export type NodoOrganigramaUncheckedCreateWithoutSubordinadosInput = {
    id?: string
    organigramaId: string
    nombre: string
    cargo: string
    departamento: string
    email: string
    telefono?: string | null
    foto?: string | null
    padreId?: string | null
  }

  export type NodoOrganigramaCreateOrConnectWithoutSubordinadosInput = {
    where: NodoOrganigramaWhereUniqueInput
    create: XOR<NodoOrganigramaCreateWithoutSubordinadosInput, NodoOrganigramaUncheckedCreateWithoutSubordinadosInput>
  }

  export type NodoOrganigramaCreateWithoutPadreInput = {
    id?: string
    nombre: string
    cargo: string
    departamento: string
    email: string
    telefono?: string | null
    foto?: string | null
    organigrama: OrganigramaCreateNestedOneWithoutNodosInput
    subordinados?: NodoOrganigramaCreateNestedManyWithoutPadreInput
  }

  export type NodoOrganigramaUncheckedCreateWithoutPadreInput = {
    id?: string
    organigramaId: string
    nombre: string
    cargo: string
    departamento: string
    email: string
    telefono?: string | null
    foto?: string | null
    subordinados?: NodoOrganigramaUncheckedCreateNestedManyWithoutPadreInput
  }

  export type NodoOrganigramaCreateOrConnectWithoutPadreInput = {
    where: NodoOrganigramaWhereUniqueInput
    create: XOR<NodoOrganigramaCreateWithoutPadreInput, NodoOrganigramaUncheckedCreateWithoutPadreInput>
  }

  export type NodoOrganigramaCreateManyPadreInputEnvelope = {
    data: NodoOrganigramaCreateManyPadreInput | NodoOrganigramaCreateManyPadreInput[]
  }

  export type OrganigramaUpsertWithoutNodosInput = {
    update: XOR<OrganigramaUpdateWithoutNodosInput, OrganigramaUncheckedUpdateWithoutNodosInput>
    create: XOR<OrganigramaCreateWithoutNodosInput, OrganigramaUncheckedCreateWithoutNodosInput>
    where?: OrganigramaWhereInput
  }

  export type OrganigramaUpdateToOneWithWhereWithoutNodosInput = {
    where?: OrganigramaWhereInput
    data: XOR<OrganigramaUpdateWithoutNodosInput, OrganigramaUncheckedUpdateWithoutNodosInput>
  }

  export type OrganigramaUpdateWithoutNodosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganigramaUncheckedUpdateWithoutNodosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodoOrganigramaUpsertWithoutSubordinadosInput = {
    update: XOR<NodoOrganigramaUpdateWithoutSubordinadosInput, NodoOrganigramaUncheckedUpdateWithoutSubordinadosInput>
    create: XOR<NodoOrganigramaCreateWithoutSubordinadosInput, NodoOrganigramaUncheckedCreateWithoutSubordinadosInput>
    where?: NodoOrganigramaWhereInput
  }

  export type NodoOrganigramaUpdateToOneWithWhereWithoutSubordinadosInput = {
    where?: NodoOrganigramaWhereInput
    data: XOR<NodoOrganigramaUpdateWithoutSubordinadosInput, NodoOrganigramaUncheckedUpdateWithoutSubordinadosInput>
  }

  export type NodoOrganigramaUpdateWithoutSubordinadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    organigrama?: OrganigramaUpdateOneRequiredWithoutNodosNestedInput
    padre?: NodoOrganigramaUpdateOneWithoutSubordinadosNestedInput
  }

  export type NodoOrganigramaUncheckedUpdateWithoutSubordinadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    organigramaId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    padreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NodoOrganigramaUpsertWithWhereUniqueWithoutPadreInput = {
    where: NodoOrganigramaWhereUniqueInput
    update: XOR<NodoOrganigramaUpdateWithoutPadreInput, NodoOrganigramaUncheckedUpdateWithoutPadreInput>
    create: XOR<NodoOrganigramaCreateWithoutPadreInput, NodoOrganigramaUncheckedCreateWithoutPadreInput>
  }

  export type NodoOrganigramaUpdateWithWhereUniqueWithoutPadreInput = {
    where: NodoOrganigramaWhereUniqueInput
    data: XOR<NodoOrganigramaUpdateWithoutPadreInput, NodoOrganigramaUncheckedUpdateWithoutPadreInput>
  }

  export type NodoOrganigramaUpdateManyWithWhereWithoutPadreInput = {
    where: NodoOrganigramaScalarWhereInput
    data: XOR<NodoOrganigramaUpdateManyMutationInput, NodoOrganigramaUncheckedUpdateManyWithoutPadreInput>
  }

  export type RequisitoNormativoCreateWithoutMarcoInput = {
    id?: string
    codigo: string
    nombre: string
    descripcion: string
    controlesAsociados: string
  }

  export type RequisitoNormativoUncheckedCreateWithoutMarcoInput = {
    id?: string
    codigo: string
    nombre: string
    descripcion: string
    controlesAsociados: string
  }

  export type RequisitoNormativoCreateOrConnectWithoutMarcoInput = {
    where: RequisitoNormativoWhereUniqueInput
    create: XOR<RequisitoNormativoCreateWithoutMarcoInput, RequisitoNormativoUncheckedCreateWithoutMarcoInput>
  }

  export type RequisitoNormativoCreateManyMarcoInputEnvelope = {
    data: RequisitoNormativoCreateManyMarcoInput | RequisitoNormativoCreateManyMarcoInput[]
  }

  export type CuestionarioCreateWithoutMarcoNormativoInput = {
    id?: string
    nombre: string
    descripcion: string
    categoria: string
    tipo: string
    tipoEvaluacion: string
    estado?: string
    periodicidad: string
    tasaCompletado?: number
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    umbrales: string
    areasObjetivo: string
    responsables: string
    secciones?: SeccionCreateNestedManyWithoutCuestionarioInput
    asignaciones?: AsignacionCuestionarioCreateNestedManyWithoutCuestionarioInput
  }

  export type CuestionarioUncheckedCreateWithoutMarcoNormativoInput = {
    id?: string
    nombre: string
    descripcion: string
    categoria: string
    tipo: string
    tipoEvaluacion: string
    estado?: string
    periodicidad: string
    tasaCompletado?: number
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    umbrales: string
    areasObjetivo: string
    responsables: string
    secciones?: SeccionUncheckedCreateNestedManyWithoutCuestionarioInput
    asignaciones?: AsignacionCuestionarioUncheckedCreateNestedManyWithoutCuestionarioInput
  }

  export type CuestionarioCreateOrConnectWithoutMarcoNormativoInput = {
    where: CuestionarioWhereUniqueInput
    create: XOR<CuestionarioCreateWithoutMarcoNormativoInput, CuestionarioUncheckedCreateWithoutMarcoNormativoInput>
  }

  export type CuestionarioCreateManyMarcoNormativoInputEnvelope = {
    data: CuestionarioCreateManyMarcoNormativoInput | CuestionarioCreateManyMarcoNormativoInput[]
  }

  export type RequisitoNormativoUpsertWithWhereUniqueWithoutMarcoInput = {
    where: RequisitoNormativoWhereUniqueInput
    update: XOR<RequisitoNormativoUpdateWithoutMarcoInput, RequisitoNormativoUncheckedUpdateWithoutMarcoInput>
    create: XOR<RequisitoNormativoCreateWithoutMarcoInput, RequisitoNormativoUncheckedCreateWithoutMarcoInput>
  }

  export type RequisitoNormativoUpdateWithWhereUniqueWithoutMarcoInput = {
    where: RequisitoNormativoWhereUniqueInput
    data: XOR<RequisitoNormativoUpdateWithoutMarcoInput, RequisitoNormativoUncheckedUpdateWithoutMarcoInput>
  }

  export type RequisitoNormativoUpdateManyWithWhereWithoutMarcoInput = {
    where: RequisitoNormativoScalarWhereInput
    data: XOR<RequisitoNormativoUpdateManyMutationInput, RequisitoNormativoUncheckedUpdateManyWithoutMarcoInput>
  }

  export type RequisitoNormativoScalarWhereInput = {
    AND?: RequisitoNormativoScalarWhereInput | RequisitoNormativoScalarWhereInput[]
    OR?: RequisitoNormativoScalarWhereInput[]
    NOT?: RequisitoNormativoScalarWhereInput | RequisitoNormativoScalarWhereInput[]
    id?: StringFilter<"RequisitoNormativo"> | string
    codigo?: StringFilter<"RequisitoNormativo"> | string
    nombre?: StringFilter<"RequisitoNormativo"> | string
    descripcion?: StringFilter<"RequisitoNormativo"> | string
    marcoId?: StringFilter<"RequisitoNormativo"> | string
    controlesAsociados?: StringFilter<"RequisitoNormativo"> | string
  }

  export type CuestionarioUpsertWithWhereUniqueWithoutMarcoNormativoInput = {
    where: CuestionarioWhereUniqueInput
    update: XOR<CuestionarioUpdateWithoutMarcoNormativoInput, CuestionarioUncheckedUpdateWithoutMarcoNormativoInput>
    create: XOR<CuestionarioCreateWithoutMarcoNormativoInput, CuestionarioUncheckedCreateWithoutMarcoNormativoInput>
  }

  export type CuestionarioUpdateWithWhereUniqueWithoutMarcoNormativoInput = {
    where: CuestionarioWhereUniqueInput
    data: XOR<CuestionarioUpdateWithoutMarcoNormativoInput, CuestionarioUncheckedUpdateWithoutMarcoNormativoInput>
  }

  export type CuestionarioUpdateManyWithWhereWithoutMarcoNormativoInput = {
    where: CuestionarioScalarWhereInput
    data: XOR<CuestionarioUpdateManyMutationInput, CuestionarioUncheckedUpdateManyWithoutMarcoNormativoInput>
  }

  export type CuestionarioScalarWhereInput = {
    AND?: CuestionarioScalarWhereInput | CuestionarioScalarWhereInput[]
    OR?: CuestionarioScalarWhereInput[]
    NOT?: CuestionarioScalarWhereInput | CuestionarioScalarWhereInput[]
    id?: StringFilter<"Cuestionario"> | string
    nombre?: StringFilter<"Cuestionario"> | string
    descripcion?: StringFilter<"Cuestionario"> | string
    categoria?: StringFilter<"Cuestionario"> | string
    tipo?: StringFilter<"Cuestionario"> | string
    tipoEvaluacion?: StringFilter<"Cuestionario"> | string
    estado?: StringFilter<"Cuestionario"> | string
    marcoNormativoId?: StringNullableFilter<"Cuestionario"> | string | null
    periodicidad?: StringFilter<"Cuestionario"> | string
    tasaCompletado?: FloatFilter<"Cuestionario"> | number
    fechaCreacion?: DateTimeFilter<"Cuestionario"> | Date | string
    fechaModificacion?: DateTimeFilter<"Cuestionario"> | Date | string
    umbrales?: StringFilter<"Cuestionario"> | string
    areasObjetivo?: StringFilter<"Cuestionario"> | string
    responsables?: StringFilter<"Cuestionario"> | string
  }

  export type MarcoNormativoCreateWithoutRequisitosInput = {
    id?: string
    nombre: string
    acronimo: string
    version: string
    fechaVigencia: Date | string
    descripcion: string
    activo?: boolean
    fechaCreacion?: Date | string
    cuestionarios?: CuestionarioCreateNestedManyWithoutMarcoNormativoInput
  }

  export type MarcoNormativoUncheckedCreateWithoutRequisitosInput = {
    id?: string
    nombre: string
    acronimo: string
    version: string
    fechaVigencia: Date | string
    descripcion: string
    activo?: boolean
    fechaCreacion?: Date | string
    cuestionarios?: CuestionarioUncheckedCreateNestedManyWithoutMarcoNormativoInput
  }

  export type MarcoNormativoCreateOrConnectWithoutRequisitosInput = {
    where: MarcoNormativoWhereUniqueInput
    create: XOR<MarcoNormativoCreateWithoutRequisitosInput, MarcoNormativoUncheckedCreateWithoutRequisitosInput>
  }

  export type MarcoNormativoUpsertWithoutRequisitosInput = {
    update: XOR<MarcoNormativoUpdateWithoutRequisitosInput, MarcoNormativoUncheckedUpdateWithoutRequisitosInput>
    create: XOR<MarcoNormativoCreateWithoutRequisitosInput, MarcoNormativoUncheckedCreateWithoutRequisitosInput>
    where?: MarcoNormativoWhereInput
  }

  export type MarcoNormativoUpdateToOneWithWhereWithoutRequisitosInput = {
    where?: MarcoNormativoWhereInput
    data: XOR<MarcoNormativoUpdateWithoutRequisitosInput, MarcoNormativoUncheckedUpdateWithoutRequisitosInput>
  }

  export type MarcoNormativoUpdateWithoutRequisitosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    acronimo?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    fechaVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    cuestionarios?: CuestionarioUpdateManyWithoutMarcoNormativoNestedInput
  }

  export type MarcoNormativoUncheckedUpdateWithoutRequisitosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    acronimo?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    fechaVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    cuestionarios?: CuestionarioUncheckedUpdateManyWithoutMarcoNormativoNestedInput
  }

  export type MarcoNormativoCreateWithoutCuestionariosInput = {
    id?: string
    nombre: string
    acronimo: string
    version: string
    fechaVigencia: Date | string
    descripcion: string
    activo?: boolean
    fechaCreacion?: Date | string
    requisitos?: RequisitoNormativoCreateNestedManyWithoutMarcoInput
  }

  export type MarcoNormativoUncheckedCreateWithoutCuestionariosInput = {
    id?: string
    nombre: string
    acronimo: string
    version: string
    fechaVigencia: Date | string
    descripcion: string
    activo?: boolean
    fechaCreacion?: Date | string
    requisitos?: RequisitoNormativoUncheckedCreateNestedManyWithoutMarcoInput
  }

  export type MarcoNormativoCreateOrConnectWithoutCuestionariosInput = {
    where: MarcoNormativoWhereUniqueInput
    create: XOR<MarcoNormativoCreateWithoutCuestionariosInput, MarcoNormativoUncheckedCreateWithoutCuestionariosInput>
  }

  export type SeccionCreateWithoutCuestionarioInput = {
    id?: string
    nombre: string
    descripcion: string
    peso?: number
    requerida?: boolean
    orden?: number
    preguntas?: PreguntaCreateNestedManyWithoutSeccionInput
  }

  export type SeccionUncheckedCreateWithoutCuestionarioInput = {
    id?: string
    nombre: string
    descripcion: string
    peso?: number
    requerida?: boolean
    orden?: number
    preguntas?: PreguntaUncheckedCreateNestedManyWithoutSeccionInput
  }

  export type SeccionCreateOrConnectWithoutCuestionarioInput = {
    where: SeccionWhereUniqueInput
    create: XOR<SeccionCreateWithoutCuestionarioInput, SeccionUncheckedCreateWithoutCuestionarioInput>
  }

  export type SeccionCreateManyCuestionarioInputEnvelope = {
    data: SeccionCreateManyCuestionarioInput | SeccionCreateManyCuestionarioInput[]
  }

  export type AsignacionCuestionarioCreateWithoutCuestionarioInput = {
    id?: string
    cuestionarioIds?: string | null
    titulo: string
    descripcion?: string | null
    tipoRevision: string
    usuariosAsignados: string
    usuariosAsignadosNombres: string
    emailsExternos?: string | null
    contrasenaAcceso?: string | null
    activosObjetivo: string
    activosObjetivoNombres: string
    procesosObjetivo: string
    procesosObjetivoNombres: string
    aprobadores: string
    aprobadoresNombres: string
    evaluadosInternos?: string | null
    evaluadosInternosNombres?: string | null
    areaId: string
    areaNombre: string
    responsableId: string
    responsableNombre: string
    fechaAsignacion?: Date | string
    fechaInicio: Date | string
    fechaVencimiento: Date | string
    estado?: string
    progreso?: number
    instrucciones?: string | null
    recordatorios?: boolean
    tokenAccesoExterno?: string | null
    recurrencia?: string | null
    evaluadosExternos?: EvaluadoExternoCreateNestedManyWithoutAsignacionInput
    respuestas?: RespuestaCuestionarioCreateNestedManyWithoutAsignacionInput
    mensajesChat?: MensajeChatCreateNestedManyWithoutAsignacionInput
  }

  export type AsignacionCuestionarioUncheckedCreateWithoutCuestionarioInput = {
    id?: string
    cuestionarioIds?: string | null
    titulo: string
    descripcion?: string | null
    tipoRevision: string
    usuariosAsignados: string
    usuariosAsignadosNombres: string
    emailsExternos?: string | null
    contrasenaAcceso?: string | null
    activosObjetivo: string
    activosObjetivoNombres: string
    procesosObjetivo: string
    procesosObjetivoNombres: string
    aprobadores: string
    aprobadoresNombres: string
    evaluadosInternos?: string | null
    evaluadosInternosNombres?: string | null
    areaId: string
    areaNombre: string
    responsableId: string
    responsableNombre: string
    fechaAsignacion?: Date | string
    fechaInicio: Date | string
    fechaVencimiento: Date | string
    estado?: string
    progreso?: number
    instrucciones?: string | null
    recordatorios?: boolean
    tokenAccesoExterno?: string | null
    recurrencia?: string | null
    evaluadosExternos?: EvaluadoExternoUncheckedCreateNestedManyWithoutAsignacionInput
    respuestas?: RespuestaCuestionarioUncheckedCreateNestedManyWithoutAsignacionInput
    mensajesChat?: MensajeChatUncheckedCreateNestedManyWithoutAsignacionInput
  }

  export type AsignacionCuestionarioCreateOrConnectWithoutCuestionarioInput = {
    where: AsignacionCuestionarioWhereUniqueInput
    create: XOR<AsignacionCuestionarioCreateWithoutCuestionarioInput, AsignacionCuestionarioUncheckedCreateWithoutCuestionarioInput>
  }

  export type AsignacionCuestionarioCreateManyCuestionarioInputEnvelope = {
    data: AsignacionCuestionarioCreateManyCuestionarioInput | AsignacionCuestionarioCreateManyCuestionarioInput[]
  }

  export type MarcoNormativoUpsertWithoutCuestionariosInput = {
    update: XOR<MarcoNormativoUpdateWithoutCuestionariosInput, MarcoNormativoUncheckedUpdateWithoutCuestionariosInput>
    create: XOR<MarcoNormativoCreateWithoutCuestionariosInput, MarcoNormativoUncheckedCreateWithoutCuestionariosInput>
    where?: MarcoNormativoWhereInput
  }

  export type MarcoNormativoUpdateToOneWithWhereWithoutCuestionariosInput = {
    where?: MarcoNormativoWhereInput
    data: XOR<MarcoNormativoUpdateWithoutCuestionariosInput, MarcoNormativoUncheckedUpdateWithoutCuestionariosInput>
  }

  export type MarcoNormativoUpdateWithoutCuestionariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    acronimo?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    fechaVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    requisitos?: RequisitoNormativoUpdateManyWithoutMarcoNestedInput
  }

  export type MarcoNormativoUncheckedUpdateWithoutCuestionariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    acronimo?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    fechaVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    requisitos?: RequisitoNormativoUncheckedUpdateManyWithoutMarcoNestedInput
  }

  export type SeccionUpsertWithWhereUniqueWithoutCuestionarioInput = {
    where: SeccionWhereUniqueInput
    update: XOR<SeccionUpdateWithoutCuestionarioInput, SeccionUncheckedUpdateWithoutCuestionarioInput>
    create: XOR<SeccionCreateWithoutCuestionarioInput, SeccionUncheckedCreateWithoutCuestionarioInput>
  }

  export type SeccionUpdateWithWhereUniqueWithoutCuestionarioInput = {
    where: SeccionWhereUniqueInput
    data: XOR<SeccionUpdateWithoutCuestionarioInput, SeccionUncheckedUpdateWithoutCuestionarioInput>
  }

  export type SeccionUpdateManyWithWhereWithoutCuestionarioInput = {
    where: SeccionScalarWhereInput
    data: XOR<SeccionUpdateManyMutationInput, SeccionUncheckedUpdateManyWithoutCuestionarioInput>
  }

  export type SeccionScalarWhereInput = {
    AND?: SeccionScalarWhereInput | SeccionScalarWhereInput[]
    OR?: SeccionScalarWhereInput[]
    NOT?: SeccionScalarWhereInput | SeccionScalarWhereInput[]
    id?: StringFilter<"Seccion"> | string
    cuestionarioId?: StringFilter<"Seccion"> | string
    nombre?: StringFilter<"Seccion"> | string
    descripcion?: StringFilter<"Seccion"> | string
    peso?: FloatFilter<"Seccion"> | number
    requerida?: BoolFilter<"Seccion"> | boolean
    orden?: IntFilter<"Seccion"> | number
  }

  export type AsignacionCuestionarioUpsertWithWhereUniqueWithoutCuestionarioInput = {
    where: AsignacionCuestionarioWhereUniqueInput
    update: XOR<AsignacionCuestionarioUpdateWithoutCuestionarioInput, AsignacionCuestionarioUncheckedUpdateWithoutCuestionarioInput>
    create: XOR<AsignacionCuestionarioCreateWithoutCuestionarioInput, AsignacionCuestionarioUncheckedCreateWithoutCuestionarioInput>
  }

  export type AsignacionCuestionarioUpdateWithWhereUniqueWithoutCuestionarioInput = {
    where: AsignacionCuestionarioWhereUniqueInput
    data: XOR<AsignacionCuestionarioUpdateWithoutCuestionarioInput, AsignacionCuestionarioUncheckedUpdateWithoutCuestionarioInput>
  }

  export type AsignacionCuestionarioUpdateManyWithWhereWithoutCuestionarioInput = {
    where: AsignacionCuestionarioScalarWhereInput
    data: XOR<AsignacionCuestionarioUpdateManyMutationInput, AsignacionCuestionarioUncheckedUpdateManyWithoutCuestionarioInput>
  }

  export type AsignacionCuestionarioScalarWhereInput = {
    AND?: AsignacionCuestionarioScalarWhereInput | AsignacionCuestionarioScalarWhereInput[]
    OR?: AsignacionCuestionarioScalarWhereInput[]
    NOT?: AsignacionCuestionarioScalarWhereInput | AsignacionCuestionarioScalarWhereInput[]
    id?: StringFilter<"AsignacionCuestionario"> | string
    cuestionarioId?: StringFilter<"AsignacionCuestionario"> | string
    cuestionarioIds?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    titulo?: StringFilter<"AsignacionCuestionario"> | string
    descripcion?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    tipoRevision?: StringFilter<"AsignacionCuestionario"> | string
    usuariosAsignados?: StringFilter<"AsignacionCuestionario"> | string
    usuariosAsignadosNombres?: StringFilter<"AsignacionCuestionario"> | string
    emailsExternos?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    contrasenaAcceso?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    activosObjetivo?: StringFilter<"AsignacionCuestionario"> | string
    activosObjetivoNombres?: StringFilter<"AsignacionCuestionario"> | string
    procesosObjetivo?: StringFilter<"AsignacionCuestionario"> | string
    procesosObjetivoNombres?: StringFilter<"AsignacionCuestionario"> | string
    aprobadores?: StringFilter<"AsignacionCuestionario"> | string
    aprobadoresNombres?: StringFilter<"AsignacionCuestionario"> | string
    evaluadosInternos?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    evaluadosInternosNombres?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    areaId?: StringFilter<"AsignacionCuestionario"> | string
    areaNombre?: StringFilter<"AsignacionCuestionario"> | string
    responsableId?: StringFilter<"AsignacionCuestionario"> | string
    responsableNombre?: StringFilter<"AsignacionCuestionario"> | string
    fechaAsignacion?: DateTimeFilter<"AsignacionCuestionario"> | Date | string
    fechaInicio?: DateTimeFilter<"AsignacionCuestionario"> | Date | string
    fechaVencimiento?: DateTimeFilter<"AsignacionCuestionario"> | Date | string
    estado?: StringFilter<"AsignacionCuestionario"> | string
    progreso?: FloatFilter<"AsignacionCuestionario"> | number
    instrucciones?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    recordatorios?: BoolFilter<"AsignacionCuestionario"> | boolean
    tokenAccesoExterno?: StringNullableFilter<"AsignacionCuestionario"> | string | null
    recurrencia?: StringNullableFilter<"AsignacionCuestionario"> | string | null
  }

  export type CuestionarioCreateWithoutSeccionesInput = {
    id?: string
    nombre: string
    descripcion: string
    categoria: string
    tipo: string
    tipoEvaluacion: string
    estado?: string
    periodicidad: string
    tasaCompletado?: number
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    umbrales: string
    areasObjetivo: string
    responsables: string
    marcoNormativo?: MarcoNormativoCreateNestedOneWithoutCuestionariosInput
    asignaciones?: AsignacionCuestionarioCreateNestedManyWithoutCuestionarioInput
  }

  export type CuestionarioUncheckedCreateWithoutSeccionesInput = {
    id?: string
    nombre: string
    descripcion: string
    categoria: string
    tipo: string
    tipoEvaluacion: string
    estado?: string
    marcoNormativoId?: string | null
    periodicidad: string
    tasaCompletado?: number
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    umbrales: string
    areasObjetivo: string
    responsables: string
    asignaciones?: AsignacionCuestionarioUncheckedCreateNestedManyWithoutCuestionarioInput
  }

  export type CuestionarioCreateOrConnectWithoutSeccionesInput = {
    where: CuestionarioWhereUniqueInput
    create: XOR<CuestionarioCreateWithoutSeccionesInput, CuestionarioUncheckedCreateWithoutSeccionesInput>
  }

  export type PreguntaCreateWithoutSeccionInput = {
    id?: string
    texto: string
    tipo: string
    requerida?: boolean
    peso?: number
    opciones?: string | null
    escalaMin?: number | null
    escalaMax?: number | null
    ayuda?: string | null
    placeholder?: string | null
    requisitoNormativoId?: string | null
    controlAsociado?: string | null
    requiereEvidencia?: boolean
    maxStars?: number | null
    leftAnchor?: string | null
    rightAnchor?: string | null
    likertLabels?: string | null
    displayConditionQuestionId?: string | null
    displayConditionAnswer?: string | null
    logicaCondicional?: string | null
    isCalculated?: boolean
    formula?: string | null
    orden?: number
    respuestas?: RespuestaPreguntaCreateNestedManyWithoutPreguntaInput
    hallazgos?: HallazgoCreateNestedManyWithoutPreguntaInput
  }

  export type PreguntaUncheckedCreateWithoutSeccionInput = {
    id?: string
    texto: string
    tipo: string
    requerida?: boolean
    peso?: number
    opciones?: string | null
    escalaMin?: number | null
    escalaMax?: number | null
    ayuda?: string | null
    placeholder?: string | null
    requisitoNormativoId?: string | null
    controlAsociado?: string | null
    requiereEvidencia?: boolean
    maxStars?: number | null
    leftAnchor?: string | null
    rightAnchor?: string | null
    likertLabels?: string | null
    displayConditionQuestionId?: string | null
    displayConditionAnswer?: string | null
    logicaCondicional?: string | null
    isCalculated?: boolean
    formula?: string | null
    orden?: number
    respuestas?: RespuestaPreguntaUncheckedCreateNestedManyWithoutPreguntaInput
    hallazgos?: HallazgoUncheckedCreateNestedManyWithoutPreguntaInput
  }

  export type PreguntaCreateOrConnectWithoutSeccionInput = {
    where: PreguntaWhereUniqueInput
    create: XOR<PreguntaCreateWithoutSeccionInput, PreguntaUncheckedCreateWithoutSeccionInput>
  }

  export type PreguntaCreateManySeccionInputEnvelope = {
    data: PreguntaCreateManySeccionInput | PreguntaCreateManySeccionInput[]
  }

  export type CuestionarioUpsertWithoutSeccionesInput = {
    update: XOR<CuestionarioUpdateWithoutSeccionesInput, CuestionarioUncheckedUpdateWithoutSeccionesInput>
    create: XOR<CuestionarioCreateWithoutSeccionesInput, CuestionarioUncheckedCreateWithoutSeccionesInput>
    where?: CuestionarioWhereInput
  }

  export type CuestionarioUpdateToOneWithWhereWithoutSeccionesInput = {
    where?: CuestionarioWhereInput
    data: XOR<CuestionarioUpdateWithoutSeccionesInput, CuestionarioUncheckedUpdateWithoutSeccionesInput>
  }

  export type CuestionarioUpdateWithoutSeccionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tipoEvaluacion?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    periodicidad?: StringFieldUpdateOperationsInput | string
    tasaCompletado?: FloatFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    umbrales?: StringFieldUpdateOperationsInput | string
    areasObjetivo?: StringFieldUpdateOperationsInput | string
    responsables?: StringFieldUpdateOperationsInput | string
    marcoNormativo?: MarcoNormativoUpdateOneWithoutCuestionariosNestedInput
    asignaciones?: AsignacionCuestionarioUpdateManyWithoutCuestionarioNestedInput
  }

  export type CuestionarioUncheckedUpdateWithoutSeccionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tipoEvaluacion?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    marcoNormativoId?: NullableStringFieldUpdateOperationsInput | string | null
    periodicidad?: StringFieldUpdateOperationsInput | string
    tasaCompletado?: FloatFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    umbrales?: StringFieldUpdateOperationsInput | string
    areasObjetivo?: StringFieldUpdateOperationsInput | string
    responsables?: StringFieldUpdateOperationsInput | string
    asignaciones?: AsignacionCuestionarioUncheckedUpdateManyWithoutCuestionarioNestedInput
  }

  export type PreguntaUpsertWithWhereUniqueWithoutSeccionInput = {
    where: PreguntaWhereUniqueInput
    update: XOR<PreguntaUpdateWithoutSeccionInput, PreguntaUncheckedUpdateWithoutSeccionInput>
    create: XOR<PreguntaCreateWithoutSeccionInput, PreguntaUncheckedCreateWithoutSeccionInput>
  }

  export type PreguntaUpdateWithWhereUniqueWithoutSeccionInput = {
    where: PreguntaWhereUniqueInput
    data: XOR<PreguntaUpdateWithoutSeccionInput, PreguntaUncheckedUpdateWithoutSeccionInput>
  }

  export type PreguntaUpdateManyWithWhereWithoutSeccionInput = {
    where: PreguntaScalarWhereInput
    data: XOR<PreguntaUpdateManyMutationInput, PreguntaUncheckedUpdateManyWithoutSeccionInput>
  }

  export type PreguntaScalarWhereInput = {
    AND?: PreguntaScalarWhereInput | PreguntaScalarWhereInput[]
    OR?: PreguntaScalarWhereInput[]
    NOT?: PreguntaScalarWhereInput | PreguntaScalarWhereInput[]
    id?: StringFilter<"Pregunta"> | string
    seccionId?: StringFilter<"Pregunta"> | string
    texto?: StringFilter<"Pregunta"> | string
    tipo?: StringFilter<"Pregunta"> | string
    requerida?: BoolFilter<"Pregunta"> | boolean
    peso?: FloatFilter<"Pregunta"> | number
    opciones?: StringNullableFilter<"Pregunta"> | string | null
    escalaMin?: IntNullableFilter<"Pregunta"> | number | null
    escalaMax?: IntNullableFilter<"Pregunta"> | number | null
    ayuda?: StringNullableFilter<"Pregunta"> | string | null
    placeholder?: StringNullableFilter<"Pregunta"> | string | null
    requisitoNormativoId?: StringNullableFilter<"Pregunta"> | string | null
    controlAsociado?: StringNullableFilter<"Pregunta"> | string | null
    requiereEvidencia?: BoolFilter<"Pregunta"> | boolean
    maxStars?: IntNullableFilter<"Pregunta"> | number | null
    leftAnchor?: StringNullableFilter<"Pregunta"> | string | null
    rightAnchor?: StringNullableFilter<"Pregunta"> | string | null
    likertLabels?: StringNullableFilter<"Pregunta"> | string | null
    displayConditionQuestionId?: StringNullableFilter<"Pregunta"> | string | null
    displayConditionAnswer?: StringNullableFilter<"Pregunta"> | string | null
    logicaCondicional?: StringNullableFilter<"Pregunta"> | string | null
    isCalculated?: BoolFilter<"Pregunta"> | boolean
    formula?: StringNullableFilter<"Pregunta"> | string | null
    orden?: IntFilter<"Pregunta"> | number
  }

  export type SeccionCreateWithoutPreguntasInput = {
    id?: string
    nombre: string
    descripcion: string
    peso?: number
    requerida?: boolean
    orden?: number
    cuestionario: CuestionarioCreateNestedOneWithoutSeccionesInput
  }

  export type SeccionUncheckedCreateWithoutPreguntasInput = {
    id?: string
    cuestionarioId: string
    nombre: string
    descripcion: string
    peso?: number
    requerida?: boolean
    orden?: number
  }

  export type SeccionCreateOrConnectWithoutPreguntasInput = {
    where: SeccionWhereUniqueInput
    create: XOR<SeccionCreateWithoutPreguntasInput, SeccionUncheckedCreateWithoutPreguntasInput>
  }

  export type RespuestaPreguntaCreateWithoutPreguntaInput = {
    id?: string
    valor?: string | null
    comentario?: string | null
    archivosAdjuntos?: string | null
    marcadaParaRevision?: boolean
    estadoRevision?: string
    comentarioRevisor?: string | null
    respuestaCuestionario: RespuestaCuestionarioCreateNestedOneWithoutRespuestasInput
    evidencias?: EvidenciaCreateNestedManyWithoutRespuestaPreguntaInput
  }

  export type RespuestaPreguntaUncheckedCreateWithoutPreguntaInput = {
    id?: string
    respuestaCuestionarioId: string
    valor?: string | null
    comentario?: string | null
    archivosAdjuntos?: string | null
    marcadaParaRevision?: boolean
    estadoRevision?: string
    comentarioRevisor?: string | null
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutRespuestaPreguntaInput
  }

  export type RespuestaPreguntaCreateOrConnectWithoutPreguntaInput = {
    where: RespuestaPreguntaWhereUniqueInput
    create: XOR<RespuestaPreguntaCreateWithoutPreguntaInput, RespuestaPreguntaUncheckedCreateWithoutPreguntaInput>
  }

  export type RespuestaPreguntaCreateManyPreguntaInputEnvelope = {
    data: RespuestaPreguntaCreateManyPreguntaInput | RespuestaPreguntaCreateManyPreguntaInput[]
  }

  export type HallazgoCreateWithoutPreguntaInput = {
    id?: string
    tipo: string
    descripcion: string
    requisitoNormativo?: string | null
    accionCorrectiva?: string | null
    responsable: string
    fechaLimite?: Date | string | null
    estado?: string
    fechaCreacion?: Date | string
  }

  export type HallazgoUncheckedCreateWithoutPreguntaInput = {
    id?: string
    tipo: string
    descripcion: string
    requisitoNormativo?: string | null
    accionCorrectiva?: string | null
    responsable: string
    fechaLimite?: Date | string | null
    estado?: string
    fechaCreacion?: Date | string
  }

  export type HallazgoCreateOrConnectWithoutPreguntaInput = {
    where: HallazgoWhereUniqueInput
    create: XOR<HallazgoCreateWithoutPreguntaInput, HallazgoUncheckedCreateWithoutPreguntaInput>
  }

  export type HallazgoCreateManyPreguntaInputEnvelope = {
    data: HallazgoCreateManyPreguntaInput | HallazgoCreateManyPreguntaInput[]
  }

  export type SeccionUpsertWithoutPreguntasInput = {
    update: XOR<SeccionUpdateWithoutPreguntasInput, SeccionUncheckedUpdateWithoutPreguntasInput>
    create: XOR<SeccionCreateWithoutPreguntasInput, SeccionUncheckedCreateWithoutPreguntasInput>
    where?: SeccionWhereInput
  }

  export type SeccionUpdateToOneWithWhereWithoutPreguntasInput = {
    where?: SeccionWhereInput
    data: XOR<SeccionUpdateWithoutPreguntasInput, SeccionUncheckedUpdateWithoutPreguntasInput>
  }

  export type SeccionUpdateWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    peso?: FloatFieldUpdateOperationsInput | number
    requerida?: BoolFieldUpdateOperationsInput | boolean
    orden?: IntFieldUpdateOperationsInput | number
    cuestionario?: CuestionarioUpdateOneRequiredWithoutSeccionesNestedInput
  }

  export type SeccionUncheckedUpdateWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    peso?: FloatFieldUpdateOperationsInput | number
    requerida?: BoolFieldUpdateOperationsInput | boolean
    orden?: IntFieldUpdateOperationsInput | number
  }

  export type RespuestaPreguntaUpsertWithWhereUniqueWithoutPreguntaInput = {
    where: RespuestaPreguntaWhereUniqueInput
    update: XOR<RespuestaPreguntaUpdateWithoutPreguntaInput, RespuestaPreguntaUncheckedUpdateWithoutPreguntaInput>
    create: XOR<RespuestaPreguntaCreateWithoutPreguntaInput, RespuestaPreguntaUncheckedCreateWithoutPreguntaInput>
  }

  export type RespuestaPreguntaUpdateWithWhereUniqueWithoutPreguntaInput = {
    where: RespuestaPreguntaWhereUniqueInput
    data: XOR<RespuestaPreguntaUpdateWithoutPreguntaInput, RespuestaPreguntaUncheckedUpdateWithoutPreguntaInput>
  }

  export type RespuestaPreguntaUpdateManyWithWhereWithoutPreguntaInput = {
    where: RespuestaPreguntaScalarWhereInput
    data: XOR<RespuestaPreguntaUpdateManyMutationInput, RespuestaPreguntaUncheckedUpdateManyWithoutPreguntaInput>
  }

  export type RespuestaPreguntaScalarWhereInput = {
    AND?: RespuestaPreguntaScalarWhereInput | RespuestaPreguntaScalarWhereInput[]
    OR?: RespuestaPreguntaScalarWhereInput[]
    NOT?: RespuestaPreguntaScalarWhereInput | RespuestaPreguntaScalarWhereInput[]
    id?: StringFilter<"RespuestaPregunta"> | string
    respuestaCuestionarioId?: StringFilter<"RespuestaPregunta"> | string
    preguntaId?: StringFilter<"RespuestaPregunta"> | string
    valor?: StringNullableFilter<"RespuestaPregunta"> | string | null
    comentario?: StringNullableFilter<"RespuestaPregunta"> | string | null
    archivosAdjuntos?: StringNullableFilter<"RespuestaPregunta"> | string | null
    marcadaParaRevision?: BoolFilter<"RespuestaPregunta"> | boolean
    estadoRevision?: StringFilter<"RespuestaPregunta"> | string
    comentarioRevisor?: StringNullableFilter<"RespuestaPregunta"> | string | null
  }

  export type HallazgoUpsertWithWhereUniqueWithoutPreguntaInput = {
    where: HallazgoWhereUniqueInput
    update: XOR<HallazgoUpdateWithoutPreguntaInput, HallazgoUncheckedUpdateWithoutPreguntaInput>
    create: XOR<HallazgoCreateWithoutPreguntaInput, HallazgoUncheckedCreateWithoutPreguntaInput>
  }

  export type HallazgoUpdateWithWhereUniqueWithoutPreguntaInput = {
    where: HallazgoWhereUniqueInput
    data: XOR<HallazgoUpdateWithoutPreguntaInput, HallazgoUncheckedUpdateWithoutPreguntaInput>
  }

  export type HallazgoUpdateManyWithWhereWithoutPreguntaInput = {
    where: HallazgoScalarWhereInput
    data: XOR<HallazgoUpdateManyMutationInput, HallazgoUncheckedUpdateManyWithoutPreguntaInput>
  }

  export type HallazgoScalarWhereInput = {
    AND?: HallazgoScalarWhereInput | HallazgoScalarWhereInput[]
    OR?: HallazgoScalarWhereInput[]
    NOT?: HallazgoScalarWhereInput | HallazgoScalarWhereInput[]
    id?: StringFilter<"Hallazgo"> | string
    preguntaId?: StringFilter<"Hallazgo"> | string
    tipo?: StringFilter<"Hallazgo"> | string
    descripcion?: StringFilter<"Hallazgo"> | string
    requisitoNormativo?: StringNullableFilter<"Hallazgo"> | string | null
    accionCorrectiva?: StringNullableFilter<"Hallazgo"> | string | null
    responsable?: StringFilter<"Hallazgo"> | string
    fechaLimite?: DateTimeNullableFilter<"Hallazgo"> | Date | string | null
    estado?: StringFilter<"Hallazgo"> | string
    fechaCreacion?: DateTimeFilter<"Hallazgo"> | Date | string
  }

  export type CuestionarioCreateWithoutAsignacionesInput = {
    id?: string
    nombre: string
    descripcion: string
    categoria: string
    tipo: string
    tipoEvaluacion: string
    estado?: string
    periodicidad: string
    tasaCompletado?: number
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    umbrales: string
    areasObjetivo: string
    responsables: string
    marcoNormativo?: MarcoNormativoCreateNestedOneWithoutCuestionariosInput
    secciones?: SeccionCreateNestedManyWithoutCuestionarioInput
  }

  export type CuestionarioUncheckedCreateWithoutAsignacionesInput = {
    id?: string
    nombre: string
    descripcion: string
    categoria: string
    tipo: string
    tipoEvaluacion: string
    estado?: string
    marcoNormativoId?: string | null
    periodicidad: string
    tasaCompletado?: number
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    umbrales: string
    areasObjetivo: string
    responsables: string
    secciones?: SeccionUncheckedCreateNestedManyWithoutCuestionarioInput
  }

  export type CuestionarioCreateOrConnectWithoutAsignacionesInput = {
    where: CuestionarioWhereUniqueInput
    create: XOR<CuestionarioCreateWithoutAsignacionesInput, CuestionarioUncheckedCreateWithoutAsignacionesInput>
  }

  export type EvaluadoExternoCreateWithoutAsignacionInput = {
    id?: string
    nombre: string
    email: string
    password?: string | null
    invitacionEnviada?: boolean
    fechaInvitacion?: Date | string | null
    haRespondido?: boolean
    fechaRespuesta?: Date | string | null
  }

  export type EvaluadoExternoUncheckedCreateWithoutAsignacionInput = {
    id?: string
    nombre: string
    email: string
    password?: string | null
    invitacionEnviada?: boolean
    fechaInvitacion?: Date | string | null
    haRespondido?: boolean
    fechaRespuesta?: Date | string | null
  }

  export type EvaluadoExternoCreateOrConnectWithoutAsignacionInput = {
    where: EvaluadoExternoWhereUniqueInput
    create: XOR<EvaluadoExternoCreateWithoutAsignacionInput, EvaluadoExternoUncheckedCreateWithoutAsignacionInput>
  }

  export type EvaluadoExternoCreateManyAsignacionInputEnvelope = {
    data: EvaluadoExternoCreateManyAsignacionInput | EvaluadoExternoCreateManyAsignacionInput[]
  }

  export type RespuestaCuestionarioCreateWithoutAsignacionInput = {
    id?: string
    cuestionarioId: string
    fechaInicio?: Date | string
    fechaEnvio?: Date | string | null
    estado?: string
    puntuacionTotal?: number
    nivelCumplimiento?: string | null
    comentariosGenerales?: string | null
    respondidoPor: UsuarioCreateNestedOneWithoutRespuestasCuestionarioInput
    respuestas?: RespuestaPreguntaCreateNestedManyWithoutRespuestaCuestionarioInput
  }

  export type RespuestaCuestionarioUncheckedCreateWithoutAsignacionInput = {
    id?: string
    cuestionarioId: string
    respondidoPorId: string
    fechaInicio?: Date | string
    fechaEnvio?: Date | string | null
    estado?: string
    puntuacionTotal?: number
    nivelCumplimiento?: string | null
    comentariosGenerales?: string | null
    respuestas?: RespuestaPreguntaUncheckedCreateNestedManyWithoutRespuestaCuestionarioInput
  }

  export type RespuestaCuestionarioCreateOrConnectWithoutAsignacionInput = {
    where: RespuestaCuestionarioWhereUniqueInput
    create: XOR<RespuestaCuestionarioCreateWithoutAsignacionInput, RespuestaCuestionarioUncheckedCreateWithoutAsignacionInput>
  }

  export type RespuestaCuestionarioCreateManyAsignacionInputEnvelope = {
    data: RespuestaCuestionarioCreateManyAsignacionInput | RespuestaCuestionarioCreateManyAsignacionInput[]
  }

  export type MensajeChatCreateWithoutAsignacionInput = {
    id?: string
    cuestionarioId?: string | null
    activoProcesoId?: string | null
    usuarioId: string
    usuarioNombre: string
    usuarioRol: string
    mensaje: string
    fecha?: Date | string
    leido?: boolean
  }

  export type MensajeChatUncheckedCreateWithoutAsignacionInput = {
    id?: string
    cuestionarioId?: string | null
    activoProcesoId?: string | null
    usuarioId: string
    usuarioNombre: string
    usuarioRol: string
    mensaje: string
    fecha?: Date | string
    leido?: boolean
  }

  export type MensajeChatCreateOrConnectWithoutAsignacionInput = {
    where: MensajeChatWhereUniqueInput
    create: XOR<MensajeChatCreateWithoutAsignacionInput, MensajeChatUncheckedCreateWithoutAsignacionInput>
  }

  export type MensajeChatCreateManyAsignacionInputEnvelope = {
    data: MensajeChatCreateManyAsignacionInput | MensajeChatCreateManyAsignacionInput[]
  }

  export type CuestionarioUpsertWithoutAsignacionesInput = {
    update: XOR<CuestionarioUpdateWithoutAsignacionesInput, CuestionarioUncheckedUpdateWithoutAsignacionesInput>
    create: XOR<CuestionarioCreateWithoutAsignacionesInput, CuestionarioUncheckedCreateWithoutAsignacionesInput>
    where?: CuestionarioWhereInput
  }

  export type CuestionarioUpdateToOneWithWhereWithoutAsignacionesInput = {
    where?: CuestionarioWhereInput
    data: XOR<CuestionarioUpdateWithoutAsignacionesInput, CuestionarioUncheckedUpdateWithoutAsignacionesInput>
  }

  export type CuestionarioUpdateWithoutAsignacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tipoEvaluacion?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    periodicidad?: StringFieldUpdateOperationsInput | string
    tasaCompletado?: FloatFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    umbrales?: StringFieldUpdateOperationsInput | string
    areasObjetivo?: StringFieldUpdateOperationsInput | string
    responsables?: StringFieldUpdateOperationsInput | string
    marcoNormativo?: MarcoNormativoUpdateOneWithoutCuestionariosNestedInput
    secciones?: SeccionUpdateManyWithoutCuestionarioNestedInput
  }

  export type CuestionarioUncheckedUpdateWithoutAsignacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tipoEvaluacion?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    marcoNormativoId?: NullableStringFieldUpdateOperationsInput | string | null
    periodicidad?: StringFieldUpdateOperationsInput | string
    tasaCompletado?: FloatFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    umbrales?: StringFieldUpdateOperationsInput | string
    areasObjetivo?: StringFieldUpdateOperationsInput | string
    responsables?: StringFieldUpdateOperationsInput | string
    secciones?: SeccionUncheckedUpdateManyWithoutCuestionarioNestedInput
  }

  export type EvaluadoExternoUpsertWithWhereUniqueWithoutAsignacionInput = {
    where: EvaluadoExternoWhereUniqueInput
    update: XOR<EvaluadoExternoUpdateWithoutAsignacionInput, EvaluadoExternoUncheckedUpdateWithoutAsignacionInput>
    create: XOR<EvaluadoExternoCreateWithoutAsignacionInput, EvaluadoExternoUncheckedCreateWithoutAsignacionInput>
  }

  export type EvaluadoExternoUpdateWithWhereUniqueWithoutAsignacionInput = {
    where: EvaluadoExternoWhereUniqueInput
    data: XOR<EvaluadoExternoUpdateWithoutAsignacionInput, EvaluadoExternoUncheckedUpdateWithoutAsignacionInput>
  }

  export type EvaluadoExternoUpdateManyWithWhereWithoutAsignacionInput = {
    where: EvaluadoExternoScalarWhereInput
    data: XOR<EvaluadoExternoUpdateManyMutationInput, EvaluadoExternoUncheckedUpdateManyWithoutAsignacionInput>
  }

  export type EvaluadoExternoScalarWhereInput = {
    AND?: EvaluadoExternoScalarWhereInput | EvaluadoExternoScalarWhereInput[]
    OR?: EvaluadoExternoScalarWhereInput[]
    NOT?: EvaluadoExternoScalarWhereInput | EvaluadoExternoScalarWhereInput[]
    id?: StringFilter<"EvaluadoExterno"> | string
    asignacionId?: StringFilter<"EvaluadoExterno"> | string
    nombre?: StringFilter<"EvaluadoExterno"> | string
    email?: StringFilter<"EvaluadoExterno"> | string
    password?: StringNullableFilter<"EvaluadoExterno"> | string | null
    invitacionEnviada?: BoolFilter<"EvaluadoExterno"> | boolean
    fechaInvitacion?: DateTimeNullableFilter<"EvaluadoExterno"> | Date | string | null
    haRespondido?: BoolFilter<"EvaluadoExterno"> | boolean
    fechaRespuesta?: DateTimeNullableFilter<"EvaluadoExterno"> | Date | string | null
  }

  export type RespuestaCuestionarioUpsertWithWhereUniqueWithoutAsignacionInput = {
    where: RespuestaCuestionarioWhereUniqueInput
    update: XOR<RespuestaCuestionarioUpdateWithoutAsignacionInput, RespuestaCuestionarioUncheckedUpdateWithoutAsignacionInput>
    create: XOR<RespuestaCuestionarioCreateWithoutAsignacionInput, RespuestaCuestionarioUncheckedCreateWithoutAsignacionInput>
  }

  export type RespuestaCuestionarioUpdateWithWhereUniqueWithoutAsignacionInput = {
    where: RespuestaCuestionarioWhereUniqueInput
    data: XOR<RespuestaCuestionarioUpdateWithoutAsignacionInput, RespuestaCuestionarioUncheckedUpdateWithoutAsignacionInput>
  }

  export type RespuestaCuestionarioUpdateManyWithWhereWithoutAsignacionInput = {
    where: RespuestaCuestionarioScalarWhereInput
    data: XOR<RespuestaCuestionarioUpdateManyMutationInput, RespuestaCuestionarioUncheckedUpdateManyWithoutAsignacionInput>
  }

  export type MensajeChatUpsertWithWhereUniqueWithoutAsignacionInput = {
    where: MensajeChatWhereUniqueInput
    update: XOR<MensajeChatUpdateWithoutAsignacionInput, MensajeChatUncheckedUpdateWithoutAsignacionInput>
    create: XOR<MensajeChatCreateWithoutAsignacionInput, MensajeChatUncheckedCreateWithoutAsignacionInput>
  }

  export type MensajeChatUpdateWithWhereUniqueWithoutAsignacionInput = {
    where: MensajeChatWhereUniqueInput
    data: XOR<MensajeChatUpdateWithoutAsignacionInput, MensajeChatUncheckedUpdateWithoutAsignacionInput>
  }

  export type MensajeChatUpdateManyWithWhereWithoutAsignacionInput = {
    where: MensajeChatScalarWhereInput
    data: XOR<MensajeChatUpdateManyMutationInput, MensajeChatUncheckedUpdateManyWithoutAsignacionInput>
  }

  export type MensajeChatScalarWhereInput = {
    AND?: MensajeChatScalarWhereInput | MensajeChatScalarWhereInput[]
    OR?: MensajeChatScalarWhereInput[]
    NOT?: MensajeChatScalarWhereInput | MensajeChatScalarWhereInput[]
    id?: StringFilter<"MensajeChat"> | string
    asignacionId?: StringFilter<"MensajeChat"> | string
    cuestionarioId?: StringNullableFilter<"MensajeChat"> | string | null
    activoProcesoId?: StringNullableFilter<"MensajeChat"> | string | null
    usuarioId?: StringFilter<"MensajeChat"> | string
    usuarioNombre?: StringFilter<"MensajeChat"> | string
    usuarioRol?: StringFilter<"MensajeChat"> | string
    mensaje?: StringFilter<"MensajeChat"> | string
    fecha?: DateTimeFilter<"MensajeChat"> | Date | string
    leido?: BoolFilter<"MensajeChat"> | boolean
  }

  export type AsignacionCuestionarioCreateWithoutEvaluadosExternosInput = {
    id?: string
    cuestionarioIds?: string | null
    titulo: string
    descripcion?: string | null
    tipoRevision: string
    usuariosAsignados: string
    usuariosAsignadosNombres: string
    emailsExternos?: string | null
    contrasenaAcceso?: string | null
    activosObjetivo: string
    activosObjetivoNombres: string
    procesosObjetivo: string
    procesosObjetivoNombres: string
    aprobadores: string
    aprobadoresNombres: string
    evaluadosInternos?: string | null
    evaluadosInternosNombres?: string | null
    areaId: string
    areaNombre: string
    responsableId: string
    responsableNombre: string
    fechaAsignacion?: Date | string
    fechaInicio: Date | string
    fechaVencimiento: Date | string
    estado?: string
    progreso?: number
    instrucciones?: string | null
    recordatorios?: boolean
    tokenAccesoExterno?: string | null
    recurrencia?: string | null
    cuestionario: CuestionarioCreateNestedOneWithoutAsignacionesInput
    respuestas?: RespuestaCuestionarioCreateNestedManyWithoutAsignacionInput
    mensajesChat?: MensajeChatCreateNestedManyWithoutAsignacionInput
  }

  export type AsignacionCuestionarioUncheckedCreateWithoutEvaluadosExternosInput = {
    id?: string
    cuestionarioId: string
    cuestionarioIds?: string | null
    titulo: string
    descripcion?: string | null
    tipoRevision: string
    usuariosAsignados: string
    usuariosAsignadosNombres: string
    emailsExternos?: string | null
    contrasenaAcceso?: string | null
    activosObjetivo: string
    activosObjetivoNombres: string
    procesosObjetivo: string
    procesosObjetivoNombres: string
    aprobadores: string
    aprobadoresNombres: string
    evaluadosInternos?: string | null
    evaluadosInternosNombres?: string | null
    areaId: string
    areaNombre: string
    responsableId: string
    responsableNombre: string
    fechaAsignacion?: Date | string
    fechaInicio: Date | string
    fechaVencimiento: Date | string
    estado?: string
    progreso?: number
    instrucciones?: string | null
    recordatorios?: boolean
    tokenAccesoExterno?: string | null
    recurrencia?: string | null
    respuestas?: RespuestaCuestionarioUncheckedCreateNestedManyWithoutAsignacionInput
    mensajesChat?: MensajeChatUncheckedCreateNestedManyWithoutAsignacionInput
  }

  export type AsignacionCuestionarioCreateOrConnectWithoutEvaluadosExternosInput = {
    where: AsignacionCuestionarioWhereUniqueInput
    create: XOR<AsignacionCuestionarioCreateWithoutEvaluadosExternosInput, AsignacionCuestionarioUncheckedCreateWithoutEvaluadosExternosInput>
  }

  export type AsignacionCuestionarioUpsertWithoutEvaluadosExternosInput = {
    update: XOR<AsignacionCuestionarioUpdateWithoutEvaluadosExternosInput, AsignacionCuestionarioUncheckedUpdateWithoutEvaluadosExternosInput>
    create: XOR<AsignacionCuestionarioCreateWithoutEvaluadosExternosInput, AsignacionCuestionarioUncheckedCreateWithoutEvaluadosExternosInput>
    where?: AsignacionCuestionarioWhereInput
  }

  export type AsignacionCuestionarioUpdateToOneWithWhereWithoutEvaluadosExternosInput = {
    where?: AsignacionCuestionarioWhereInput
    data: XOR<AsignacionCuestionarioUpdateWithoutEvaluadosExternosInput, AsignacionCuestionarioUncheckedUpdateWithoutEvaluadosExternosInput>
  }

  export type AsignacionCuestionarioUpdateWithoutEvaluadosExternosInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioIds?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipoRevision?: StringFieldUpdateOperationsInput | string
    usuariosAsignados?: StringFieldUpdateOperationsInput | string
    usuariosAsignadosNombres?: StringFieldUpdateOperationsInput | string
    emailsExternos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasenaAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activosObjetivo?: StringFieldUpdateOperationsInput | string
    activosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    procesosObjetivo?: StringFieldUpdateOperationsInput | string
    procesosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    aprobadores?: StringFieldUpdateOperationsInput | string
    aprobadoresNombres?: StringFieldUpdateOperationsInput | string
    evaluadosInternos?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosInternosNombres?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: StringFieldUpdateOperationsInput | string
    areaNombre?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    responsableNombre?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    instrucciones?: NullableStringFieldUpdateOperationsInput | string | null
    recordatorios?: BoolFieldUpdateOperationsInput | boolean
    tokenAccesoExterno?: NullableStringFieldUpdateOperationsInput | string | null
    recurrencia?: NullableStringFieldUpdateOperationsInput | string | null
    cuestionario?: CuestionarioUpdateOneRequiredWithoutAsignacionesNestedInput
    respuestas?: RespuestaCuestionarioUpdateManyWithoutAsignacionNestedInput
    mensajesChat?: MensajeChatUpdateManyWithoutAsignacionNestedInput
  }

  export type AsignacionCuestionarioUncheckedUpdateWithoutEvaluadosExternosInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    cuestionarioIds?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipoRevision?: StringFieldUpdateOperationsInput | string
    usuariosAsignados?: StringFieldUpdateOperationsInput | string
    usuariosAsignadosNombres?: StringFieldUpdateOperationsInput | string
    emailsExternos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasenaAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activosObjetivo?: StringFieldUpdateOperationsInput | string
    activosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    procesosObjetivo?: StringFieldUpdateOperationsInput | string
    procesosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    aprobadores?: StringFieldUpdateOperationsInput | string
    aprobadoresNombres?: StringFieldUpdateOperationsInput | string
    evaluadosInternos?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosInternosNombres?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: StringFieldUpdateOperationsInput | string
    areaNombre?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    responsableNombre?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    instrucciones?: NullableStringFieldUpdateOperationsInput | string | null
    recordatorios?: BoolFieldUpdateOperationsInput | boolean
    tokenAccesoExterno?: NullableStringFieldUpdateOperationsInput | string | null
    recurrencia?: NullableStringFieldUpdateOperationsInput | string | null
    respuestas?: RespuestaCuestionarioUncheckedUpdateManyWithoutAsignacionNestedInput
    mensajesChat?: MensajeChatUncheckedUpdateManyWithoutAsignacionNestedInput
  }

  export type AsignacionCuestionarioCreateWithoutRespuestasInput = {
    id?: string
    cuestionarioIds?: string | null
    titulo: string
    descripcion?: string | null
    tipoRevision: string
    usuariosAsignados: string
    usuariosAsignadosNombres: string
    emailsExternos?: string | null
    contrasenaAcceso?: string | null
    activosObjetivo: string
    activosObjetivoNombres: string
    procesosObjetivo: string
    procesosObjetivoNombres: string
    aprobadores: string
    aprobadoresNombres: string
    evaluadosInternos?: string | null
    evaluadosInternosNombres?: string | null
    areaId: string
    areaNombre: string
    responsableId: string
    responsableNombre: string
    fechaAsignacion?: Date | string
    fechaInicio: Date | string
    fechaVencimiento: Date | string
    estado?: string
    progreso?: number
    instrucciones?: string | null
    recordatorios?: boolean
    tokenAccesoExterno?: string | null
    recurrencia?: string | null
    cuestionario: CuestionarioCreateNestedOneWithoutAsignacionesInput
    evaluadosExternos?: EvaluadoExternoCreateNestedManyWithoutAsignacionInput
    mensajesChat?: MensajeChatCreateNestedManyWithoutAsignacionInput
  }

  export type AsignacionCuestionarioUncheckedCreateWithoutRespuestasInput = {
    id?: string
    cuestionarioId: string
    cuestionarioIds?: string | null
    titulo: string
    descripcion?: string | null
    tipoRevision: string
    usuariosAsignados: string
    usuariosAsignadosNombres: string
    emailsExternos?: string | null
    contrasenaAcceso?: string | null
    activosObjetivo: string
    activosObjetivoNombres: string
    procesosObjetivo: string
    procesosObjetivoNombres: string
    aprobadores: string
    aprobadoresNombres: string
    evaluadosInternos?: string | null
    evaluadosInternosNombres?: string | null
    areaId: string
    areaNombre: string
    responsableId: string
    responsableNombre: string
    fechaAsignacion?: Date | string
    fechaInicio: Date | string
    fechaVencimiento: Date | string
    estado?: string
    progreso?: number
    instrucciones?: string | null
    recordatorios?: boolean
    tokenAccesoExterno?: string | null
    recurrencia?: string | null
    evaluadosExternos?: EvaluadoExternoUncheckedCreateNestedManyWithoutAsignacionInput
    mensajesChat?: MensajeChatUncheckedCreateNestedManyWithoutAsignacionInput
  }

  export type AsignacionCuestionarioCreateOrConnectWithoutRespuestasInput = {
    where: AsignacionCuestionarioWhereUniqueInput
    create: XOR<AsignacionCuestionarioCreateWithoutRespuestasInput, AsignacionCuestionarioUncheckedCreateWithoutRespuestasInput>
  }

  export type UsuarioCreateWithoutRespuestasCuestionarioInput = {
    id?: string
    nombre: string
    apellido: string
    email: string
    password?: string | null
    telefono?: string | null
    avatar?: string | null
    estado?: string
    departamento?: string | null
    cargo?: string | null
    region?: string
    autenticacionDosFactor?: boolean
    cambioPasswordRequerido?: boolean
    sesionesActivas?: number
    maxSesionesPermitidas?: number
    ultimoCambioPassword?: Date | string | null
    intentosFallidos?: number
    fechaCreacion?: Date | string
    fechaExpiracion?: Date | string | null
    ultimoAcceso?: Date | string | null
    updatedAt?: Date | string
    roles?: UsuarioRolCreateNestedManyWithoutUsuarioInput
    activosAcceso?: UsuarioActivoCreateNestedManyWithoutUsuarioInput
    logsAuditoria?: LogAuditoriaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutRespuestasCuestionarioInput = {
    id?: string
    nombre: string
    apellido: string
    email: string
    password?: string | null
    telefono?: string | null
    avatar?: string | null
    estado?: string
    departamento?: string | null
    cargo?: string | null
    region?: string
    autenticacionDosFactor?: boolean
    cambioPasswordRequerido?: boolean
    sesionesActivas?: number
    maxSesionesPermitidas?: number
    ultimoCambioPassword?: Date | string | null
    intentosFallidos?: number
    fechaCreacion?: Date | string
    fechaExpiracion?: Date | string | null
    ultimoAcceso?: Date | string | null
    updatedAt?: Date | string
    roles?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput
    activosAcceso?: UsuarioActivoUncheckedCreateNestedManyWithoutUsuarioInput
    logsAuditoria?: LogAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutRespuestasCuestionarioInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutRespuestasCuestionarioInput, UsuarioUncheckedCreateWithoutRespuestasCuestionarioInput>
  }

  export type RespuestaPreguntaCreateWithoutRespuestaCuestionarioInput = {
    id?: string
    valor?: string | null
    comentario?: string | null
    archivosAdjuntos?: string | null
    marcadaParaRevision?: boolean
    estadoRevision?: string
    comentarioRevisor?: string | null
    pregunta: PreguntaCreateNestedOneWithoutRespuestasInput
    evidencias?: EvidenciaCreateNestedManyWithoutRespuestaPreguntaInput
  }

  export type RespuestaPreguntaUncheckedCreateWithoutRespuestaCuestionarioInput = {
    id?: string
    preguntaId: string
    valor?: string | null
    comentario?: string | null
    archivosAdjuntos?: string | null
    marcadaParaRevision?: boolean
    estadoRevision?: string
    comentarioRevisor?: string | null
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutRespuestaPreguntaInput
  }

  export type RespuestaPreguntaCreateOrConnectWithoutRespuestaCuestionarioInput = {
    where: RespuestaPreguntaWhereUniqueInput
    create: XOR<RespuestaPreguntaCreateWithoutRespuestaCuestionarioInput, RespuestaPreguntaUncheckedCreateWithoutRespuestaCuestionarioInput>
  }

  export type RespuestaPreguntaCreateManyRespuestaCuestionarioInputEnvelope = {
    data: RespuestaPreguntaCreateManyRespuestaCuestionarioInput | RespuestaPreguntaCreateManyRespuestaCuestionarioInput[]
  }

  export type AsignacionCuestionarioUpsertWithoutRespuestasInput = {
    update: XOR<AsignacionCuestionarioUpdateWithoutRespuestasInput, AsignacionCuestionarioUncheckedUpdateWithoutRespuestasInput>
    create: XOR<AsignacionCuestionarioCreateWithoutRespuestasInput, AsignacionCuestionarioUncheckedCreateWithoutRespuestasInput>
    where?: AsignacionCuestionarioWhereInput
  }

  export type AsignacionCuestionarioUpdateToOneWithWhereWithoutRespuestasInput = {
    where?: AsignacionCuestionarioWhereInput
    data: XOR<AsignacionCuestionarioUpdateWithoutRespuestasInput, AsignacionCuestionarioUncheckedUpdateWithoutRespuestasInput>
  }

  export type AsignacionCuestionarioUpdateWithoutRespuestasInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioIds?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipoRevision?: StringFieldUpdateOperationsInput | string
    usuariosAsignados?: StringFieldUpdateOperationsInput | string
    usuariosAsignadosNombres?: StringFieldUpdateOperationsInput | string
    emailsExternos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasenaAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activosObjetivo?: StringFieldUpdateOperationsInput | string
    activosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    procesosObjetivo?: StringFieldUpdateOperationsInput | string
    procesosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    aprobadores?: StringFieldUpdateOperationsInput | string
    aprobadoresNombres?: StringFieldUpdateOperationsInput | string
    evaluadosInternos?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosInternosNombres?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: StringFieldUpdateOperationsInput | string
    areaNombre?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    responsableNombre?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    instrucciones?: NullableStringFieldUpdateOperationsInput | string | null
    recordatorios?: BoolFieldUpdateOperationsInput | boolean
    tokenAccesoExterno?: NullableStringFieldUpdateOperationsInput | string | null
    recurrencia?: NullableStringFieldUpdateOperationsInput | string | null
    cuestionario?: CuestionarioUpdateOneRequiredWithoutAsignacionesNestedInput
    evaluadosExternos?: EvaluadoExternoUpdateManyWithoutAsignacionNestedInput
    mensajesChat?: MensajeChatUpdateManyWithoutAsignacionNestedInput
  }

  export type AsignacionCuestionarioUncheckedUpdateWithoutRespuestasInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    cuestionarioIds?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipoRevision?: StringFieldUpdateOperationsInput | string
    usuariosAsignados?: StringFieldUpdateOperationsInput | string
    usuariosAsignadosNombres?: StringFieldUpdateOperationsInput | string
    emailsExternos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasenaAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activosObjetivo?: StringFieldUpdateOperationsInput | string
    activosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    procesosObjetivo?: StringFieldUpdateOperationsInput | string
    procesosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    aprobadores?: StringFieldUpdateOperationsInput | string
    aprobadoresNombres?: StringFieldUpdateOperationsInput | string
    evaluadosInternos?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosInternosNombres?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: StringFieldUpdateOperationsInput | string
    areaNombre?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    responsableNombre?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    instrucciones?: NullableStringFieldUpdateOperationsInput | string | null
    recordatorios?: BoolFieldUpdateOperationsInput | boolean
    tokenAccesoExterno?: NullableStringFieldUpdateOperationsInput | string | null
    recurrencia?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosExternos?: EvaluadoExternoUncheckedUpdateManyWithoutAsignacionNestedInput
    mensajesChat?: MensajeChatUncheckedUpdateManyWithoutAsignacionNestedInput
  }

  export type UsuarioUpsertWithoutRespuestasCuestionarioInput = {
    update: XOR<UsuarioUpdateWithoutRespuestasCuestionarioInput, UsuarioUncheckedUpdateWithoutRespuestasCuestionarioInput>
    create: XOR<UsuarioCreateWithoutRespuestasCuestionarioInput, UsuarioUncheckedCreateWithoutRespuestasCuestionarioInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutRespuestasCuestionarioInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutRespuestasCuestionarioInput, UsuarioUncheckedUpdateWithoutRespuestasCuestionarioInput>
  }

  export type UsuarioUpdateWithoutRespuestasCuestionarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    region?: StringFieldUpdateOperationsInput | string
    autenticacionDosFactor?: BoolFieldUpdateOperationsInput | boolean
    cambioPasswordRequerido?: BoolFieldUpdateOperationsInput | boolean
    sesionesActivas?: IntFieldUpdateOperationsInput | number
    maxSesionesPermitidas?: IntFieldUpdateOperationsInput | number
    ultimoCambioPassword?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UsuarioRolUpdateManyWithoutUsuarioNestedInput
    activosAcceso?: UsuarioActivoUpdateManyWithoutUsuarioNestedInput
    logsAuditoria?: LogAuditoriaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutRespuestasCuestionarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    region?: StringFieldUpdateOperationsInput | string
    autenticacionDosFactor?: BoolFieldUpdateOperationsInput | boolean
    cambioPasswordRequerido?: BoolFieldUpdateOperationsInput | boolean
    sesionesActivas?: IntFieldUpdateOperationsInput | number
    maxSesionesPermitidas?: IntFieldUpdateOperationsInput | number
    ultimoCambioPassword?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput
    activosAcceso?: UsuarioActivoUncheckedUpdateManyWithoutUsuarioNestedInput
    logsAuditoria?: LogAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type RespuestaPreguntaUpsertWithWhereUniqueWithoutRespuestaCuestionarioInput = {
    where: RespuestaPreguntaWhereUniqueInput
    update: XOR<RespuestaPreguntaUpdateWithoutRespuestaCuestionarioInput, RespuestaPreguntaUncheckedUpdateWithoutRespuestaCuestionarioInput>
    create: XOR<RespuestaPreguntaCreateWithoutRespuestaCuestionarioInput, RespuestaPreguntaUncheckedCreateWithoutRespuestaCuestionarioInput>
  }

  export type RespuestaPreguntaUpdateWithWhereUniqueWithoutRespuestaCuestionarioInput = {
    where: RespuestaPreguntaWhereUniqueInput
    data: XOR<RespuestaPreguntaUpdateWithoutRespuestaCuestionarioInput, RespuestaPreguntaUncheckedUpdateWithoutRespuestaCuestionarioInput>
  }

  export type RespuestaPreguntaUpdateManyWithWhereWithoutRespuestaCuestionarioInput = {
    where: RespuestaPreguntaScalarWhereInput
    data: XOR<RespuestaPreguntaUpdateManyMutationInput, RespuestaPreguntaUncheckedUpdateManyWithoutRespuestaCuestionarioInput>
  }

  export type RespuestaCuestionarioCreateWithoutRespuestasInput = {
    id?: string
    cuestionarioId: string
    fechaInicio?: Date | string
    fechaEnvio?: Date | string | null
    estado?: string
    puntuacionTotal?: number
    nivelCumplimiento?: string | null
    comentariosGenerales?: string | null
    asignacion: AsignacionCuestionarioCreateNestedOneWithoutRespuestasInput
    respondidoPor: UsuarioCreateNestedOneWithoutRespuestasCuestionarioInput
  }

  export type RespuestaCuestionarioUncheckedCreateWithoutRespuestasInput = {
    id?: string
    asignacionId: string
    cuestionarioId: string
    respondidoPorId: string
    fechaInicio?: Date | string
    fechaEnvio?: Date | string | null
    estado?: string
    puntuacionTotal?: number
    nivelCumplimiento?: string | null
    comentariosGenerales?: string | null
  }

  export type RespuestaCuestionarioCreateOrConnectWithoutRespuestasInput = {
    where: RespuestaCuestionarioWhereUniqueInput
    create: XOR<RespuestaCuestionarioCreateWithoutRespuestasInput, RespuestaCuestionarioUncheckedCreateWithoutRespuestasInput>
  }

  export type PreguntaCreateWithoutRespuestasInput = {
    id?: string
    texto: string
    tipo: string
    requerida?: boolean
    peso?: number
    opciones?: string | null
    escalaMin?: number | null
    escalaMax?: number | null
    ayuda?: string | null
    placeholder?: string | null
    requisitoNormativoId?: string | null
    controlAsociado?: string | null
    requiereEvidencia?: boolean
    maxStars?: number | null
    leftAnchor?: string | null
    rightAnchor?: string | null
    likertLabels?: string | null
    displayConditionQuestionId?: string | null
    displayConditionAnswer?: string | null
    logicaCondicional?: string | null
    isCalculated?: boolean
    formula?: string | null
    orden?: number
    seccion: SeccionCreateNestedOneWithoutPreguntasInput
    hallazgos?: HallazgoCreateNestedManyWithoutPreguntaInput
  }

  export type PreguntaUncheckedCreateWithoutRespuestasInput = {
    id?: string
    seccionId: string
    texto: string
    tipo: string
    requerida?: boolean
    peso?: number
    opciones?: string | null
    escalaMin?: number | null
    escalaMax?: number | null
    ayuda?: string | null
    placeholder?: string | null
    requisitoNormativoId?: string | null
    controlAsociado?: string | null
    requiereEvidencia?: boolean
    maxStars?: number | null
    leftAnchor?: string | null
    rightAnchor?: string | null
    likertLabels?: string | null
    displayConditionQuestionId?: string | null
    displayConditionAnswer?: string | null
    logicaCondicional?: string | null
    isCalculated?: boolean
    formula?: string | null
    orden?: number
    hallazgos?: HallazgoUncheckedCreateNestedManyWithoutPreguntaInput
  }

  export type PreguntaCreateOrConnectWithoutRespuestasInput = {
    where: PreguntaWhereUniqueInput
    create: XOR<PreguntaCreateWithoutRespuestasInput, PreguntaUncheckedCreateWithoutRespuestasInput>
  }

  export type EvidenciaCreateWithoutRespuestaPreguntaInput = {
    id?: string
    nombre: string
    tipo: string
    tamano: number
    fechaCarga?: Date | string
    url: string
    descripcion?: string | null
    vigencia?: Date | string | null
    estado?: string
  }

  export type EvidenciaUncheckedCreateWithoutRespuestaPreguntaInput = {
    id?: string
    nombre: string
    tipo: string
    tamano: number
    fechaCarga?: Date | string
    url: string
    descripcion?: string | null
    vigencia?: Date | string | null
    estado?: string
  }

  export type EvidenciaCreateOrConnectWithoutRespuestaPreguntaInput = {
    where: EvidenciaWhereUniqueInput
    create: XOR<EvidenciaCreateWithoutRespuestaPreguntaInput, EvidenciaUncheckedCreateWithoutRespuestaPreguntaInput>
  }

  export type EvidenciaCreateManyRespuestaPreguntaInputEnvelope = {
    data: EvidenciaCreateManyRespuestaPreguntaInput | EvidenciaCreateManyRespuestaPreguntaInput[]
  }

  export type RespuestaCuestionarioUpsertWithoutRespuestasInput = {
    update: XOR<RespuestaCuestionarioUpdateWithoutRespuestasInput, RespuestaCuestionarioUncheckedUpdateWithoutRespuestasInput>
    create: XOR<RespuestaCuestionarioCreateWithoutRespuestasInput, RespuestaCuestionarioUncheckedCreateWithoutRespuestasInput>
    where?: RespuestaCuestionarioWhereInput
  }

  export type RespuestaCuestionarioUpdateToOneWithWhereWithoutRespuestasInput = {
    where?: RespuestaCuestionarioWhereInput
    data: XOR<RespuestaCuestionarioUpdateWithoutRespuestasInput, RespuestaCuestionarioUncheckedUpdateWithoutRespuestasInput>
  }

  export type RespuestaCuestionarioUpdateWithoutRespuestasInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    puntuacionTotal?: FloatFieldUpdateOperationsInput | number
    nivelCumplimiento?: NullableStringFieldUpdateOperationsInput | string | null
    comentariosGenerales?: NullableStringFieldUpdateOperationsInput | string | null
    asignacion?: AsignacionCuestionarioUpdateOneRequiredWithoutRespuestasNestedInput
    respondidoPor?: UsuarioUpdateOneRequiredWithoutRespuestasCuestionarioNestedInput
  }

  export type RespuestaCuestionarioUncheckedUpdateWithoutRespuestasInput = {
    id?: StringFieldUpdateOperationsInput | string
    asignacionId?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    respondidoPorId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    puntuacionTotal?: FloatFieldUpdateOperationsInput | number
    nivelCumplimiento?: NullableStringFieldUpdateOperationsInput | string | null
    comentariosGenerales?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PreguntaUpsertWithoutRespuestasInput = {
    update: XOR<PreguntaUpdateWithoutRespuestasInput, PreguntaUncheckedUpdateWithoutRespuestasInput>
    create: XOR<PreguntaCreateWithoutRespuestasInput, PreguntaUncheckedCreateWithoutRespuestasInput>
    where?: PreguntaWhereInput
  }

  export type PreguntaUpdateToOneWithWhereWithoutRespuestasInput = {
    where?: PreguntaWhereInput
    data: XOR<PreguntaUpdateWithoutRespuestasInput, PreguntaUncheckedUpdateWithoutRespuestasInput>
  }

  export type PreguntaUpdateWithoutRespuestasInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    requerida?: BoolFieldUpdateOperationsInput | boolean
    peso?: FloatFieldUpdateOperationsInput | number
    opciones?: NullableStringFieldUpdateOperationsInput | string | null
    escalaMin?: NullableIntFieldUpdateOperationsInput | number | null
    escalaMax?: NullableIntFieldUpdateOperationsInput | number | null
    ayuda?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    requisitoNormativoId?: NullableStringFieldUpdateOperationsInput | string | null
    controlAsociado?: NullableStringFieldUpdateOperationsInput | string | null
    requiereEvidencia?: BoolFieldUpdateOperationsInput | boolean
    maxStars?: NullableIntFieldUpdateOperationsInput | number | null
    leftAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    rightAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    likertLabels?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    logicaCondicional?: NullableStringFieldUpdateOperationsInput | string | null
    isCalculated?: BoolFieldUpdateOperationsInput | boolean
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    seccion?: SeccionUpdateOneRequiredWithoutPreguntasNestedInput
    hallazgos?: HallazgoUpdateManyWithoutPreguntaNestedInput
  }

  export type PreguntaUncheckedUpdateWithoutRespuestasInput = {
    id?: StringFieldUpdateOperationsInput | string
    seccionId?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    requerida?: BoolFieldUpdateOperationsInput | boolean
    peso?: FloatFieldUpdateOperationsInput | number
    opciones?: NullableStringFieldUpdateOperationsInput | string | null
    escalaMin?: NullableIntFieldUpdateOperationsInput | number | null
    escalaMax?: NullableIntFieldUpdateOperationsInput | number | null
    ayuda?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    requisitoNormativoId?: NullableStringFieldUpdateOperationsInput | string | null
    controlAsociado?: NullableStringFieldUpdateOperationsInput | string | null
    requiereEvidencia?: BoolFieldUpdateOperationsInput | boolean
    maxStars?: NullableIntFieldUpdateOperationsInput | number | null
    leftAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    rightAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    likertLabels?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    logicaCondicional?: NullableStringFieldUpdateOperationsInput | string | null
    isCalculated?: BoolFieldUpdateOperationsInput | boolean
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    hallazgos?: HallazgoUncheckedUpdateManyWithoutPreguntaNestedInput
  }

  export type EvidenciaUpsertWithWhereUniqueWithoutRespuestaPreguntaInput = {
    where: EvidenciaWhereUniqueInput
    update: XOR<EvidenciaUpdateWithoutRespuestaPreguntaInput, EvidenciaUncheckedUpdateWithoutRespuestaPreguntaInput>
    create: XOR<EvidenciaCreateWithoutRespuestaPreguntaInput, EvidenciaUncheckedCreateWithoutRespuestaPreguntaInput>
  }

  export type EvidenciaUpdateWithWhereUniqueWithoutRespuestaPreguntaInput = {
    where: EvidenciaWhereUniqueInput
    data: XOR<EvidenciaUpdateWithoutRespuestaPreguntaInput, EvidenciaUncheckedUpdateWithoutRespuestaPreguntaInput>
  }

  export type EvidenciaUpdateManyWithWhereWithoutRespuestaPreguntaInput = {
    where: EvidenciaScalarWhereInput
    data: XOR<EvidenciaUpdateManyMutationInput, EvidenciaUncheckedUpdateManyWithoutRespuestaPreguntaInput>
  }

  export type EvidenciaScalarWhereInput = {
    AND?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
    OR?: EvidenciaScalarWhereInput[]
    NOT?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
    id?: StringFilter<"Evidencia"> | string
    respuestaPreguntaId?: StringFilter<"Evidencia"> | string
    nombre?: StringFilter<"Evidencia"> | string
    tipo?: StringFilter<"Evidencia"> | string
    tamano?: IntFilter<"Evidencia"> | number
    fechaCarga?: DateTimeFilter<"Evidencia"> | Date | string
    url?: StringFilter<"Evidencia"> | string
    descripcion?: StringNullableFilter<"Evidencia"> | string | null
    vigencia?: DateTimeNullableFilter<"Evidencia"> | Date | string | null
    estado?: StringFilter<"Evidencia"> | string
  }

  export type RespuestaPreguntaCreateWithoutEvidenciasInput = {
    id?: string
    valor?: string | null
    comentario?: string | null
    archivosAdjuntos?: string | null
    marcadaParaRevision?: boolean
    estadoRevision?: string
    comentarioRevisor?: string | null
    respuestaCuestionario: RespuestaCuestionarioCreateNestedOneWithoutRespuestasInput
    pregunta: PreguntaCreateNestedOneWithoutRespuestasInput
  }

  export type RespuestaPreguntaUncheckedCreateWithoutEvidenciasInput = {
    id?: string
    respuestaCuestionarioId: string
    preguntaId: string
    valor?: string | null
    comentario?: string | null
    archivosAdjuntos?: string | null
    marcadaParaRevision?: boolean
    estadoRevision?: string
    comentarioRevisor?: string | null
  }

  export type RespuestaPreguntaCreateOrConnectWithoutEvidenciasInput = {
    where: RespuestaPreguntaWhereUniqueInput
    create: XOR<RespuestaPreguntaCreateWithoutEvidenciasInput, RespuestaPreguntaUncheckedCreateWithoutEvidenciasInput>
  }

  export type RespuestaPreguntaUpsertWithoutEvidenciasInput = {
    update: XOR<RespuestaPreguntaUpdateWithoutEvidenciasInput, RespuestaPreguntaUncheckedUpdateWithoutEvidenciasInput>
    create: XOR<RespuestaPreguntaCreateWithoutEvidenciasInput, RespuestaPreguntaUncheckedCreateWithoutEvidenciasInput>
    where?: RespuestaPreguntaWhereInput
  }

  export type RespuestaPreguntaUpdateToOneWithWhereWithoutEvidenciasInput = {
    where?: RespuestaPreguntaWhereInput
    data: XOR<RespuestaPreguntaUpdateWithoutEvidenciasInput, RespuestaPreguntaUncheckedUpdateWithoutEvidenciasInput>
  }

  export type RespuestaPreguntaUpdateWithoutEvidenciasInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    archivosAdjuntos?: NullableStringFieldUpdateOperationsInput | string | null
    marcadaParaRevision?: BoolFieldUpdateOperationsInput | boolean
    estadoRevision?: StringFieldUpdateOperationsInput | string
    comentarioRevisor?: NullableStringFieldUpdateOperationsInput | string | null
    respuestaCuestionario?: RespuestaCuestionarioUpdateOneRequiredWithoutRespuestasNestedInput
    pregunta?: PreguntaUpdateOneRequiredWithoutRespuestasNestedInput
  }

  export type RespuestaPreguntaUncheckedUpdateWithoutEvidenciasInput = {
    id?: StringFieldUpdateOperationsInput | string
    respuestaCuestionarioId?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    archivosAdjuntos?: NullableStringFieldUpdateOperationsInput | string | null
    marcadaParaRevision?: BoolFieldUpdateOperationsInput | boolean
    estadoRevision?: StringFieldUpdateOperationsInput | string
    comentarioRevisor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PreguntaCreateWithoutHallazgosInput = {
    id?: string
    texto: string
    tipo: string
    requerida?: boolean
    peso?: number
    opciones?: string | null
    escalaMin?: number | null
    escalaMax?: number | null
    ayuda?: string | null
    placeholder?: string | null
    requisitoNormativoId?: string | null
    controlAsociado?: string | null
    requiereEvidencia?: boolean
    maxStars?: number | null
    leftAnchor?: string | null
    rightAnchor?: string | null
    likertLabels?: string | null
    displayConditionQuestionId?: string | null
    displayConditionAnswer?: string | null
    logicaCondicional?: string | null
    isCalculated?: boolean
    formula?: string | null
    orden?: number
    seccion: SeccionCreateNestedOneWithoutPreguntasInput
    respuestas?: RespuestaPreguntaCreateNestedManyWithoutPreguntaInput
  }

  export type PreguntaUncheckedCreateWithoutHallazgosInput = {
    id?: string
    seccionId: string
    texto: string
    tipo: string
    requerida?: boolean
    peso?: number
    opciones?: string | null
    escalaMin?: number | null
    escalaMax?: number | null
    ayuda?: string | null
    placeholder?: string | null
    requisitoNormativoId?: string | null
    controlAsociado?: string | null
    requiereEvidencia?: boolean
    maxStars?: number | null
    leftAnchor?: string | null
    rightAnchor?: string | null
    likertLabels?: string | null
    displayConditionQuestionId?: string | null
    displayConditionAnswer?: string | null
    logicaCondicional?: string | null
    isCalculated?: boolean
    formula?: string | null
    orden?: number
    respuestas?: RespuestaPreguntaUncheckedCreateNestedManyWithoutPreguntaInput
  }

  export type PreguntaCreateOrConnectWithoutHallazgosInput = {
    where: PreguntaWhereUniqueInput
    create: XOR<PreguntaCreateWithoutHallazgosInput, PreguntaUncheckedCreateWithoutHallazgosInput>
  }

  export type PreguntaUpsertWithoutHallazgosInput = {
    update: XOR<PreguntaUpdateWithoutHallazgosInput, PreguntaUncheckedUpdateWithoutHallazgosInput>
    create: XOR<PreguntaCreateWithoutHallazgosInput, PreguntaUncheckedCreateWithoutHallazgosInput>
    where?: PreguntaWhereInput
  }

  export type PreguntaUpdateToOneWithWhereWithoutHallazgosInput = {
    where?: PreguntaWhereInput
    data: XOR<PreguntaUpdateWithoutHallazgosInput, PreguntaUncheckedUpdateWithoutHallazgosInput>
  }

  export type PreguntaUpdateWithoutHallazgosInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    requerida?: BoolFieldUpdateOperationsInput | boolean
    peso?: FloatFieldUpdateOperationsInput | number
    opciones?: NullableStringFieldUpdateOperationsInput | string | null
    escalaMin?: NullableIntFieldUpdateOperationsInput | number | null
    escalaMax?: NullableIntFieldUpdateOperationsInput | number | null
    ayuda?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    requisitoNormativoId?: NullableStringFieldUpdateOperationsInput | string | null
    controlAsociado?: NullableStringFieldUpdateOperationsInput | string | null
    requiereEvidencia?: BoolFieldUpdateOperationsInput | boolean
    maxStars?: NullableIntFieldUpdateOperationsInput | number | null
    leftAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    rightAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    likertLabels?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    logicaCondicional?: NullableStringFieldUpdateOperationsInput | string | null
    isCalculated?: BoolFieldUpdateOperationsInput | boolean
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    seccion?: SeccionUpdateOneRequiredWithoutPreguntasNestedInput
    respuestas?: RespuestaPreguntaUpdateManyWithoutPreguntaNestedInput
  }

  export type PreguntaUncheckedUpdateWithoutHallazgosInput = {
    id?: StringFieldUpdateOperationsInput | string
    seccionId?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    requerida?: BoolFieldUpdateOperationsInput | boolean
    peso?: FloatFieldUpdateOperationsInput | number
    opciones?: NullableStringFieldUpdateOperationsInput | string | null
    escalaMin?: NullableIntFieldUpdateOperationsInput | number | null
    escalaMax?: NullableIntFieldUpdateOperationsInput | number | null
    ayuda?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    requisitoNormativoId?: NullableStringFieldUpdateOperationsInput | string | null
    controlAsociado?: NullableStringFieldUpdateOperationsInput | string | null
    requiereEvidencia?: BoolFieldUpdateOperationsInput | boolean
    maxStars?: NullableIntFieldUpdateOperationsInput | number | null
    leftAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    rightAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    likertLabels?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    logicaCondicional?: NullableStringFieldUpdateOperationsInput | string | null
    isCalculated?: BoolFieldUpdateOperationsInput | boolean
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    respuestas?: RespuestaPreguntaUncheckedUpdateManyWithoutPreguntaNestedInput
  }

  export type AsignacionCuestionarioCreateWithoutMensajesChatInput = {
    id?: string
    cuestionarioIds?: string | null
    titulo: string
    descripcion?: string | null
    tipoRevision: string
    usuariosAsignados: string
    usuariosAsignadosNombres: string
    emailsExternos?: string | null
    contrasenaAcceso?: string | null
    activosObjetivo: string
    activosObjetivoNombres: string
    procesosObjetivo: string
    procesosObjetivoNombres: string
    aprobadores: string
    aprobadoresNombres: string
    evaluadosInternos?: string | null
    evaluadosInternosNombres?: string | null
    areaId: string
    areaNombre: string
    responsableId: string
    responsableNombre: string
    fechaAsignacion?: Date | string
    fechaInicio: Date | string
    fechaVencimiento: Date | string
    estado?: string
    progreso?: number
    instrucciones?: string | null
    recordatorios?: boolean
    tokenAccesoExterno?: string | null
    recurrencia?: string | null
    cuestionario: CuestionarioCreateNestedOneWithoutAsignacionesInput
    evaluadosExternos?: EvaluadoExternoCreateNestedManyWithoutAsignacionInput
    respuestas?: RespuestaCuestionarioCreateNestedManyWithoutAsignacionInput
  }

  export type AsignacionCuestionarioUncheckedCreateWithoutMensajesChatInput = {
    id?: string
    cuestionarioId: string
    cuestionarioIds?: string | null
    titulo: string
    descripcion?: string | null
    tipoRevision: string
    usuariosAsignados: string
    usuariosAsignadosNombres: string
    emailsExternos?: string | null
    contrasenaAcceso?: string | null
    activosObjetivo: string
    activosObjetivoNombres: string
    procesosObjetivo: string
    procesosObjetivoNombres: string
    aprobadores: string
    aprobadoresNombres: string
    evaluadosInternos?: string | null
    evaluadosInternosNombres?: string | null
    areaId: string
    areaNombre: string
    responsableId: string
    responsableNombre: string
    fechaAsignacion?: Date | string
    fechaInicio: Date | string
    fechaVencimiento: Date | string
    estado?: string
    progreso?: number
    instrucciones?: string | null
    recordatorios?: boolean
    tokenAccesoExterno?: string | null
    recurrencia?: string | null
    evaluadosExternos?: EvaluadoExternoUncheckedCreateNestedManyWithoutAsignacionInput
    respuestas?: RespuestaCuestionarioUncheckedCreateNestedManyWithoutAsignacionInput
  }

  export type AsignacionCuestionarioCreateOrConnectWithoutMensajesChatInput = {
    where: AsignacionCuestionarioWhereUniqueInput
    create: XOR<AsignacionCuestionarioCreateWithoutMensajesChatInput, AsignacionCuestionarioUncheckedCreateWithoutMensajesChatInput>
  }

  export type AsignacionCuestionarioUpsertWithoutMensajesChatInput = {
    update: XOR<AsignacionCuestionarioUpdateWithoutMensajesChatInput, AsignacionCuestionarioUncheckedUpdateWithoutMensajesChatInput>
    create: XOR<AsignacionCuestionarioCreateWithoutMensajesChatInput, AsignacionCuestionarioUncheckedCreateWithoutMensajesChatInput>
    where?: AsignacionCuestionarioWhereInput
  }

  export type AsignacionCuestionarioUpdateToOneWithWhereWithoutMensajesChatInput = {
    where?: AsignacionCuestionarioWhereInput
    data: XOR<AsignacionCuestionarioUpdateWithoutMensajesChatInput, AsignacionCuestionarioUncheckedUpdateWithoutMensajesChatInput>
  }

  export type AsignacionCuestionarioUpdateWithoutMensajesChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioIds?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipoRevision?: StringFieldUpdateOperationsInput | string
    usuariosAsignados?: StringFieldUpdateOperationsInput | string
    usuariosAsignadosNombres?: StringFieldUpdateOperationsInput | string
    emailsExternos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasenaAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activosObjetivo?: StringFieldUpdateOperationsInput | string
    activosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    procesosObjetivo?: StringFieldUpdateOperationsInput | string
    procesosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    aprobadores?: StringFieldUpdateOperationsInput | string
    aprobadoresNombres?: StringFieldUpdateOperationsInput | string
    evaluadosInternos?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosInternosNombres?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: StringFieldUpdateOperationsInput | string
    areaNombre?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    responsableNombre?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    instrucciones?: NullableStringFieldUpdateOperationsInput | string | null
    recordatorios?: BoolFieldUpdateOperationsInput | boolean
    tokenAccesoExterno?: NullableStringFieldUpdateOperationsInput | string | null
    recurrencia?: NullableStringFieldUpdateOperationsInput | string | null
    cuestionario?: CuestionarioUpdateOneRequiredWithoutAsignacionesNestedInput
    evaluadosExternos?: EvaluadoExternoUpdateManyWithoutAsignacionNestedInput
    respuestas?: RespuestaCuestionarioUpdateManyWithoutAsignacionNestedInput
  }

  export type AsignacionCuestionarioUncheckedUpdateWithoutMensajesChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    cuestionarioIds?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipoRevision?: StringFieldUpdateOperationsInput | string
    usuariosAsignados?: StringFieldUpdateOperationsInput | string
    usuariosAsignadosNombres?: StringFieldUpdateOperationsInput | string
    emailsExternos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasenaAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activosObjetivo?: StringFieldUpdateOperationsInput | string
    activosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    procesosObjetivo?: StringFieldUpdateOperationsInput | string
    procesosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    aprobadores?: StringFieldUpdateOperationsInput | string
    aprobadoresNombres?: StringFieldUpdateOperationsInput | string
    evaluadosInternos?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosInternosNombres?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: StringFieldUpdateOperationsInput | string
    areaNombre?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    responsableNombre?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    instrucciones?: NullableStringFieldUpdateOperationsInput | string | null
    recordatorios?: BoolFieldUpdateOperationsInput | boolean
    tokenAccesoExterno?: NullableStringFieldUpdateOperationsInput | string | null
    recurrencia?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosExternos?: EvaluadoExternoUncheckedUpdateManyWithoutAsignacionNestedInput
    respuestas?: RespuestaCuestionarioUncheckedUpdateManyWithoutAsignacionNestedInput
  }

  export type ProcessNodeCreateWithoutProcesoInput = {
    id?: string
    type: string
    label: string
    descripcion?: string | null
    config: string
    positionX: number
    positionY: number
    edgesFrom?: ProcessEdgeCreateNestedManyWithoutSourceNodeInput
    edgesTo?: ProcessEdgeCreateNestedManyWithoutTargetNodeInput
    kpiHistorico?: KpiHistoricoCreateNestedManyWithoutNodoInput
  }

  export type ProcessNodeUncheckedCreateWithoutProcesoInput = {
    id?: string
    type: string
    label: string
    descripcion?: string | null
    config: string
    positionX: number
    positionY: number
    edgesFrom?: ProcessEdgeUncheckedCreateNestedManyWithoutSourceNodeInput
    edgesTo?: ProcessEdgeUncheckedCreateNestedManyWithoutTargetNodeInput
    kpiHistorico?: KpiHistoricoUncheckedCreateNestedManyWithoutNodoInput
  }

  export type ProcessNodeCreateOrConnectWithoutProcesoInput = {
    where: ProcessNodeWhereUniqueInput
    create: XOR<ProcessNodeCreateWithoutProcesoInput, ProcessNodeUncheckedCreateWithoutProcesoInput>
  }

  export type ProcessNodeCreateManyProcesoInputEnvelope = {
    data: ProcessNodeCreateManyProcesoInput | ProcessNodeCreateManyProcesoInput[]
  }

  export type ProcessEdgeCreateWithoutProcesoInput = {
    id?: string
    sourceHandle?: string | null
    targetHandle?: string | null
    label?: string | null
    sourceNode: ProcessNodeCreateNestedOneWithoutEdgesFromInput
    targetNode: ProcessNodeCreateNestedOneWithoutEdgesToInput
  }

  export type ProcessEdgeUncheckedCreateWithoutProcesoInput = {
    id?: string
    sourceNodeId: string
    targetNodeId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    label?: string | null
  }

  export type ProcessEdgeCreateOrConnectWithoutProcesoInput = {
    where: ProcessEdgeWhereUniqueInput
    create: XOR<ProcessEdgeCreateWithoutProcesoInput, ProcessEdgeUncheckedCreateWithoutProcesoInput>
  }

  export type ProcessEdgeCreateManyProcesoInputEnvelope = {
    data: ProcessEdgeCreateManyProcesoInput | ProcessEdgeCreateManyProcesoInput[]
  }

  export type ObjetivoProcesoCreateWithoutProcesoInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    progreso?: number
    kpis?: KpiProcesoCreateNestedManyWithoutObjetivoInput
  }

  export type ObjetivoProcesoUncheckedCreateWithoutProcesoInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    progreso?: number
    kpis?: KpiProcesoUncheckedCreateNestedManyWithoutObjetivoInput
  }

  export type ObjetivoProcesoCreateOrConnectWithoutProcesoInput = {
    where: ObjetivoProcesoWhereUniqueInput
    create: XOR<ObjetivoProcesoCreateWithoutProcesoInput, ObjetivoProcesoUncheckedCreateWithoutProcesoInput>
  }

  export type ObjetivoProcesoCreateManyProcesoInputEnvelope = {
    data: ObjetivoProcesoCreateManyProcesoInput | ObjetivoProcesoCreateManyProcesoInput[]
  }

  export type KpiProcesoCreateWithoutProcesoInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    unidad: string
    meta: number
    valorActual?: number
    fechaUltimaActualizacion?: Date | string | null
    alertaAdvertencia?: number | null
    alertaCritico?: number | null
    alertaDireccion?: string
    objetivo?: ObjetivoProcesoCreateNestedOneWithoutKpisInput
    historico?: KpiHistoricoCreateNestedManyWithoutKpiInput
  }

  export type KpiProcesoUncheckedCreateWithoutProcesoInput = {
    id?: string
    objetivoId?: string | null
    nombre: string
    descripcion?: string | null
    unidad: string
    meta: number
    valorActual?: number
    fechaUltimaActualizacion?: Date | string | null
    alertaAdvertencia?: number | null
    alertaCritico?: number | null
    alertaDireccion?: string
    historico?: KpiHistoricoUncheckedCreateNestedManyWithoutKpiInput
  }

  export type KpiProcesoCreateOrConnectWithoutProcesoInput = {
    where: KpiProcesoWhereUniqueInput
    create: XOR<KpiProcesoCreateWithoutProcesoInput, KpiProcesoUncheckedCreateWithoutProcesoInput>
  }

  export type KpiProcesoCreateManyProcesoInputEnvelope = {
    data: KpiProcesoCreateManyProcesoInput | KpiProcesoCreateManyProcesoInput[]
  }

  export type ProcessNodeUpsertWithWhereUniqueWithoutProcesoInput = {
    where: ProcessNodeWhereUniqueInput
    update: XOR<ProcessNodeUpdateWithoutProcesoInput, ProcessNodeUncheckedUpdateWithoutProcesoInput>
    create: XOR<ProcessNodeCreateWithoutProcesoInput, ProcessNodeUncheckedCreateWithoutProcesoInput>
  }

  export type ProcessNodeUpdateWithWhereUniqueWithoutProcesoInput = {
    where: ProcessNodeWhereUniqueInput
    data: XOR<ProcessNodeUpdateWithoutProcesoInput, ProcessNodeUncheckedUpdateWithoutProcesoInput>
  }

  export type ProcessNodeUpdateManyWithWhereWithoutProcesoInput = {
    where: ProcessNodeScalarWhereInput
    data: XOR<ProcessNodeUpdateManyMutationInput, ProcessNodeUncheckedUpdateManyWithoutProcesoInput>
  }

  export type ProcessNodeScalarWhereInput = {
    AND?: ProcessNodeScalarWhereInput | ProcessNodeScalarWhereInput[]
    OR?: ProcessNodeScalarWhereInput[]
    NOT?: ProcessNodeScalarWhereInput | ProcessNodeScalarWhereInput[]
    id?: StringFilter<"ProcessNode"> | string
    procesoId?: StringFilter<"ProcessNode"> | string
    type?: StringFilter<"ProcessNode"> | string
    label?: StringFilter<"ProcessNode"> | string
    descripcion?: StringNullableFilter<"ProcessNode"> | string | null
    config?: StringFilter<"ProcessNode"> | string
    positionX?: FloatFilter<"ProcessNode"> | number
    positionY?: FloatFilter<"ProcessNode"> | number
  }

  export type ProcessEdgeUpsertWithWhereUniqueWithoutProcesoInput = {
    where: ProcessEdgeWhereUniqueInput
    update: XOR<ProcessEdgeUpdateWithoutProcesoInput, ProcessEdgeUncheckedUpdateWithoutProcesoInput>
    create: XOR<ProcessEdgeCreateWithoutProcesoInput, ProcessEdgeUncheckedCreateWithoutProcesoInput>
  }

  export type ProcessEdgeUpdateWithWhereUniqueWithoutProcesoInput = {
    where: ProcessEdgeWhereUniqueInput
    data: XOR<ProcessEdgeUpdateWithoutProcesoInput, ProcessEdgeUncheckedUpdateWithoutProcesoInput>
  }

  export type ProcessEdgeUpdateManyWithWhereWithoutProcesoInput = {
    where: ProcessEdgeScalarWhereInput
    data: XOR<ProcessEdgeUpdateManyMutationInput, ProcessEdgeUncheckedUpdateManyWithoutProcesoInput>
  }

  export type ProcessEdgeScalarWhereInput = {
    AND?: ProcessEdgeScalarWhereInput | ProcessEdgeScalarWhereInput[]
    OR?: ProcessEdgeScalarWhereInput[]
    NOT?: ProcessEdgeScalarWhereInput | ProcessEdgeScalarWhereInput[]
    id?: StringFilter<"ProcessEdge"> | string
    procesoId?: StringFilter<"ProcessEdge"> | string
    sourceNodeId?: StringFilter<"ProcessEdge"> | string
    targetNodeId?: StringFilter<"ProcessEdge"> | string
    sourceHandle?: StringNullableFilter<"ProcessEdge"> | string | null
    targetHandle?: StringNullableFilter<"ProcessEdge"> | string | null
    label?: StringNullableFilter<"ProcessEdge"> | string | null
  }

  export type ObjetivoProcesoUpsertWithWhereUniqueWithoutProcesoInput = {
    where: ObjetivoProcesoWhereUniqueInput
    update: XOR<ObjetivoProcesoUpdateWithoutProcesoInput, ObjetivoProcesoUncheckedUpdateWithoutProcesoInput>
    create: XOR<ObjetivoProcesoCreateWithoutProcesoInput, ObjetivoProcesoUncheckedCreateWithoutProcesoInput>
  }

  export type ObjetivoProcesoUpdateWithWhereUniqueWithoutProcesoInput = {
    where: ObjetivoProcesoWhereUniqueInput
    data: XOR<ObjetivoProcesoUpdateWithoutProcesoInput, ObjetivoProcesoUncheckedUpdateWithoutProcesoInput>
  }

  export type ObjetivoProcesoUpdateManyWithWhereWithoutProcesoInput = {
    where: ObjetivoProcesoScalarWhereInput
    data: XOR<ObjetivoProcesoUpdateManyMutationInput, ObjetivoProcesoUncheckedUpdateManyWithoutProcesoInput>
  }

  export type ObjetivoProcesoScalarWhereInput = {
    AND?: ObjetivoProcesoScalarWhereInput | ObjetivoProcesoScalarWhereInput[]
    OR?: ObjetivoProcesoScalarWhereInput[]
    NOT?: ObjetivoProcesoScalarWhereInput | ObjetivoProcesoScalarWhereInput[]
    id?: StringFilter<"ObjetivoProceso"> | string
    procesoId?: StringFilter<"ObjetivoProceso"> | string
    nombre?: StringFilter<"ObjetivoProceso"> | string
    descripcion?: StringFilter<"ObjetivoProceso"> | string
    tipo?: StringFilter<"ObjetivoProceso"> | string
    progreso?: FloatFilter<"ObjetivoProceso"> | number
  }

  export type KpiProcesoUpsertWithWhereUniqueWithoutProcesoInput = {
    where: KpiProcesoWhereUniqueInput
    update: XOR<KpiProcesoUpdateWithoutProcesoInput, KpiProcesoUncheckedUpdateWithoutProcesoInput>
    create: XOR<KpiProcesoCreateWithoutProcesoInput, KpiProcesoUncheckedCreateWithoutProcesoInput>
  }

  export type KpiProcesoUpdateWithWhereUniqueWithoutProcesoInput = {
    where: KpiProcesoWhereUniqueInput
    data: XOR<KpiProcesoUpdateWithoutProcesoInput, KpiProcesoUncheckedUpdateWithoutProcesoInput>
  }

  export type KpiProcesoUpdateManyWithWhereWithoutProcesoInput = {
    where: KpiProcesoScalarWhereInput
    data: XOR<KpiProcesoUpdateManyMutationInput, KpiProcesoUncheckedUpdateManyWithoutProcesoInput>
  }

  export type KpiProcesoScalarWhereInput = {
    AND?: KpiProcesoScalarWhereInput | KpiProcesoScalarWhereInput[]
    OR?: KpiProcesoScalarWhereInput[]
    NOT?: KpiProcesoScalarWhereInput | KpiProcesoScalarWhereInput[]
    id?: StringFilter<"KpiProceso"> | string
    procesoId?: StringFilter<"KpiProceso"> | string
    objetivoId?: StringNullableFilter<"KpiProceso"> | string | null
    nombre?: StringFilter<"KpiProceso"> | string
    descripcion?: StringNullableFilter<"KpiProceso"> | string | null
    unidad?: StringFilter<"KpiProceso"> | string
    meta?: FloatFilter<"KpiProceso"> | number
    valorActual?: FloatFilter<"KpiProceso"> | number
    fechaUltimaActualizacion?: DateTimeNullableFilter<"KpiProceso"> | Date | string | null
    alertaAdvertencia?: FloatNullableFilter<"KpiProceso"> | number | null
    alertaCritico?: FloatNullableFilter<"KpiProceso"> | number | null
    alertaDireccion?: StringFilter<"KpiProceso"> | string
  }

  export type ProcesoCreateWithoutNodosInput = {
    id?: string
    nombre: string
    descripcion: string
    version?: string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    edges?: ProcessEdgeCreateNestedManyWithoutProcesoInput
    objetivos?: ObjetivoProcesoCreateNestedManyWithoutProcesoInput
    kpis?: KpiProcesoCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoUncheckedCreateWithoutNodosInput = {
    id?: string
    nombre: string
    descripcion: string
    version?: string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    edges?: ProcessEdgeUncheckedCreateNestedManyWithoutProcesoInput
    objetivos?: ObjetivoProcesoUncheckedCreateNestedManyWithoutProcesoInput
    kpis?: KpiProcesoUncheckedCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoCreateOrConnectWithoutNodosInput = {
    where: ProcesoWhereUniqueInput
    create: XOR<ProcesoCreateWithoutNodosInput, ProcesoUncheckedCreateWithoutNodosInput>
  }

  export type ProcessEdgeCreateWithoutSourceNodeInput = {
    id?: string
    sourceHandle?: string | null
    targetHandle?: string | null
    label?: string | null
    proceso: ProcesoCreateNestedOneWithoutEdgesInput
    targetNode: ProcessNodeCreateNestedOneWithoutEdgesToInput
  }

  export type ProcessEdgeUncheckedCreateWithoutSourceNodeInput = {
    id?: string
    procesoId: string
    targetNodeId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    label?: string | null
  }

  export type ProcessEdgeCreateOrConnectWithoutSourceNodeInput = {
    where: ProcessEdgeWhereUniqueInput
    create: XOR<ProcessEdgeCreateWithoutSourceNodeInput, ProcessEdgeUncheckedCreateWithoutSourceNodeInput>
  }

  export type ProcessEdgeCreateManySourceNodeInputEnvelope = {
    data: ProcessEdgeCreateManySourceNodeInput | ProcessEdgeCreateManySourceNodeInput[]
  }

  export type ProcessEdgeCreateWithoutTargetNodeInput = {
    id?: string
    sourceHandle?: string | null
    targetHandle?: string | null
    label?: string | null
    proceso: ProcesoCreateNestedOneWithoutEdgesInput
    sourceNode: ProcessNodeCreateNestedOneWithoutEdgesFromInput
  }

  export type ProcessEdgeUncheckedCreateWithoutTargetNodeInput = {
    id?: string
    procesoId: string
    sourceNodeId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    label?: string | null
  }

  export type ProcessEdgeCreateOrConnectWithoutTargetNodeInput = {
    where: ProcessEdgeWhereUniqueInput
    create: XOR<ProcessEdgeCreateWithoutTargetNodeInput, ProcessEdgeUncheckedCreateWithoutTargetNodeInput>
  }

  export type ProcessEdgeCreateManyTargetNodeInputEnvelope = {
    data: ProcessEdgeCreateManyTargetNodeInput | ProcessEdgeCreateManyTargetNodeInput[]
  }

  export type KpiHistoricoCreateWithoutNodoInput = {
    id?: string
    valor: number
    timestamp?: Date | string
    procesoId: string
    metadatos?: string | null
    kpi: KpiProcesoCreateNestedOneWithoutHistoricoInput
  }

  export type KpiHistoricoUncheckedCreateWithoutNodoInput = {
    id?: string
    kpiId: string
    valor: number
    timestamp?: Date | string
    procesoId: string
    metadatos?: string | null
  }

  export type KpiHistoricoCreateOrConnectWithoutNodoInput = {
    where: KpiHistoricoWhereUniqueInput
    create: XOR<KpiHistoricoCreateWithoutNodoInput, KpiHistoricoUncheckedCreateWithoutNodoInput>
  }

  export type KpiHistoricoCreateManyNodoInputEnvelope = {
    data: KpiHistoricoCreateManyNodoInput | KpiHistoricoCreateManyNodoInput[]
  }

  export type ProcesoUpsertWithoutNodosInput = {
    update: XOR<ProcesoUpdateWithoutNodosInput, ProcesoUncheckedUpdateWithoutNodosInput>
    create: XOR<ProcesoCreateWithoutNodosInput, ProcesoUncheckedCreateWithoutNodosInput>
    where?: ProcesoWhereInput
  }

  export type ProcesoUpdateToOneWithWhereWithoutNodosInput = {
    where?: ProcesoWhereInput
    data: XOR<ProcesoUpdateWithoutNodosInput, ProcesoUncheckedUpdateWithoutNodosInput>
  }

  export type ProcesoUpdateWithoutNodosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    edges?: ProcessEdgeUpdateManyWithoutProcesoNestedInput
    objetivos?: ObjetivoProcesoUpdateManyWithoutProcesoNestedInput
    kpis?: KpiProcesoUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoUncheckedUpdateWithoutNodosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    edges?: ProcessEdgeUncheckedUpdateManyWithoutProcesoNestedInput
    objetivos?: ObjetivoProcesoUncheckedUpdateManyWithoutProcesoNestedInput
    kpis?: KpiProcesoUncheckedUpdateManyWithoutProcesoNestedInput
  }

  export type ProcessEdgeUpsertWithWhereUniqueWithoutSourceNodeInput = {
    where: ProcessEdgeWhereUniqueInput
    update: XOR<ProcessEdgeUpdateWithoutSourceNodeInput, ProcessEdgeUncheckedUpdateWithoutSourceNodeInput>
    create: XOR<ProcessEdgeCreateWithoutSourceNodeInput, ProcessEdgeUncheckedCreateWithoutSourceNodeInput>
  }

  export type ProcessEdgeUpdateWithWhereUniqueWithoutSourceNodeInput = {
    where: ProcessEdgeWhereUniqueInput
    data: XOR<ProcessEdgeUpdateWithoutSourceNodeInput, ProcessEdgeUncheckedUpdateWithoutSourceNodeInput>
  }

  export type ProcessEdgeUpdateManyWithWhereWithoutSourceNodeInput = {
    where: ProcessEdgeScalarWhereInput
    data: XOR<ProcessEdgeUpdateManyMutationInput, ProcessEdgeUncheckedUpdateManyWithoutSourceNodeInput>
  }

  export type ProcessEdgeUpsertWithWhereUniqueWithoutTargetNodeInput = {
    where: ProcessEdgeWhereUniqueInput
    update: XOR<ProcessEdgeUpdateWithoutTargetNodeInput, ProcessEdgeUncheckedUpdateWithoutTargetNodeInput>
    create: XOR<ProcessEdgeCreateWithoutTargetNodeInput, ProcessEdgeUncheckedCreateWithoutTargetNodeInput>
  }

  export type ProcessEdgeUpdateWithWhereUniqueWithoutTargetNodeInput = {
    where: ProcessEdgeWhereUniqueInput
    data: XOR<ProcessEdgeUpdateWithoutTargetNodeInput, ProcessEdgeUncheckedUpdateWithoutTargetNodeInput>
  }

  export type ProcessEdgeUpdateManyWithWhereWithoutTargetNodeInput = {
    where: ProcessEdgeScalarWhereInput
    data: XOR<ProcessEdgeUpdateManyMutationInput, ProcessEdgeUncheckedUpdateManyWithoutTargetNodeInput>
  }

  export type KpiHistoricoUpsertWithWhereUniqueWithoutNodoInput = {
    where: KpiHistoricoWhereUniqueInput
    update: XOR<KpiHistoricoUpdateWithoutNodoInput, KpiHistoricoUncheckedUpdateWithoutNodoInput>
    create: XOR<KpiHistoricoCreateWithoutNodoInput, KpiHistoricoUncheckedCreateWithoutNodoInput>
  }

  export type KpiHistoricoUpdateWithWhereUniqueWithoutNodoInput = {
    where: KpiHistoricoWhereUniqueInput
    data: XOR<KpiHistoricoUpdateWithoutNodoInput, KpiHistoricoUncheckedUpdateWithoutNodoInput>
  }

  export type KpiHistoricoUpdateManyWithWhereWithoutNodoInput = {
    where: KpiHistoricoScalarWhereInput
    data: XOR<KpiHistoricoUpdateManyMutationInput, KpiHistoricoUncheckedUpdateManyWithoutNodoInput>
  }

  export type KpiHistoricoScalarWhereInput = {
    AND?: KpiHistoricoScalarWhereInput | KpiHistoricoScalarWhereInput[]
    OR?: KpiHistoricoScalarWhereInput[]
    NOT?: KpiHistoricoScalarWhereInput | KpiHistoricoScalarWhereInput[]
    id?: StringFilter<"KpiHistorico"> | string
    kpiId?: StringFilter<"KpiHistorico"> | string
    valor?: FloatFilter<"KpiHistorico"> | number
    timestamp?: DateTimeFilter<"KpiHistorico"> | Date | string
    procesoId?: StringFilter<"KpiHistorico"> | string
    nodoId?: StringNullableFilter<"KpiHistorico"> | string | null
    metadatos?: StringNullableFilter<"KpiHistorico"> | string | null
  }

  export type ProcesoCreateWithoutEdgesInput = {
    id?: string
    nombre: string
    descripcion: string
    version?: string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    nodos?: ProcessNodeCreateNestedManyWithoutProcesoInput
    objetivos?: ObjetivoProcesoCreateNestedManyWithoutProcesoInput
    kpis?: KpiProcesoCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoUncheckedCreateWithoutEdgesInput = {
    id?: string
    nombre: string
    descripcion: string
    version?: string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    nodos?: ProcessNodeUncheckedCreateNestedManyWithoutProcesoInput
    objetivos?: ObjetivoProcesoUncheckedCreateNestedManyWithoutProcesoInput
    kpis?: KpiProcesoUncheckedCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoCreateOrConnectWithoutEdgesInput = {
    where: ProcesoWhereUniqueInput
    create: XOR<ProcesoCreateWithoutEdgesInput, ProcesoUncheckedCreateWithoutEdgesInput>
  }

  export type ProcessNodeCreateWithoutEdgesFromInput = {
    id?: string
    type: string
    label: string
    descripcion?: string | null
    config: string
    positionX: number
    positionY: number
    proceso: ProcesoCreateNestedOneWithoutNodosInput
    edgesTo?: ProcessEdgeCreateNestedManyWithoutTargetNodeInput
    kpiHistorico?: KpiHistoricoCreateNestedManyWithoutNodoInput
  }

  export type ProcessNodeUncheckedCreateWithoutEdgesFromInput = {
    id?: string
    procesoId: string
    type: string
    label: string
    descripcion?: string | null
    config: string
    positionX: number
    positionY: number
    edgesTo?: ProcessEdgeUncheckedCreateNestedManyWithoutTargetNodeInput
    kpiHistorico?: KpiHistoricoUncheckedCreateNestedManyWithoutNodoInput
  }

  export type ProcessNodeCreateOrConnectWithoutEdgesFromInput = {
    where: ProcessNodeWhereUniqueInput
    create: XOR<ProcessNodeCreateWithoutEdgesFromInput, ProcessNodeUncheckedCreateWithoutEdgesFromInput>
  }

  export type ProcessNodeCreateWithoutEdgesToInput = {
    id?: string
    type: string
    label: string
    descripcion?: string | null
    config: string
    positionX: number
    positionY: number
    proceso: ProcesoCreateNestedOneWithoutNodosInput
    edgesFrom?: ProcessEdgeCreateNestedManyWithoutSourceNodeInput
    kpiHistorico?: KpiHistoricoCreateNestedManyWithoutNodoInput
  }

  export type ProcessNodeUncheckedCreateWithoutEdgesToInput = {
    id?: string
    procesoId: string
    type: string
    label: string
    descripcion?: string | null
    config: string
    positionX: number
    positionY: number
    edgesFrom?: ProcessEdgeUncheckedCreateNestedManyWithoutSourceNodeInput
    kpiHistorico?: KpiHistoricoUncheckedCreateNestedManyWithoutNodoInput
  }

  export type ProcessNodeCreateOrConnectWithoutEdgesToInput = {
    where: ProcessNodeWhereUniqueInput
    create: XOR<ProcessNodeCreateWithoutEdgesToInput, ProcessNodeUncheckedCreateWithoutEdgesToInput>
  }

  export type ProcesoUpsertWithoutEdgesInput = {
    update: XOR<ProcesoUpdateWithoutEdgesInput, ProcesoUncheckedUpdateWithoutEdgesInput>
    create: XOR<ProcesoCreateWithoutEdgesInput, ProcesoUncheckedCreateWithoutEdgesInput>
    where?: ProcesoWhereInput
  }

  export type ProcesoUpdateToOneWithWhereWithoutEdgesInput = {
    where?: ProcesoWhereInput
    data: XOR<ProcesoUpdateWithoutEdgesInput, ProcesoUncheckedUpdateWithoutEdgesInput>
  }

  export type ProcesoUpdateWithoutEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    nodos?: ProcessNodeUpdateManyWithoutProcesoNestedInput
    objetivos?: ObjetivoProcesoUpdateManyWithoutProcesoNestedInput
    kpis?: KpiProcesoUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoUncheckedUpdateWithoutEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    nodos?: ProcessNodeUncheckedUpdateManyWithoutProcesoNestedInput
    objetivos?: ObjetivoProcesoUncheckedUpdateManyWithoutProcesoNestedInput
    kpis?: KpiProcesoUncheckedUpdateManyWithoutProcesoNestedInput
  }

  export type ProcessNodeUpsertWithoutEdgesFromInput = {
    update: XOR<ProcessNodeUpdateWithoutEdgesFromInput, ProcessNodeUncheckedUpdateWithoutEdgesFromInput>
    create: XOR<ProcessNodeCreateWithoutEdgesFromInput, ProcessNodeUncheckedCreateWithoutEdgesFromInput>
    where?: ProcessNodeWhereInput
  }

  export type ProcessNodeUpdateToOneWithWhereWithoutEdgesFromInput = {
    where?: ProcessNodeWhereInput
    data: XOR<ProcessNodeUpdateWithoutEdgesFromInput, ProcessNodeUncheckedUpdateWithoutEdgesFromInput>
  }

  export type ProcessNodeUpdateWithoutEdgesFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    proceso?: ProcesoUpdateOneRequiredWithoutNodosNestedInput
    edgesTo?: ProcessEdgeUpdateManyWithoutTargetNodeNestedInput
    kpiHistorico?: KpiHistoricoUpdateManyWithoutNodoNestedInput
  }

  export type ProcessNodeUncheckedUpdateWithoutEdgesFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    edgesTo?: ProcessEdgeUncheckedUpdateManyWithoutTargetNodeNestedInput
    kpiHistorico?: KpiHistoricoUncheckedUpdateManyWithoutNodoNestedInput
  }

  export type ProcessNodeUpsertWithoutEdgesToInput = {
    update: XOR<ProcessNodeUpdateWithoutEdgesToInput, ProcessNodeUncheckedUpdateWithoutEdgesToInput>
    create: XOR<ProcessNodeCreateWithoutEdgesToInput, ProcessNodeUncheckedCreateWithoutEdgesToInput>
    where?: ProcessNodeWhereInput
  }

  export type ProcessNodeUpdateToOneWithWhereWithoutEdgesToInput = {
    where?: ProcessNodeWhereInput
    data: XOR<ProcessNodeUpdateWithoutEdgesToInput, ProcessNodeUncheckedUpdateWithoutEdgesToInput>
  }

  export type ProcessNodeUpdateWithoutEdgesToInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    proceso?: ProcesoUpdateOneRequiredWithoutNodosNestedInput
    edgesFrom?: ProcessEdgeUpdateManyWithoutSourceNodeNestedInput
    kpiHistorico?: KpiHistoricoUpdateManyWithoutNodoNestedInput
  }

  export type ProcessNodeUncheckedUpdateWithoutEdgesToInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    edgesFrom?: ProcessEdgeUncheckedUpdateManyWithoutSourceNodeNestedInput
    kpiHistorico?: KpiHistoricoUncheckedUpdateManyWithoutNodoNestedInput
  }

  export type ProcesoCreateWithoutObjetivosInput = {
    id?: string
    nombre: string
    descripcion: string
    version?: string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    nodos?: ProcessNodeCreateNestedManyWithoutProcesoInput
    edges?: ProcessEdgeCreateNestedManyWithoutProcesoInput
    kpis?: KpiProcesoCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoUncheckedCreateWithoutObjetivosInput = {
    id?: string
    nombre: string
    descripcion: string
    version?: string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    nodos?: ProcessNodeUncheckedCreateNestedManyWithoutProcesoInput
    edges?: ProcessEdgeUncheckedCreateNestedManyWithoutProcesoInput
    kpis?: KpiProcesoUncheckedCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoCreateOrConnectWithoutObjetivosInput = {
    where: ProcesoWhereUniqueInput
    create: XOR<ProcesoCreateWithoutObjetivosInput, ProcesoUncheckedCreateWithoutObjetivosInput>
  }

  export type KpiProcesoCreateWithoutObjetivoInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    unidad: string
    meta: number
    valorActual?: number
    fechaUltimaActualizacion?: Date | string | null
    alertaAdvertencia?: number | null
    alertaCritico?: number | null
    alertaDireccion?: string
    proceso: ProcesoCreateNestedOneWithoutKpisInput
    historico?: KpiHistoricoCreateNestedManyWithoutKpiInput
  }

  export type KpiProcesoUncheckedCreateWithoutObjetivoInput = {
    id?: string
    procesoId: string
    nombre: string
    descripcion?: string | null
    unidad: string
    meta: number
    valorActual?: number
    fechaUltimaActualizacion?: Date | string | null
    alertaAdvertencia?: number | null
    alertaCritico?: number | null
    alertaDireccion?: string
    historico?: KpiHistoricoUncheckedCreateNestedManyWithoutKpiInput
  }

  export type KpiProcesoCreateOrConnectWithoutObjetivoInput = {
    where: KpiProcesoWhereUniqueInput
    create: XOR<KpiProcesoCreateWithoutObjetivoInput, KpiProcesoUncheckedCreateWithoutObjetivoInput>
  }

  export type KpiProcesoCreateManyObjetivoInputEnvelope = {
    data: KpiProcesoCreateManyObjetivoInput | KpiProcesoCreateManyObjetivoInput[]
  }

  export type ProcesoUpsertWithoutObjetivosInput = {
    update: XOR<ProcesoUpdateWithoutObjetivosInput, ProcesoUncheckedUpdateWithoutObjetivosInput>
    create: XOR<ProcesoCreateWithoutObjetivosInput, ProcesoUncheckedCreateWithoutObjetivosInput>
    where?: ProcesoWhereInput
  }

  export type ProcesoUpdateToOneWithWhereWithoutObjetivosInput = {
    where?: ProcesoWhereInput
    data: XOR<ProcesoUpdateWithoutObjetivosInput, ProcesoUncheckedUpdateWithoutObjetivosInput>
  }

  export type ProcesoUpdateWithoutObjetivosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    nodos?: ProcessNodeUpdateManyWithoutProcesoNestedInput
    edges?: ProcessEdgeUpdateManyWithoutProcesoNestedInput
    kpis?: KpiProcesoUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoUncheckedUpdateWithoutObjetivosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    nodos?: ProcessNodeUncheckedUpdateManyWithoutProcesoNestedInput
    edges?: ProcessEdgeUncheckedUpdateManyWithoutProcesoNestedInput
    kpis?: KpiProcesoUncheckedUpdateManyWithoutProcesoNestedInput
  }

  export type KpiProcesoUpsertWithWhereUniqueWithoutObjetivoInput = {
    where: KpiProcesoWhereUniqueInput
    update: XOR<KpiProcesoUpdateWithoutObjetivoInput, KpiProcesoUncheckedUpdateWithoutObjetivoInput>
    create: XOR<KpiProcesoCreateWithoutObjetivoInput, KpiProcesoUncheckedCreateWithoutObjetivoInput>
  }

  export type KpiProcesoUpdateWithWhereUniqueWithoutObjetivoInput = {
    where: KpiProcesoWhereUniqueInput
    data: XOR<KpiProcesoUpdateWithoutObjetivoInput, KpiProcesoUncheckedUpdateWithoutObjetivoInput>
  }

  export type KpiProcesoUpdateManyWithWhereWithoutObjetivoInput = {
    where: KpiProcesoScalarWhereInput
    data: XOR<KpiProcesoUpdateManyMutationInput, KpiProcesoUncheckedUpdateManyWithoutObjetivoInput>
  }

  export type ProcesoCreateWithoutKpisInput = {
    id?: string
    nombre: string
    descripcion: string
    version?: string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    nodos?: ProcessNodeCreateNestedManyWithoutProcesoInput
    edges?: ProcessEdgeCreateNestedManyWithoutProcesoInput
    objetivos?: ObjetivoProcesoCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoUncheckedCreateWithoutKpisInput = {
    id?: string
    nombre: string
    descripcion: string
    version?: string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    nodos?: ProcessNodeUncheckedCreateNestedManyWithoutProcesoInput
    edges?: ProcessEdgeUncheckedCreateNestedManyWithoutProcesoInput
    objetivos?: ObjetivoProcesoUncheckedCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoCreateOrConnectWithoutKpisInput = {
    where: ProcesoWhereUniqueInput
    create: XOR<ProcesoCreateWithoutKpisInput, ProcesoUncheckedCreateWithoutKpisInput>
  }

  export type ObjetivoProcesoCreateWithoutKpisInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    progreso?: number
    proceso: ProcesoCreateNestedOneWithoutObjetivosInput
  }

  export type ObjetivoProcesoUncheckedCreateWithoutKpisInput = {
    id?: string
    procesoId: string
    nombre: string
    descripcion: string
    tipo: string
    progreso?: number
  }

  export type ObjetivoProcesoCreateOrConnectWithoutKpisInput = {
    where: ObjetivoProcesoWhereUniqueInput
    create: XOR<ObjetivoProcesoCreateWithoutKpisInput, ObjetivoProcesoUncheckedCreateWithoutKpisInput>
  }

  export type KpiHistoricoCreateWithoutKpiInput = {
    id?: string
    valor: number
    timestamp?: Date | string
    procesoId: string
    metadatos?: string | null
    nodo?: ProcessNodeCreateNestedOneWithoutKpiHistoricoInput
  }

  export type KpiHistoricoUncheckedCreateWithoutKpiInput = {
    id?: string
    valor: number
    timestamp?: Date | string
    procesoId: string
    nodoId?: string | null
    metadatos?: string | null
  }

  export type KpiHistoricoCreateOrConnectWithoutKpiInput = {
    where: KpiHistoricoWhereUniqueInput
    create: XOR<KpiHistoricoCreateWithoutKpiInput, KpiHistoricoUncheckedCreateWithoutKpiInput>
  }

  export type KpiHistoricoCreateManyKpiInputEnvelope = {
    data: KpiHistoricoCreateManyKpiInput | KpiHistoricoCreateManyKpiInput[]
  }

  export type ProcesoUpsertWithoutKpisInput = {
    update: XOR<ProcesoUpdateWithoutKpisInput, ProcesoUncheckedUpdateWithoutKpisInput>
    create: XOR<ProcesoCreateWithoutKpisInput, ProcesoUncheckedCreateWithoutKpisInput>
    where?: ProcesoWhereInput
  }

  export type ProcesoUpdateToOneWithWhereWithoutKpisInput = {
    where?: ProcesoWhereInput
    data: XOR<ProcesoUpdateWithoutKpisInput, ProcesoUncheckedUpdateWithoutKpisInput>
  }

  export type ProcesoUpdateWithoutKpisInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    nodos?: ProcessNodeUpdateManyWithoutProcesoNestedInput
    edges?: ProcessEdgeUpdateManyWithoutProcesoNestedInput
    objetivos?: ObjetivoProcesoUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoUncheckedUpdateWithoutKpisInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    nodos?: ProcessNodeUncheckedUpdateManyWithoutProcesoNestedInput
    edges?: ProcessEdgeUncheckedUpdateManyWithoutProcesoNestedInput
    objetivos?: ObjetivoProcesoUncheckedUpdateManyWithoutProcesoNestedInput
  }

  export type ObjetivoProcesoUpsertWithoutKpisInput = {
    update: XOR<ObjetivoProcesoUpdateWithoutKpisInput, ObjetivoProcesoUncheckedUpdateWithoutKpisInput>
    create: XOR<ObjetivoProcesoCreateWithoutKpisInput, ObjetivoProcesoUncheckedCreateWithoutKpisInput>
    where?: ObjetivoProcesoWhereInput
  }

  export type ObjetivoProcesoUpdateToOneWithWhereWithoutKpisInput = {
    where?: ObjetivoProcesoWhereInput
    data: XOR<ObjetivoProcesoUpdateWithoutKpisInput, ObjetivoProcesoUncheckedUpdateWithoutKpisInput>
  }

  export type ObjetivoProcesoUpdateWithoutKpisInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    proceso?: ProcesoUpdateOneRequiredWithoutObjetivosNestedInput
  }

  export type ObjetivoProcesoUncheckedUpdateWithoutKpisInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
  }

  export type KpiHistoricoUpsertWithWhereUniqueWithoutKpiInput = {
    where: KpiHistoricoWhereUniqueInput
    update: XOR<KpiHistoricoUpdateWithoutKpiInput, KpiHistoricoUncheckedUpdateWithoutKpiInput>
    create: XOR<KpiHistoricoCreateWithoutKpiInput, KpiHistoricoUncheckedCreateWithoutKpiInput>
  }

  export type KpiHistoricoUpdateWithWhereUniqueWithoutKpiInput = {
    where: KpiHistoricoWhereUniqueInput
    data: XOR<KpiHistoricoUpdateWithoutKpiInput, KpiHistoricoUncheckedUpdateWithoutKpiInput>
  }

  export type KpiHistoricoUpdateManyWithWhereWithoutKpiInput = {
    where: KpiHistoricoScalarWhereInput
    data: XOR<KpiHistoricoUpdateManyMutationInput, KpiHistoricoUncheckedUpdateManyWithoutKpiInput>
  }

  export type KpiProcesoCreateWithoutHistoricoInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    unidad: string
    meta: number
    valorActual?: number
    fechaUltimaActualizacion?: Date | string | null
    alertaAdvertencia?: number | null
    alertaCritico?: number | null
    alertaDireccion?: string
    proceso: ProcesoCreateNestedOneWithoutKpisInput
    objetivo?: ObjetivoProcesoCreateNestedOneWithoutKpisInput
  }

  export type KpiProcesoUncheckedCreateWithoutHistoricoInput = {
    id?: string
    procesoId: string
    objetivoId?: string | null
    nombre: string
    descripcion?: string | null
    unidad: string
    meta: number
    valorActual?: number
    fechaUltimaActualizacion?: Date | string | null
    alertaAdvertencia?: number | null
    alertaCritico?: number | null
    alertaDireccion?: string
  }

  export type KpiProcesoCreateOrConnectWithoutHistoricoInput = {
    where: KpiProcesoWhereUniqueInput
    create: XOR<KpiProcesoCreateWithoutHistoricoInput, KpiProcesoUncheckedCreateWithoutHistoricoInput>
  }

  export type ProcessNodeCreateWithoutKpiHistoricoInput = {
    id?: string
    type: string
    label: string
    descripcion?: string | null
    config: string
    positionX: number
    positionY: number
    proceso: ProcesoCreateNestedOneWithoutNodosInput
    edgesFrom?: ProcessEdgeCreateNestedManyWithoutSourceNodeInput
    edgesTo?: ProcessEdgeCreateNestedManyWithoutTargetNodeInput
  }

  export type ProcessNodeUncheckedCreateWithoutKpiHistoricoInput = {
    id?: string
    procesoId: string
    type: string
    label: string
    descripcion?: string | null
    config: string
    positionX: number
    positionY: number
    edgesFrom?: ProcessEdgeUncheckedCreateNestedManyWithoutSourceNodeInput
    edgesTo?: ProcessEdgeUncheckedCreateNestedManyWithoutTargetNodeInput
  }

  export type ProcessNodeCreateOrConnectWithoutKpiHistoricoInput = {
    where: ProcessNodeWhereUniqueInput
    create: XOR<ProcessNodeCreateWithoutKpiHistoricoInput, ProcessNodeUncheckedCreateWithoutKpiHistoricoInput>
  }

  export type KpiProcesoUpsertWithoutHistoricoInput = {
    update: XOR<KpiProcesoUpdateWithoutHistoricoInput, KpiProcesoUncheckedUpdateWithoutHistoricoInput>
    create: XOR<KpiProcesoCreateWithoutHistoricoInput, KpiProcesoUncheckedCreateWithoutHistoricoInput>
    where?: KpiProcesoWhereInput
  }

  export type KpiProcesoUpdateToOneWithWhereWithoutHistoricoInput = {
    where?: KpiProcesoWhereInput
    data: XOR<KpiProcesoUpdateWithoutHistoricoInput, KpiProcesoUncheckedUpdateWithoutHistoricoInput>
  }

  export type KpiProcesoUpdateWithoutHistoricoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    unidad?: StringFieldUpdateOperationsInput | string
    meta?: FloatFieldUpdateOperationsInput | number
    valorActual?: FloatFieldUpdateOperationsInput | number
    fechaUltimaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertaAdvertencia?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaCritico?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaDireccion?: StringFieldUpdateOperationsInput | string
    proceso?: ProcesoUpdateOneRequiredWithoutKpisNestedInput
    objetivo?: ObjetivoProcesoUpdateOneWithoutKpisNestedInput
  }

  export type KpiProcesoUncheckedUpdateWithoutHistoricoInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    objetivoId?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    unidad?: StringFieldUpdateOperationsInput | string
    meta?: FloatFieldUpdateOperationsInput | number
    valorActual?: FloatFieldUpdateOperationsInput | number
    fechaUltimaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertaAdvertencia?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaCritico?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaDireccion?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessNodeUpsertWithoutKpiHistoricoInput = {
    update: XOR<ProcessNodeUpdateWithoutKpiHistoricoInput, ProcessNodeUncheckedUpdateWithoutKpiHistoricoInput>
    create: XOR<ProcessNodeCreateWithoutKpiHistoricoInput, ProcessNodeUncheckedCreateWithoutKpiHistoricoInput>
    where?: ProcessNodeWhereInput
  }

  export type ProcessNodeUpdateToOneWithWhereWithoutKpiHistoricoInput = {
    where?: ProcessNodeWhereInput
    data: XOR<ProcessNodeUpdateWithoutKpiHistoricoInput, ProcessNodeUncheckedUpdateWithoutKpiHistoricoInput>
  }

  export type ProcessNodeUpdateWithoutKpiHistoricoInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    proceso?: ProcesoUpdateOneRequiredWithoutNodosNestedInput
    edgesFrom?: ProcessEdgeUpdateManyWithoutSourceNodeNestedInput
    edgesTo?: ProcessEdgeUpdateManyWithoutTargetNodeNestedInput
  }

  export type ProcessNodeUncheckedUpdateWithoutKpiHistoricoInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    edgesFrom?: ProcessEdgeUncheckedUpdateManyWithoutSourceNodeNestedInput
    edgesTo?: ProcessEdgeUncheckedUpdateManyWithoutTargetNodeNestedInput
  }

  export type DashboardWidgetCreateWithoutDashboardInput = {
    id?: string
    tipo: string
    titulo: string
    subtitulo?: string | null
    icono?: string | null
    config: string
    x: number
    y: number
    cols: number
    rows: number
    canResize?: boolean
    canDrag?: boolean
    canRemove?: boolean
    canEdit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardWidgetUncheckedCreateWithoutDashboardInput = {
    id?: string
    tipo: string
    titulo: string
    subtitulo?: string | null
    icono?: string | null
    config: string
    x: number
    y: number
    cols: number
    rows: number
    canResize?: boolean
    canDrag?: boolean
    canRemove?: boolean
    canEdit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardWidgetCreateOrConnectWithoutDashboardInput = {
    where: DashboardWidgetWhereUniqueInput
    create: XOR<DashboardWidgetCreateWithoutDashboardInput, DashboardWidgetUncheckedCreateWithoutDashboardInput>
  }

  export type DashboardWidgetCreateManyDashboardInputEnvelope = {
    data: DashboardWidgetCreateManyDashboardInput | DashboardWidgetCreateManyDashboardInput[]
  }

  export type DashboardWidgetUpsertWithWhereUniqueWithoutDashboardInput = {
    where: DashboardWidgetWhereUniqueInput
    update: XOR<DashboardWidgetUpdateWithoutDashboardInput, DashboardWidgetUncheckedUpdateWithoutDashboardInput>
    create: XOR<DashboardWidgetCreateWithoutDashboardInput, DashboardWidgetUncheckedCreateWithoutDashboardInput>
  }

  export type DashboardWidgetUpdateWithWhereUniqueWithoutDashboardInput = {
    where: DashboardWidgetWhereUniqueInput
    data: XOR<DashboardWidgetUpdateWithoutDashboardInput, DashboardWidgetUncheckedUpdateWithoutDashboardInput>
  }

  export type DashboardWidgetUpdateManyWithWhereWithoutDashboardInput = {
    where: DashboardWidgetScalarWhereInput
    data: XOR<DashboardWidgetUpdateManyMutationInput, DashboardWidgetUncheckedUpdateManyWithoutDashboardInput>
  }

  export type DashboardWidgetScalarWhereInput = {
    AND?: DashboardWidgetScalarWhereInput | DashboardWidgetScalarWhereInput[]
    OR?: DashboardWidgetScalarWhereInput[]
    NOT?: DashboardWidgetScalarWhereInput | DashboardWidgetScalarWhereInput[]
    id?: StringFilter<"DashboardWidget"> | string
    dashboardId?: StringFilter<"DashboardWidget"> | string
    tipo?: StringFilter<"DashboardWidget"> | string
    titulo?: StringFilter<"DashboardWidget"> | string
    subtitulo?: StringNullableFilter<"DashboardWidget"> | string | null
    icono?: StringNullableFilter<"DashboardWidget"> | string | null
    config?: StringFilter<"DashboardWidget"> | string
    x?: IntFilter<"DashboardWidget"> | number
    y?: IntFilter<"DashboardWidget"> | number
    cols?: IntFilter<"DashboardWidget"> | number
    rows?: IntFilter<"DashboardWidget"> | number
    canResize?: BoolFilter<"DashboardWidget"> | boolean
    canDrag?: BoolFilter<"DashboardWidget"> | boolean
    canRemove?: BoolFilter<"DashboardWidget"> | boolean
    canEdit?: BoolFilter<"DashboardWidget"> | boolean
    createdAt?: DateTimeFilter<"DashboardWidget"> | Date | string
    updatedAt?: DateTimeFilter<"DashboardWidget"> | Date | string
  }

  export type DashboardConfigCreateWithoutWidgetsInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    isDefault?: boolean
    isLocked?: boolean
    columns?: number
    rowHeight?: number
    gap?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type DashboardConfigUncheckedCreateWithoutWidgetsInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    isDefault?: boolean
    isLocked?: boolean
    columns?: number
    rowHeight?: number
    gap?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type DashboardConfigCreateOrConnectWithoutWidgetsInput = {
    where: DashboardConfigWhereUniqueInput
    create: XOR<DashboardConfigCreateWithoutWidgetsInput, DashboardConfigUncheckedCreateWithoutWidgetsInput>
  }

  export type DashboardConfigUpsertWithoutWidgetsInput = {
    update: XOR<DashboardConfigUpdateWithoutWidgetsInput, DashboardConfigUncheckedUpdateWithoutWidgetsInput>
    create: XOR<DashboardConfigCreateWithoutWidgetsInput, DashboardConfigUncheckedCreateWithoutWidgetsInput>
    where?: DashboardConfigWhereInput
  }

  export type DashboardConfigUpdateToOneWithWhereWithoutWidgetsInput = {
    where?: DashboardConfigWhereInput
    data: XOR<DashboardConfigUpdateWithoutWidgetsInput, DashboardConfigUncheckedUpdateWithoutWidgetsInput>
  }

  export type DashboardConfigUpdateWithoutWidgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    columns?: IntFieldUpdateOperationsInput | number
    rowHeight?: IntFieldUpdateOperationsInput | number
    gap?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardConfigUncheckedUpdateWithoutWidgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    columns?: IntFieldUpdateOperationsInput | number
    rowHeight?: IntFieldUpdateOperationsInput | number
    gap?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectObjectiveCreateWithoutProjectInput = {
    id?: string
    description: string
    category: string
    status?: string
    targetDate?: Date | string | null
    completedDate?: Date | string | null
  }

  export type ProjectObjectiveUncheckedCreateWithoutProjectInput = {
    id?: string
    description: string
    category: string
    status?: string
    targetDate?: Date | string | null
    completedDate?: Date | string | null
  }

  export type ProjectObjectiveCreateOrConnectWithoutProjectInput = {
    where: ProjectObjectiveWhereUniqueInput
    create: XOR<ProjectObjectiveCreateWithoutProjectInput, ProjectObjectiveUncheckedCreateWithoutProjectInput>
  }

  export type ProjectObjectiveCreateManyProjectInputEnvelope = {
    data: ProjectObjectiveCreateManyProjectInput | ProjectObjectiveCreateManyProjectInput[]
  }

  export type ProjectKPICreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    targetValue: number
    currentValue?: number
    unit: string
    formulaType: string
    formula?: string | null
    status?: string
  }

  export type ProjectKPIUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    targetValue: number
    currentValue?: number
    unit: string
    formulaType: string
    formula?: string | null
    status?: string
  }

  export type ProjectKPICreateOrConnectWithoutProjectInput = {
    where: ProjectKPIWhereUniqueInput
    create: XOR<ProjectKPICreateWithoutProjectInput, ProjectKPIUncheckedCreateWithoutProjectInput>
  }

  export type ProjectKPICreateManyProjectInputEnvelope = {
    data: ProjectKPICreateManyProjectInput | ProjectKPICreateManyProjectInput[]
  }

  export type ProjectPhaseCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    orderNum: number
    startDate: Date | string
    endDate: Date | string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    status?: string
    weight?: number
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dependsOn?: ProjectPhaseCreateNestedOneWithoutDependentsInput
    dependents?: ProjectPhaseCreateNestedManyWithoutDependsOnInput
    tasks?: TaskCreateNestedManyWithoutPhaseInput
  }

  export type ProjectPhaseUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    orderNum: number
    startDate: Date | string
    endDate: Date | string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    status?: string
    weight?: number
    dependsOnPhaseId?: string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dependents?: ProjectPhaseUncheckedCreateNestedManyWithoutDependsOnInput
    tasks?: TaskUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type ProjectPhaseCreateOrConnectWithoutProjectInput = {
    where: ProjectPhaseWhereUniqueInput
    create: XOR<ProjectPhaseCreateWithoutProjectInput, ProjectPhaseUncheckedCreateWithoutProjectInput>
  }

  export type ProjectPhaseCreateManyProjectInputEnvelope = {
    data: ProjectPhaseCreateManyProjectInput | ProjectPhaseCreateManyProjectInput[]
  }

  export type TaskCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    assignedTo: string
    assignedBy: string
    assignedAt?: Date | string
    startDate: Date | string
    dueDate: Date | string
    completedDate?: Date | string | null
    progress?: number
    status?: string
    priority?: string
    estimatedHours?: number | null
    actualHours?: number | null
    taskType?: string
    linkedEntityType?: string | null
    linkedEntityId?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    phase: ProjectPhaseCreateNestedOneWithoutTasksInput
    evidences?: TaskEvidenceCreateNestedManyWithoutTaskInput
    history?: TaskHistoryCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutProjectInput = {
    id?: string
    phaseId: string
    title: string
    description?: string | null
    assignedTo: string
    assignedBy: string
    assignedAt?: Date | string
    startDate: Date | string
    dueDate: Date | string
    completedDate?: Date | string | null
    progress?: number
    status?: string
    priority?: string
    estimatedHours?: number | null
    actualHours?: number | null
    taskType?: string
    linkedEntityType?: string | null
    linkedEntityId?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    evidences?: TaskEvidenceUncheckedCreateNestedManyWithoutTaskInput
    history?: TaskHistoryUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutProjectInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskCreateManyProjectInputEnvelope = {
    data: TaskCreateManyProjectInput | TaskCreateManyProjectInput[]
  }

  export type ProjectObjectiveUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectObjectiveWhereUniqueInput
    update: XOR<ProjectObjectiveUpdateWithoutProjectInput, ProjectObjectiveUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectObjectiveCreateWithoutProjectInput, ProjectObjectiveUncheckedCreateWithoutProjectInput>
  }

  export type ProjectObjectiveUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectObjectiveWhereUniqueInput
    data: XOR<ProjectObjectiveUpdateWithoutProjectInput, ProjectObjectiveUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectObjectiveUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectObjectiveScalarWhereInput
    data: XOR<ProjectObjectiveUpdateManyMutationInput, ProjectObjectiveUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectObjectiveScalarWhereInput = {
    AND?: ProjectObjectiveScalarWhereInput | ProjectObjectiveScalarWhereInput[]
    OR?: ProjectObjectiveScalarWhereInput[]
    NOT?: ProjectObjectiveScalarWhereInput | ProjectObjectiveScalarWhereInput[]
    id?: StringFilter<"ProjectObjective"> | string
    projectId?: StringFilter<"ProjectObjective"> | string
    description?: StringFilter<"ProjectObjective"> | string
    category?: StringFilter<"ProjectObjective"> | string
    status?: StringFilter<"ProjectObjective"> | string
    targetDate?: DateTimeNullableFilter<"ProjectObjective"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"ProjectObjective"> | Date | string | null
  }

  export type ProjectKPIUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectKPIWhereUniqueInput
    update: XOR<ProjectKPIUpdateWithoutProjectInput, ProjectKPIUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectKPICreateWithoutProjectInput, ProjectKPIUncheckedCreateWithoutProjectInput>
  }

  export type ProjectKPIUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectKPIWhereUniqueInput
    data: XOR<ProjectKPIUpdateWithoutProjectInput, ProjectKPIUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectKPIUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectKPIScalarWhereInput
    data: XOR<ProjectKPIUpdateManyMutationInput, ProjectKPIUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectKPIScalarWhereInput = {
    AND?: ProjectKPIScalarWhereInput | ProjectKPIScalarWhereInput[]
    OR?: ProjectKPIScalarWhereInput[]
    NOT?: ProjectKPIScalarWhereInput | ProjectKPIScalarWhereInput[]
    id?: StringFilter<"ProjectKPI"> | string
    projectId?: StringFilter<"ProjectKPI"> | string
    name?: StringFilter<"ProjectKPI"> | string
    description?: StringNullableFilter<"ProjectKPI"> | string | null
    targetValue?: FloatFilter<"ProjectKPI"> | number
    currentValue?: FloatFilter<"ProjectKPI"> | number
    unit?: StringFilter<"ProjectKPI"> | string
    formulaType?: StringFilter<"ProjectKPI"> | string
    formula?: StringNullableFilter<"ProjectKPI"> | string | null
    status?: StringFilter<"ProjectKPI"> | string
  }

  export type ProjectPhaseUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectPhaseWhereUniqueInput
    update: XOR<ProjectPhaseUpdateWithoutProjectInput, ProjectPhaseUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectPhaseCreateWithoutProjectInput, ProjectPhaseUncheckedCreateWithoutProjectInput>
  }

  export type ProjectPhaseUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectPhaseWhereUniqueInput
    data: XOR<ProjectPhaseUpdateWithoutProjectInput, ProjectPhaseUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectPhaseUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectPhaseScalarWhereInput
    data: XOR<ProjectPhaseUpdateManyMutationInput, ProjectPhaseUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectPhaseScalarWhereInput = {
    AND?: ProjectPhaseScalarWhereInput | ProjectPhaseScalarWhereInput[]
    OR?: ProjectPhaseScalarWhereInput[]
    NOT?: ProjectPhaseScalarWhereInput | ProjectPhaseScalarWhereInput[]
    id?: StringFilter<"ProjectPhase"> | string
    projectId?: StringFilter<"ProjectPhase"> | string
    name?: StringFilter<"ProjectPhase"> | string
    description?: StringNullableFilter<"ProjectPhase"> | string | null
    orderNum?: IntFilter<"ProjectPhase"> | number
    startDate?: DateTimeFilter<"ProjectPhase"> | Date | string
    endDate?: DateTimeFilter<"ProjectPhase"> | Date | string
    actualStartDate?: DateTimeNullableFilter<"ProjectPhase"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"ProjectPhase"> | Date | string | null
    status?: StringFilter<"ProjectPhase"> | string
    weight?: IntFilter<"ProjectPhase"> | number
    dependsOnPhaseId?: StringNullableFilter<"ProjectPhase"> | string | null
    progress?: IntFilter<"ProjectPhase"> | number
    createdAt?: DateTimeFilter<"ProjectPhase"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectPhase"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
  }

  export type TaskUpdateManyWithWhereWithoutProjectInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutProjectInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    projectId?: StringFilter<"Task"> | string
    phaseId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    assignedTo?: StringFilter<"Task"> | string
    assignedBy?: StringFilter<"Task"> | string
    assignedAt?: DateTimeFilter<"Task"> | Date | string
    startDate?: DateTimeFilter<"Task"> | Date | string
    dueDate?: DateTimeFilter<"Task"> | Date | string
    completedDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    progress?: IntFilter<"Task"> | number
    status?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    estimatedHours?: FloatNullableFilter<"Task"> | number | null
    actualHours?: FloatNullableFilter<"Task"> | number | null
    taskType?: StringFilter<"Task"> | string
    linkedEntityType?: StringNullableFilter<"Task"> | string | null
    linkedEntityId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    createdBy?: StringFilter<"Task"> | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type ProjectCreateWithoutObjectivesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    responsibleUserId: string
    orgUnitId?: string | null
    priority?: string
    status?: string
    progress?: number
    reminderDays?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    kpis?: ProjectKPICreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutObjectivesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    responsibleUserId: string
    orgUnitId?: string | null
    priority?: string
    status?: string
    progress?: number
    reminderDays?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    kpis?: ProjectKPIUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutObjectivesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutObjectivesInput, ProjectUncheckedCreateWithoutObjectivesInput>
  }

  export type ProjectUpsertWithoutObjectivesInput = {
    update: XOR<ProjectUpdateWithoutObjectivesInput, ProjectUncheckedUpdateWithoutObjectivesInput>
    create: XOR<ProjectCreateWithoutObjectivesInput, ProjectUncheckedCreateWithoutObjectivesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutObjectivesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutObjectivesInput, ProjectUncheckedUpdateWithoutObjectivesInput>
  }

  export type ProjectUpdateWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUserId?: StringFieldUpdateOperationsInput | string
    orgUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    reminderDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: ProjectKPIUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUserId?: StringFieldUpdateOperationsInput | string
    orgUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    reminderDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpis?: ProjectKPIUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutKpisInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    responsibleUserId: string
    orgUnitId?: string | null
    priority?: string
    status?: string
    progress?: number
    reminderDays?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    objectives?: ProjectObjectiveCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutKpisInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    responsibleUserId: string
    orgUnitId?: string | null
    priority?: string
    status?: string
    progress?: number
    reminderDays?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    objectives?: ProjectObjectiveUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutKpisInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutKpisInput, ProjectUncheckedCreateWithoutKpisInput>
  }

  export type ProjectUpsertWithoutKpisInput = {
    update: XOR<ProjectUpdateWithoutKpisInput, ProjectUncheckedUpdateWithoutKpisInput>
    create: XOR<ProjectCreateWithoutKpisInput, ProjectUncheckedCreateWithoutKpisInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutKpisInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutKpisInput, ProjectUncheckedUpdateWithoutKpisInput>
  }

  export type ProjectUpdateWithoutKpisInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUserId?: StringFieldUpdateOperationsInput | string
    orgUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    reminderDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    objectives?: ProjectObjectiveUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutKpisInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUserId?: StringFieldUpdateOperationsInput | string
    orgUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    reminderDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    objectives?: ProjectObjectiveUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutPhasesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    responsibleUserId: string
    orgUnitId?: string | null
    priority?: string
    status?: string
    progress?: number
    reminderDays?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    objectives?: ProjectObjectiveCreateNestedManyWithoutProjectInput
    kpis?: ProjectKPICreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPhasesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    responsibleUserId: string
    orgUnitId?: string | null
    priority?: string
    status?: string
    progress?: number
    reminderDays?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    objectives?: ProjectObjectiveUncheckedCreateNestedManyWithoutProjectInput
    kpis?: ProjectKPIUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPhasesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPhasesInput, ProjectUncheckedCreateWithoutPhasesInput>
  }

  export type ProjectPhaseCreateWithoutDependentsInput = {
    id?: string
    name: string
    description?: string | null
    orderNum: number
    startDate: Date | string
    endDate: Date | string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    status?: string
    weight?: number
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPhasesInput
    dependsOn?: ProjectPhaseCreateNestedOneWithoutDependentsInput
    tasks?: TaskCreateNestedManyWithoutPhaseInput
  }

  export type ProjectPhaseUncheckedCreateWithoutDependentsInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    orderNum: number
    startDate: Date | string
    endDate: Date | string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    status?: string
    weight?: number
    dependsOnPhaseId?: string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type ProjectPhaseCreateOrConnectWithoutDependentsInput = {
    where: ProjectPhaseWhereUniqueInput
    create: XOR<ProjectPhaseCreateWithoutDependentsInput, ProjectPhaseUncheckedCreateWithoutDependentsInput>
  }

  export type ProjectPhaseCreateWithoutDependsOnInput = {
    id?: string
    name: string
    description?: string | null
    orderNum: number
    startDate: Date | string
    endDate: Date | string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    status?: string
    weight?: number
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPhasesInput
    dependents?: ProjectPhaseCreateNestedManyWithoutDependsOnInput
    tasks?: TaskCreateNestedManyWithoutPhaseInput
  }

  export type ProjectPhaseUncheckedCreateWithoutDependsOnInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    orderNum: number
    startDate: Date | string
    endDate: Date | string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    status?: string
    weight?: number
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dependents?: ProjectPhaseUncheckedCreateNestedManyWithoutDependsOnInput
    tasks?: TaskUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type ProjectPhaseCreateOrConnectWithoutDependsOnInput = {
    where: ProjectPhaseWhereUniqueInput
    create: XOR<ProjectPhaseCreateWithoutDependsOnInput, ProjectPhaseUncheckedCreateWithoutDependsOnInput>
  }

  export type ProjectPhaseCreateManyDependsOnInputEnvelope = {
    data: ProjectPhaseCreateManyDependsOnInput | ProjectPhaseCreateManyDependsOnInput[]
  }

  export type TaskCreateWithoutPhaseInput = {
    id?: string
    title: string
    description?: string | null
    assignedTo: string
    assignedBy: string
    assignedAt?: Date | string
    startDate: Date | string
    dueDate: Date | string
    completedDate?: Date | string | null
    progress?: number
    status?: string
    priority?: string
    estimatedHours?: number | null
    actualHours?: number | null
    taskType?: string
    linkedEntityType?: string | null
    linkedEntityId?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    evidences?: TaskEvidenceCreateNestedManyWithoutTaskInput
    history?: TaskHistoryCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutPhaseInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    assignedTo: string
    assignedBy: string
    assignedAt?: Date | string
    startDate: Date | string
    dueDate: Date | string
    completedDate?: Date | string | null
    progress?: number
    status?: string
    priority?: string
    estimatedHours?: number | null
    actualHours?: number | null
    taskType?: string
    linkedEntityType?: string | null
    linkedEntityId?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    evidences?: TaskEvidenceUncheckedCreateNestedManyWithoutTaskInput
    history?: TaskHistoryUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutPhaseInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutPhaseInput, TaskUncheckedCreateWithoutPhaseInput>
  }

  export type TaskCreateManyPhaseInputEnvelope = {
    data: TaskCreateManyPhaseInput | TaskCreateManyPhaseInput[]
  }

  export type ProjectUpsertWithoutPhasesInput = {
    update: XOR<ProjectUpdateWithoutPhasesInput, ProjectUncheckedUpdateWithoutPhasesInput>
    create: XOR<ProjectCreateWithoutPhasesInput, ProjectUncheckedCreateWithoutPhasesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPhasesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPhasesInput, ProjectUncheckedUpdateWithoutPhasesInput>
  }

  export type ProjectUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUserId?: StringFieldUpdateOperationsInput | string
    orgUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    reminderDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    objectives?: ProjectObjectiveUpdateManyWithoutProjectNestedInput
    kpis?: ProjectKPIUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUserId?: StringFieldUpdateOperationsInput | string
    orgUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    reminderDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    objectives?: ProjectObjectiveUncheckedUpdateManyWithoutProjectNestedInput
    kpis?: ProjectKPIUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectPhaseUpsertWithoutDependentsInput = {
    update: XOR<ProjectPhaseUpdateWithoutDependentsInput, ProjectPhaseUncheckedUpdateWithoutDependentsInput>
    create: XOR<ProjectPhaseCreateWithoutDependentsInput, ProjectPhaseUncheckedCreateWithoutDependentsInput>
    where?: ProjectPhaseWhereInput
  }

  export type ProjectPhaseUpdateToOneWithWhereWithoutDependentsInput = {
    where?: ProjectPhaseWhereInput
    data: XOR<ProjectPhaseUpdateWithoutDependentsInput, ProjectPhaseUncheckedUpdateWithoutDependentsInput>
  }

  export type ProjectPhaseUpdateWithoutDependentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPhasesNestedInput
    dependsOn?: ProjectPhaseUpdateOneWithoutDependentsNestedInput
    tasks?: TaskUpdateManyWithoutPhaseNestedInput
  }

  export type ProjectPhaseUncheckedUpdateWithoutDependentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    dependsOnPhaseId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type ProjectPhaseUpsertWithWhereUniqueWithoutDependsOnInput = {
    where: ProjectPhaseWhereUniqueInput
    update: XOR<ProjectPhaseUpdateWithoutDependsOnInput, ProjectPhaseUncheckedUpdateWithoutDependsOnInput>
    create: XOR<ProjectPhaseCreateWithoutDependsOnInput, ProjectPhaseUncheckedCreateWithoutDependsOnInput>
  }

  export type ProjectPhaseUpdateWithWhereUniqueWithoutDependsOnInput = {
    where: ProjectPhaseWhereUniqueInput
    data: XOR<ProjectPhaseUpdateWithoutDependsOnInput, ProjectPhaseUncheckedUpdateWithoutDependsOnInput>
  }

  export type ProjectPhaseUpdateManyWithWhereWithoutDependsOnInput = {
    where: ProjectPhaseScalarWhereInput
    data: XOR<ProjectPhaseUpdateManyMutationInput, ProjectPhaseUncheckedUpdateManyWithoutDependsOnInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutPhaseInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutPhaseInput, TaskUncheckedUpdateWithoutPhaseInput>
    create: XOR<TaskCreateWithoutPhaseInput, TaskUncheckedCreateWithoutPhaseInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutPhaseInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutPhaseInput, TaskUncheckedUpdateWithoutPhaseInput>
  }

  export type TaskUpdateManyWithWhereWithoutPhaseInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutPhaseInput>
  }

  export type ProjectCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    responsibleUserId: string
    orgUnitId?: string | null
    priority?: string
    status?: string
    progress?: number
    reminderDays?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    objectives?: ProjectObjectiveCreateNestedManyWithoutProjectInput
    kpis?: ProjectKPICreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    responsibleUserId: string
    orgUnitId?: string | null
    priority?: string
    status?: string
    progress?: number
    reminderDays?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    objectives?: ProjectObjectiveUncheckedCreateNestedManyWithoutProjectInput
    kpis?: ProjectKPIUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTasksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
  }

  export type ProjectPhaseCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    orderNum: number
    startDate: Date | string
    endDate: Date | string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    status?: string
    weight?: number
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPhasesInput
    dependsOn?: ProjectPhaseCreateNestedOneWithoutDependentsInput
    dependents?: ProjectPhaseCreateNestedManyWithoutDependsOnInput
  }

  export type ProjectPhaseUncheckedCreateWithoutTasksInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    orderNum: number
    startDate: Date | string
    endDate: Date | string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    status?: string
    weight?: number
    dependsOnPhaseId?: string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dependents?: ProjectPhaseUncheckedCreateNestedManyWithoutDependsOnInput
  }

  export type ProjectPhaseCreateOrConnectWithoutTasksInput = {
    where: ProjectPhaseWhereUniqueInput
    create: XOR<ProjectPhaseCreateWithoutTasksInput, ProjectPhaseUncheckedCreateWithoutTasksInput>
  }

  export type TaskEvidenceCreateWithoutTaskInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    storageUrl: string
    evidenceType: string
    description?: string | null
    documentDate?: Date | string | null
    uploadedBy: string
    uploadedAt?: Date | string
  }

  export type TaskEvidenceUncheckedCreateWithoutTaskInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    storageUrl: string
    evidenceType: string
    description?: string | null
    documentDate?: Date | string | null
    uploadedBy: string
    uploadedAt?: Date | string
  }

  export type TaskEvidenceCreateOrConnectWithoutTaskInput = {
    where: TaskEvidenceWhereUniqueInput
    create: XOR<TaskEvidenceCreateWithoutTaskInput, TaskEvidenceUncheckedCreateWithoutTaskInput>
  }

  export type TaskEvidenceCreateManyTaskInputEnvelope = {
    data: TaskEvidenceCreateManyTaskInput | TaskEvidenceCreateManyTaskInput[]
  }

  export type TaskHistoryCreateWithoutTaskInput = {
    id?: string
    userId: string
    action: string
    changes?: string | null
    comment?: string | null
    timestamp?: Date | string
  }

  export type TaskHistoryUncheckedCreateWithoutTaskInput = {
    id?: string
    userId: string
    action: string
    changes?: string | null
    comment?: string | null
    timestamp?: Date | string
  }

  export type TaskHistoryCreateOrConnectWithoutTaskInput = {
    where: TaskHistoryWhereUniqueInput
    create: XOR<TaskHistoryCreateWithoutTaskInput, TaskHistoryUncheckedCreateWithoutTaskInput>
  }

  export type TaskHistoryCreateManyTaskInputEnvelope = {
    data: TaskHistoryCreateManyTaskInput | TaskHistoryCreateManyTaskInput[]
  }

  export type ProjectUpsertWithoutTasksInput = {
    update: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUserId?: StringFieldUpdateOperationsInput | string
    orgUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    reminderDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    objectives?: ProjectObjectiveUpdateManyWithoutProjectNestedInput
    kpis?: ProjectKPIUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUserId?: StringFieldUpdateOperationsInput | string
    orgUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    reminderDays?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    objectives?: ProjectObjectiveUncheckedUpdateManyWithoutProjectNestedInput
    kpis?: ProjectKPIUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectPhaseUpsertWithoutTasksInput = {
    update: XOR<ProjectPhaseUpdateWithoutTasksInput, ProjectPhaseUncheckedUpdateWithoutTasksInput>
    create: XOR<ProjectPhaseCreateWithoutTasksInput, ProjectPhaseUncheckedCreateWithoutTasksInput>
    where?: ProjectPhaseWhereInput
  }

  export type ProjectPhaseUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProjectPhaseWhereInput
    data: XOR<ProjectPhaseUpdateWithoutTasksInput, ProjectPhaseUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectPhaseUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPhasesNestedInput
    dependsOn?: ProjectPhaseUpdateOneWithoutDependentsNestedInput
    dependents?: ProjectPhaseUpdateManyWithoutDependsOnNestedInput
  }

  export type ProjectPhaseUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    dependsOnPhaseId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependents?: ProjectPhaseUncheckedUpdateManyWithoutDependsOnNestedInput
  }

  export type TaskEvidenceUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskEvidenceWhereUniqueInput
    update: XOR<TaskEvidenceUpdateWithoutTaskInput, TaskEvidenceUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskEvidenceCreateWithoutTaskInput, TaskEvidenceUncheckedCreateWithoutTaskInput>
  }

  export type TaskEvidenceUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskEvidenceWhereUniqueInput
    data: XOR<TaskEvidenceUpdateWithoutTaskInput, TaskEvidenceUncheckedUpdateWithoutTaskInput>
  }

  export type TaskEvidenceUpdateManyWithWhereWithoutTaskInput = {
    where: TaskEvidenceScalarWhereInput
    data: XOR<TaskEvidenceUpdateManyMutationInput, TaskEvidenceUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskEvidenceScalarWhereInput = {
    AND?: TaskEvidenceScalarWhereInput | TaskEvidenceScalarWhereInput[]
    OR?: TaskEvidenceScalarWhereInput[]
    NOT?: TaskEvidenceScalarWhereInput | TaskEvidenceScalarWhereInput[]
    id?: StringFilter<"TaskEvidence"> | string
    taskId?: StringFilter<"TaskEvidence"> | string
    fileName?: StringFilter<"TaskEvidence"> | string
    fileType?: StringFilter<"TaskEvidence"> | string
    fileSize?: IntFilter<"TaskEvidence"> | number
    storageUrl?: StringFilter<"TaskEvidence"> | string
    evidenceType?: StringFilter<"TaskEvidence"> | string
    description?: StringNullableFilter<"TaskEvidence"> | string | null
    documentDate?: DateTimeNullableFilter<"TaskEvidence"> | Date | string | null
    uploadedBy?: StringFilter<"TaskEvidence"> | string
    uploadedAt?: DateTimeFilter<"TaskEvidence"> | Date | string
  }

  export type TaskHistoryUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskHistoryWhereUniqueInput
    update: XOR<TaskHistoryUpdateWithoutTaskInput, TaskHistoryUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskHistoryCreateWithoutTaskInput, TaskHistoryUncheckedCreateWithoutTaskInput>
  }

  export type TaskHistoryUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskHistoryWhereUniqueInput
    data: XOR<TaskHistoryUpdateWithoutTaskInput, TaskHistoryUncheckedUpdateWithoutTaskInput>
  }

  export type TaskHistoryUpdateManyWithWhereWithoutTaskInput = {
    where: TaskHistoryScalarWhereInput
    data: XOR<TaskHistoryUpdateManyMutationInput, TaskHistoryUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskHistoryScalarWhereInput = {
    AND?: TaskHistoryScalarWhereInput | TaskHistoryScalarWhereInput[]
    OR?: TaskHistoryScalarWhereInput[]
    NOT?: TaskHistoryScalarWhereInput | TaskHistoryScalarWhereInput[]
    id?: StringFilter<"TaskHistory"> | string
    taskId?: StringFilter<"TaskHistory"> | string
    userId?: StringFilter<"TaskHistory"> | string
    action?: StringFilter<"TaskHistory"> | string
    changes?: StringNullableFilter<"TaskHistory"> | string | null
    comment?: StringNullableFilter<"TaskHistory"> | string | null
    timestamp?: DateTimeFilter<"TaskHistory"> | Date | string
  }

  export type TaskCreateWithoutEvidencesInput = {
    id?: string
    title: string
    description?: string | null
    assignedTo: string
    assignedBy: string
    assignedAt?: Date | string
    startDate: Date | string
    dueDate: Date | string
    completedDate?: Date | string | null
    progress?: number
    status?: string
    priority?: string
    estimatedHours?: number | null
    actualHours?: number | null
    taskType?: string
    linkedEntityType?: string | null
    linkedEntityId?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    phase: ProjectPhaseCreateNestedOneWithoutTasksInput
    history?: TaskHistoryCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutEvidencesInput = {
    id?: string
    projectId: string
    phaseId: string
    title: string
    description?: string | null
    assignedTo: string
    assignedBy: string
    assignedAt?: Date | string
    startDate: Date | string
    dueDate: Date | string
    completedDate?: Date | string | null
    progress?: number
    status?: string
    priority?: string
    estimatedHours?: number | null
    actualHours?: number | null
    taskType?: string
    linkedEntityType?: string | null
    linkedEntityId?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    history?: TaskHistoryUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutEvidencesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutEvidencesInput, TaskUncheckedCreateWithoutEvidencesInput>
  }

  export type TaskUpsertWithoutEvidencesInput = {
    update: XOR<TaskUpdateWithoutEvidencesInput, TaskUncheckedUpdateWithoutEvidencesInput>
    create: XOR<TaskCreateWithoutEvidencesInput, TaskUncheckedCreateWithoutEvidencesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutEvidencesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutEvidencesInput, TaskUncheckedUpdateWithoutEvidencesInput>
  }

  export type TaskUpdateWithoutEvidencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedBy?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    taskType?: StringFieldUpdateOperationsInput | string
    linkedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    phase?: ProjectPhaseUpdateOneRequiredWithoutTasksNestedInput
    history?: TaskHistoryUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutEvidencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedBy?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    taskType?: StringFieldUpdateOperationsInput | string
    linkedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: TaskHistoryUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateWithoutHistoryInput = {
    id?: string
    title: string
    description?: string | null
    assignedTo: string
    assignedBy: string
    assignedAt?: Date | string
    startDate: Date | string
    dueDate: Date | string
    completedDate?: Date | string | null
    progress?: number
    status?: string
    priority?: string
    estimatedHours?: number | null
    actualHours?: number | null
    taskType?: string
    linkedEntityType?: string | null
    linkedEntityId?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    phase: ProjectPhaseCreateNestedOneWithoutTasksInput
    evidences?: TaskEvidenceCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutHistoryInput = {
    id?: string
    projectId: string
    phaseId: string
    title: string
    description?: string | null
    assignedTo: string
    assignedBy: string
    assignedAt?: Date | string
    startDate: Date | string
    dueDate: Date | string
    completedDate?: Date | string | null
    progress?: number
    status?: string
    priority?: string
    estimatedHours?: number | null
    actualHours?: number | null
    taskType?: string
    linkedEntityType?: string | null
    linkedEntityId?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    evidences?: TaskEvidenceUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutHistoryInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutHistoryInput, TaskUncheckedCreateWithoutHistoryInput>
  }

  export type TaskUpsertWithoutHistoryInput = {
    update: XOR<TaskUpdateWithoutHistoryInput, TaskUncheckedUpdateWithoutHistoryInput>
    create: XOR<TaskCreateWithoutHistoryInput, TaskUncheckedCreateWithoutHistoryInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutHistoryInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutHistoryInput, TaskUncheckedUpdateWithoutHistoryInput>
  }

  export type TaskUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedBy?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    taskType?: StringFieldUpdateOperationsInput | string
    linkedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    phase?: ProjectPhaseUpdateOneRequiredWithoutTasksNestedInput
    evidences?: TaskEvidenceUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedBy?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    taskType?: StringFieldUpdateOperationsInput | string
    linkedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidences?: TaskEvidenceUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UsuarioRolCreateManyUsuarioInput = {
    rolId: string
    fechaAsignacion?: Date | string
  }

  export type UsuarioActivoCreateManyUsuarioInput = {
    activoId: string
    nivelAcceso?: string
  }

  export type LogAuditoriaCreateManyUsuarioInput = {
    id?: string
    accion: string
    entidad: string
    entidadId: string
    entidadNombre: string
    detalles?: string | null
    ip?: string | null
    userAgent?: string | null
    fecha?: Date | string
  }

  export type RespuestaCuestionarioCreateManyRespondidoPorInput = {
    id?: string
    asignacionId: string
    cuestionarioId: string
    fechaInicio?: Date | string
    fechaEnvio?: Date | string | null
    estado?: string
    puntuacionTotal?: number
    nivelCumplimiento?: string | null
    comentariosGenerales?: string | null
  }

  export type UsuarioRolUpdateWithoutUsuarioInput = {
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: RolUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type UsuarioRolUncheckedUpdateWithoutUsuarioInput = {
    rolId?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioRolUncheckedUpdateManyWithoutUsuarioInput = {
    rolId?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioActivoUpdateWithoutUsuarioInput = {
    nivelAcceso?: StringFieldUpdateOperationsInput | string
    activo?: ActivoAccesoUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type UsuarioActivoUncheckedUpdateWithoutUsuarioInput = {
    activoId?: StringFieldUpdateOperationsInput | string
    nivelAcceso?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioActivoUncheckedUpdateManyWithoutUsuarioInput = {
    activoId?: StringFieldUpdateOperationsInput | string
    nivelAcceso?: StringFieldUpdateOperationsInput | string
  }

  export type LogAuditoriaUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: StringFieldUpdateOperationsInput | string
    entidadNombre?: StringFieldUpdateOperationsInput | string
    detalles?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogAuditoriaUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: StringFieldUpdateOperationsInput | string
    entidadNombre?: StringFieldUpdateOperationsInput | string
    detalles?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogAuditoriaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: StringFieldUpdateOperationsInput | string
    entidadNombre?: StringFieldUpdateOperationsInput | string
    detalles?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RespuestaCuestionarioUpdateWithoutRespondidoPorInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    puntuacionTotal?: FloatFieldUpdateOperationsInput | number
    nivelCumplimiento?: NullableStringFieldUpdateOperationsInput | string | null
    comentariosGenerales?: NullableStringFieldUpdateOperationsInput | string | null
    asignacion?: AsignacionCuestionarioUpdateOneRequiredWithoutRespuestasNestedInput
    respuestas?: RespuestaPreguntaUpdateManyWithoutRespuestaCuestionarioNestedInput
  }

  export type RespuestaCuestionarioUncheckedUpdateWithoutRespondidoPorInput = {
    id?: StringFieldUpdateOperationsInput | string
    asignacionId?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    puntuacionTotal?: FloatFieldUpdateOperationsInput | number
    nivelCumplimiento?: NullableStringFieldUpdateOperationsInput | string | null
    comentariosGenerales?: NullableStringFieldUpdateOperationsInput | string | null
    respuestas?: RespuestaPreguntaUncheckedUpdateManyWithoutRespuestaCuestionarioNestedInput
  }

  export type RespuestaCuestionarioUncheckedUpdateManyWithoutRespondidoPorInput = {
    id?: StringFieldUpdateOperationsInput | string
    asignacionId?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    puntuacionTotal?: FloatFieldUpdateOperationsInput | number
    nivelCumplimiento?: NullableStringFieldUpdateOperationsInput | string | null
    comentariosGenerales?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuarioRolCreateManyRolInput = {
    usuarioId: string
    fechaAsignacion?: Date | string
  }

  export type RolPermisoCreateManyRolInput = {
    permisoId: string
  }

  export type UsuarioRolUpdateWithoutRolInput = {
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UsuarioRolUncheckedUpdateWithoutRolInput = {
    usuarioId?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioRolUncheckedUpdateManyWithoutRolInput = {
    usuarioId?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolPermisoUpdateWithoutRolInput = {
    permiso?: PermisoUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolPermisoUncheckedUpdateWithoutRolInput = {
    permisoId?: StringFieldUpdateOperationsInput | string
  }

  export type RolPermisoUncheckedUpdateManyWithoutRolInput = {
    permisoId?: StringFieldUpdateOperationsInput | string
  }

  export type PermisoCreateManyPadreInput = {
    id?: string
    codigo: string
    nombre: string
    descripcion: string
    modulo: string
    categoria: string
    activo?: boolean
  }

  export type RolPermisoCreateManyPermisoInput = {
    rolId: string
  }

  export type PermisoUpdateWithoutPadreInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    hijos?: PermisoUpdateManyWithoutPadreNestedInput
    roles?: RolPermisoUpdateManyWithoutPermisoNestedInput
  }

  export type PermisoUncheckedUpdateWithoutPadreInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    hijos?: PermisoUncheckedUpdateManyWithoutPadreNestedInput
    roles?: RolPermisoUncheckedUpdateManyWithoutPermisoNestedInput
  }

  export type PermisoUncheckedUpdateManyWithoutPadreInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolPermisoUpdateWithoutPermisoInput = {
    rol?: RolUpdateOneRequiredWithoutPermisosNestedInput
  }

  export type RolPermisoUncheckedUpdateWithoutPermisoInput = {
    rolId?: StringFieldUpdateOperationsInput | string
  }

  export type RolPermisoUncheckedUpdateManyWithoutPermisoInput = {
    rolId?: StringFieldUpdateOperationsInput | string
  }

  export type ActivoAccesoCreateManyPadreInput = {
    id?: string
    nombre: string
    tipo: string
    icono?: string | null
    nivelAcceso?: string | null
    expanded?: boolean
  }

  export type UsuarioActivoCreateManyActivoInput = {
    usuarioId: string
    nivelAcceso?: string
  }

  export type ActivoAccesoUpdateWithoutPadreInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    expanded?: BoolFieldUpdateOperationsInput | boolean
    hijos?: ActivoAccesoUpdateManyWithoutPadreNestedInput
    usuarios?: UsuarioActivoUpdateManyWithoutActivoNestedInput
  }

  export type ActivoAccesoUncheckedUpdateWithoutPadreInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    expanded?: BoolFieldUpdateOperationsInput | boolean
    hijos?: ActivoAccesoUncheckedUpdateManyWithoutPadreNestedInput
    usuarios?: UsuarioActivoUncheckedUpdateManyWithoutActivoNestedInput
  }

  export type ActivoAccesoUncheckedUpdateManyWithoutPadreInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    expanded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioActivoUpdateWithoutActivoInput = {
    nivelAcceso?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateOneRequiredWithoutActivosAccesoNestedInput
  }

  export type UsuarioActivoUncheckedUpdateWithoutActivoInput = {
    usuarioId?: StringFieldUpdateOperationsInput | string
    nivelAcceso?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioActivoUncheckedUpdateManyWithoutActivoInput = {
    usuarioId?: StringFieldUpdateOperationsInput | string
    nivelAcceso?: StringFieldUpdateOperationsInput | string
  }

  export type ActivoCreateManyPlantillaInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    criticidad: string
    responsable: string
    departamento: string
    fechaRegistro?: Date | string
    updatedAt?: Date | string
    propiedadesCustom?: string | null
  }

  export type ActivoUpdateWithoutPlantillaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    criticidad?: StringFieldUpdateOperationsInput | string
    responsable?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propiedadesCustom?: NullableStringFieldUpdateOperationsInput | string | null
    riesgos?: RiesgoUpdateManyWithoutActivoNestedInput
    incidentes?: IncidenteUpdateManyWithoutActivoNestedInput
    defectos?: DefectoUpdateManyWithoutActivoNestedInput
  }

  export type ActivoUncheckedUpdateWithoutPlantillaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    criticidad?: StringFieldUpdateOperationsInput | string
    responsable?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propiedadesCustom?: NullableStringFieldUpdateOperationsInput | string | null
    riesgos?: RiesgoUncheckedUpdateManyWithoutActivoNestedInput
    incidentes?: IncidenteUncheckedUpdateManyWithoutActivoNestedInput
    defectos?: DefectoUncheckedUpdateManyWithoutActivoNestedInput
  }

  export type ActivoUncheckedUpdateManyWithoutPlantillaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    criticidad?: StringFieldUpdateOperationsInput | string
    responsable?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propiedadesCustom?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RiesgoCreateManyActivoInput = {
    id?: string
    descripcion: string
    probabilidad: number
    impacto: number
    estado: string
    fechaIdentificacion?: Date | string
    responsable: string
    updatedAt?: Date | string
  }

  export type IncidenteCreateManyActivoInput = {
    id?: string
    titulo: string
    descripcion: string
    severidad: string
    estado: string
    fechaReporte?: Date | string
    reportadoPor: string
    updatedAt?: Date | string
  }

  export type DefectoCreateManyActivoInput = {
    id?: string
    titulo: string
    descripcion: string
    tipo: string
    prioridad: string
    estado: string
    fechaDeteccion?: Date | string
    detectadoPor: string
    updatedAt?: Date | string
  }

  export type RiesgoUpdateWithoutActivoInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    probabilidad?: IntFieldUpdateOperationsInput | number
    impacto?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    fechaIdentificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    responsable?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiesgoUncheckedUpdateWithoutActivoInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    probabilidad?: IntFieldUpdateOperationsInput | number
    impacto?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    fechaIdentificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    responsable?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiesgoUncheckedUpdateManyWithoutActivoInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    probabilidad?: IntFieldUpdateOperationsInput | number
    impacto?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    fechaIdentificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    responsable?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidenteUpdateWithoutActivoInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    severidad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
    reportadoPor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidenteUncheckedUpdateWithoutActivoInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    severidad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
    reportadoPor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidenteUncheckedUpdateManyWithoutActivoInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    severidad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
    reportadoPor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectoUpdateWithoutActivoInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    prioridad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaDeteccion?: DateTimeFieldUpdateOperationsInput | Date | string
    detectadoPor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectoUncheckedUpdateWithoutActivoInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    prioridad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaDeteccion?: DateTimeFieldUpdateOperationsInput | Date | string
    detectadoPor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefectoUncheckedUpdateManyWithoutActivoInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    prioridad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaDeteccion?: DateTimeFieldUpdateOperationsInput | Date | string
    detectadoPor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodoOrganigramaCreateManyOrganigramaInput = {
    id?: string
    nombre: string
    cargo: string
    departamento: string
    email: string
    telefono?: string | null
    foto?: string | null
    padreId?: string | null
  }

  export type NodoOrganigramaUpdateWithoutOrganigramaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    padre?: NodoOrganigramaUpdateOneWithoutSubordinadosNestedInput
    subordinados?: NodoOrganigramaUpdateManyWithoutPadreNestedInput
  }

  export type NodoOrganigramaUncheckedUpdateWithoutOrganigramaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    padreId?: NullableStringFieldUpdateOperationsInput | string | null
    subordinados?: NodoOrganigramaUncheckedUpdateManyWithoutPadreNestedInput
  }

  export type NodoOrganigramaUncheckedUpdateManyWithoutOrganigramaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    padreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NodoOrganigramaCreateManyPadreInput = {
    id?: string
    organigramaId: string
    nombre: string
    cargo: string
    departamento: string
    email: string
    telefono?: string | null
    foto?: string | null
  }

  export type NodoOrganigramaUpdateWithoutPadreInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    organigrama?: OrganigramaUpdateOneRequiredWithoutNodosNestedInput
    subordinados?: NodoOrganigramaUpdateManyWithoutPadreNestedInput
  }

  export type NodoOrganigramaUncheckedUpdateWithoutPadreInput = {
    id?: StringFieldUpdateOperationsInput | string
    organigramaId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    subordinados?: NodoOrganigramaUncheckedUpdateManyWithoutPadreNestedInput
  }

  export type NodoOrganigramaUncheckedUpdateManyWithoutPadreInput = {
    id?: StringFieldUpdateOperationsInput | string
    organigramaId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RequisitoNormativoCreateManyMarcoInput = {
    id?: string
    codigo: string
    nombre: string
    descripcion: string
    controlesAsociados: string
  }

  export type CuestionarioCreateManyMarcoNormativoInput = {
    id?: string
    nombre: string
    descripcion: string
    categoria: string
    tipo: string
    tipoEvaluacion: string
    estado?: string
    periodicidad: string
    tasaCompletado?: number
    fechaCreacion?: Date | string
    fechaModificacion?: Date | string
    umbrales: string
    areasObjetivo: string
    responsables: string
  }

  export type RequisitoNormativoUpdateWithoutMarcoInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    controlesAsociados?: StringFieldUpdateOperationsInput | string
  }

  export type RequisitoNormativoUncheckedUpdateWithoutMarcoInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    controlesAsociados?: StringFieldUpdateOperationsInput | string
  }

  export type RequisitoNormativoUncheckedUpdateManyWithoutMarcoInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    controlesAsociados?: StringFieldUpdateOperationsInput | string
  }

  export type CuestionarioUpdateWithoutMarcoNormativoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tipoEvaluacion?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    periodicidad?: StringFieldUpdateOperationsInput | string
    tasaCompletado?: FloatFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    umbrales?: StringFieldUpdateOperationsInput | string
    areasObjetivo?: StringFieldUpdateOperationsInput | string
    responsables?: StringFieldUpdateOperationsInput | string
    secciones?: SeccionUpdateManyWithoutCuestionarioNestedInput
    asignaciones?: AsignacionCuestionarioUpdateManyWithoutCuestionarioNestedInput
  }

  export type CuestionarioUncheckedUpdateWithoutMarcoNormativoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tipoEvaluacion?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    periodicidad?: StringFieldUpdateOperationsInput | string
    tasaCompletado?: FloatFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    umbrales?: StringFieldUpdateOperationsInput | string
    areasObjetivo?: StringFieldUpdateOperationsInput | string
    responsables?: StringFieldUpdateOperationsInput | string
    secciones?: SeccionUncheckedUpdateManyWithoutCuestionarioNestedInput
    asignaciones?: AsignacionCuestionarioUncheckedUpdateManyWithoutCuestionarioNestedInput
  }

  export type CuestionarioUncheckedUpdateManyWithoutMarcoNormativoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tipoEvaluacion?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    periodicidad?: StringFieldUpdateOperationsInput | string
    tasaCompletado?: FloatFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaModificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    umbrales?: StringFieldUpdateOperationsInput | string
    areasObjetivo?: StringFieldUpdateOperationsInput | string
    responsables?: StringFieldUpdateOperationsInput | string
  }

  export type SeccionCreateManyCuestionarioInput = {
    id?: string
    nombre: string
    descripcion: string
    peso?: number
    requerida?: boolean
    orden?: number
  }

  export type AsignacionCuestionarioCreateManyCuestionarioInput = {
    id?: string
    cuestionarioIds?: string | null
    titulo: string
    descripcion?: string | null
    tipoRevision: string
    usuariosAsignados: string
    usuariosAsignadosNombres: string
    emailsExternos?: string | null
    contrasenaAcceso?: string | null
    activosObjetivo: string
    activosObjetivoNombres: string
    procesosObjetivo: string
    procesosObjetivoNombres: string
    aprobadores: string
    aprobadoresNombres: string
    evaluadosInternos?: string | null
    evaluadosInternosNombres?: string | null
    areaId: string
    areaNombre: string
    responsableId: string
    responsableNombre: string
    fechaAsignacion?: Date | string
    fechaInicio: Date | string
    fechaVencimiento: Date | string
    estado?: string
    progreso?: number
    instrucciones?: string | null
    recordatorios?: boolean
    tokenAccesoExterno?: string | null
    recurrencia?: string | null
  }

  export type SeccionUpdateWithoutCuestionarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    peso?: FloatFieldUpdateOperationsInput | number
    requerida?: BoolFieldUpdateOperationsInput | boolean
    orden?: IntFieldUpdateOperationsInput | number
    preguntas?: PreguntaUpdateManyWithoutSeccionNestedInput
  }

  export type SeccionUncheckedUpdateWithoutCuestionarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    peso?: FloatFieldUpdateOperationsInput | number
    requerida?: BoolFieldUpdateOperationsInput | boolean
    orden?: IntFieldUpdateOperationsInput | number
    preguntas?: PreguntaUncheckedUpdateManyWithoutSeccionNestedInput
  }

  export type SeccionUncheckedUpdateManyWithoutCuestionarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    peso?: FloatFieldUpdateOperationsInput | number
    requerida?: BoolFieldUpdateOperationsInput | boolean
    orden?: IntFieldUpdateOperationsInput | number
  }

  export type AsignacionCuestionarioUpdateWithoutCuestionarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioIds?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipoRevision?: StringFieldUpdateOperationsInput | string
    usuariosAsignados?: StringFieldUpdateOperationsInput | string
    usuariosAsignadosNombres?: StringFieldUpdateOperationsInput | string
    emailsExternos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasenaAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activosObjetivo?: StringFieldUpdateOperationsInput | string
    activosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    procesosObjetivo?: StringFieldUpdateOperationsInput | string
    procesosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    aprobadores?: StringFieldUpdateOperationsInput | string
    aprobadoresNombres?: StringFieldUpdateOperationsInput | string
    evaluadosInternos?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosInternosNombres?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: StringFieldUpdateOperationsInput | string
    areaNombre?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    responsableNombre?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    instrucciones?: NullableStringFieldUpdateOperationsInput | string | null
    recordatorios?: BoolFieldUpdateOperationsInput | boolean
    tokenAccesoExterno?: NullableStringFieldUpdateOperationsInput | string | null
    recurrencia?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosExternos?: EvaluadoExternoUpdateManyWithoutAsignacionNestedInput
    respuestas?: RespuestaCuestionarioUpdateManyWithoutAsignacionNestedInput
    mensajesChat?: MensajeChatUpdateManyWithoutAsignacionNestedInput
  }

  export type AsignacionCuestionarioUncheckedUpdateWithoutCuestionarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioIds?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipoRevision?: StringFieldUpdateOperationsInput | string
    usuariosAsignados?: StringFieldUpdateOperationsInput | string
    usuariosAsignadosNombres?: StringFieldUpdateOperationsInput | string
    emailsExternos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasenaAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activosObjetivo?: StringFieldUpdateOperationsInput | string
    activosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    procesosObjetivo?: StringFieldUpdateOperationsInput | string
    procesosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    aprobadores?: StringFieldUpdateOperationsInput | string
    aprobadoresNombres?: StringFieldUpdateOperationsInput | string
    evaluadosInternos?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosInternosNombres?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: StringFieldUpdateOperationsInput | string
    areaNombre?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    responsableNombre?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    instrucciones?: NullableStringFieldUpdateOperationsInput | string | null
    recordatorios?: BoolFieldUpdateOperationsInput | boolean
    tokenAccesoExterno?: NullableStringFieldUpdateOperationsInput | string | null
    recurrencia?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosExternos?: EvaluadoExternoUncheckedUpdateManyWithoutAsignacionNestedInput
    respuestas?: RespuestaCuestionarioUncheckedUpdateManyWithoutAsignacionNestedInput
    mensajesChat?: MensajeChatUncheckedUpdateManyWithoutAsignacionNestedInput
  }

  export type AsignacionCuestionarioUncheckedUpdateManyWithoutCuestionarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioIds?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipoRevision?: StringFieldUpdateOperationsInput | string
    usuariosAsignados?: StringFieldUpdateOperationsInput | string
    usuariosAsignadosNombres?: StringFieldUpdateOperationsInput | string
    emailsExternos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasenaAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activosObjetivo?: StringFieldUpdateOperationsInput | string
    activosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    procesosObjetivo?: StringFieldUpdateOperationsInput | string
    procesosObjetivoNombres?: StringFieldUpdateOperationsInput | string
    aprobadores?: StringFieldUpdateOperationsInput | string
    aprobadoresNombres?: StringFieldUpdateOperationsInput | string
    evaluadosInternos?: NullableStringFieldUpdateOperationsInput | string | null
    evaluadosInternosNombres?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: StringFieldUpdateOperationsInput | string
    areaNombre?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    responsableNombre?: StringFieldUpdateOperationsInput | string
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    instrucciones?: NullableStringFieldUpdateOperationsInput | string | null
    recordatorios?: BoolFieldUpdateOperationsInput | boolean
    tokenAccesoExterno?: NullableStringFieldUpdateOperationsInput | string | null
    recurrencia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PreguntaCreateManySeccionInput = {
    id?: string
    texto: string
    tipo: string
    requerida?: boolean
    peso?: number
    opciones?: string | null
    escalaMin?: number | null
    escalaMax?: number | null
    ayuda?: string | null
    placeholder?: string | null
    requisitoNormativoId?: string | null
    controlAsociado?: string | null
    requiereEvidencia?: boolean
    maxStars?: number | null
    leftAnchor?: string | null
    rightAnchor?: string | null
    likertLabels?: string | null
    displayConditionQuestionId?: string | null
    displayConditionAnswer?: string | null
    logicaCondicional?: string | null
    isCalculated?: boolean
    formula?: string | null
    orden?: number
  }

  export type PreguntaUpdateWithoutSeccionInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    requerida?: BoolFieldUpdateOperationsInput | boolean
    peso?: FloatFieldUpdateOperationsInput | number
    opciones?: NullableStringFieldUpdateOperationsInput | string | null
    escalaMin?: NullableIntFieldUpdateOperationsInput | number | null
    escalaMax?: NullableIntFieldUpdateOperationsInput | number | null
    ayuda?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    requisitoNormativoId?: NullableStringFieldUpdateOperationsInput | string | null
    controlAsociado?: NullableStringFieldUpdateOperationsInput | string | null
    requiereEvidencia?: BoolFieldUpdateOperationsInput | boolean
    maxStars?: NullableIntFieldUpdateOperationsInput | number | null
    leftAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    rightAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    likertLabels?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    logicaCondicional?: NullableStringFieldUpdateOperationsInput | string | null
    isCalculated?: BoolFieldUpdateOperationsInput | boolean
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    respuestas?: RespuestaPreguntaUpdateManyWithoutPreguntaNestedInput
    hallazgos?: HallazgoUpdateManyWithoutPreguntaNestedInput
  }

  export type PreguntaUncheckedUpdateWithoutSeccionInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    requerida?: BoolFieldUpdateOperationsInput | boolean
    peso?: FloatFieldUpdateOperationsInput | number
    opciones?: NullableStringFieldUpdateOperationsInput | string | null
    escalaMin?: NullableIntFieldUpdateOperationsInput | number | null
    escalaMax?: NullableIntFieldUpdateOperationsInput | number | null
    ayuda?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    requisitoNormativoId?: NullableStringFieldUpdateOperationsInput | string | null
    controlAsociado?: NullableStringFieldUpdateOperationsInput | string | null
    requiereEvidencia?: BoolFieldUpdateOperationsInput | boolean
    maxStars?: NullableIntFieldUpdateOperationsInput | number | null
    leftAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    rightAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    likertLabels?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    logicaCondicional?: NullableStringFieldUpdateOperationsInput | string | null
    isCalculated?: BoolFieldUpdateOperationsInput | boolean
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    respuestas?: RespuestaPreguntaUncheckedUpdateManyWithoutPreguntaNestedInput
    hallazgos?: HallazgoUncheckedUpdateManyWithoutPreguntaNestedInput
  }

  export type PreguntaUncheckedUpdateManyWithoutSeccionInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    requerida?: BoolFieldUpdateOperationsInput | boolean
    peso?: FloatFieldUpdateOperationsInput | number
    opciones?: NullableStringFieldUpdateOperationsInput | string | null
    escalaMin?: NullableIntFieldUpdateOperationsInput | number | null
    escalaMax?: NullableIntFieldUpdateOperationsInput | number | null
    ayuda?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    requisitoNormativoId?: NullableStringFieldUpdateOperationsInput | string | null
    controlAsociado?: NullableStringFieldUpdateOperationsInput | string | null
    requiereEvidencia?: BoolFieldUpdateOperationsInput | boolean
    maxStars?: NullableIntFieldUpdateOperationsInput | number | null
    leftAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    rightAnchor?: NullableStringFieldUpdateOperationsInput | string | null
    likertLabels?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    displayConditionAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    logicaCondicional?: NullableStringFieldUpdateOperationsInput | string | null
    isCalculated?: BoolFieldUpdateOperationsInput | boolean
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
  }

  export type RespuestaPreguntaCreateManyPreguntaInput = {
    id?: string
    respuestaCuestionarioId: string
    valor?: string | null
    comentario?: string | null
    archivosAdjuntos?: string | null
    marcadaParaRevision?: boolean
    estadoRevision?: string
    comentarioRevisor?: string | null
  }

  export type HallazgoCreateManyPreguntaInput = {
    id?: string
    tipo: string
    descripcion: string
    requisitoNormativo?: string | null
    accionCorrectiva?: string | null
    responsable: string
    fechaLimite?: Date | string | null
    estado?: string
    fechaCreacion?: Date | string
  }

  export type RespuestaPreguntaUpdateWithoutPreguntaInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    archivosAdjuntos?: NullableStringFieldUpdateOperationsInput | string | null
    marcadaParaRevision?: BoolFieldUpdateOperationsInput | boolean
    estadoRevision?: StringFieldUpdateOperationsInput | string
    comentarioRevisor?: NullableStringFieldUpdateOperationsInput | string | null
    respuestaCuestionario?: RespuestaCuestionarioUpdateOneRequiredWithoutRespuestasNestedInput
    evidencias?: EvidenciaUpdateManyWithoutRespuestaPreguntaNestedInput
  }

  export type RespuestaPreguntaUncheckedUpdateWithoutPreguntaInput = {
    id?: StringFieldUpdateOperationsInput | string
    respuestaCuestionarioId?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    archivosAdjuntos?: NullableStringFieldUpdateOperationsInput | string | null
    marcadaParaRevision?: BoolFieldUpdateOperationsInput | boolean
    estadoRevision?: StringFieldUpdateOperationsInput | string
    comentarioRevisor?: NullableStringFieldUpdateOperationsInput | string | null
    evidencias?: EvidenciaUncheckedUpdateManyWithoutRespuestaPreguntaNestedInput
  }

  export type RespuestaPreguntaUncheckedUpdateManyWithoutPreguntaInput = {
    id?: StringFieldUpdateOperationsInput | string
    respuestaCuestionarioId?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    archivosAdjuntos?: NullableStringFieldUpdateOperationsInput | string | null
    marcadaParaRevision?: BoolFieldUpdateOperationsInput | boolean
    estadoRevision?: StringFieldUpdateOperationsInput | string
    comentarioRevisor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HallazgoUpdateWithoutPreguntaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    requisitoNormativo?: NullableStringFieldUpdateOperationsInput | string | null
    accionCorrectiva?: NullableStringFieldUpdateOperationsInput | string | null
    responsable?: StringFieldUpdateOperationsInput | string
    fechaLimite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HallazgoUncheckedUpdateWithoutPreguntaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    requisitoNormativo?: NullableStringFieldUpdateOperationsInput | string | null
    accionCorrectiva?: NullableStringFieldUpdateOperationsInput | string | null
    responsable?: StringFieldUpdateOperationsInput | string
    fechaLimite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HallazgoUncheckedUpdateManyWithoutPreguntaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    requisitoNormativo?: NullableStringFieldUpdateOperationsInput | string | null
    accionCorrectiva?: NullableStringFieldUpdateOperationsInput | string | null
    responsable?: StringFieldUpdateOperationsInput | string
    fechaLimite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluadoExternoCreateManyAsignacionInput = {
    id?: string
    nombre: string
    email: string
    password?: string | null
    invitacionEnviada?: boolean
    fechaInvitacion?: Date | string | null
    haRespondido?: boolean
    fechaRespuesta?: Date | string | null
  }

  export type RespuestaCuestionarioCreateManyAsignacionInput = {
    id?: string
    cuestionarioId: string
    respondidoPorId: string
    fechaInicio?: Date | string
    fechaEnvio?: Date | string | null
    estado?: string
    puntuacionTotal?: number
    nivelCumplimiento?: string | null
    comentariosGenerales?: string | null
  }

  export type MensajeChatCreateManyAsignacionInput = {
    id?: string
    cuestionarioId?: string | null
    activoProcesoId?: string | null
    usuarioId: string
    usuarioNombre: string
    usuarioRol: string
    mensaje: string
    fecha?: Date | string
    leido?: boolean
  }

  export type EvaluadoExternoUpdateWithoutAsignacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    invitacionEnviada?: BoolFieldUpdateOperationsInput | boolean
    fechaInvitacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    haRespondido?: BoolFieldUpdateOperationsInput | boolean
    fechaRespuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluadoExternoUncheckedUpdateWithoutAsignacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    invitacionEnviada?: BoolFieldUpdateOperationsInput | boolean
    fechaInvitacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    haRespondido?: BoolFieldUpdateOperationsInput | boolean
    fechaRespuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluadoExternoUncheckedUpdateManyWithoutAsignacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    invitacionEnviada?: BoolFieldUpdateOperationsInput | boolean
    fechaInvitacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    haRespondido?: BoolFieldUpdateOperationsInput | boolean
    fechaRespuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RespuestaCuestionarioUpdateWithoutAsignacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    puntuacionTotal?: FloatFieldUpdateOperationsInput | number
    nivelCumplimiento?: NullableStringFieldUpdateOperationsInput | string | null
    comentariosGenerales?: NullableStringFieldUpdateOperationsInput | string | null
    respondidoPor?: UsuarioUpdateOneRequiredWithoutRespuestasCuestionarioNestedInput
    respuestas?: RespuestaPreguntaUpdateManyWithoutRespuestaCuestionarioNestedInput
  }

  export type RespuestaCuestionarioUncheckedUpdateWithoutAsignacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    respondidoPorId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    puntuacionTotal?: FloatFieldUpdateOperationsInput | number
    nivelCumplimiento?: NullableStringFieldUpdateOperationsInput | string | null
    comentariosGenerales?: NullableStringFieldUpdateOperationsInput | string | null
    respuestas?: RespuestaPreguntaUncheckedUpdateManyWithoutRespuestaCuestionarioNestedInput
  }

  export type RespuestaCuestionarioUncheckedUpdateManyWithoutAsignacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: StringFieldUpdateOperationsInput | string
    respondidoPorId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    puntuacionTotal?: FloatFieldUpdateOperationsInput | number
    nivelCumplimiento?: NullableStringFieldUpdateOperationsInput | string | null
    comentariosGenerales?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MensajeChatUpdateWithoutAsignacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: NullableStringFieldUpdateOperationsInput | string | null
    activoProcesoId?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    usuarioNombre?: StringFieldUpdateOperationsInput | string
    usuarioRol?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    leido?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MensajeChatUncheckedUpdateWithoutAsignacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: NullableStringFieldUpdateOperationsInput | string | null
    activoProcesoId?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    usuarioNombre?: StringFieldUpdateOperationsInput | string
    usuarioRol?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    leido?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MensajeChatUncheckedUpdateManyWithoutAsignacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cuestionarioId?: NullableStringFieldUpdateOperationsInput | string | null
    activoProcesoId?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: StringFieldUpdateOperationsInput | string
    usuarioNombre?: StringFieldUpdateOperationsInput | string
    usuarioRol?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    leido?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RespuestaPreguntaCreateManyRespuestaCuestionarioInput = {
    id?: string
    preguntaId: string
    valor?: string | null
    comentario?: string | null
    archivosAdjuntos?: string | null
    marcadaParaRevision?: boolean
    estadoRevision?: string
    comentarioRevisor?: string | null
  }

  export type RespuestaPreguntaUpdateWithoutRespuestaCuestionarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    archivosAdjuntos?: NullableStringFieldUpdateOperationsInput | string | null
    marcadaParaRevision?: BoolFieldUpdateOperationsInput | boolean
    estadoRevision?: StringFieldUpdateOperationsInput | string
    comentarioRevisor?: NullableStringFieldUpdateOperationsInput | string | null
    pregunta?: PreguntaUpdateOneRequiredWithoutRespuestasNestedInput
    evidencias?: EvidenciaUpdateManyWithoutRespuestaPreguntaNestedInput
  }

  export type RespuestaPreguntaUncheckedUpdateWithoutRespuestaCuestionarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    archivosAdjuntos?: NullableStringFieldUpdateOperationsInput | string | null
    marcadaParaRevision?: BoolFieldUpdateOperationsInput | boolean
    estadoRevision?: StringFieldUpdateOperationsInput | string
    comentarioRevisor?: NullableStringFieldUpdateOperationsInput | string | null
    evidencias?: EvidenciaUncheckedUpdateManyWithoutRespuestaPreguntaNestedInput
  }

  export type RespuestaPreguntaUncheckedUpdateManyWithoutRespuestaCuestionarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    archivosAdjuntos?: NullableStringFieldUpdateOperationsInput | string | null
    marcadaParaRevision?: BoolFieldUpdateOperationsInput | boolean
    estadoRevision?: StringFieldUpdateOperationsInput | string
    comentarioRevisor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvidenciaCreateManyRespuestaPreguntaInput = {
    id?: string
    nombre: string
    tipo: string
    tamano: number
    fechaCarga?: Date | string
    url: string
    descripcion?: string | null
    vigencia?: Date | string | null
    estado?: string
  }

  export type EvidenciaUpdateWithoutRespuestaPreguntaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tamano?: IntFieldUpdateOperationsInput | number
    fechaCarga?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type EvidenciaUncheckedUpdateWithoutRespuestaPreguntaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tamano?: IntFieldUpdateOperationsInput | number
    fechaCarga?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type EvidenciaUncheckedUpdateManyWithoutRespuestaPreguntaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    tamano?: IntFieldUpdateOperationsInput | number
    fechaCarga?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessNodeCreateManyProcesoInput = {
    id?: string
    type: string
    label: string
    descripcion?: string | null
    config: string
    positionX: number
    positionY: number
  }

  export type ProcessEdgeCreateManyProcesoInput = {
    id?: string
    sourceNodeId: string
    targetNodeId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    label?: string | null
  }

  export type ObjetivoProcesoCreateManyProcesoInput = {
    id?: string
    nombre: string
    descripcion: string
    tipo: string
    progreso?: number
  }

  export type KpiProcesoCreateManyProcesoInput = {
    id?: string
    objetivoId?: string | null
    nombre: string
    descripcion?: string | null
    unidad: string
    meta: number
    valorActual?: number
    fechaUltimaActualizacion?: Date | string | null
    alertaAdvertencia?: number | null
    alertaCritico?: number | null
    alertaDireccion?: string
  }

  export type ProcessNodeUpdateWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    edgesFrom?: ProcessEdgeUpdateManyWithoutSourceNodeNestedInput
    edgesTo?: ProcessEdgeUpdateManyWithoutTargetNodeNestedInput
    kpiHistorico?: KpiHistoricoUpdateManyWithoutNodoNestedInput
  }

  export type ProcessNodeUncheckedUpdateWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    edgesFrom?: ProcessEdgeUncheckedUpdateManyWithoutSourceNodeNestedInput
    edgesTo?: ProcessEdgeUncheckedUpdateManyWithoutTargetNodeNestedInput
    kpiHistorico?: KpiHistoricoUncheckedUpdateManyWithoutNodoNestedInput
  }

  export type ProcessNodeUncheckedUpdateManyWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
  }

  export type ProcessEdgeUpdateWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNode?: ProcessNodeUpdateOneRequiredWithoutEdgesFromNestedInput
    targetNode?: ProcessNodeUpdateOneRequiredWithoutEdgesToNestedInput
  }

  export type ProcessEdgeUncheckedUpdateWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceNodeId?: StringFieldUpdateOperationsInput | string
    targetNodeId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProcessEdgeUncheckedUpdateManyWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceNodeId?: StringFieldUpdateOperationsInput | string
    targetNodeId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ObjetivoProcesoUpdateWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    kpis?: KpiProcesoUpdateManyWithoutObjetivoNestedInput
  }

  export type ObjetivoProcesoUncheckedUpdateWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
    kpis?: KpiProcesoUncheckedUpdateManyWithoutObjetivoNestedInput
  }

  export type ObjetivoProcesoUncheckedUpdateManyWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    progreso?: FloatFieldUpdateOperationsInput | number
  }

  export type KpiProcesoUpdateWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    unidad?: StringFieldUpdateOperationsInput | string
    meta?: FloatFieldUpdateOperationsInput | number
    valorActual?: FloatFieldUpdateOperationsInput | number
    fechaUltimaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertaAdvertencia?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaCritico?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaDireccion?: StringFieldUpdateOperationsInput | string
    objetivo?: ObjetivoProcesoUpdateOneWithoutKpisNestedInput
    historico?: KpiHistoricoUpdateManyWithoutKpiNestedInput
  }

  export type KpiProcesoUncheckedUpdateWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    objetivoId?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    unidad?: StringFieldUpdateOperationsInput | string
    meta?: FloatFieldUpdateOperationsInput | number
    valorActual?: FloatFieldUpdateOperationsInput | number
    fechaUltimaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertaAdvertencia?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaCritico?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaDireccion?: StringFieldUpdateOperationsInput | string
    historico?: KpiHistoricoUncheckedUpdateManyWithoutKpiNestedInput
  }

  export type KpiProcesoUncheckedUpdateManyWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    objetivoId?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    unidad?: StringFieldUpdateOperationsInput | string
    meta?: FloatFieldUpdateOperationsInput | number
    valorActual?: FloatFieldUpdateOperationsInput | number
    fechaUltimaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertaAdvertencia?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaCritico?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaDireccion?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessEdgeCreateManySourceNodeInput = {
    id?: string
    procesoId: string
    targetNodeId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    label?: string | null
  }

  export type ProcessEdgeCreateManyTargetNodeInput = {
    id?: string
    procesoId: string
    sourceNodeId: string
    sourceHandle?: string | null
    targetHandle?: string | null
    label?: string | null
  }

  export type KpiHistoricoCreateManyNodoInput = {
    id?: string
    kpiId: string
    valor: number
    timestamp?: Date | string
    procesoId: string
    metadatos?: string | null
  }

  export type ProcessEdgeUpdateWithoutSourceNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    proceso?: ProcesoUpdateOneRequiredWithoutEdgesNestedInput
    targetNode?: ProcessNodeUpdateOneRequiredWithoutEdgesToNestedInput
  }

  export type ProcessEdgeUncheckedUpdateWithoutSourceNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    targetNodeId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProcessEdgeUncheckedUpdateManyWithoutSourceNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    targetNodeId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProcessEdgeUpdateWithoutTargetNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    proceso?: ProcesoUpdateOneRequiredWithoutEdgesNestedInput
    sourceNode?: ProcessNodeUpdateOneRequiredWithoutEdgesFromNestedInput
  }

  export type ProcessEdgeUncheckedUpdateWithoutTargetNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    sourceNodeId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProcessEdgeUncheckedUpdateManyWithoutTargetNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    sourceNodeId?: StringFieldUpdateOperationsInput | string
    sourceHandle?: NullableStringFieldUpdateOperationsInput | string | null
    targetHandle?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KpiHistoricoUpdateWithoutNodoInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    procesoId?: StringFieldUpdateOperationsInput | string
    metadatos?: NullableStringFieldUpdateOperationsInput | string | null
    kpi?: KpiProcesoUpdateOneRequiredWithoutHistoricoNestedInput
  }

  export type KpiHistoricoUncheckedUpdateWithoutNodoInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiId?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    procesoId?: StringFieldUpdateOperationsInput | string
    metadatos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KpiHistoricoUncheckedUpdateManyWithoutNodoInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiId?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    procesoId?: StringFieldUpdateOperationsInput | string
    metadatos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KpiProcesoCreateManyObjetivoInput = {
    id?: string
    procesoId: string
    nombre: string
    descripcion?: string | null
    unidad: string
    meta: number
    valorActual?: number
    fechaUltimaActualizacion?: Date | string | null
    alertaAdvertencia?: number | null
    alertaCritico?: number | null
    alertaDireccion?: string
  }

  export type KpiProcesoUpdateWithoutObjetivoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    unidad?: StringFieldUpdateOperationsInput | string
    meta?: FloatFieldUpdateOperationsInput | number
    valorActual?: FloatFieldUpdateOperationsInput | number
    fechaUltimaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertaAdvertencia?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaCritico?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaDireccion?: StringFieldUpdateOperationsInput | string
    proceso?: ProcesoUpdateOneRequiredWithoutKpisNestedInput
    historico?: KpiHistoricoUpdateManyWithoutKpiNestedInput
  }

  export type KpiProcesoUncheckedUpdateWithoutObjetivoInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    unidad?: StringFieldUpdateOperationsInput | string
    meta?: FloatFieldUpdateOperationsInput | number
    valorActual?: FloatFieldUpdateOperationsInput | number
    fechaUltimaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertaAdvertencia?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaCritico?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaDireccion?: StringFieldUpdateOperationsInput | string
    historico?: KpiHistoricoUncheckedUpdateManyWithoutKpiNestedInput
  }

  export type KpiProcesoUncheckedUpdateManyWithoutObjetivoInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    unidad?: StringFieldUpdateOperationsInput | string
    meta?: FloatFieldUpdateOperationsInput | number
    valorActual?: FloatFieldUpdateOperationsInput | number
    fechaUltimaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertaAdvertencia?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaCritico?: NullableFloatFieldUpdateOperationsInput | number | null
    alertaDireccion?: StringFieldUpdateOperationsInput | string
  }

  export type KpiHistoricoCreateManyKpiInput = {
    id?: string
    valor: number
    timestamp?: Date | string
    procesoId: string
    nodoId?: string | null
    metadatos?: string | null
  }

  export type KpiHistoricoUpdateWithoutKpiInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    procesoId?: StringFieldUpdateOperationsInput | string
    metadatos?: NullableStringFieldUpdateOperationsInput | string | null
    nodo?: ProcessNodeUpdateOneWithoutKpiHistoricoNestedInput
  }

  export type KpiHistoricoUncheckedUpdateWithoutKpiInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    procesoId?: StringFieldUpdateOperationsInput | string
    nodoId?: NullableStringFieldUpdateOperationsInput | string | null
    metadatos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KpiHistoricoUncheckedUpdateManyWithoutKpiInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    procesoId?: StringFieldUpdateOperationsInput | string
    nodoId?: NullableStringFieldUpdateOperationsInput | string | null
    metadatos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardWidgetCreateManyDashboardInput = {
    id?: string
    tipo: string
    titulo: string
    subtitulo?: string | null
    icono?: string | null
    config: string
    x: number
    y: number
    cols: number
    rows: number
    canResize?: boolean
    canDrag?: boolean
    canRemove?: boolean
    canEdit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardWidgetUpdateWithoutDashboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    subtitulo?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    canResize?: BoolFieldUpdateOperationsInput | boolean
    canDrag?: BoolFieldUpdateOperationsInput | boolean
    canRemove?: BoolFieldUpdateOperationsInput | boolean
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardWidgetUncheckedUpdateWithoutDashboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    subtitulo?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    canResize?: BoolFieldUpdateOperationsInput | boolean
    canDrag?: BoolFieldUpdateOperationsInput | boolean
    canRemove?: BoolFieldUpdateOperationsInput | boolean
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardWidgetUncheckedUpdateManyWithoutDashboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    subtitulo?: NullableStringFieldUpdateOperationsInput | string | null
    icono?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    cols?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    canResize?: BoolFieldUpdateOperationsInput | boolean
    canDrag?: BoolFieldUpdateOperationsInput | boolean
    canRemove?: BoolFieldUpdateOperationsInput | boolean
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectObjectiveCreateManyProjectInput = {
    id?: string
    description: string
    category: string
    status?: string
    targetDate?: Date | string | null
    completedDate?: Date | string | null
  }

  export type ProjectKPICreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    targetValue: number
    currentValue?: number
    unit: string
    formulaType: string
    formula?: string | null
    status?: string
  }

  export type ProjectPhaseCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    orderNum: number
    startDate: Date | string
    endDate: Date | string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    status?: string
    weight?: number
    dependsOnPhaseId?: string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyProjectInput = {
    id?: string
    phaseId: string
    title: string
    description?: string | null
    assignedTo: string
    assignedBy: string
    assignedAt?: Date | string
    startDate: Date | string
    dueDate: Date | string
    completedDate?: Date | string | null
    progress?: number
    status?: string
    priority?: string
    estimatedHours?: number | null
    actualHours?: number | null
    taskType?: string
    linkedEntityType?: string | null
    linkedEntityId?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
  }

  export type ProjectObjectiveUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectObjectiveUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectObjectiveUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectKPIUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    formulaType?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectKPIUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    formulaType?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectKPIUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    formulaType?: StringFieldUpdateOperationsInput | string
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectPhaseUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependsOn?: ProjectPhaseUpdateOneWithoutDependentsNestedInput
    dependents?: ProjectPhaseUpdateManyWithoutDependsOnNestedInput
    tasks?: TaskUpdateManyWithoutPhaseNestedInput
  }

  export type ProjectPhaseUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    dependsOnPhaseId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependents?: ProjectPhaseUncheckedUpdateManyWithoutDependsOnNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type ProjectPhaseUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    dependsOnPhaseId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedBy?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    taskType?: StringFieldUpdateOperationsInput | string
    linkedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: ProjectPhaseUpdateOneRequiredWithoutTasksNestedInput
    evidences?: TaskEvidenceUpdateManyWithoutTaskNestedInput
    history?: TaskHistoryUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedBy?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    taskType?: StringFieldUpdateOperationsInput | string
    linkedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidences?: TaskEvidenceUncheckedUpdateManyWithoutTaskNestedInput
    history?: TaskHistoryUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedBy?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    taskType?: StringFieldUpdateOperationsInput | string
    linkedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectPhaseCreateManyDependsOnInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    orderNum: number
    startDate: Date | string
    endDate: Date | string
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    status?: string
    weight?: number
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyPhaseInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    assignedTo: string
    assignedBy: string
    assignedAt?: Date | string
    startDate: Date | string
    dueDate: Date | string
    completedDate?: Date | string | null
    progress?: number
    status?: string
    priority?: string
    estimatedHours?: number | null
    actualHours?: number | null
    taskType?: string
    linkedEntityType?: string | null
    linkedEntityId?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
  }

  export type ProjectPhaseUpdateWithoutDependsOnInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPhasesNestedInput
    dependents?: ProjectPhaseUpdateManyWithoutDependsOnNestedInput
    tasks?: TaskUpdateManyWithoutPhaseNestedInput
  }

  export type ProjectPhaseUncheckedUpdateWithoutDependsOnInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependents?: ProjectPhaseUncheckedUpdateManyWithoutDependsOnNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type ProjectPhaseUncheckedUpdateManyWithoutDependsOnInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedBy?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    taskType?: StringFieldUpdateOperationsInput | string
    linkedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    evidences?: TaskEvidenceUpdateManyWithoutTaskNestedInput
    history?: TaskHistoryUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedBy?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    taskType?: StringFieldUpdateOperationsInput | string
    linkedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidences?: TaskEvidenceUncheckedUpdateManyWithoutTaskNestedInput
    history?: TaskHistoryUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedBy?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    taskType?: StringFieldUpdateOperationsInput | string
    linkedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEvidenceCreateManyTaskInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    storageUrl: string
    evidenceType: string
    description?: string | null
    documentDate?: Date | string | null
    uploadedBy: string
    uploadedAt?: Date | string
  }

  export type TaskHistoryCreateManyTaskInput = {
    id?: string
    userId: string
    action: string
    changes?: string | null
    comment?: string | null
    timestamp?: Date | string
  }

  export type TaskEvidenceUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    evidenceType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEvidenceUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    evidenceType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEvidenceUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    evidenceType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskHistoryUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskHistoryUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskHistoryUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolCountOutputTypeDefaultArgs instead
     */
    export type RolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermisoCountOutputTypeDefaultArgs instead
     */
    export type PermisoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermisoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivoAccesoCountOutputTypeDefaultArgs instead
     */
    export type ActivoAccesoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivoAccesoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlantillaActivoCountOutputTypeDefaultArgs instead
     */
    export type PlantillaActivoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlantillaActivoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivoCountOutputTypeDefaultArgs instead
     */
    export type ActivoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganigramaCountOutputTypeDefaultArgs instead
     */
    export type OrganigramaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganigramaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NodoOrganigramaCountOutputTypeDefaultArgs instead
     */
    export type NodoOrganigramaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NodoOrganigramaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarcoNormativoCountOutputTypeDefaultArgs instead
     */
    export type MarcoNormativoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarcoNormativoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CuestionarioCountOutputTypeDefaultArgs instead
     */
    export type CuestionarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CuestionarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeccionCountOutputTypeDefaultArgs instead
     */
    export type SeccionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeccionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PreguntaCountOutputTypeDefaultArgs instead
     */
    export type PreguntaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PreguntaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AsignacionCuestionarioCountOutputTypeDefaultArgs instead
     */
    export type AsignacionCuestionarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AsignacionCuestionarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RespuestaCuestionarioCountOutputTypeDefaultArgs instead
     */
    export type RespuestaCuestionarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RespuestaCuestionarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RespuestaPreguntaCountOutputTypeDefaultArgs instead
     */
    export type RespuestaPreguntaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RespuestaPreguntaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcesoCountOutputTypeDefaultArgs instead
     */
    export type ProcesoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcesoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessNodeCountOutputTypeDefaultArgs instead
     */
    export type ProcessNodeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessNodeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjetivoProcesoCountOutputTypeDefaultArgs instead
     */
    export type ObjetivoProcesoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjetivoProcesoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KpiProcesoCountOutputTypeDefaultArgs instead
     */
    export type KpiProcesoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KpiProcesoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DashboardConfigCountOutputTypeDefaultArgs instead
     */
    export type DashboardConfigCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DashboardConfigCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectPhaseCountOutputTypeDefaultArgs instead
     */
    export type ProjectPhaseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectPhaseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskCountOutputTypeDefaultArgs instead
     */
    export type TaskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolDefaultArgs instead
     */
    export type RolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermisoDefaultArgs instead
     */
    export type PermisoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermisoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuloDefaultArgs instead
     */
    export type ModuloArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuloDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioRolDefaultArgs instead
     */
    export type UsuarioRolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioRolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolPermisoDefaultArgs instead
     */
    export type RolPermisoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolPermisoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioActivoDefaultArgs instead
     */
    export type UsuarioActivoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioActivoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogAuditoriaDefaultArgs instead
     */
    export type LogAuditoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogAuditoriaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivoAccesoDefaultArgs instead
     */
    export type ActivoAccesoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivoAccesoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlantillaActivoDefaultArgs instead
     */
    export type PlantillaActivoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlantillaActivoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivoDefaultArgs instead
     */
    export type ActivoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RiesgoDefaultArgs instead
     */
    export type RiesgoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RiesgoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncidenteDefaultArgs instead
     */
    export type IncidenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncidenteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DefectoDefaultArgs instead
     */
    export type DefectoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DefectoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganigramaDefaultArgs instead
     */
    export type OrganigramaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganigramaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NodoOrganigramaDefaultArgs instead
     */
    export type NodoOrganigramaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NodoOrganigramaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarcoNormativoDefaultArgs instead
     */
    export type MarcoNormativoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarcoNormativoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RequisitoNormativoDefaultArgs instead
     */
    export type RequisitoNormativoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RequisitoNormativoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CuestionarioDefaultArgs instead
     */
    export type CuestionarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CuestionarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeccionDefaultArgs instead
     */
    export type SeccionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeccionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PreguntaDefaultArgs instead
     */
    export type PreguntaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PreguntaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AsignacionCuestionarioDefaultArgs instead
     */
    export type AsignacionCuestionarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AsignacionCuestionarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluadoExternoDefaultArgs instead
     */
    export type EvaluadoExternoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluadoExternoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RespuestaCuestionarioDefaultArgs instead
     */
    export type RespuestaCuestionarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RespuestaCuestionarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RespuestaPreguntaDefaultArgs instead
     */
    export type RespuestaPreguntaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RespuestaPreguntaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvidenciaDefaultArgs instead
     */
    export type EvidenciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvidenciaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HallazgoDefaultArgs instead
     */
    export type HallazgoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HallazgoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MensajeChatDefaultArgs instead
     */
    export type MensajeChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MensajeChatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertaCumplimientoDefaultArgs instead
     */
    export type AlertaCumplimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertaCumplimientoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcesoDefaultArgs instead
     */
    export type ProcesoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcesoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessNodeDefaultArgs instead
     */
    export type ProcessNodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessNodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessEdgeDefaultArgs instead
     */
    export type ProcessEdgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessEdgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjetivoProcesoDefaultArgs instead
     */
    export type ObjetivoProcesoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjetivoProcesoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KpiProcesoDefaultArgs instead
     */
    export type KpiProcesoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KpiProcesoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KpiHistoricoDefaultArgs instead
     */
    export type KpiHistoricoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KpiHistoricoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DashboardConfigDefaultArgs instead
     */
    export type DashboardConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DashboardConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DashboardWidgetDefaultArgs instead
     */
    export type DashboardWidgetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DashboardWidgetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogoDefaultArgs instead
     */
    export type CatalogoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationRuleDefaultArgs instead
     */
    export type NotificationRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertRuleDefaultArgs instead
     */
    export type AlertRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpirationRuleDefaultArgs instead
     */
    export type ExpirationRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpirationRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserNotificationPreferencesDefaultArgs instead
     */
    export type UserNotificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserNotificationPreferencesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationLogDefaultArgs instead
     */
    export type NotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationProfileDefaultArgs instead
     */
    export type NotificationProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectObjectiveDefaultArgs instead
     */
    export type ProjectObjectiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectObjectiveDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectKPIDefaultArgs instead
     */
    export type ProjectKPIArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectKPIDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectPhaseDefaultArgs instead
     */
    export type ProjectPhaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectPhaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDefaultArgs instead
     */
    export type TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskEvidenceDefaultArgs instead
     */
    export type TaskEvidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskEvidenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskHistoryDefaultArgs instead
     */
    export type TaskHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskHistoryDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}